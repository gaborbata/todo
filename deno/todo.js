// deno-fmt-ignore-file
// deno-lint-ignore-file
// This code was bundled using `deno bundle` and it's not recommended to edit it manually

const osType = (()=>{
    const { Deno: Deno1  } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows = osType === "windows";
const isLinux = osType === "linux";
const CHAR_FORWARD_SLASH = 47;
function assertPath(path4) {
    if (typeof path4 !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path4)}`);
    }
}
function isPosixPathSeparator(code) {
    return code === 47;
}
function isPathSeparator(code) {
    return isPosixPathSeparator(code) || code === 92;
}
function isWindowsDeviceRoot(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString(path5, allowAboveRoot, separator, isPathSeparator1) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i2 = 0, len = path5.length; i2 <= len; ++i2){
        if (i2 < len) code = path5.charCodeAt(i2);
        else if (isPathSeparator1(code)) break;
        else code = CHAR_FORWARD_SLASH;
        if (isPathSeparator1(code)) {
            if (lastSlash === i2 - 1 || dots === 1) {} else if (lastSlash !== i2 - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i2;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i2;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path5.slice(lastSlash + 1, i2);
                else res = path5.slice(lastSlash + 1, i2);
                lastSegmentLength = i2 - lastSlash - 1;
            }
            lastSlash = i2;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep6, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base1 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base1;
    if (dir === pathObject.root) return dir + base1;
    return dir + sep6 + base1;
}
const WHITESPACE_ENCODINGS = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS[c] ?? c;
    });
}
class DenoStdInternalError extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg);
    }
}
const sep = "\\";
const delimiter = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i3 = pathSegments.length - 1; i3 >= -1; i3--){
        let path6;
        const { Deno: Deno2  } = globalThis;
        if (i3 >= 0) {
            path6 = pathSegments[i3];
        } else if (!resolvedDevice) {
            if (typeof Deno2?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path6 = Deno2.cwd();
        } else {
            if (typeof Deno2?.env?.get !== "function" || typeof Deno2?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path6 = Deno2.cwd();
            if (path6 === undefined || path6.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path6 = `${resolvedDevice}\\`;
            }
        }
        assertPath(path6);
        const len = path6.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute1 = false;
        const code = path6.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code)) {
                isAbsolute1 = true;
                if (isPathSeparator(path6.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator(path6.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path6.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator(path6.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator(path6.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path6.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path6.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code)) {
                if (path6.charCodeAt(1) === 58) {
                    device = path6.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path6.charCodeAt(2))) {
                            isAbsolute1 = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute1 = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path6.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute1;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path7) {
    assertPath(path7);
    const len = path7.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute2 = false;
    const code = path7.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            isAbsolute2 = true;
            if (isPathSeparator(path7.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path7.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path7.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path7.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path7.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path7.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path7.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path7.charCodeAt(1) === 58) {
                device = path7.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path7.charCodeAt(2))) {
                        isAbsolute2 = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path7.slice(rootEnd), !isAbsolute2, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute2) tail = ".";
    if (tail.length > 0 && isPathSeparator(path7.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute2) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute2) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path8) {
    assertPath(path8);
    const len = path8.length;
    if (len === 0) return false;
    const code = path8.charCodeAt(0);
    if (isPathSeparator(code)) {
        return true;
    } else if (isWindowsDeviceRoot(code)) {
        if (len > 2 && path8.charCodeAt(1) === 58) {
            if (isPathSeparator(path8.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i4 = 0; i4 < pathsCount; ++i4){
        const path9 = paths[i4];
        assertPath(path9);
        if (path9.length > 0) {
            if (joined === undefined) joined = firstPart = path9;
            else joined += `\\${path9}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i5 = 0;
    for(; i5 <= length; ++i5){
        if (i5 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i5) === 92) {
                    return toOrig.slice(toStart + i5 + 1);
                } else if (i5 === 2) {
                    return toOrig.slice(toStart + i5);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i5) === 92) {
                    lastCommonSep = i5;
                } else if (i5 === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i5);
        const toCode = to.charCodeAt(toStart + i5);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i5;
    }
    if (i5 !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i5 = fromStart + lastCommonSep + 1; i5 <= fromEnd; ++i5){
        if (i5 === fromEnd || from.charCodeAt(i5) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path10) {
    if (typeof path10 !== "string") return path10;
    if (path10.length === 0) return "";
    const resolvedPath = resolve(path10);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path10;
}
function dirname(path11) {
    assertPath(path11);
    const len = path11.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path11.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path11.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path11.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path11.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path11.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path11;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path11.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path11.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return path11;
    }
    for(let i6 = len - 1; i6 >= offset; --i6){
        if (isPathSeparator(path11.charCodeAt(i6))) {
            if (!matchedSlash) {
                end = i6;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path11.slice(0, end);
}
function basename(path12, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path12);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i7;
    if (path12.length >= 2) {
        const drive = path12.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path12.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path12.length) {
        if (ext.length === path12.length && ext === path12) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i7 = path12.length - 1; i7 >= start; --i7){
            const code = path12.charCodeAt(i7);
            if (isPathSeparator(code)) {
                if (!matchedSlash) {
                    start = i7 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i7 + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i7;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path12.length;
        return path12.slice(start, end);
    } else {
        for(i7 = path12.length - 1; i7 >= start; --i7){
            if (isPathSeparator(path12.charCodeAt(i7))) {
                if (!matchedSlash) {
                    start = i7 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i7 + 1;
            }
        }
        if (end === -1) return "";
        return path12.slice(start, end);
    }
}
function extname(path13) {
    assertPath(path13);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path13.length >= 2 && path13.charCodeAt(1) === 58 && isWindowsDeviceRoot(path13.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i8 = path13.length - 1; i8 >= start; --i8){
        const code = path13.charCodeAt(i8);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i8 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i8 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i8;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path13.slice(startDot, end);
}
function format(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("\\", pathObject);
}
function parse(path14) {
    assertPath(path14);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path14.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path14.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path14.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path14.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path14.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path14.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path14.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path14.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path14;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path14;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        ret.root = ret.dir = path14;
        return ret;
    }
    if (rootEnd > 0) ret.root = path14.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i9 = path14.length - 1;
    let preDotState = 0;
    for(; i9 >= rootEnd; --i9){
        code = path14.charCodeAt(i9);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i9 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i9 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i9;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path14.slice(startPart, end);
        }
    } else {
        ret.name = path14.slice(startPart, startDot);
        ret.base = path14.slice(startPart, end);
        ret.ext = path14.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path14.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path15 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path15 = `\\\\${url.hostname}${path15}`;
    }
    return path15;
}
function toFileUrl(path16) {
    if (!isAbsolute(path16)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname2, pathname] = path16.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname2 != null && hostname2 != "localhost") {
        url.hostname = hostname2;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod = {
    sep: sep,
    delimiter: delimiter,
    resolve: resolve,
    normalize: normalize,
    isAbsolute: isAbsolute,
    join: join,
    relative: relative,
    toNamespacedPath: toNamespacedPath,
    dirname: dirname,
    basename: basename,
    extname: extname,
    format: format,
    parse: parse,
    fromFileUrl: fromFileUrl,
    toFileUrl: toFileUrl
};
const sep1 = "/";
const delimiter1 = ":";
function resolve1(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i10 = pathSegments.length - 1; i10 >= -1 && !resolvedAbsolute; i10--){
        let path17;
        if (i10 >= 0) path17 = pathSegments[i10];
        else {
            const { Deno: Deno3  } = globalThis;
            if (typeof Deno3?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path17 = Deno3.cwd();
        }
        assertPath(path17);
        if (path17.length === 0) {
            continue;
        }
        resolvedPath = `${path17}/${resolvedPath}`;
        resolvedAbsolute = path17.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize1(path18) {
    assertPath(path18);
    if (path18.length === 0) return ".";
    const isAbsolute1 = path18.charCodeAt(0) === 47;
    const trailingSeparator = path18.charCodeAt(path18.length - 1) === 47;
    path18 = normalizeString(path18, !isAbsolute1, "/", isPosixPathSeparator);
    if (path18.length === 0 && !isAbsolute1) path18 = ".";
    if (path18.length > 0 && trailingSeparator) path18 += "/";
    if (isAbsolute1) return `/${path18}`;
    return path18;
}
function isAbsolute1(path19) {
    assertPath(path19);
    return path19.length > 0 && path19.charCodeAt(0) === 47;
}
function join1(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i11 = 0, len = paths.length; i11 < len; ++i11){
        const path20 = paths[i11];
        assertPath(path20);
        if (path20.length > 0) {
            if (!joined) joined = path20;
            else joined += `/${path20}`;
        }
    }
    if (!joined) return ".";
    return normalize1(joined);
}
function relative1(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve1(from);
    to = resolve1(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i12 = 0;
    for(; i12 <= length; ++i12){
        if (i12 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i12) === 47) {
                    return to.slice(toStart + i12 + 1);
                } else if (i12 === 0) {
                    return to.slice(toStart + i12);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i12) === 47) {
                    lastCommonSep = i12;
                } else if (i12 === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i12);
        const toCode = to.charCodeAt(toStart + i12);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i12;
    }
    let out = "";
    for(i12 = fromStart + lastCommonSep + 1; i12 <= fromEnd; ++i12){
        if (i12 === fromEnd || from.charCodeAt(i12) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath1(path21) {
    return path21;
}
function dirname1(path22) {
    assertPath(path22);
    if (path22.length === 0) return ".";
    const hasRoot = path22.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i13 = path22.length - 1; i13 >= 1; --i13){
        if (path22.charCodeAt(i13) === 47) {
            if (!matchedSlash) {
                end = i13;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path22.slice(0, end);
}
function basename1(path23, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path23);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i14;
    if (ext !== undefined && ext.length > 0 && ext.length <= path23.length) {
        if (ext.length === path23.length && ext === path23) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i14 = path23.length - 1; i14 >= 0; --i14){
            const code = path23.charCodeAt(i14);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i14 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i14 + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i14;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path23.length;
        return path23.slice(start, end);
    } else {
        for(i14 = path23.length - 1; i14 >= 0; --i14){
            if (path23.charCodeAt(i14) === 47) {
                if (!matchedSlash) {
                    start = i14 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i14 + 1;
            }
        }
        if (end === -1) return "";
        return path23.slice(start, end);
    }
}
function extname1(path24) {
    assertPath(path24);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i15 = path24.length - 1; i15 >= 0; --i15){
        const code = path24.charCodeAt(i15);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i15 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i15 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i15;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path24.slice(startDot, end);
}
function format1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("/", pathObject);
}
function parse1(path25) {
    assertPath(path25);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path25.length === 0) return ret;
    const isAbsolute2 = path25.charCodeAt(0) === 47;
    let start;
    if (isAbsolute2) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i16 = path25.length - 1;
    let preDotState = 0;
    for(; i16 >= start; --i16){
        const code = path25.charCodeAt(i16);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i16 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i16 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i16;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute2) {
                ret.base = ret.name = path25.slice(1, end);
            } else {
                ret.base = ret.name = path25.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute2) {
            ret.name = path25.slice(1, startDot);
            ret.base = path25.slice(1, end);
        } else {
            ret.name = path25.slice(startPart, startDot);
            ret.base = path25.slice(startPart, end);
        }
        ret.ext = path25.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path25.slice(0, startPart - 1);
    else if (isAbsolute2) ret.dir = "/";
    return ret;
}
function fromFileUrl1(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path26) {
    if (!isAbsolute1(path26)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(path26.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod1 = {
    sep: sep1,
    delimiter: delimiter1,
    resolve: resolve1,
    normalize: normalize1,
    isAbsolute: isAbsolute1,
    join: join1,
    relative: relative1,
    toNamespacedPath: toNamespacedPath1,
    dirname: dirname1,
    basename: basename1,
    extname: extname1,
    format: format1,
    parse: parse1,
    fromFileUrl: fromFileUrl1,
    toFileUrl: toFileUrl1
};
const path = isWindows ? mod : mod1;
const { join: join2 , normalize: normalize2  } = path;
const path1 = isWindows ? mod : mod1;
const { basename: basename2 , delimiter: delimiter2 , dirname: dirname2 , extname: extname2 , format: format2 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join3 , normalize: normalize3 , parse: parse2 , relative: relative2 , resolve: resolve2 , sep: sep2 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath2 ,  } = path1;
function addSignalListener(...args) {
    if (typeof Deno.addSignalListener == "function") {
        return Deno.addSignalListener(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function getUid(...args) {
    if (typeof Deno.getUid == "function") {
        return Deno.getUid(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function hostname(...args) {
    if (typeof Deno.hostname == "function") {
        return Deno.hostname(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function osRelease(...args) {
    if (typeof Deno.osRelease == "function") {
        return Deno.osRelease(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function removeSignalListener(...args) {
    if (typeof Deno.removeSignalListener == "function") {
        return Deno.removeSignalListener(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function setRaw(...args) {
    if (typeof Deno.setRaw == "function") {
        return Deno.setRaw(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function systemMemoryInfo(...args) {
    if (typeof Deno.systemMemoryInfo == "function") {
        return Deno.systemMemoryInfo(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function utime(...args) {
    if (typeof Deno.utime == "function") {
        return Deno.utime(...args);
    } else {
        return Promise.reject(new TypeError("Requires --unstable"));
    }
}
async function connect(options) {
    return await Deno.connect(options);
}
function listen(options) {
    return Deno.listen(options);
}
function listenDatagram(options) {
    return Deno.listenDatagram(options);
}
function ListenerRef(listener, ...args) {
    if (typeof listener.ref == "function") {
        return listener.ref(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function ListenerUnref(listener, ...args) {
    if (typeof listener.unref == "function") {
        return listener.unref(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
const codes = {};
function hideStackFrames(fn) {
    const hidden = "__node_internal_" + fn.name;
    Object.defineProperty(fn, "name", {
        value: hidden
    });
    return fn;
}
const _toString = Object.prototype.toString;
const _isObjectLike = (value)=>value !== null && typeof value === "object"
;
const _isFunctionLike = (value)=>value !== null && typeof value === "function"
;
function isAnyArrayBuffer(value) {
    return _isObjectLike(value) && (_toString.call(value) === "[object ArrayBuffer]" || _toString.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Arguments]";
}
function isArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object AsyncFunction]";
}
function isBooleanObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Boolean]";
}
function isBoxedPrimitive(value) {
    return isBooleanObject(value) || isStringObject(value) || isNumberObject(value) || isSymbolObject(value) || isBigIntObject(value);
}
function isDataView(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object DataView]";
}
function isDate(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Date]";
}
function isGeneratorFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Generator]";
}
function isMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map]";
}
function isMapIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Module]";
}
function isNativeError(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Error]";
}
function isNumberObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Number]";
}
function isBigIntObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object BigInt]";
}
function isPromise(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Promise]";
}
function isRegExp(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object RegExp]";
}
function isSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set]";
}
function isSetIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object String]";
}
function isSymbolObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Symbol]";
}
function isWeakMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakMap]";
}
function isWeakSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakSet]";
}
const __default = {
    isAsyncFunction,
    isGeneratorFunction,
    isAnyArrayBuffer,
    isArrayBuffer,
    isArgumentsObject,
    isBoxedPrimitive,
    isDataView,
    isMap,
    isMapIterator,
    isModuleNamespaceObject,
    isNativeError,
    isPromise,
    isSet,
    isSetIterator,
    isWeakMap,
    isWeakSet,
    isRegExp,
    isDate,
    isStringObject,
    isNumberObject,
    isBooleanObject,
    isBigIntObject
};
const mod2 = {
    isAnyArrayBuffer: isAnyArrayBuffer,
    isArgumentsObject: isArgumentsObject,
    isArrayBuffer: isArrayBuffer,
    isAsyncFunction: isAsyncFunction,
    isBooleanObject: isBooleanObject,
    isBoxedPrimitive: isBoxedPrimitive,
    isDataView: isDataView,
    isDate: isDate,
    isGeneratorFunction: isGeneratorFunction,
    isGeneratorObject: isGeneratorObject,
    isMap: isMap,
    isMapIterator: isMapIterator,
    isModuleNamespaceObject: isModuleNamespaceObject,
    isNativeError: isNativeError,
    isNumberObject: isNumberObject,
    isBigIntObject: isBigIntObject,
    isPromise: isPromise,
    isRegExp: isRegExp,
    isSet: isSet,
    isSetIterator: isSetIterator,
    isSharedArrayBuffer: isSharedArrayBuffer,
    isStringObject: isStringObject,
    isSymbolObject: isSymbolObject,
    isWeakMap: isWeakMap,
    isWeakSet: isWeakSet,
    default: __default
};
Symbol("kHandle");
Symbol("kKeyObject");
Symbol("kKeyType");
const _toString1 = Object.prototype.toString;
const _isObjectLike1 = (value)=>value !== null && typeof value === "object"
;
function isArrayBufferView(value) {
    return ArrayBuffer.isView(value);
}
function isBigUint64Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object BigUint64Array]";
}
function isFloat32Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Float32Array]";
}
function isFloat64Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Float64Array]";
}
function isTypedArray(value) {
    const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
    return _isObjectLike1(value) && reTypedTag.test(_toString1.call(value));
}
function isUint8Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Uint8Array]";
}
const { isDate: isDate1 , isArgumentsObject: isArgumentsObject1 , isBigIntObject: isBigIntObject1 , isBooleanObject: isBooleanObject1 , isNumberObject: isNumberObject1 , isStringObject: isStringObject1 , isSymbolObject: isSymbolObject1 , isNativeError: isNativeError1 , isRegExp: isRegExp1 , isAsyncFunction: isAsyncFunction1 , isGeneratorFunction: isGeneratorFunction1 , isGeneratorObject: isGeneratorObject1 , isPromise: isPromise1 , isMap: isMap1 , isSet: isSet1 , isMapIterator: isMapIterator1 , isSetIterator: isSetIterator1 , isWeakMap: isWeakMap1 , isWeakSet: isWeakSet1 , isArrayBuffer: isArrayBuffer1 , isDataView: isDataView1 , isSharedArrayBuffer: isSharedArrayBuffer1 , isModuleNamespaceObject: isModuleNamespaceObject1 , isAnyArrayBuffer: isAnyArrayBuffer1 , isBoxedPrimitive: isBoxedPrimitive1 ,  } = mod2;
function normalizeEncoding(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases(enc);
}
function slowCases(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        case 9:
            if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
                return "base64url";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function isInt32(value) {
    return value === (value | 0);
}
function isUint32(value) {
    return value === value >>> 0;
}
const octalReg = /^[0-7]+$/;
const modeDesc = "must be a 32-bit unsigned integer or an octal string";
function parseFileMode(value, name1, def) {
    value ??= def;
    if (typeof value === "string") {
        if (!octalReg.test(value)) {
            throw new codes.ERR_INVALID_ARG_VALUE(name1, value, modeDesc);
        }
        value = Number.parseInt(value, 8);
    }
    validateInt32(value, name1, 0, 2 ** 32 - 1);
    return value;
}
const validateBuffer = hideStackFrames((buffer, name2 = "buffer")=>{
    if (!isArrayBufferView(buffer)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name2, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer);
    }
});
const validateInteger = hideStackFrames((value, name3, min1 = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER)=>{
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name3, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name3, "an integer", value);
    }
    if (value < min1 || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name3, `>= ${min1} && <= ${max}`, value);
    }
});
const validateObject = hideStackFrames((value, name4, options)=>{
    const useDefaultOptions = options == null;
    const allowArray = useDefaultOptions ? false : options.allowArray;
    const allowFunction = useDefaultOptions ? false : options.allowFunction;
    const nullable = useDefaultOptions ? false : options.nullable;
    if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new codes.ERR_INVALID_ARG_TYPE(name4, "Object", value);
    }
});
const validateInt32 = hideStackFrames((value, name5, min2 = -2147483648, max = 2147483647)=>{
    if (!isInt32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name5, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name5, "an integer", value);
        }
        throw new codes.ERR_OUT_OF_RANGE(name5, `>= ${min2} && <= ${max}`, value);
    }
    if (value < min2 || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name5, `>= ${min2} && <= ${max}`, value);
    }
});
const validateUint32 = hideStackFrames((value, name6, positive)=>{
    if (!isUint32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name6, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name6, "an integer", value);
        }
        const min3 = positive ? 1 : 0;
        throw new codes.ERR_OUT_OF_RANGE(name6, `>= ${min3} && < 4294967296`, value);
    }
    if (positive && value === 0) {
        throw new codes.ERR_OUT_OF_RANGE(name6, ">= 1 && < 4294967296", value);
    }
});
function validateString(value, name7) {
    if (typeof value !== "string") {
        throw new codes.ERR_INVALID_ARG_TYPE(name7, "string", value);
    }
}
function validateBoolean(value, name8) {
    if (typeof value !== "boolean") {
        throw new codes.ERR_INVALID_ARG_TYPE(name8, "boolean", value);
    }
}
hideStackFrames((value, name9, oneOf)=>{
    if (!Array.prototype.includes.call(oneOf, value)) {
        const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v)=>typeof v === "string" ? `'${v}'` : String(v)
        ), ", ");
        const reason = "must be one of: " + allowed;
        throw new codes.ERR_INVALID_ARG_VALUE(name9, value, reason);
    }
});
function validateEncoding(data, encoding) {
    const normalizedEncoding = normalizeEncoding(encoding);
    const length = data.length;
    if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new codes.ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
    }
}
const validateCallback = hideStackFrames((callback)=>{
    if (typeof callback !== "function") {
        throw new codes.ERR_INVALID_CALLBACK(callback);
    }
});
const validateAbortSignal = hideStackFrames((signal, name10)=>{
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new codes.ERR_INVALID_ARG_TYPE(name10, "AbortSignal", signal);
    }
});
const validateFunction = hideStackFrames((value, name11)=>{
    if (typeof value !== "function") {
        throw new codes.ERR_INVALID_ARG_TYPE(name11, "Function", value);
    }
});
hideStackFrames((value, name12, minLength = 0)=>{
    if (!Array.isArray(value)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name12, "Array", value);
    }
    if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new codes.ERR_INVALID_ARG_VALUE(name12, value, reason);
    }
});
function delay(ms, options = {}) {
    const { signal  } = options;
    if (signal?.aborted) {
        return Promise.reject(new DOMException("Delay was aborted.", "AbortError"));
    }
    return new Promise((resolve6, reject)=>{
        const abort = ()=>{
            clearTimeout(i17);
            reject(new DOMException("Delay was aborted.", "AbortError"));
        };
        const done = ()=>{
            signal?.removeEventListener("abort", abort);
            resolve6();
        };
        const i17 = setTimeout(done, ms);
        signal?.addEventListener("abort", abort, {
            once: true
        });
    });
}
const { Deno: Deno4  } = globalThis;
typeof Deno4?.noColor === "boolean" ? Deno4.noColor : true;
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))", 
].join("|"), "g");
var DiffType;
(function(DiffType1) {
    DiffType1["removed"] = "removed";
    DiffType1["common"] = "common";
    DiffType1["added"] = "added";
})(DiffType || (DiffType = {}));
class AssertionError extends Error {
    name = "AssertionError";
    constructor(message){
        super(message);
    }
}
function unreachable() {
    throw new AssertionError("unreachable");
}
function notImplemented(msg) {
    const message = msg ? `Not implemented: ${msg}` : "Not implemented";
    throw new Error(message);
}
function warnNotImplemented(msg) {
    const message = msg ? `Not implemented: ${msg}` : "Not implemented";
    console.warn(message);
}
function intoCallbackAPIWithIntercept(func, interceptor, cb, ...args) {
    func(...args).then((value)=>cb && cb(null, interceptor(value))
    , (err)=>cb && cb(err)
    );
}
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function normalizeEncoding1(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases1(enc);
}
function slowCases1(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function isFileOptions(fileOptions) {
    if (!fileOptions) return false;
    return fileOptions.encoding != undefined || fileOptions.flag != undefined || fileOptions.signal != undefined || fileOptions.mode != undefined;
}
function getEncoding(optOrCallback) {
    if (!optOrCallback || typeof optOrCallback === "function") {
        return null;
    }
    const encoding = typeof optOrCallback === "string" ? optOrCallback : optOrCallback.encoding;
    if (!encoding) return null;
    return encoding;
}
function checkEncoding(encoding) {
    if (!encoding) return null;
    encoding = encoding.toLowerCase();
    if ([
        "utf8",
        "hex",
        "base64"
    ].includes(encoding)) return encoding;
    if (encoding === "utf-8") {
        return "utf8";
    }
    if (encoding === "binary") {
        return "binary";
    }
    const notImplementedEncodings = [
        "utf16le",
        "latin1",
        "ascii",
        "ucs2"
    ];
    if (notImplementedEncodings.includes(encoding)) {
        notImplemented(`"${encoding}" encoding`);
    }
    throw new Error(`The value "${encoding}" is invalid for option "encoding"`);
}
function getOpenOptions(flag) {
    if (!flag) {
        return {
            create: true,
            append: true
        };
    }
    let openOptions;
    switch(flag){
        case "a":
            {
                openOptions = {
                    create: true,
                    append: true
                };
                break;
            }
        case "ax":
            {
                openOptions = {
                    createNew: true,
                    write: true,
                    append: true
                };
                break;
            }
        case "a+":
            {
                openOptions = {
                    read: true,
                    create: true,
                    append: true
                };
                break;
            }
        case "ax+":
            {
                openOptions = {
                    read: true,
                    createNew: true,
                    append: true
                };
                break;
            }
        case "r":
            {
                openOptions = {
                    read: true
                };
                break;
            }
        case "r+":
            {
                openOptions = {
                    read: true,
                    write: true
                };
                break;
            }
        case "w":
            {
                openOptions = {
                    create: true,
                    write: true,
                    truncate: true
                };
                break;
            }
        case "wx":
            {
                openOptions = {
                    createNew: true,
                    write: true
                };
                break;
            }
        case "w+":
            {
                openOptions = {
                    create: true,
                    write: true,
                    truncate: true,
                    read: true
                };
                break;
            }
        case "wx+":
            {
                openOptions = {
                    createNew: true,
                    write: true,
                    read: true
                };
                break;
            }
        case "as":
            {
                openOptions = {
                    create: true,
                    append: true
                };
                break;
            }
        case "as+":
            {
                openOptions = {
                    create: true,
                    read: true,
                    append: true
                };
                break;
            }
        case "rs+":
            {
                openOptions = {
                    create: true,
                    read: true,
                    write: true
                };
                break;
            }
        default:
            {
                throw new Error(`Unrecognized file system flag: ${flag}`);
            }
    }
    return openOptions;
}
function maybeCallback(cb) {
    validateCallback(cb);
    return cb;
}
function makeCallback(cb) {
    validateCallback(cb);
    return (...args)=>Reflect.apply(cb, this, args)
    ;
}
const os = {
    UV_UDP_IPV6ONLY: 1,
    UV_UDP_PARTIAL: 2,
    UV_UDP_REUSEADDR: 4,
    UV_UDP_MMSG_CHUNK: 8,
    UV_UDP_MMSG_FREE: 16,
    UV_UDP_LINUX_RECVERR: 32,
    UV_UDP_RECVMMSG: 256,
    dlopen: {
        RTLD_LAZY: 1,
        RTLD_NOW: 2,
        RTLD_GLOBAL: 8,
        RTLD_LOCAL: 4
    },
    errno: {
        E2BIG: 7,
        EACCES: 13,
        EADDRINUSE: 48,
        EADDRNOTAVAIL: 49,
        EAFNOSUPPORT: 47,
        EAGAIN: 35,
        EALREADY: 37,
        EBADF: 9,
        EBADMSG: 94,
        EBUSY: 16,
        ECANCELED: 89,
        ECHILD: 10,
        ECONNABORTED: 53,
        ECONNREFUSED: 61,
        ECONNRESET: 54,
        EDEADLK: 11,
        EDESTADDRREQ: 39,
        EDOM: 33,
        EDQUOT: 69,
        EEXIST: 17,
        EFAULT: 14,
        EFBIG: 27,
        EHOSTUNREACH: 65,
        EIDRM: 90,
        EILSEQ: 92,
        EINPROGRESS: 36,
        EINTR: 4,
        EINVAL: 22,
        EIO: 5,
        EISCONN: 56,
        EISDIR: 21,
        ELOOP: 62,
        EMFILE: 24,
        EMLINK: 31,
        EMSGSIZE: 40,
        EMULTIHOP: 95,
        ENAMETOOLONG: 63,
        ENETDOWN: 50,
        ENETRESET: 52,
        ENETUNREACH: 51,
        ENFILE: 23,
        ENOBUFS: 55,
        ENODATA: 96,
        ENODEV: 19,
        ENOENT: 2,
        ENOEXEC: 8,
        ENOLCK: 77,
        ENOLINK: 97,
        ENOMEM: 12,
        ENOMSG: 91,
        ENOPROTOOPT: 42,
        ENOSPC: 28,
        ENOSR: 98,
        ENOSTR: 99,
        ENOSYS: 78,
        ENOTCONN: 57,
        ENOTDIR: 20,
        ENOTEMPTY: 66,
        ENOTSOCK: 38,
        ENOTSUP: 45,
        ENOTTY: 25,
        ENXIO: 6,
        EOPNOTSUPP: 102,
        EOVERFLOW: 84,
        EPERM: 1,
        EPIPE: 32,
        EPROTO: 100,
        EPROTONOSUPPORT: 43,
        EPROTOTYPE: 41,
        ERANGE: 34,
        EROFS: 30,
        ESPIPE: 29,
        ESRCH: 3,
        ESTALE: 70,
        ETIME: 101,
        ETIMEDOUT: 60,
        ETXTBSY: 26,
        EWOULDBLOCK: 35,
        EXDEV: 18
    },
    signals: {
        SIGHUP: 1,
        SIGINT: 2,
        SIGQUIT: 3,
        SIGILL: 4,
        SIGTRAP: 5,
        SIGABRT: 6,
        SIGIOT: 6,
        SIGBUS: 10,
        SIGFPE: 8,
        SIGKILL: 9,
        SIGUSR1: 30,
        SIGSEGV: 11,
        SIGUSR2: 31,
        SIGPIPE: 13,
        SIGALRM: 14,
        SIGTERM: 15,
        SIGCHLD: 20,
        SIGCONT: 19,
        SIGSTOP: 17,
        SIGTSTP: 18,
        SIGTTIN: 21,
        SIGBREAK: 21,
        SIGTTOU: 22,
        SIGURG: 16,
        SIGXCPU: 24,
        SIGXFSZ: 25,
        SIGVTALRM: 26,
        SIGPROF: 27,
        SIGWINCH: 28,
        SIGIO: 23,
        SIGINFO: 29,
        SIGSYS: 12,
        SIGEMT: 7,
        SIGPWR: 30,
        SIGSTKFLT: 16
    },
    priority: {
        PRIORITY_LOW: 19,
        PRIORITY_BELOW_NORMAL: 10,
        PRIORITY_NORMAL: 0,
        PRIORITY_ABOVE_NORMAL: -7,
        PRIORITY_HIGH: -14,
        PRIORITY_HIGHEST: -20
    }
};
const fs = {
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    UV_DIRENT_UNKNOWN: 0,
    UV_DIRENT_FILE: 1,
    UV_DIRENT_DIR: 2,
    UV_DIRENT_LINK: 3,
    UV_DIRENT_FIFO: 4,
    UV_DIRENT_SOCKET: 5,
    UV_DIRENT_CHAR: 6,
    UV_DIRENT_BLOCK: 7,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 512,
    O_EXCL: 2048,
    UV_FS_O_FILEMAP: 0,
    O_NOCTTY: 131072,
    O_TRUNC: 1024,
    O_APPEND: 8,
    O_DIRECTORY: 1048576,
    O_NOFOLLOW: 256,
    O_SYNC: 128,
    O_DSYNC: 4194304,
    O_SYMLINK: 2097152,
    O_NONBLOCK: 4,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_COPYFILE_EXCL: 1,
    COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_FICLONE_FORCE: 4
};
const crypto = {
    OPENSSL_VERSION_NUMBER: 269488319,
    SSL_OP_ALL: 2147485780,
    SSL_OP_ALLOW_NO_DHE_KEX: 1024,
    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
    SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
    SSL_OP_CISCO_ANYCONNECT: 32768,
    SSL_OP_COOKIE_EXCHANGE: 8192,
    SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
    SSL_OP_EPHEMERAL_RSA: 0,
    SSL_OP_LEGACY_SERVER_CONNECT: 4,
    SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0,
    SSL_OP_MICROSOFT_SESS_ID_BUG: 0,
    SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
    SSL_OP_NETSCAPE_CA_DN_BUG: 0,
    SSL_OP_NETSCAPE_CHALLENGE_BUG: 0,
    SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NO_COMPRESSION: 131072,
    SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
    SSL_OP_NO_QUERY_MTU: 4096,
    SSL_OP_NO_RENEGOTIATION: 1073741824,
    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
    SSL_OP_NO_SSLv2: 0,
    SSL_OP_NO_SSLv3: 33554432,
    SSL_OP_NO_TICKET: 16384,
    SSL_OP_NO_TLSv1: 67108864,
    SSL_OP_NO_TLSv1_1: 268435456,
    SSL_OP_NO_TLSv1_2: 134217728,
    SSL_OP_NO_TLSv1_3: 536870912,
    SSL_OP_PKCS1_CHECK_1: 0,
    SSL_OP_PKCS1_CHECK_2: 0,
    SSL_OP_PRIORITIZE_CHACHA: 2097152,
    SSL_OP_SINGLE_DH_USE: 0,
    SSL_OP_SINGLE_ECDH_USE: 0,
    SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0,
    SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
    SSL_OP_TLS_BLOCK_PADDING_BUG: 0,
    SSL_OP_TLS_D5_BUG: 0,
    SSL_OP_TLS_ROLLBACK_BUG: 8388608,
    ENGINE_METHOD_RSA: 1,
    ENGINE_METHOD_DSA: 2,
    ENGINE_METHOD_DH: 4,
    ENGINE_METHOD_RAND: 8,
    ENGINE_METHOD_EC: 2048,
    ENGINE_METHOD_CIPHERS: 64,
    ENGINE_METHOD_DIGESTS: 128,
    ENGINE_METHOD_PKEY_METHS: 512,
    ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
    ENGINE_METHOD_ALL: 65535,
    ENGINE_METHOD_NONE: 0,
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    RSA_PSS_SALTLEN_DIGEST: -1,
    RSA_PSS_SALTLEN_MAX_SIGN: -2,
    RSA_PSS_SALTLEN_AUTO: -2,
    defaultCoreCipherList: "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
    TLS1_VERSION: 769,
    TLS1_1_VERSION: 770,
    TLS1_2_VERSION: 771,
    TLS1_3_VERSION: 772,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
};
const zlib = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    ZLIB_VERNUM: 4784,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_PARAM_MODE: 0,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
};
const trace = {
    TRACE_EVENT_PHASE_BEGIN: 66,
    TRACE_EVENT_PHASE_END: 69,
    TRACE_EVENT_PHASE_COMPLETE: 88,
    TRACE_EVENT_PHASE_INSTANT: 73,
    TRACE_EVENT_PHASE_ASYNC_BEGIN: 83,
    TRACE_EVENT_PHASE_ASYNC_STEP_INTO: 84,
    TRACE_EVENT_PHASE_ASYNC_STEP_PAST: 112,
    TRACE_EVENT_PHASE_ASYNC_END: 70,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN: 98,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_END: 101,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT: 110,
    TRACE_EVENT_PHASE_FLOW_BEGIN: 115,
    TRACE_EVENT_PHASE_FLOW_STEP: 116,
    TRACE_EVENT_PHASE_FLOW_END: 102,
    TRACE_EVENT_PHASE_METADATA: 77,
    TRACE_EVENT_PHASE_COUNTER: 67,
    TRACE_EVENT_PHASE_SAMPLE: 80,
    TRACE_EVENT_PHASE_CREATE_OBJECT: 78,
    TRACE_EVENT_PHASE_SNAPSHOT_OBJECT: 79,
    TRACE_EVENT_PHASE_DELETE_OBJECT: 68,
    TRACE_EVENT_PHASE_MEMORY_DUMP: 118,
    TRACE_EVENT_PHASE_MARK: 82,
    TRACE_EVENT_PHASE_CLOCK_SYNC: 99,
    TRACE_EVENT_PHASE_ENTER_CONTEXT: 40,
    TRACE_EVENT_PHASE_LEAVE_CONTEXT: 41,
    TRACE_EVENT_PHASE_LINK_IDS: 61
};
const mod3 = {
    os: os,
    fs: fs,
    crypto: crypto,
    zlib: zlib,
    trace: trace
};
Symbol.for("nodejs.util.inspect.custom");
const kEnumerableProperty = Object.create(null);
kEnumerableProperty.enumerable = true;
function once(callback) {
    let called = false;
    return function(...args) {
        if (called) return;
        called = true;
        Reflect.apply(callback, this, args);
    };
}
function createDeferredPromise() {
    let resolve7;
    let reject;
    const promise = new Promise((res, rej)=>{
        resolve7 = res;
        reject = rej;
    });
    return {
        promise,
        resolve: resolve7,
        reject
    };
}
new Set();
const kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom");
const kCustomPromisifyArgsSymbol = Symbol.for("nodejs.util.promisify.customArgs");
function promisify(original) {
    validateFunction(original, "original");
    if (original[kCustomPromisifiedSymbol]) {
        const fn = original[kCustomPromisifiedSymbol];
        validateFunction(fn, "util.promisify.custom");
        return Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    const argumentNames = original[kCustomPromisifyArgsSymbol];
    function fn(...args) {
        return new Promise((resolve8, reject)=>{
            args.push((err, ...values)=>{
                if (err) {
                    return reject(err);
                }
                if (argumentNames !== undefined && values.length > 1) {
                    const obj = {};
                    for(let i18 = 0; i18 < argumentNames.length; i18++){
                        obj[argumentNames[i18]] = values[i18];
                    }
                    resolve8(obj);
                } else {
                    resolve8(values[0]);
                }
            });
            Reflect.apply(original, this, args);
        });
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(original));
}
promisify.custom = kCustomPromisifiedSymbol;
var Encodings;
(function(Encodings1) {
    Encodings1[Encodings1["ASCII"] = 0] = "ASCII";
    Encodings1[Encodings1["UTF8"] = 1] = "UTF8";
    Encodings1[Encodings1["BASE64"] = 2] = "BASE64";
    Encodings1[Encodings1["UCS2"] = 3] = "UCS2";
    Encodings1[Encodings1["BINARY"] = 4] = "BINARY";
    Encodings1[Encodings1["HEX"] = 5] = "HEX";
    Encodings1[Encodings1["BUFFER"] = 6] = "BUFFER";
    Encodings1[Encodings1["BASE64URL"] = 7] = "BASE64URL";
    Encodings1[Encodings1["LATIN1"] = 4] = "LATIN1";
})(Encodings || (Encodings = {}));
const encodings = [];
encodings[Encodings.ASCII] = "ascii";
encodings[Encodings.BASE64] = "base64";
encodings[Encodings.BASE64URL] = "base64url";
encodings[Encodings.BUFFER] = "buffer";
encodings[Encodings.HEX] = "hex";
encodings[Encodings.LATIN1] = "latin1";
encodings[Encodings.UCS2] = "utf16le";
encodings[Encodings.UTF8] = "utf8";
const __default1 = {
    encodings
};
const mod4 = {
    encodings: encodings,
    default: __default1
};
function indexOfNeedle(source, needle, start = 0) {
    if (start >= source.length) {
        return -1;
    }
    if (start < 0) {
        start = Math.max(0, source.length + start);
    }
    const s = needle[0];
    for(let i19 = start; i19 < source.length; i19++){
        if (source[i19] !== s) continue;
        const pin = i19;
        let matched = 1;
        let j = i19;
        while(matched < needle.length){
            j++;
            if (source[j] !== needle[j - pin]) {
                break;
            }
            matched++;
        }
        if (matched === needle.length) {
            return pin;
        }
    }
    return -1;
}
function copy(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
function numberToBytes(n) {
    if (n === 0) return new Uint8Array([
        0
    ]);
    const bytes = [];
    bytes.unshift(n & 255);
    while(n >= 256){
        n = n >>> 8;
        bytes.unshift(n & 255);
    }
    return new Uint8Array(bytes);
}
function findLastIndex(targetBuffer, buffer, offset) {
    offset = offset > targetBuffer.length ? targetBuffer.length : offset;
    const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
    const searchableBufferLastIndex = searchableBuffer.length - 1;
    const bufferLastIndex = buffer.length - 1;
    let lastMatchIndex = -1;
    let matches = 0;
    let index = -1;
    for(let x = 0; x <= searchableBufferLastIndex; x++){
        if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
            if (lastMatchIndex === -1) {
                lastMatchIndex = x;
            }
            matches++;
        } else {
            matches = 0;
            if (lastMatchIndex !== -1) {
                x = lastMatchIndex + 1;
                lastMatchIndex = -1;
            }
            continue;
        }
        if (matches === buffer.length) {
            index = x;
            break;
        }
    }
    if (index === -1) return index;
    return searchableBufferLastIndex - index;
}
function indexOfBuffer(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
    if (!Encodings[encoding] === undefined) {
        throw new Error(`Unknown encoding code ${encoding}`);
    }
    if (!forwardDirection) {
        if (byteOffset < 0) {
            byteOffset = targetBuffer.length + byteOffset;
        }
        if (buffer.length === 0) {
            return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
        }
        return findLastIndex(targetBuffer, buffer, byteOffset);
    }
    if (buffer.length === 0) {
        return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return indexOfNeedle(targetBuffer, buffer, byteOffset);
}
function indexOfNumber(targetBuffer, number, byteOffset, forwardDirection) {
    const bytes = numberToBytes(number);
    if (bytes.length > 1) {
        throw new Error("Multi byte number search is not supported");
    }
    return indexOfBuffer(targetBuffer, numberToBytes(number), byteOffset, Encodings.UTF8, forwardDirection);
}
const __default2 = {
    indexOfBuffer,
    indexOfNumber
};
const mod5 = {
    indexOfBuffer: indexOfBuffer,
    indexOfNumber: indexOfNumber,
    numberToBytes: numberToBytes,
    default: __default2
};
const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/", 
];
function encode(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i20;
    const l = uint8.length;
    for(i20 = 2; i20 < l; i20 += 3){
        result += base64abc[uint8[i20 - 2] >> 2];
        result += base64abc[(uint8[i20 - 2] & 0x03) << 4 | uint8[i20 - 1] >> 4];
        result += base64abc[(uint8[i20 - 1] & 0x0f) << 2 | uint8[i20] >> 6];
        result += base64abc[uint8[i20] & 0x3f];
    }
    if (i20 === l + 1) {
        result += base64abc[uint8[i20 - 2] >> 2];
        result += base64abc[(uint8[i20 - 2] & 0x03) << 4];
        result += "==";
    }
    if (i20 === l) {
        result += base64abc[uint8[i20 - 2] >> 2];
        result += base64abc[(uint8[i20 - 2] & 0x03) << 4 | uint8[i20 - 1] >> 4];
        result += base64abc[(uint8[i20 - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i21 = 0; i21 < size; i21++){
        bytes[i21] = binString.charCodeAt(i21);
    }
    return bytes;
}
function addPaddingToBase64url(base64url) {
    if (base64url.length % 4 === 2) return base64url + "==";
    if (base64url.length % 4 === 3) return base64url + "=";
    if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
    }
    return base64url;
}
function convertBase64urlToBase64(b64url) {
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
    }
    return addPaddingToBase64url(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode1(data) {
    return convertBase64ToBase64url(encode(data));
}
function decode1(b64url) {
    return decode(convertBase64urlToBase64(b64url));
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i22 = 0; i22 < str.length; ++i22){
        byteArray.push(str.charCodeAt(i22) & 255);
    }
    return new Uint8Array(byteArray);
}
function base64ToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("-", "+").replaceAll("_", "/");
    return decode(str);
}
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while(str.length % 4 !== 0){
        str = str + "=";
    }
    return str;
}
function base64UrlToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("+", "-").replaceAll("/", "_");
    return decode1(str);
}
function hexToBytes(str) {
    const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
    let i23;
    for(i23 = 0; i23 < byteArray.length; i23++){
        const a = Number.parseInt(str[i23 * 2], 16);
        const b = Number.parseInt(str[i23 * 2 + 1], 16);
        if (Number.isNaN(a) && Number.isNaN(b)) {
            break;
        }
        byteArray[i23] = a << 4 | b;
    }
    return new Uint8Array(i23 === byteArray.length ? byteArray : byteArray.slice(0, i23));
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i24 = 0; i24 < str.length; ++i24){
        if ((units -= 2) < 0) {
            break;
        }
        c = str.charCodeAt(i24);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return new Uint8Array(byteArray);
}
function bytesToAscii(bytes) {
    let ret = "";
    for(let i25 = 0; i25 < bytes.length; ++i25){
        ret += String.fromCharCode(bytes[i25] & 127);
    }
    return ret;
}
function bytesToUtf16le(bytes) {
    let res = "";
    for(let i26 = 0; i26 < bytes.length - 1; i26 += 2){
        res += String.fromCharCode(bytes[i26] + bytes[i26 + 1] * 256);
    }
    return res;
}
const utf8Encoder = new TextEncoder();
const float32Array = new Float32Array(1);
const uInt8Float32Array = new Uint8Array(float32Array.buffer);
const float64Array = new Float64Array(1);
const uInt8Float64Array = new Uint8Array(float64Array.buffer);
float32Array[0] = -1;
const bigEndian = uInt8Float32Array[3] === 0;
function readUInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first * 2 ** 8 + last;
}
function readUInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[7] = first;
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[0] = last;
    return float64Array[0];
}
function readDoubleForwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[0] = first;
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[7] = last;
    return float64Array[0];
}
function writeDoubleForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[0];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[7];
    return offset;
}
function writeDoubleBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[7];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[0];
    return offset;
}
function readFloatBackwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[3] = first;
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[0] = last;
    return float32Array[0];
}
function readFloatForwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[0] = first;
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[3] = last;
    return float32Array[0];
}
function writeFloatForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[0];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[3];
    return offset;
}
function writeFloatBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[3];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[0];
    return offset;
}
function readInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[offset + 4] + last * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[++offset] + first * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf8(str) {
    return utf8Encoder.encode(str).length;
}
function base64ByteLength(str, bytes) {
    if (str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    return bytes * 3 >>> 2;
}
const encodingsMap = Object.create(null);
for(let i = 0; i < encodings.length; ++i){
    encodingsMap[encodings[i]] = i;
}
const encodingOps = {
    ascii: {
        byteLength: (string)=>string.length
        ,
        encoding: "ascii",
        encodingVal: encodingsMap.ascii,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.ascii, dir)
        ,
        slice: (buf, start, end)=>buf.asciiSlice(start, end)
        ,
        write: (buf, string, offset, len)=>buf.asciiWrite(string, offset, len)
    },
    base64: {
        byteLength: (string)=>base64ByteLength(string, string.length)
        ,
        encoding: "base64",
        encodingVal: encodingsMap.base64,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64ToBytes(val), byteOffset, encodingsMap.base64, dir)
        ,
        slice: (buf, start, end)=>buf.base64Slice(start, end)
        ,
        write: (buf, string, offset, len)=>buf.base64Write(string, offset, len)
    },
    base64url: {
        byteLength: (string)=>base64ByteLength(string, string.length)
        ,
        encoding: "base64url",
        encodingVal: encodingsMap.base64url,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64UrlToBytes(val), byteOffset, encodingsMap.base64url, dir)
        ,
        slice: (buf, start, end)=>buf.base64urlSlice(start, end)
        ,
        write: (buf, string, offset, len)=>buf.base64urlWrite(string, offset, len)
    },
    hex: {
        byteLength: (string)=>string.length >>> 1
        ,
        encoding: "hex",
        encodingVal: encodingsMap.hex,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, hexToBytes(val), byteOffset, encodingsMap.hex, dir)
        ,
        slice: (buf, start, end)=>buf.hexSlice(start, end)
        ,
        write: (buf, string, offset, len)=>buf.hexWrite(string, offset, len)
    },
    latin1: {
        byteLength: (string)=>string.length
        ,
        encoding: "latin1",
        encodingVal: encodingsMap.latin1,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.latin1, dir)
        ,
        slice: (buf, start, end)=>buf.latin1Slice(start, end)
        ,
        write: (buf, string, offset, len)=>buf.latin1Write(string, offset, len)
    },
    ucs2: {
        byteLength: (string)=>string.length * 2
        ,
        encoding: "ucs2",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir)
        ,
        slice: (buf, start, end)=>buf.ucs2Slice(start, end)
        ,
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    },
    utf8: {
        byteLength: byteLengthUtf8,
        encoding: "utf8",
        encodingVal: encodingsMap.utf8,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf8Encoder.encode(val), byteOffset, encodingsMap.utf8, dir)
        ,
        slice: (buf, start, end)=>buf.utf8Slice(start, end)
        ,
        write: (buf, string, offset, len)=>buf.utf8Write(string, offset, len)
    },
    utf16le: {
        byteLength: (string)=>string.length * 2
        ,
        encoding: "utf16le",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir)
        ,
        slice: (buf, start, end)=>buf.ucs2Slice(start, end)
        ,
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    }
};
function getEncodingOps(encoding) {
    encoding = String(encoding).toLowerCase();
    switch(encoding.length){
        case 4:
            if (encoding === "utf8") return encodingOps.utf8;
            if (encoding === "ucs2") return encodingOps.ucs2;
            break;
        case 5:
            if (encoding === "utf-8") return encodingOps.utf8;
            if (encoding === "ascii") return encodingOps.ascii;
            if (encoding === "ucs-2") return encodingOps.ucs2;
            break;
        case 7:
            if (encoding === "utf16le") {
                return encodingOps.utf16le;
            }
            break;
        case 8:
            if (encoding === "utf-16le") {
                return encodingOps.utf16le;
            }
            break;
        case 6:
            if (encoding === "latin1" || encoding === "binary") {
                return encodingOps.latin1;
            }
            if (encoding === "base64") return encodingOps.base64;
        case 3:
            if (encoding === "hex") {
                return encodingOps.hex;
            }
            break;
        case 9:
            if (encoding === "base64url") {
                return encodingOps.base64url;
            }
            break;
    }
}
function _copyActual(source, target, targetStart, sourceStart, sourceEnd) {
    if (sourceEnd - sourceStart > target.length - targetStart) {
        sourceEnd = sourceStart + target.length - targetStart;
    }
    let nb = sourceEnd - sourceStart;
    const sourceLen = source.length - sourceStart;
    if (nb > sourceLen) {
        nb = sourceLen;
    }
    if (sourceStart !== 0 || sourceEnd < source.length) {
        source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
    }
    target.set(source, targetStart);
    return nb;
}
function boundsError(value, length, type1) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type1);
        throw new codes.ERR_OUT_OF_RANGE(type1 || "offset", "an integer", value);
    }
    if (length < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new codes.ERR_OUT_OF_RANGE(type1 || "offset", `>= ${type1 ? 1 : 0} and <= ${length}`, value);
}
function validateNumber(value, name13) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name13, "number", value);
    }
}
function checkBounds(buf, offset, byteLength1) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength1] === undefined) {
        boundsError(offset, buf.length - (byteLength1 + 1));
    }
}
function checkInt(value, min4, max, buf, offset, byteLength2) {
    if (value > max || value < min4) {
        const n = typeof min4 === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min4 === 0 || min4 === 0n) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and ` + `< 2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min4}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
}
function toInteger(n, defaultVal) {
    n = +n;
    if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
        return n % 1 === 0 ? n : Math.floor(n);
    }
    return defaultVal;
}
function writeU_Int8(buf, value, offset, min5, max) {
    value = +value;
    validateNumber(offset, "offset");
    if (value > max || value < min5) {
        throw new codes.ERR_OUT_OF_RANGE("value", `>= ${min5} and <= ${max}`, value);
    }
    if (buf[offset] === undefined) {
        boundsError(offset, buf.length - 1);
    }
    buf[offset] = value;
    return offset + 1;
}
function writeU_Int16BE(buf, value, offset, min6, max) {
    value = +value;
    checkInt(value, min6, max, buf, offset, 1);
    buf[offset++] = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function _writeUInt32LE(buf, value, offset, min7, max) {
    value = +value;
    checkInt(value, min7, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int16LE(buf, value, offset, min8, max) {
    value = +value;
    checkInt(value, min8, max, buf, offset, 1);
    buf[offset++] = value;
    buf[offset++] = value >>> 8;
    return offset;
}
function _writeUInt32BE(buf, value, offset, min9, max) {
    value = +value;
    checkInt(value, min9, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int48BE(buf, value, offset, min10, max) {
    value = +value;
    checkInt(value, min10, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = newVal >>> 8;
    buf[offset++] = newVal;
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int40BE(buf, value, offset, min11, max) {
    value = +value;
    checkInt(value, min11, max, buf, offset, 4);
    buf[offset++] = Math.floor(value * 2 ** -32);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int32BE(buf, value, offset, min12, max) {
    value = +value;
    checkInt(value, min12, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int24BE(buf, value, offset, min13, max) {
    value = +value;
    checkInt(value, min13, max, buf, offset, 2);
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 3;
}
function validateOffset(value, name14, min14 = 0, max = Number.MAX_SAFE_INTEGER) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name14, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name14, "an integer", value);
    }
    if (value < min14 || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name14, `>= ${min14} && <= ${max}`, value);
    }
}
function writeU_Int48LE(buf, value, offset, min15, max) {
    value = +value;
    checkInt(value, min15, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = newVal;
    buf[offset++] = newVal >>> 8;
    return offset;
}
function writeU_Int40LE(buf, value, offset, min16, max) {
    value = +value;
    checkInt(value, min16, max, buf, offset, 4);
    const newVal = value;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = Math.floor(newVal * 2 ** -32);
    return offset;
}
function writeU_Int32LE(buf, value, offset, min17, max) {
    value = +value;
    checkInt(value, min17, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int24LE(buf, value, offset, min18, max) {
    value = +value;
    checkInt(value, min18, max, buf, offset, 2);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
const kMaxLength = 2147483647;
const MAX_UINT32 = 2 ** 32;
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
const INSPECT_MAX_BYTES = 50;
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) {
            return void 0;
        }
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) {
            return void 0;
        }
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > 2147483647) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function Buffer(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("string", "string", arg);
        }
        return _allocUnsafe(arg);
    }
    return _from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192;
function _from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
    }
    if (typeof value === "object" && value !== null) {
        if (isAnyArrayBuffer1(value)) {
            return fromArrayBuffer(value, encodingOrOffset, length);
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
            return _from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) {
            return b;
        }
        if (typeof value[Symbol.toPrimitive] === "function") {
            const primitive = value[Symbol.toPrimitive]("string");
            if (typeof primitive === "string") {
                return fromString(primitive, encodingOrOffset);
            }
        }
    }
    throw new codes.ERR_INVALID_ARG_TYPE("first argument", [
        "string",
        "Buffer",
        "ArrayBuffer",
        "Array",
        "Array-like Object"
    ], value);
}
Buffer.from = function from(value, encodingOrOffset, length) {
    return _from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    validateNumber(size, "size");
    if (!(size >= 0 && size <= 2147483647)) {
        throw new codes.ERR_INVALID_ARG_VALUE.RangeError("size", size);
    }
}
function _alloc(size, fill, encoding) {
    assertSize(size);
    const buffer = createBuffer(size);
    if (fill !== undefined) {
        if (encoding !== undefined && typeof encoding !== "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
        }
        return buffer.fill(fill, encoding);
    }
    return buffer;
}
Buffer.alloc = function alloc(size, fill, encoding) {
    return _alloc(size, fill, encoding);
};
function _allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
Buffer.allocUnsafe = function allocUnsafe(size) {
    return _allocUnsafe(size);
};
Buffer.allocUnsafeSlow = function allocUnsafeSlow(size) {
    return _allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
    }
    if (!Buffer.isEncoding(encoding)) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i27 = 0; i27 < length; i27 += 1){
        buf[i27] = array[i27] & 255;
    }
    return buf;
}
function fromObject(obj) {
    if (obj.length !== undefined || isAnyArrayBuffer1(obj.buffer)) {
        if (typeof obj.length !== "number") {
            return createBuffer(0);
        }
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
    }
}
function checked(length) {
    if (length >= 2147483647) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
    }
    return length | 0;
}
function SlowBuffer(length) {
    assertSize(length);
    return Buffer.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer, Uint8Array);
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) {
        a = Buffer.from(a, a.offset, a.byteLength);
    }
    if (isInstance(b, Uint8Array)) {
        b = Buffer.from(b, b.offset, b.byteLength);
    }
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) {
        return 0;
    }
    let x = a.length;
    let y = b.length;
    for(let i28 = 0, len = Math.min(x, y); i28 < len; ++i28){
        if (a[i28] !== b[i28]) {
            x = a[i28];
            y = b[i28];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding(encoding) !== undefined;
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new codes.ERR_INVALID_ARG_TYPE("list", "Array", list);
    }
    if (list.length === 0) {
        return Buffer.alloc(0);
    }
    if (length === undefined) {
        length = 0;
        for(let i29 = 0; i29 < list.length; i29++){
            if (list[i29].length) {
                length += list[i29].length;
            }
        }
    } else {
        validateOffset(length, "length");
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(let i30 = 0; i30 < list.length; i30++){
        const buf = list[i30];
        if (!isUint8Array(buf)) {
            throw new codes.ERR_INVALID_ARG_TYPE(`list[${i30}]`, [
                "Buffer",
                "Uint8Array"
            ], list[i30]);
        }
        pos += _copyActual(buf, buffer, pos, 0, buf.length);
    }
    if (pos < length) {
        buffer.fill(0, pos, length);
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (typeof string !== "string") {
        if (isArrayBufferView(string) || isAnyArrayBuffer1(string)) {
            return string.byteLength;
        }
        throw new codes.ERR_INVALID_ARG_TYPE("string", [
            "string",
            "Buffer",
            "ArrayBuffer"
        ], string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) {
        return 0;
    }
    if (!encoding) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    return ops.byteLength(string);
}
Buffer.byteLength = byteLength;
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i31 = b[n];
    b[n] = b[m];
    b[m] = i31;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for(let i32 = 0; i32 < len; i32 += 2){
        swap(this, i32, i32 + 1);
    }
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for(let i33 = 0; i33 < len; i33 += 4){
        swap(this, i33, i33 + 3);
        swap(this, i33 + 1, i33 + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for(let i34 = 0; i34 < len; i34 += 8){
        swap(this, i34, i34 + 7);
        swap(this, i34 + 1, i34 + 6);
        swap(this, i34 + 2, i34 + 5);
        swap(this, i34 + 3, i34 + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString(encoding, start, end) {
    if (arguments.length === 0) {
        return this.utf8Slice(0, this.length);
    }
    const len = this.length;
    if (start <= 0) {
        start = 0;
    } else if (start >= len) {
        return "";
    } else {
        start |= 0;
    }
    if (end === undefined || end > len) {
        end = len;
    } else {
        end |= 0;
    }
    if (end <= start) {
        return "";
    }
    if (encoding === undefined) {
        return this.utf8Slice(start, end);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.slice(this, start, end);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!isUint8Array(b)) {
        throw new codes.ERR_INVALID_ARG_TYPE("otherBuffer", [
            "Buffer",
            "Uint8Array"
        ], b);
    }
    if (this === b) {
        return true;
    }
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) {
        str += " ... ";
    }
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (start === undefined) {
        start = 0;
    } else {
        validateOffset(start, "targetStart", 0, kMaxLength);
    }
    if (end === undefined) {
        end = target.length;
    } else {
        validateOffset(end, "targetEnd", 0, target.length);
    }
    if (thisStart === undefined) {
        thisStart = 0;
    } else {
        validateOffset(start, "sourceStart", 0, kMaxLength);
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    } else {
        validateOffset(end, "sourceEnd", 0, this.length);
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new codes.ERR_OUT_OF_RANGE("out of range index", "range");
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) {
        return 0;
    }
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i35 = 0; i35 < len; ++i35){
        if (thisCopy[i35] !== targetCopy[i35]) {
            x = thisCopy[i35];
            y = targetCopy[i35];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    validateBuffer(buffer);
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = undefined;
    } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
    }
    dir = !!dir;
    if (typeof val === "number") {
        return indexOfNumber(buffer, val >>> 0, byteOffset, dir);
    }
    let ops;
    if (encoding === undefined) {
        ops = encodingOps.utf8;
    } else {
        ops = getEncodingOps(encoding);
    }
    if (typeof val === "string") {
        if (ops === undefined) {
            throw new codes.ERR_UNKNOWN_ENCODING(encoding);
        }
        return ops.indexOf(buffer, val, byteOffset, dir);
    }
    if (isUint8Array(val)) {
        const encodingVal = ops === undefined ? encodingsMap.utf8 : ops.encodingVal;
        return indexOfBuffer(buffer, val, byteOffset, encodingVal, dir);
    }
    throw new codes.ERR_INVALID_ARG_TYPE("value", [
        "number",
        "string",
        "Buffer",
        "Uint8Array"
    ], val);
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
Buffer.prototype.asciiSlice = function asciiSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToAscii(this);
    } else {
        return bytesToAscii(this.slice(offset, length));
    }
};
Buffer.prototype.asciiWrite = function asciiWrite(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer.prototype.base64Slice = function base64Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode(this);
    } else {
        return encode(this.slice(offset, length));
    }
};
Buffer.prototype.base64Write = function base64Write(string, offset, length) {
    return blitBuffer(base64ToBytes(string), this, offset, length);
};
Buffer.prototype.base64urlSlice = function base64urlSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode1(this);
    } else {
        return encode1(this.slice(offset, length));
    }
};
Buffer.prototype.base64urlWrite = function base64urlWrite(string, offset, length) {
    return blitBuffer(base64UrlToBytes(string), this, offset, length);
};
Buffer.prototype.hexWrite = function hexWrite(string, offset, length) {
    return blitBuffer(hexToBytes(string, this.length - offset), this, offset, length);
};
Buffer.prototype.hexSlice = function hexSlice(string, offset, length) {
    return _hexSlice(this, string, offset, length);
};
Buffer.prototype.latin1Slice = function latin1Slice(string, offset, length) {
    return _latin1Slice(this, string, offset, length);
};
Buffer.prototype.latin1Write = function latin1Write(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer.prototype.ucs2Slice = function ucs2Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToUtf16le(this);
    } else {
        return bytesToUtf16le(this.slice(offset, length));
    }
};
Buffer.prototype.ucs2Write = function ucs2Write(string, offset, length) {
    return blitBuffer(utf16leToBytes(string, this.length - offset), this, offset, length);
};
Buffer.prototype.utf8Slice = function utf8Slice(string, offset, length) {
    return _utf8Slice(this, string, offset, length);
};
Buffer.prototype.utf8Write = function utf8Write(string, offset, length) {
    return blitBuffer(utf8ToBytes(string, this.length - offset), this, offset, length);
};
Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
        return this.utf8Write(string, 0, this.length);
    }
    if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    } else {
        validateOffset(offset, "offset", 0, this.length);
        const remaining = this.length - offset;
        if (length === undefined) {
            length = remaining;
        } else if (typeof length === "string") {
            encoding = length;
            length = remaining;
        } else {
            validateOffset(length, "length", 0, this.length);
            if (length > remaining) {
                length = remaining;
            }
        }
    }
    if (!encoding) {
        return this.utf8Write(string, offset, length);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.write(this, string, offset, length);
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function fromArrayBuffer(obj, byteOffset, length) {
    if (byteOffset === undefined) {
        byteOffset = 0;
    } else {
        byteOffset = +byteOffset;
        if (Number.isNaN(byteOffset)) {
            byteOffset = 0;
        }
    }
    const maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("offset");
    }
    if (length === undefined) {
        length = maxLength;
    } else {
        length = +length;
        if (length > 0) {
            if (length > maxLength) {
                throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("length");
            }
        } else {
            length = 0;
        }
    }
    const buffer = new Uint8Array(obj, byteOffset, length);
    Object.setPrototypeOf(buffer, Buffer.prototype);
    return buffer;
}
function _utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i36 = start;
    while(i36 < end){
        const firstByte = buf[i36];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i36 + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i36 + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i36 + 1];
                    thirdByte = buf[i36 + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i36 + 1];
                    thirdByte = buf[i36 + 2];
                    fourthByte = buf[i36 + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i36 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= 4096) {
        return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i37 = 0;
    while(i37 < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i37, i37 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
}
function _latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i38 = start; i38 < end; ++i38){
        ret += String.fromCharCode(buf[i38]);
    }
    return ret;
}
function _hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) {
        start = 0;
    }
    if (!end || end < 0 || end > len) {
        end = len;
    }
    let out = "";
    for(let i39 = start; i39 < end; ++i39){
        out += hexSliceLookupTable[buf[i39]];
    }
    return out;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) {
            start = 0;
        }
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) {
            end = 0;
        }
    } else if (end > len) {
        end = len;
    }
    if (end < start) {
        end = start;
    }
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength1) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength1 === 6) {
        return readUInt48LE(this, offset);
    }
    if (byteLength1 === 5) {
        return readUInt40LE(this, offset);
    }
    if (byteLength1 === 3) {
        return readUInt24LE(this, offset);
    }
    if (byteLength1 === 4) {
        return this.readUInt32LE(offset);
    }
    if (byteLength1 === 2) {
        return this.readUInt16LE(offset);
    }
    if (byteLength1 === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength1, 6, "byteLength");
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength2 === 6) {
        return readUInt48BE(this, offset);
    }
    if (byteLength2 === 5) {
        return readUInt40BE(this, offset);
    }
    if (byteLength2 === 3) {
        return readUInt24BE(this, offset);
    }
    if (byteLength2 === 4) {
        return this.readUInt32BE(offset);
    }
    if (byteLength2 === 2) {
        return this.readUInt16BE(offset);
    }
    if (byteLength2 === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength2, 6, "byteLength");
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = readUInt16BE;
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first + last * 2 ** 8;
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = readUInt32BE;
Buffer.prototype.readBigUint64LE = Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUint64BE = Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength3) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength3 === 6) {
        return readInt48LE(this, offset);
    }
    if (byteLength3 === 5) {
        return readInt40LE(this, offset);
    }
    if (byteLength3 === 3) {
        return readInt24LE(this, offset);
    }
    if (byteLength3 === 4) {
        return this.readInt32LE(offset);
    }
    if (byteLength3 === 2) {
        return this.readInt16LE(offset);
    }
    if (byteLength3 === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength3, 6, "byteLength");
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength4) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength4 === 6) {
        return readInt48BE(this, offset);
    }
    if (byteLength4 === 5) {
        return readInt40BE(this, offset);
    }
    if (byteLength4 === 3) {
        return readInt24BE(this, offset);
    }
    if (byteLength4 === 4) {
        return this.readInt32BE(offset);
    }
    if (byteLength4 === 2) {
        return this.readInt16BE(offset);
    }
    if (byteLength4 === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength4, 6, "byteLength");
};
Buffer.prototype.readInt8 = function readInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val | (val & 2 ** 7) * 0x1fffffe;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first + last * 2 ** 8;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first * 2 ** 8 + last;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer.prototype.readInt32BE = function readInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset) {
    return bigEndian ? readFloatBackwards(this, offset) : readFloatForwards(this, offset);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset) {
    return bigEndian ? readFloatForwards(this, offset) : readFloatBackwards(this, offset);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset) {
    return bigEndian ? readDoubleBackwards(this, offset) : readDoubleForwards(this, offset);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset) {
    return bigEndian ? readDoubleForwards(this, offset) : readDoubleBackwards(this, offset);
};
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength5) {
    if (byteLength5 === 6) {
        return writeU_Int48LE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength5 === 5) {
        return writeU_Int40LE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength5 === 3) {
        return writeU_Int24LE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength5 === 4) {
        return writeU_Int32LE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength5 === 2) {
        return writeU_Int16LE(this, value, offset, 0, 0xffff);
    }
    if (byteLength5 === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength5, 6, "byteLength");
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength6) {
    if (byteLength6 === 6) {
        return writeU_Int48BE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength6 === 5) {
        return writeU_Int40BE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength6 === 3) {
        return writeU_Int24BE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength6 === 4) {
        return writeU_Int32BE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength6 === 2) {
        return writeU_Int16BE(this, value, offset, 0, 0xffff);
    }
    if (byteLength6 === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength6, 6, "byteLength");
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, 0, 0xff);
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, 0, 0xffff);
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, 0, 0xffff);
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
    return _writeUInt32LE(this, value, offset, 0, 0xffffffff);
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
    return _writeUInt32BE(this, value, offset, 0, 0xffffffff);
};
function wrtBigUInt64LE(buf, value, offset, min19, max) {
    checkIntBI(value, min19, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min20, max) {
    checkIntBI(value, min20, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUint64LE = Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUint64BE = Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength7) {
    if (byteLength7 === 6) {
        return writeU_Int48LE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength7 === 5) {
        return writeU_Int40LE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength7 === 3) {
        return writeU_Int24LE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength7 === 4) {
        return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength7 === 2) {
        return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength7 === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength7, 6, "byteLength");
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength8) {
    if (byteLength8 === 6) {
        return writeU_Int48BE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength8 === 5) {
        return writeU_Int40BE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength8 === 3) {
        return writeU_Int24BE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength8 === 4) {
        return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength8 === 2) {
        return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength8 === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength8, 6, "byteLength");
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, -0x80, 0x7f);
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
    return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
    return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset) {
    return bigEndian ? writeFloatBackwards(this, value, offset) : writeFloatForwards(this, value, offset);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset) {
    return bigEndian ? writeFloatForwards(this, value, offset) : writeFloatBackwards(this, value, offset);
};
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
    return bigEndian ? writeDoubleBackwards(this, value, offset) : writeDoubleForwards(this, value, offset);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
    return bigEndian ? writeDoubleForwards(this, value, offset) : writeDoubleBackwards(this, value, offset);
};
Buffer.prototype.copy = function copy(target, targetStart, sourceStart, sourceEnd) {
    if (!isUint8Array(this)) {
        throw new codes.ERR_INVALID_ARG_TYPE("source", [
            "Buffer",
            "Uint8Array"
        ], this);
    }
    if (!isUint8Array(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (targetStart === undefined) {
        targetStart = 0;
    } else {
        targetStart = toInteger(targetStart, 0);
        if (targetStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
        }
    }
    if (sourceStart === undefined) {
        sourceStart = 0;
    } else {
        sourceStart = toInteger(sourceStart, 0);
        if (sourceStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
        }
        if (sourceStart >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT32}`, sourceStart);
        }
    }
    if (sourceEnd === undefined) {
        sourceEnd = this.length;
    } else {
        sourceEnd = toInteger(sourceEnd, 0);
        if (sourceEnd < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
        }
        if (sourceEnd >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT32}`, sourceEnd);
        }
    }
    if (targetStart >= target.length) {
        return 0;
    }
    if (sourceEnd > 0 && sourceEnd < sourceStart) {
        sourceEnd = sourceStart;
    }
    if (sourceEnd === sourceStart) {
        return 0;
    }
    if (target.length === 0 || this.length === 0) {
        return 0;
    }
    if (sourceEnd > this.length) {
        sourceEnd = this.length;
    }
    if (target.length - targetStart < sourceEnd - sourceStart) {
        sourceEnd = target.length - targetStart + sourceStart;
    }
    const len = sourceEnd - sourceStart;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, sourceStart, sourceEnd);
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
    }
    return len;
};
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                val = code;
            }
        }
    } else if (typeof val === "number") {
        val = val & 255;
    } else if (typeof val === "boolean") {
        val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) {
        val = 0;
    }
    let i40;
    if (typeof val === "number") {
        for(i40 = start; i40 < end; ++i40){
            this[i40] = val;
        }
    } else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new codes.ERR_INVALID_ARG_VALUE("value", val);
        }
        for(i40 = 0; i40 < end - start; ++i40){
            this[i40 + start] = bytes[i40 % len];
        }
    }
    return this;
};
function checkBounds1(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
    }
}
function checkIntBI(value, min21, max, buf, offset, byteLength2) {
    if (value > max || value < min21) {
        const n = typeof min21 === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min21 === 0 || min21 === BigInt(0)) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min21}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds1(buf, offset, byteLength2);
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i41 = 0; i41 < length; ++i41){
        codePoint = string.charCodeAt(i41);
        if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
                if (codePoint > 56319) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                } else if (i41 + 1 === length) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                }
                leadSurrogate = codePoint;
                continue;
            }
            if (codePoint < 56320) {
                if ((units -= 3) > -1) {
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = codePoint;
                continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
            if ((units -= 3) > -1) {
                bytes.push(239, 191, 189);
            }
        }
        leadSurrogate = null;
        if (codePoint < 128) {
            if ((units -= 1) < 0) {
                break;
            }
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) {
                break;
            }
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) {
                break;
            }
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) {
                break;
            }
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
            throw new Error("Invalid code point");
        }
    }
    return bytes;
}
function blitBuffer(src, dst, offset, byteLength9) {
    let i42;
    const length = byteLength9 === undefined ? src.length : byteLength9;
    for(i42 = 0; i42 < length; ++i42){
        if (i42 + offset >= dst.length || i42 >= src.length) {
            break;
        }
        dst[i42 + offset] = src[i42];
    }
    return i42;
}
function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
}
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i43 = 0; i43 < 16; ++i43){
        const i16 = i43 * 16;
        for(let j = 0; j < 16; ++j){
            table[i16 + j] = alphabet[i43] + alphabet[j];
        }
    }
    return table;
}();
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}
globalThis.atob;
globalThis.Blob;
globalThis.btoa;
let core;
if (Deno?.core) {
    core = Deno.core;
} else {
    core = {
        setNextTickCallback: undefined,
        evalContext (_code, _filename) {
            throw new Error("Deno.core.evalContext is not supported in this environment");
        },
        encode (chunk) {
            return new TextEncoder().encode(chunk);
        }
    };
}
let _exiting = false;
const kSize = 2048;
const kMask = 2048 - 1;
class FixedCircularBuffer {
    bottom;
    top;
    list;
    next;
    constructor(){
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
    }
    isEmpty() {
        return this.top === this.bottom;
    }
    isFull() {
        return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
    }
    shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === undefined) {
            return null;
        }
        this.list[this.bottom] = undefined;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
    }
}
class FixedQueue {
    head;
    tail;
    constructor(){
        this.head = this.tail = new FixedCircularBuffer();
    }
    isEmpty() {
        return this.head.isEmpty();
    }
    push(data) {
        if (this.head.isFull()) {
            this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
    }
    shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
            this.tail = tail.next;
        }
        return next;
    }
}
const queue = new FixedQueue();
let _nextTick;
if (typeof core.setNextTickCallback !== "undefined") {
    function runNextTicks() {
        if (!core.hasTickScheduled()) {
            core.runMicrotasks();
        }
        if (!core.hasTickScheduled()) {
            return true;
        }
        processTicksAndRejections();
        return true;
    }
    function processTicksAndRejections() {
        let tock;
        do {
            while(tock = queue.shift()){
                try {
                    const callback = tock.callback;
                    if (tock.args === undefined) {
                        callback();
                    } else {
                        const args = tock.args;
                        switch(args.length){
                            case 1:
                                callback(args[0]);
                                break;
                            case 2:
                                callback(args[0], args[1]);
                                break;
                            case 3:
                                callback(args[0], args[1], args[2]);
                                break;
                            case 4:
                                callback(args[0], args[1], args[2], args[3]);
                                break;
                            default:
                                callback(...args);
                        }
                    }
                } finally{}
            }
            core.runMicrotasks();
        }while (!queue.isEmpty())
        core.setHasTickScheduled(false);
    }
    core.setNextTickCallback(processTicksAndRejections);
    core.setMacrotaskCallback(runNextTicks);
    function __nextTickNative(callback, ...args) {
        validateCallback(callback);
        if (_exiting) {
            return;
        }
        let args_;
        switch(args.length){
            case 0:
                break;
            case 1:
                args_ = [
                    args[0]
                ];
                break;
            case 2:
                args_ = [
                    args[0],
                    args[1]
                ];
                break;
            case 3:
                args_ = [
                    args[0],
                    args[1],
                    args[2]
                ];
                break;
            default:
                args_ = new Array(args.length);
                for(let i44 = 0; i44 < args.length; i44++){
                    args_[i44] = args[i44];
                }
        }
        if (queue.isEmpty()) {
            core.setHasTickScheduled(true);
        }
        const tickObject = {
            callback,
            args: args_
        };
        queue.push(tickObject);
    }
    _nextTick = __nextTickNative;
} else {
    function __nextTickQueueMicrotask(callback, ...args) {
        if (args) {
            queueMicrotask(()=>callback.call(this, ...args)
            );
        } else {
            queueMicrotask(callback);
        }
    }
    _nextTick = __nextTickQueueMicrotask;
}
function nextTick2(callback, ...args) {
    _nextTick(callback, ...args);
}
var State;
(function(State1) {
    State1[State1["PASSTHROUGH"] = 0] = "PASSTHROUGH";
    State1[State1["PERCENT"] = 1] = "PERCENT";
    State1[State1["POSITIONAL"] = 2] = "POSITIONAL";
    State1[State1["PRECISION"] = 3] = "PRECISION";
    State1[State1["WIDTH"] = 4] = "WIDTH";
})(State || (State = {}));
var WorP;
(function(WorP1) {
    WorP1[WorP1["WIDTH"] = 0] = "WIDTH";
    WorP1[WorP1["PRECISION"] = 1] = "PRECISION";
})(WorP || (WorP = {}));
class Flags {
    plus;
    dash;
    sharp;
    space;
    zero;
    lessthan;
    width = -1;
    precision = -1;
}
const min = Math.min;
const UNICODE_REPLACEMENT_CHARACTER = "\ufffd";
const FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var F;
(function(F1) {
    F1[F1["sign"] = 1] = "sign";
    F1[F1["mantissa"] = 2] = "mantissa";
    F1[F1["fractional"] = 3] = "fractional";
    F1[F1["esign"] = 4] = "esign";
    F1[F1["exponent"] = 5] = "exponent";
})(F || (F = {}));
class Printf {
    format;
    args;
    i;
    state = State.PASSTHROUGH;
    verb = "";
    buf = "";
    argNum = 0;
    flags = new Flags();
    haveSeen;
    tmpError;
    constructor(format6, ...args){
        this.format = format6;
        this.args = args;
        this.haveSeen = Array.from({
            length: args.length
        });
        this.i = 0;
    }
    doPrintf() {
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State.PASSTHROUGH:
                    if (c === "%") {
                        this.state = State.PERCENT;
                    } else {
                        this.buf += c;
                    }
                    break;
                case State.PERCENT:
                    if (c === "%") {
                        this.buf += c;
                        this.state = State.PASSTHROUGH;
                    } else {
                        this.handleFormat();
                    }
                    break;
                default:
                    throw Error("Should be unreachable, certainly a bug in the lib.");
            }
        }
        let extras = false;
        let err = "%!(EXTRA";
        for(let i45 = 0; i45 !== this.haveSeen.length; ++i45){
            if (!this.haveSeen[i45]) {
                extras = true;
                err += ` '${Deno.inspect(this.args[i45])}'`;
            }
        }
        err += ")";
        if (extras) {
            this.buf += err;
        }
        return this.buf;
    }
    handleFormat() {
        this.flags = new Flags();
        const flags = this.flags;
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State.PERCENT:
                    switch(c){
                        case "[":
                            this.handlePositional();
                            this.state = State.POSITIONAL;
                            break;
                        case "+":
                            flags.plus = true;
                            break;
                        case "<":
                            flags.lessthan = true;
                            break;
                        case "-":
                            flags.dash = true;
                            flags.zero = false;
                            break;
                        case "#":
                            flags.sharp = true;
                            break;
                        case " ":
                            flags.space = true;
                            break;
                        case "0":
                            flags.zero = !flags.dash;
                            break;
                        default:
                            if ("1" <= c && c <= "9" || c === "." || c === "*") {
                                if (c === ".") {
                                    this.flags.precision = 0;
                                    this.state = State.PRECISION;
                                    this.i++;
                                } else {
                                    this.state = State.WIDTH;
                                }
                                this.handleWidthAndPrecision(flags);
                            } else {
                                this.handleVerb();
                                return;
                            }
                    }
                    break;
                case State.POSITIONAL:
                    if (c === "*") {
                        const worp = this.flags.precision === -1 ? WorP.WIDTH : WorP.PRECISION;
                        this.handleWidthOrPrecisionRef(worp);
                        this.state = State.PERCENT;
                        break;
                    } else {
                        this.handleVerb();
                        return;
                    }
                default:
                    throw new Error(`Should not be here ${this.state}, library bug!`);
            }
        }
    }
    handleWidthOrPrecisionRef(wOrP) {
        if (this.argNum >= this.args.length) {
            return;
        }
        const arg = this.args[this.argNum];
        this.haveSeen[this.argNum] = true;
        if (typeof arg === "number") {
            switch(wOrP){
                case WorP.WIDTH:
                    this.flags.width = arg;
                    break;
                default:
                    this.flags.precision = arg;
            }
        } else {
            const tmp = wOrP === WorP.WIDTH ? "WIDTH" : "PREC";
            this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
        }
        this.argNum++;
    }
    handleWidthAndPrecision(flags) {
        const fmt = this.format;
        for(; this.i !== this.format.length; ++this.i){
            const c = fmt[this.i];
            switch(this.state){
                case State.WIDTH:
                    switch(c){
                        case ".":
                            this.flags.precision = 0;
                            this.state = State.PRECISION;
                            break;
                        case "*":
                            this.handleWidthOrPrecisionRef(WorP.WIDTH);
                            break;
                        default:
                            {
                                const val = parseInt(c);
                                if (isNaN(val)) {
                                    this.i--;
                                    this.state = State.PERCENT;
                                    return;
                                }
                                flags.width = flags.width == -1 ? 0 : flags.width;
                                flags.width *= 10;
                                flags.width += val;
                            }
                    }
                    break;
                case State.PRECISION:
                    {
                        if (c === "*") {
                            this.handleWidthOrPrecisionRef(WorP.PRECISION);
                            break;
                        }
                        const val = parseInt(c);
                        if (isNaN(val)) {
                            this.i--;
                            this.state = State.PERCENT;
                            return;
                        }
                        flags.precision *= 10;
                        flags.precision += val;
                        break;
                    }
                default:
                    throw new Error("can't be here. bug.");
            }
        }
    }
    handlePositional() {
        if (this.format[this.i] !== "[") {
            throw new Error("Can't happen? Bug.");
        }
        let positional = 0;
        const format7 = this.format;
        this.i++;
        let err = false;
        for(; this.i !== this.format.length; ++this.i){
            if (format7[this.i] === "]") {
                break;
            }
            positional *= 10;
            const val = parseInt(format7[this.i]);
            if (isNaN(val)) {
                this.tmpError = "%!(BAD INDEX)";
                err = true;
            }
            positional += val;
        }
        if (positional - 1 >= this.args.length) {
            this.tmpError = "%!(BAD INDEX)";
            err = true;
        }
        this.argNum = err ? this.argNum : positional - 1;
        return;
    }
    handleLessThan() {
        const arg = this.args[this.argNum];
        if ((arg || {}).constructor.name !== "Array") {
            throw new Error(`arg ${arg} is not an array. Todo better error handling`);
        }
        let str = "[ ";
        for(let i46 = 0; i46 !== arg.length; ++i46){
            if (i46 !== 0) str += ", ";
            str += this._handleVerb(arg[i46]);
        }
        return str + " ]";
    }
    handleVerb() {
        const verb = this.format[this.i];
        this.verb = verb;
        if (this.tmpError) {
            this.buf += this.tmpError;
            this.tmpError = undefined;
            if (this.argNum < this.haveSeen.length) {
                this.haveSeen[this.argNum] = true;
            }
        } else if (this.args.length <= this.argNum) {
            this.buf += `%!(MISSING '${verb}')`;
        } else {
            const arg = this.args[this.argNum];
            this.haveSeen[this.argNum] = true;
            if (this.flags.lessthan) {
                this.buf += this.handleLessThan();
            } else {
                this.buf += this._handleVerb(arg);
            }
        }
        this.argNum++;
        this.state = State.PASSTHROUGH;
    }
    _handleVerb(arg) {
        switch(this.verb){
            case "t":
                return this.pad(arg.toString());
            case "b":
                return this.fmtNumber(arg, 2);
            case "c":
                return this.fmtNumberCodePoint(arg);
            case "d":
                return this.fmtNumber(arg, 10);
            case "o":
                return this.fmtNumber(arg, 8);
            case "x":
                return this.fmtHex(arg);
            case "X":
                return this.fmtHex(arg, true);
            case "e":
                return this.fmtFloatE(arg);
            case "E":
                return this.fmtFloatE(arg, true);
            case "f":
            case "F":
                return this.fmtFloatF(arg);
            case "g":
                return this.fmtFloatG(arg);
            case "G":
                return this.fmtFloatG(arg, true);
            case "s":
                return this.fmtString(arg);
            case "T":
                return this.fmtString(typeof arg);
            case "v":
                return this.fmtV(arg);
            case "j":
                return this.fmtJ(arg);
            default:
                return `%!(BAD VERB '${this.verb}')`;
        }
    }
    pad(s) {
        const padding = this.flags.zero ? "0" : " ";
        if (this.flags.dash) {
            return s.padEnd(this.flags.width, padding);
        }
        return s.padStart(this.flags.width, padding);
    }
    padNum(nStr, neg) {
        let sign;
        if (neg) {
            sign = "-";
        } else if (this.flags.plus || this.flags.space) {
            sign = this.flags.plus ? "+" : " ";
        } else {
            sign = "";
        }
        const zero = this.flags.zero;
        if (!zero) {
            nStr = sign + nStr;
        }
        const pad = zero ? "0" : " ";
        const len = zero ? this.flags.width - sign.length : this.flags.width;
        if (this.flags.dash) {
            nStr = nStr.padEnd(len, pad);
        } else {
            nStr = nStr.padStart(len, pad);
        }
        if (zero) {
            nStr = sign + nStr;
        }
        return nStr;
    }
    fmtNumber(n, radix, upcase = false) {
        let num = Math.abs(n).toString(radix);
        const prec = this.flags.precision;
        if (prec !== -1) {
            this.flags.zero = false;
            num = n === 0 && prec === 0 ? "" : num;
            while(num.length < prec){
                num = "0" + num;
            }
        }
        let prefix = "";
        if (this.flags.sharp) {
            switch(radix){
                case 2:
                    prefix += "0b";
                    break;
                case 8:
                    prefix += num.startsWith("0") ? "" : "0";
                    break;
                case 16:
                    prefix += "0x";
                    break;
                default:
                    throw new Error("cannot handle base: " + radix);
            }
        }
        num = num.length === 0 ? num : prefix + num;
        if (upcase) {
            num = num.toUpperCase();
        }
        return this.padNum(num, n < 0);
    }
    fmtNumberCodePoint(n) {
        let s = "";
        try {
            s = String.fromCodePoint(n);
        } catch  {
            s = UNICODE_REPLACEMENT_CHARACTER;
        }
        return this.pad(s);
    }
    fmtFloatSpecial(n) {
        if (isNaN(n)) {
            this.flags.zero = false;
            return this.padNum("NaN", false);
        }
        if (n === Number.POSITIVE_INFINITY) {
            this.flags.zero = false;
            this.flags.plus = true;
            return this.padNum("Inf", false);
        }
        if (n === Number.NEGATIVE_INFINITY) {
            this.flags.zero = false;
            return this.padNum("Inf", true);
        }
        return "";
    }
    roundFractionToPrecision(fractional, precision) {
        let round = false;
        if (fractional.length > precision) {
            fractional = "1" + fractional;
            let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
            tmp = Math.round(tmp);
            fractional = Math.floor(tmp).toString();
            round = fractional[0] === "2";
            fractional = fractional.substr(1);
        } else {
            while(fractional.length < precision){
                fractional += "0";
            }
        }
        return [
            fractional,
            round
        ];
    }
    fmtFloatE(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen, bug");
        }
        let fractional = m[F.fractional];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let rounding = false;
        [fractional, rounding] = this.roundFractionToPrecision(fractional, precision);
        let e = m[F.exponent];
        let esign = m[F.esign];
        let mantissa = parseInt(m[F.mantissa]);
        if (rounding) {
            mantissa += 1;
            if (10 <= mantissa) {
                mantissa = 1;
                const r = parseInt(esign + e) + 1;
                e = r.toString();
                esign = r < 0 ? "-" : "+";
            }
        }
        e = e.length == 1 ? "0" + e : e;
        const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e}`;
        return this.padNum(val, n < 0);
    }
    fmtFloatF(n1) {
        const special = this.fmtFloatSpecial(n1);
        if (special !== "") {
            return special;
        }
        function expandNumber(n) {
            if (Number.isSafeInteger(n)) {
                return n.toString() + ".";
            }
            const t = n.toExponential().split("e");
            let m = t[0].replace(".", "");
            const e = parseInt(t[1]);
            if (e < 0) {
                let nStr = "0.";
                for(let i47 = 0; i47 !== Math.abs(e) - 1; ++i47){
                    nStr += "0";
                }
                return nStr += m;
            } else {
                const splIdx = e + 1;
                while(m.length < splIdx){
                    m += "0";
                }
                return m.substr(0, splIdx) + "." + m.substr(splIdx);
            }
        }
        const val = expandNumber(Math.abs(n1));
        const arr = val.split(".");
        let dig = arr[0];
        let fractional = arr[1];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let round = false;
        [fractional, round] = this.roundFractionToPrecision(fractional, precision);
        if (round) {
            dig = (parseInt(dig) + 1).toString();
        }
        return this.padNum(`${dig}.${fractional}`, n1 < 0);
    }
    fmtFloatG(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        let P = this.flags.precision !== -1 ? this.flags.precision : 6;
        P = P === 0 ? 1 : P;
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen");
        }
        const X = parseInt(m[F.exponent]) * (m[F.esign] === "-" ? -1 : 1);
        let nStr = "";
        if (P > X && X >= -4) {
            this.flags.precision = P - (X + 1);
            nStr = this.fmtFloatF(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*$/, "");
            }
        } else {
            this.flags.precision = P - 1;
            nStr = this.fmtFloatE(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
            }
        }
        return nStr;
    }
    fmtString(s) {
        if (this.flags.precision !== -1) {
            s = s.substr(0, this.flags.precision);
        }
        return this.pad(s);
    }
    fmtHex(val, upper = false) {
        switch(typeof val){
            case "number":
                return this.fmtNumber(val, 16, upper);
            case "string":
                {
                    const sharp = this.flags.sharp && val.length !== 0;
                    let hex = sharp ? "0x" : "";
                    const prec = this.flags.precision;
                    const end = prec !== -1 ? min(prec, val.length) : val.length;
                    for(let i48 = 0; i48 !== end; ++i48){
                        if (i48 !== 0 && this.flags.space) {
                            hex += sharp ? " 0x" : " ";
                        }
                        const c = (val.charCodeAt(i48) & 0xff).toString(16);
                        hex += c.length === 1 ? `0${c}` : c;
                    }
                    if (upper) {
                        hex = hex.toUpperCase();
                    }
                    return this.pad(hex);
                }
            default:
                throw new Error("currently only number and string are implemented for hex");
        }
    }
    fmtV(val) {
        if (this.flags.sharp) {
            const options = this.flags.precision !== -1 ? {
                depth: this.flags.precision
            } : {};
            return this.pad(Deno.inspect(val, options));
        } else {
            const p = this.flags.precision;
            return p === -1 ? val.toString() : val.toString().substr(0, p);
        }
    }
    fmtJ(val) {
        return JSON.stringify(val);
    }
}
function sprintf(format8, ...args) {
    const printf1 = new Printf(format8, ...args);
    return printf1.doPrintf();
}
function guessHandleType(_fd) {
    notImplemented("util.guessHandleType");
}
const isNumericLookup = {};
function isArrayIndex(value) {
    switch(typeof value){
        case "number":
            return value >= 0 && (value | 0) === value;
        case "string":
            {
                const result = isNumericLookup[value];
                if (result !== void 0) {
                    return result;
                }
                const length = value.length;
                if (length === 0) {
                    return isNumericLookup[value] = false;
                }
                let ch = 0;
                let i49 = 0;
                for(; i49 < length; ++i49){
                    ch = value.charCodeAt(i49);
                    if (i49 === 0 && ch === 0x30 && length > 1 || ch < 0x30 || ch > 0x39) {
                        return isNumericLookup[value] = false;
                    }
                }
                return isNumericLookup[value] = true;
            }
        default:
            return false;
    }
}
function getOwnNonIndexProperties(obj, filter) {
    let allProperties = [
        ...Object.getOwnPropertyNames(obj),
        ...Object.getOwnPropertySymbols(obj), 
    ];
    if (Array.isArray(obj)) {
        allProperties = allProperties.filter((k)=>!isArrayIndex(k)
        );
    }
    if (filter === 0) {
        return allProperties;
    }
    const result = [];
    for (const key of allProperties){
        const desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc === undefined) {
            continue;
        }
        if (filter & 1 && !desc.writable) {
            continue;
        }
        if (filter & 2 && !desc.enumerable) {
            continue;
        }
        if (filter & 4 && !desc.configurable) {
            continue;
        }
        if (filter & 8 && typeof key === "string") {
            continue;
        }
        if (filter & 16 && typeof key === "symbol") {
            continue;
        }
        result.push(key);
    }
    return result;
}
const mod6 = function() {
    return {
        guessHandleType: guessHandleType,
        ALL_PROPERTIES: 0,
        ONLY_WRITABLE: 1,
        ONLY_ENUMERABLE: 2,
        ONLY_CONFIGURABLE: 4,
        ONLY_ENUM_WRITABLE: 6,
        SKIP_STRINGS: 8,
        SKIP_SYMBOLS: 16,
        isArrayIndex: isArrayIndex,
        getOwnNonIndexProperties: getOwnNonIndexProperties
    };
}();
const kObjectType = 0;
const kArrayExtrasType = 2;
const kRejected = 2;
const meta = [
    '\\x00',
    '\\x01',
    '\\x02',
    '\\x03',
    '\\x04',
    '\\x05',
    '\\x06',
    '\\x07',
    '\\b',
    '\\t',
    '\\n',
    '\\x0B',
    '\\f',
    '\\r',
    '\\x0E',
    '\\x0F',
    '\\x10',
    '\\x11',
    '\\x12',
    '\\x13',
    '\\x14',
    '\\x15',
    '\\x16',
    '\\x17',
    '\\x18',
    '\\x19',
    '\\x1A',
    '\\x1B',
    '\\x1C',
    '\\x1D',
    '\\x1E',
    '\\x1F',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    "\\'",
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\\\',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\x7F',
    '\\x80',
    '\\x81',
    '\\x82',
    '\\x83',
    '\\x84',
    '\\x85',
    '\\x86',
    '\\x87',
    '\\x88',
    '\\x89',
    '\\x8A',
    '\\x8B',
    '\\x8C',
    '\\x8D',
    '\\x8E',
    '\\x8F',
    '\\x90',
    '\\x91',
    '\\x92',
    '\\x93',
    '\\x94',
    '\\x95',
    '\\x96',
    '\\x97',
    '\\x98',
    '\\x99',
    '\\x9A',
    '\\x9B',
    '\\x9C',
    '\\x9D',
    '\\x9E',
    '\\x9F'
];
const isUndetectableObject = (v)=>typeof v === "undefined" && v !== undefined
;
const strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
const strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c\x7f-\x9f]/g;
const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
const numberRegExp = /^(0|[1-9][0-9]*)$/;
const nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
const classRegExp = /^(\s+[^(]*?)\s*{/;
const stripCommentsRegExp = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
const inspectDefaultOptions = {
    showHidden: false,
    depth: 2,
    colors: false,
    customInspect: true,
    showProxy: false,
    maxArrayLength: 100,
    maxStringLength: 10000,
    breakLength: 80,
    compact: 3,
    sorted: false,
    getters: false
};
function getUserOptions(ctx, isCrossContext) {
    const ret = {
        stylize: ctx.stylize,
        showHidden: ctx.showHidden,
        depth: ctx.depth,
        colors: ctx.colors,
        customInspect: ctx.customInspect,
        showProxy: ctx.showProxy,
        maxArrayLength: ctx.maxArrayLength,
        maxStringLength: ctx.maxStringLength,
        breakLength: ctx.breakLength,
        compact: ctx.compact,
        sorted: ctx.sorted,
        getters: ctx.getters,
        ...ctx.userOptions
    };
    if (isCrossContext) {
        Object.setPrototypeOf(ret, null);
        for (const key of Object.keys(ret)){
            if ((typeof ret[key] === "object" || typeof ret[key] === "function") && ret[key] !== null) {
                delete ret[key];
            }
        }
        ret.stylize = Object.setPrototypeOf((value, flavour)=>{
            let stylized;
            try {
                stylized = `${ctx.stylize(value, flavour)}`;
            } catch  {}
            if (typeof stylized !== "string") return value;
            return stylized;
        }, null);
    }
    return ret;
}
function inspect(value, opts) {
    const ctx = {
        budget: {},
        indentationLvl: 0,
        seen: [],
        currentDepth: 0,
        stylize: stylizeNoColor,
        showHidden: inspectDefaultOptions.showHidden,
        depth: inspectDefaultOptions.depth,
        colors: inspectDefaultOptions.colors,
        customInspect: inspectDefaultOptions.customInspect,
        showProxy: inspectDefaultOptions.showProxy,
        maxArrayLength: inspectDefaultOptions.maxArrayLength,
        maxStringLength: inspectDefaultOptions.maxStringLength,
        breakLength: inspectDefaultOptions.breakLength,
        compact: inspectDefaultOptions.compact,
        sorted: inspectDefaultOptions.sorted,
        getters: inspectDefaultOptions.getters
    };
    if (arguments.length > 1) {
        if (arguments.length > 2) {
            if (arguments[2] !== undefined) {
                ctx.depth = arguments[2];
            }
            if (arguments.length > 3 && arguments[3] !== undefined) {
                ctx.colors = arguments[3];
            }
        }
        if (typeof opts === "boolean") {
            ctx.showHidden = opts;
        } else if (opts) {
            const optKeys = Object.keys(opts);
            for(let i50 = 0; i50 < optKeys.length; ++i50){
                const key = optKeys[i50];
                if (inspectDefaultOptions.hasOwnProperty(key) || key === "stylize") {
                    ctx[key] = opts[key];
                } else if (ctx.userOptions === undefined) {
                    ctx.userOptions = opts;
                }
            }
        }
    }
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;
    if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;
    return formatValue(ctx, value, 0);
}
const customInspectSymbol1 = Symbol.for("nodejs.util.inspect.custom");
inspect.custom = customInspectSymbol1;
Object.defineProperty(inspect, "defaultOptions", {
    get () {
        return inspectDefaultOptions;
    },
    set (options) {
        validateObject(options, "options");
        return Object.assign(inspectDefaultOptions, options);
    }
});
const defaultFG = 39;
const defaultBG = 49;
inspect.colors = Object.assign(Object.create(null), {
    reset: [
        0,
        0
    ],
    bold: [
        1,
        22
    ],
    dim: [
        2,
        22
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    blink: [
        5,
        25
    ],
    inverse: [
        7,
        27
    ],
    hidden: [
        8,
        28
    ],
    strikethrough: [
        9,
        29
    ],
    doubleunderline: [
        21,
        24
    ],
    black: [
        30,
        defaultFG
    ],
    red: [
        31,
        defaultFG
    ],
    green: [
        32,
        defaultFG
    ],
    yellow: [
        33,
        defaultFG
    ],
    blue: [
        34,
        defaultFG
    ],
    magenta: [
        35,
        defaultFG
    ],
    cyan: [
        36,
        defaultFG
    ],
    white: [
        37,
        defaultFG
    ],
    bgBlack: [
        40,
        defaultBG
    ],
    bgRed: [
        41,
        defaultBG
    ],
    bgGreen: [
        42,
        defaultBG
    ],
    bgYellow: [
        43,
        defaultBG
    ],
    bgBlue: [
        44,
        defaultBG
    ],
    bgMagenta: [
        45,
        defaultBG
    ],
    bgCyan: [
        46,
        defaultBG
    ],
    bgWhite: [
        47,
        defaultBG
    ],
    framed: [
        51,
        54
    ],
    overlined: [
        53,
        55
    ],
    gray: [
        90,
        defaultFG
    ],
    redBright: [
        91,
        defaultFG
    ],
    greenBright: [
        92,
        defaultFG
    ],
    yellowBright: [
        93,
        defaultFG
    ],
    blueBright: [
        94,
        defaultFG
    ],
    magentaBright: [
        95,
        defaultFG
    ],
    cyanBright: [
        96,
        defaultFG
    ],
    whiteBright: [
        97,
        defaultFG
    ],
    bgGray: [
        100,
        defaultBG
    ],
    bgRedBright: [
        101,
        defaultBG
    ],
    bgGreenBright: [
        102,
        defaultBG
    ],
    bgYellowBright: [
        103,
        defaultBG
    ],
    bgBlueBright: [
        104,
        defaultBG
    ],
    bgMagentaBright: [
        105,
        defaultBG
    ],
    bgCyanBright: [
        106,
        defaultBG
    ],
    bgWhiteBright: [
        107,
        defaultBG
    ]
});
function defineColorAlias(target, alias) {
    Object.defineProperty(inspect.colors, alias, {
        get () {
            return this[target];
        },
        set (value) {
            this[target] = value;
        },
        configurable: true,
        enumerable: false
    });
}
defineColorAlias("gray", "grey");
defineColorAlias("gray", "blackBright");
defineColorAlias("bgGray", "bgGrey");
defineColorAlias("bgGray", "bgBlackBright");
defineColorAlias("dim", "faint");
defineColorAlias("strikethrough", "crossedout");
defineColorAlias("strikethrough", "strikeThrough");
defineColorAlias("strikethrough", "crossedOut");
defineColorAlias("hidden", "conceal");
defineColorAlias("inverse", "swapColors");
defineColorAlias("inverse", "swapcolors");
defineColorAlias("doubleunderline", "doubleUnderline");
inspect.styles = Object.assign(Object.create(null), {
    special: "cyan",
    number: "yellow",
    bigint: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    symbol: "green",
    date: "magenta",
    regexp: "red",
    module: "underline"
});
function addQuotes(str, quotes) {
    if (quotes === -1) {
        return `"${str}"`;
    }
    if (quotes === -2) {
        return `\`${str}\``;
    }
    return `'${str}'`;
}
const escapeFn = (str)=>meta[str.charCodeAt(0)]
;
function strEscape(str) {
    let escapeTest = strEscapeSequencesRegExp;
    let escapeReplace = strEscapeSequencesReplacer;
    let singleQuote = 39;
    if (str.includes("'")) {
        if (!str.includes('"')) {
            singleQuote = -1;
        } else if (!str.includes("`") && !str.includes("${")) {
            singleQuote = -2;
        }
        if (singleQuote !== 39) {
            escapeTest = strEscapeSequencesRegExpSingle;
            escapeReplace = strEscapeSequencesReplacerSingle;
        }
    }
    if (str.length < 5000 && !escapeTest.test(str)) {
        return addQuotes(str, singleQuote);
    }
    if (str.length > 100) {
        str = str.replace(escapeReplace, escapeFn);
        return addQuotes(str, singleQuote);
    }
    let result = "";
    let last = 0;
    const lastIndex = str.length;
    for(let i51 = 0; i51 < lastIndex; i51++){
        const point = str.charCodeAt(i51);
        if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
            if (last === i51) {
                result += meta[point];
            } else {
                result += `${str.slice(last, i51)}${meta[point]}`;
            }
            last = i51 + 1;
        }
    }
    if (last !== lastIndex) {
        result += str.slice(last);
    }
    return addQuotes(result, singleQuote);
}
function stylizeWithColor(str, styleType) {
    const style = inspect.styles[styleType];
    if (style !== undefined) {
        const color = inspect.colors[style];
        if (color !== undefined) {
            return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
        }
    }
    return str;
}
function stylizeNoColor(str) {
    return str;
}
function formatValue(ctx, value, recurseTimes, typedArray) {
    if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject(value)) {
        return formatPrimitive(ctx.stylize, value, ctx);
    }
    if (value === null) {
        return ctx.stylize("null", "null");
    }
    const context = value;
    const proxy = undefined;
    if (ctx.customInspect) {
        const maybeCustom = value[customInspectSymbol1];
        if (typeof maybeCustom === "function" && maybeCustom !== inspect && !(value.constructor && value.constructor.prototype === value)) {
            const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
            const isCrossContext = proxy !== undefined || !(context instanceof Object);
            const ret = maybeCustom.call(context, depth, getUserOptions(ctx, isCrossContext));
            if (ret !== context) {
                if (typeof ret !== "string") {
                    return formatValue(ctx, ret, recurseTimes);
                }
                return ret.replace(/\n/g, `\n${" ".repeat(ctx.indentationLvl)}`);
            }
        }
    }
    if (ctx.seen.includes(value)) {
        let index = 1;
        if (ctx.circular === undefined) {
            ctx.circular = new Map();
            ctx.circular.set(value, index);
        } else {
            index = ctx.circular.get(value);
            if (index === undefined) {
                index = ctx.circular.size + 1;
                ctx.circular.set(value, index);
            }
        }
        return ctx.stylize(`[Circular *${index}]`, "special");
    }
    return formatRaw(ctx, value, recurseTimes, typedArray);
}
function formatRaw(ctx, value, recurseTimes, typedArray) {
    let keys;
    let protoProps;
    if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
        protoProps = [];
    }
    const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);
    if (protoProps !== undefined && protoProps.length === 0) {
        protoProps = undefined;
    }
    let tag = value[Symbol.toStringTag];
    if (typeof tag !== "string") {
        tag = "";
    }
    let base2 = "";
    let formatter = getEmptyFormatArray;
    let braces;
    let noIterator = true;
    let i52 = 0;
    const filter = ctx.showHidden ? 0 : 2;
    let extrasType = 0;
    if (value[Symbol.iterator] || constructor === null) {
        noIterator = false;
        if (Array.isArray(value)) {
            const prefix = constructor !== "Array" || tag !== "" ? getPrefix(constructor, tag, "Array", `(${value.length})`) : "";
            keys = getOwnNonIndexProperties(value, filter);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}]`;
            }
            extrasType = kArrayExtrasType;
            formatter = formatArray;
        } else if (isSet1(value)) {
            const size = value.size;
            const prefix = getPrefix(constructor, tag, "Set", `(${size})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatSet.bind(null, value) : formatSet.bind(null, value.values());
            if (size === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix}{}`;
            }
            braces = [
                `${prefix}{`,
                "}"
            ];
        } else if (isMap1(value)) {
            const size = value.size;
            const prefix = getPrefix(constructor, tag, "Map", `(${size})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatMap.bind(null, value) : formatMap.bind(null, value.entries());
            if (size === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix}{}`;
            }
            braces = [
                `${prefix}{`,
                "}"
            ];
        } else if (isTypedArray(value)) {
            keys = getOwnNonIndexProperties(value, filter);
            const bound = value;
            const fallback = "";
            const size = value.length;
            const prefix = getPrefix(constructor, tag, fallback, `(${size})`);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
                return `${braces[0]}]`;
            }
            formatter = formatTypedArray.bind(null, bound, size);
            extrasType = kArrayExtrasType;
        } else if (isMapIterator1(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Map", tag);
            formatter = formatIterator.bind(null, braces);
        } else if (isSetIterator1(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Set", tag);
            formatter = formatIterator.bind(null, braces);
        } else {
            noIterator = true;
        }
    }
    if (noIterator) {
        keys = getKeys(value, ctx.showHidden);
        braces = [
            "{",
            "}"
        ];
        if (constructor === "Object") {
            if (isArgumentsObject1(value)) {
                braces[0] = "[Arguments] {";
            } else if (tag !== "") {
                braces[0] = `${getPrefix(constructor, tag, "Object")}{`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}}`;
            }
        } else if (typeof value === "function") {
            base2 = getFunctionBase(value, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base2, "special");
            }
        } else if (isRegExp1(value)) {
            base2 = RegExp(constructor !== null ? value : new RegExp(value)).toString();
            const prefix = getPrefix(constructor, tag, "RegExp");
            if (prefix !== "RegExp ") {
                base2 = `${prefix}${base2}`;
            }
            if (keys.length === 0 && protoProps === undefined || recurseTimes > ctx.depth && ctx.depth !== null) {
                return ctx.stylize(base2, "regexp");
            }
        } else if (isDate1(value)) {
            base2 = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
            const prefix = getPrefix(constructor, tag, "Date");
            if (prefix !== "Date ") {
                base2 = `${prefix}${base2}`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base2, "date");
            }
        } else if (value instanceof Error) {
            base2 = formatError(value, constructor, tag, ctx, keys);
            if (keys.length === 0 && protoProps === undefined) {
                return base2;
            }
        } else if (isAnyArrayBuffer1(value)) {
            const arrayType = isArrayBuffer1(value) ? "ArrayBuffer" : "SharedArrayBuffer";
            const prefix = getPrefix(constructor, tag, arrayType);
            if (typedArray === undefined) {
                formatter = formatArrayBuffer;
            } else if (keys.length === 0 && protoProps === undefined) {
                return prefix + `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
            }
            braces[0] = `${prefix}{`;
            Array.prototype.unshift(keys, "byteLength");
        } else if (isDataView1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "DataView")}{`;
            Array.prototype.unshift(keys, "byteLength", "byteOffset", "buffer");
        } else if (isPromise1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "Promise")}{`;
            formatter = formatPromise;
        } else if (isWeakSet1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "WeakSet")}{`;
            formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
        } else if (isWeakMap1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "WeakMap")}{`;
            formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
        } else if (isModuleNamespaceObject1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "Module")}{`;
            formatter = formatNamespaceObject.bind(null, keys);
        } else if (isBoxedPrimitive1(value)) {
            base2 = getBoxedBase(value, ctx, keys, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return base2;
            }
        } else {
            if (keys.length === 0 && protoProps === undefined) {
                return `${getCtxStyle(value, constructor, tag)}{}`;
            }
            braces[0] = `${getCtxStyle(value, constructor, tag)}{`;
        }
    }
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
        if (constructor !== null) {
            constructorName = `[${constructorName}]`;
        }
        return ctx.stylize(constructorName, "special");
    }
    recurseTimes += 1;
    ctx.seen.push(value);
    ctx.currentDepth = recurseTimes;
    let output;
    const indentationLvl = ctx.indentationLvl;
    try {
        output = formatter(ctx, value, recurseTimes);
        for(i52 = 0; i52 < keys.length; i52++){
            output.push(formatProperty(ctx, value, recurseTimes, keys[i52], extrasType));
        }
        if (protoProps !== undefined) {
            output.push(...protoProps);
        }
    } catch (err) {
        const constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
        return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);
    }
    if (ctx.circular !== undefined) {
        const index = ctx.circular.get(value);
        if (index !== undefined) {
            const reference = ctx.stylize(`<ref *${index}>`, "special");
            if (ctx.compact !== true) {
                base2 = base2 === "" ? reference : `${reference} ${base2}`;
            } else {
                braces[0] = `${reference} ${braces[0]}`;
            }
        }
    }
    ctx.seen.pop();
    if (ctx.sorted) {
        const comparator = ctx.sorted === true ? undefined : ctx.sorted;
        if (extrasType === 0) {
            output = output.sort(comparator);
        } else if (keys.length > 1) {
            const sorted = output.slice(output.length - keys.length).sort(comparator);
            output.splice(output.length - keys.length, keys.length, ...sorted);
        }
    }
    const res = reduceToSingleString(ctx, output, base2, braces, extrasType, recurseTimes, value);
    const budget = ctx.budget[ctx.indentationLvl] || 0;
    const newLength = budget + res.length;
    ctx.budget[ctx.indentationLvl] = newLength;
    if (newLength > 2 ** 27) {
        ctx.depth = -1;
    }
    return res;
}
const builtInObjects = new Set(Object.getOwnPropertyNames(globalThis).filter((e)=>/^[A-Z][a-zA-Z0-9]+$/.test(e)
));
function addPrototypeProperties(ctx, main, obj, recurseTimes, output) {
    let depth = 0;
    let keys;
    let keySet;
    do {
        if (depth !== 0 || main === obj) {
            obj = Object.getPrototypeOf(obj);
            if (obj === null) {
                return;
            }
            const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
            if (descriptor !== undefined && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name)) {
                return;
            }
        }
        if (depth === 0) {
            keySet = new Set();
        } else {
            Array.prototype.forEach(keys, (key)=>keySet.add(key)
            );
        }
        keys = Reflect.ownKeys(obj);
        Array.prototype.push(ctx.seen, main);
        for (const key1 of keys){
            if (key1 === "constructor" || main.hasOwnProperty(key1) || depth !== 0 && keySet.has(key1)) {
                continue;
            }
            const desc = Object.getOwnPropertyDescriptor(obj, key1);
            if (typeof desc.value === "function") {
                continue;
            }
            const value = formatProperty(ctx, obj, recurseTimes, key1, 0, desc, main);
            if (ctx.colors) {
                Array.prototype.push(output, `\u001b[2m${value}\u001b[22m`);
            } else {
                Array.prototype.push(output, value);
            }
        }
        Array.prototype.pop(ctx.seen);
    }while (++depth !== 3)
}
function getConstructorName(obj, ctx, recurseTimes, protoProps) {
    let firstProto;
    const tmp = obj;
    while(obj || isUndetectableObject(obj)){
        const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
        if (descriptor !== undefined && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof(tmp, descriptor.value)) {
            if (protoProps !== undefined && (firstProto !== obj || !builtInObjects.has(descriptor.value.name))) {
                addPrototypeProperties(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
            }
            return descriptor.value.name;
        }
        obj = Object.getPrototypeOf(obj);
        if (firstProto === undefined) {
            firstProto = obj;
        }
    }
    if (firstProto === null) {
        return null;
    }
    const res = undefined;
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        return `${res} <Complex prototype>`;
    }
    const protoConstr = getConstructorName(firstProto, ctx, recurseTimes + 1, protoProps);
    if (protoConstr === null) {
        return `${res} <${inspect(firstProto, {
            ...ctx,
            customInspect: false,
            depth: -1
        })}>`;
    }
    return `${res} <${protoConstr}>`;
}
function formatPrimitive(fn, value, ctx) {
    if (typeof value === "string") {
        let trailer = "";
        if (value.length > ctx.maxStringLength) {
            const remaining = value.length - ctx.maxStringLength;
            value = value.slice(0, ctx.maxStringLength);
            trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
        }
        if (ctx.compact !== true && value.length > 16 && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
            return value.split(/(?<=\n)/).map((line)=>fn(strEscape(line), "string")
            ).join(` +\n${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
        }
        return fn(strEscape(value), "string") + trailer;
    }
    if (typeof value === "number") {
        return formatNumber(fn, value);
    }
    if (typeof value === "bigint") {
        return formatBigInt(fn, value);
    }
    if (typeof value === "boolean") {
        return fn(`${value}`, "boolean");
    }
    if (typeof value === "undefined") {
        return fn("undefined", "undefined");
    }
    return fn(value.toString(), "symbol");
}
function getEmptyFormatArray() {
    return [];
}
function isInstanceof(object, proto) {
    try {
        return object instanceof proto;
    } catch  {
        return false;
    }
}
function getPrefix(constructor, tag, fallback, size = "") {
    if (constructor === null) {
        if (tag !== "" && fallback !== tag) {
            return `[${fallback}${size}: null prototype] [${tag}] `;
        }
        return `[${fallback}${size}: null prototype] `;
    }
    if (tag !== "" && constructor !== tag) {
        return `${constructor}${size} [${tag}] `;
    }
    return `${constructor}${size} `;
}
function formatArray(ctx, value, recurseTimes) {
    const valLen = value.length;
    const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
    const remaining = valLen - len;
    const output = [];
    for(let i53 = 0; i53 < len; i53++){
        if (!value.hasOwnProperty(i53)) {
            return formatSpecialArray(ctx, value, recurseTimes, len, output, i53);
        }
        output.push(formatProperty(ctx, value, recurseTimes, i53, 1));
    }
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getCtxStyle(_value, constructor, tag) {
    let fallback = "";
    if (constructor === null) {
        if (fallback === tag) {
            fallback = "Object";
        }
    }
    return getPrefix(constructor, tag, fallback);
}
function getKeys(value, showHidden) {
    let keys;
    const symbols = Object.getOwnPropertySymbols(value);
    if (showHidden) {
        keys = Object.getOwnPropertyNames(value);
        if (symbols.length !== 0) {
            Array.prototype.push.apply(keys, symbols);
        }
    } else {
        try {
            keys = Object.keys(value);
        } catch (_err) {
            keys = Object.getOwnPropertyNames(value);
        }
        if (symbols.length !== 0) {}
    }
    return keys;
}
function formatSet(value, ctx, _ignored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const v of value){
        Array.prototype.push(output, formatValue(ctx, v, recurseTimes));
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatMap(value, ctx, _gnored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const { 0: k , 1: v  } of value){
        output.push(`${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`);
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatTypedArray(value, length, ctx, _ignored, recurseTimes) {
    const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
    const remaining = value.length - maxLength;
    const output = new Array(maxLength);
    const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber : formatBigInt;
    for(let i54 = 0; i54 < maxLength; ++i54){
        output[i54] = elementFormatter(ctx.stylize, value[i54]);
    }
    if (remaining > 0) {
        output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.showHidden) {
        ctx.indentationLvl += 2;
        for (const key of [
            "BYTES_PER_ELEMENT",
            "length",
            "byteLength",
            "byteOffset",
            "buffer", 
        ]){
            const str = formatValue(ctx, value[key], recurseTimes, true);
            Array.prototype.push(output, `[${key}]: ${str}`);
        }
        ctx.indentationLvl -= 2;
    }
    return output;
}
function getIteratorBraces(type3, tag) {
    if (tag !== `${type3} Iterator`) {
        if (tag !== "") {
            tag += "] [";
        }
        tag += `${type3} Iterator`;
    }
    return [
        `[${tag}] {`,
        "}"
    ];
}
function formatIterator(braces, ctx, value, recurseTimes) {
    const { 0: entries , 1: isKeyValue  } = value;
    if (isKeyValue) {
        braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
        return formatMapIterInner(ctx, recurseTimes, entries, 2);
    }
    return formatSetIterInner(ctx, recurseTimes, entries, 1);
}
function getFunctionBase(value, constructor, tag) {
    const stringified = Function.prototype.toString(value);
    if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
        const slice = stringified.slice(5, -1);
        const bracketIndex = slice.indexOf("{");
        if (bracketIndex !== -1 && (!slice.slice(0, bracketIndex).includes("(") || classRegExp.test(slice.replace(stripCommentsRegExp)))) {
            return getClassBase(value, constructor, tag);
        }
    }
    let type4 = "Function";
    if (isGeneratorFunction1(value)) {
        type4 = `Generator${type4}`;
    }
    if (isAsyncFunction1(value)) {
        type4 = `Async${type4}`;
    }
    let base3 = `[${type4}`;
    if (constructor === null) {
        base3 += " (null prototype)";
    }
    if (value.name === "") {
        base3 += " (anonymous)";
    } else {
        base3 += `: ${value.name}`;
    }
    base3 += "]";
    if (constructor !== type4 && constructor !== null) {
        base3 += ` ${constructor}`;
    }
    if (tag !== "" && constructor !== tag) {
        base3 += ` [${tag}]`;
    }
    return base3;
}
function formatError(err, constructor, tag, ctx, keys) {
    const name15 = err.name != null ? String(err.name) : "Error";
    let len = name15.length;
    let stack = err.stack ? String(err.stack) : err.toString();
    if (!ctx.showHidden && keys.length !== 0) {
        for (const name16 of [
            "name",
            "message",
            "stack"
        ]){
            const index = keys.indexOf(name16);
            if (index !== -1 && stack.includes(err[name16])) {
                keys.splice(index, 1);
            }
        }
    }
    if (constructor === null || name15.endsWith("Error") && stack.startsWith(name15) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
        let fallback = "Error";
        if (constructor === null) {
            const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
            fallback = start && start[1] || "";
            len = fallback.length;
            fallback = fallback || "Error";
        }
        const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);
        if (name15 !== prefix) {
            if (prefix.includes(name15)) {
                if (len === 0) {
                    stack = `${prefix}: ${stack}`;
                } else {
                    stack = `${prefix}${stack.slice(len)}`;
                }
            } else {
                stack = `${prefix} [${name15}]${stack.slice(len)}`;
            }
        }
    }
    let pos = err.message && stack.indexOf(err.message) || -1;
    if (pos !== -1) {
        pos += err.message.length;
    }
    const stackStart = stack.indexOf("\n    at", pos);
    if (stackStart === -1) {
        stack = `[${stack}]`;
    } else if (ctx.colors) {
        let newStack = stack.slice(0, stackStart);
        const lines = stack.slice(stackStart + 1).split("\n");
        for (const line of lines){
            let nodeModule;
            newStack += "\n";
            let pos = 0;
            while(nodeModule = nodeModulesRegExp.exec(line)){
                newStack += line.slice(pos, nodeModule.index + 14);
                newStack += ctx.stylize(nodeModule[1], "module");
                pos = nodeModule.index + nodeModule[0].length;
            }
            newStack += pos === 0 ? line : line.slice(pos);
        }
        stack = newStack;
    }
    if (ctx.indentationLvl !== 0) {
        const indentation = " ".repeat(ctx.indentationLvl);
        stack = stack.replace(/\n/g, `\n${indentation}`);
    }
    return stack;
}
let hexSlice;
function formatArrayBuffer(ctx, value) {
    let buffer;
    try {
        buffer = new Uint8Array(value);
    } catch  {
        return [
            ctx.stylize("(detached)", "special")
        ];
    }
    let str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
    const remaining = buffer.length - ctx.maxArrayLength;
    if (remaining > 0) {
        str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
    }
    return [
        `${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`
    ];
}
function formatNumber(fn, value) {
    return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise(ctx, value, recurseTimes) {
    let output;
    const { 0: state , 1: result  } = value;
    if (state === 0) {
        output = [
            ctx.stylize("<pending>", "special")
        ];
    } else {
        ctx.indentationLvl += 2;
        const str = formatValue(ctx, result, recurseTimes);
        ctx.indentationLvl -= 2;
        output = [
            state === kRejected ? `${ctx.stylize("<rejected>", "special")} ${str}` : str, 
        ];
    }
    return output;
}
function formatWeakCollection(ctx) {
    return [
        ctx.stylize("<items unknown>", "special")
    ];
}
function formatWeakSet(ctx, value, recurseTimes) {
    const entries = value;
    return formatSetIterInner(ctx, recurseTimes, entries, 0);
}
function formatWeakMap(ctx, value, recurseTimes) {
    const entries = value;
    return formatMapIterInner(ctx, recurseTimes, entries, 0);
}
function formatProperty(ctx, value, recurseTimes, key, type5, desc, original = value) {
    let name17, str;
    let extra = " ";
    desc = desc || Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key],
        enumerable: true
    };
    if (desc.value !== undefined) {
        const diff = ctx.compact !== true || type5 !== 0 ? 2 : 3;
        ctx.indentationLvl += diff;
        str = formatValue(ctx, desc.value, recurseTimes);
        if (diff === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {
            extra = `\n${" ".repeat(ctx.indentationLvl)}`;
        }
        ctx.indentationLvl -= diff;
    } else if (desc.get !== undefined) {
        const label = desc.set !== undefined ? "Getter/Setter" : "Getter";
        const s = ctx.stylize;
        const sp = "special";
        if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === undefined || ctx.getters === "set" && desc.set !== undefined)) {
            try {
                const tmp = desc.get.call(original);
                ctx.indentationLvl += 2;
                if (tmp === null) {
                    str = `${s(`[${label}:`, sp)} ${s("null", "null")}${s("]", sp)}`;
                } else if (typeof tmp === "object") {
                    str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
                } else {
                    const primitive = formatPrimitive(s, tmp, ctx);
                    str = `${s(`[${label}:`, sp)} ${primitive}${s("]", sp)}`;
                }
                ctx.indentationLvl -= 2;
            } catch (err) {
                const message = `<Inspection threw (${err.message})>`;
                str = `${s(`[${label}:`, sp)} ${message}${s("]", sp)}`;
            }
        } else {
            str = ctx.stylize(`[${label}]`, sp);
        }
    } else if (desc.set !== undefined) {
        str = ctx.stylize("[Setter]", "special");
    } else {
        str = ctx.stylize("undefined", "undefined");
    }
    if (type5 === 1) {
        return str;
    }
    if (typeof key === "symbol") {
        const tmp = key.toString().replace(strEscapeSequencesReplacer, escapeFn);
        name17 = `[${ctx.stylize(tmp, "symbol")}]`;
    } else if (key === "__proto__") {
        name17 = "['__proto__']";
    } else if (desc.enumerable === false) {
        const tmp = key.replace(strEscapeSequencesReplacer, escapeFn);
        name17 = `[${tmp}]`;
    } else if (keyStrRegExp.test(key)) {
        name17 = ctx.stylize(key, "name");
    } else {
        name17 = ctx.stylize(strEscape(key), "string");
    }
    return `${name17}:${extra}${str}`;
}
function handleMaxCallStackSize(_ctx, _err, _constructorName, _indentationLvl) {}
const colorRegExp = /\u001b\[\d\d?m/g;
function removeColors(str) {
    return str.replace(colorRegExp, "");
}
function isBelowBreakLength(ctx, output, start, base4) {
    let totalLength = output.length + start;
    if (totalLength + output.length > ctx.breakLength) {
        return false;
    }
    for(let i55 = 0; i55 < output.length; i55++){
        if (ctx.colors) {
            totalLength += removeColors(output[i55]).length;
        } else {
            totalLength += output[i55].length;
        }
        if (totalLength > ctx.breakLength) {
            return false;
        }
    }
    return base4 === "" || !base4.includes("\n");
}
function formatBigInt(fn, value) {
    return fn(`${value}n`, "bigint");
}
function formatNamespaceObject(keys, ctx, value, recurseTimes) {
    const output = new Array(keys.length);
    for(let i56 = 0; i56 < keys.length; i56++){
        try {
            output[i56] = formatProperty(ctx, value, recurseTimes, keys[i56], kObjectType);
        } catch (_err) {
            const tmp = {
                [keys[i56]]: ""
            };
            output[i56] = formatProperty(ctx, tmp, recurseTimes, keys[i56], kObjectType);
            const pos = output[i56].lastIndexOf(" ");
            output[i56] = output[i56].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
        }
    }
    keys.length = 0;
    return output;
}
function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i57) {
    const keys = Object.keys(value);
    let index = i57;
    for(; i57 < keys.length && output.length < maxLength; i57++){
        const key = keys[i57];
        const tmp = +key;
        if (tmp > 2 ** 32 - 2) {
            break;
        }
        if (`${index}` !== key) {
            if (!numberRegExp.test(key)) {
                break;
            }
            const emptyItems = tmp - index;
            const ending = emptyItems > 1 ? "s" : "";
            const message = `<${emptyItems} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
            index = tmp;
            if (output.length === maxLength) {
                break;
            }
        }
        output.push(formatProperty(ctx, value, recurseTimes, key, 1));
        index++;
    }
    const remaining = value.length - index;
    if (output.length !== maxLength) {
        if (remaining > 0) {
            const ending = remaining > 1 ? "s" : "";
            const message = `<${remaining} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
        }
    } else if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getBoxedBase(value, ctx, keys, constructor, tag) {
    let type6;
    if (isNumberObject1(value)) {
        type6 = "Number";
    } else if (isStringObject1(value)) {
        type6 = "String";
        keys.splice(0, value.length);
    } else if (isBooleanObject1(value)) {
        type6 = "Boolean";
    } else if (isBigIntObject1(value)) {
        type6 = "BigInt";
    } else {
        type6 = "Symbol";
    }
    let base5 = `[${type6}`;
    if (type6 !== constructor) {
        if (constructor === null) {
            base5 += " (null prototype)";
        } else {
            base5 += ` (${constructor})`;
        }
    }
    base5 += `: ${formatPrimitive(stylizeNoColor, value.valueOf(), ctx)}]`;
    if (tag !== "" && tag !== constructor) {
        base5 += ` [${tag}]`;
    }
    if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
        return base5;
    }
    return ctx.stylize(base5, type6.toLowerCase());
}
function getClassBase(value, constructor, tag) {
    const hasName = value.hasOwnProperty("name");
    const name18 = hasName && value.name || "(anonymous)";
    let base6 = `class ${name18}`;
    if (constructor !== "Function" && constructor !== null) {
        base6 += ` [${constructor}]`;
    }
    if (tag !== "" && constructor !== tag) {
        base6 += ` [${tag}]`;
    }
    if (constructor !== null) {
        const superName = Object.getPrototypeOf(value).name;
        if (superName) {
            base6 += ` extends ${superName}`;
        }
    } else {
        base6 += " extends [null prototype]";
    }
    return `[${base6}]`;
}
function reduceToSingleString(ctx, output, base7, braces, extrasType, recurseTimes, value) {
    if (ctx.compact !== true) {
        if (typeof ctx.compact === "number" && ctx.compact >= 1) {
            const entries = output.length;
            if (extrasType === 2 && entries > 6) {
                output = groupArrayElements(ctx, output, value);
            }
            if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
                const start = output.length + ctx.indentationLvl + braces[0].length + base7.length + 10;
                if (isBelowBreakLength(ctx, output, start, base7)) {
                    return `${base7 ? `${base7} ` : ""}${braces[0]} ${join4(output, ", ")}` + ` ${braces[1]}`;
                }
            }
        }
        const indentation = `\n${" ".repeat(ctx.indentationLvl)}`;
        return `${base7 ? `${base7} ` : ""}${braces[0]}${indentation}  ` + `${join4(output, `,${indentation}  `)}${indentation}${braces[1]}`;
    }
    if (isBelowBreakLength(ctx, output, 0, base7)) {
        return `${braces[0]}${base7 ? ` ${base7}` : ""} ${join4(output, ", ")} ` + braces[1];
    }
    const indentation = " ".repeat(ctx.indentationLvl);
    const ln = base7 === "" && braces[0].length === 1 ? " " : `${base7 ? ` ${base7}` : ""}\n${indentation}  `;
    return `${braces[0]}${ln}${join4(output, `,\n${indentation}  `)} ${braces[1]}`;
}
function join4(output, separator) {
    let str = "";
    if (output.length !== 0) {
        const lastIndex = output.length - 1;
        for(let i58 = 0; i58 < lastIndex; i58++){
            str += output[i58];
            str += separator;
        }
        str += output[lastIndex];
    }
    return str;
}
function groupArrayElements(ctx, output, value) {
    let totalLength = 0;
    let maxLength = 0;
    let i59 = 0;
    let outputLength = output.length;
    if (ctx.maxArrayLength < output.length) {
        outputLength--;
    }
    const separatorSpace = 2;
    const dataLen = new Array(outputLength);
    for(; i59 < outputLength; i59++){
        const len = getStringWidth(output[i59], ctx.colors);
        dataLen[i59] = len;
        totalLength += len + separatorSpace;
        if (maxLength < len) {
            maxLength = len;
        }
    }
    const actualMax = maxLength + 2;
    if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
        const averageBias = Math.sqrt(actualMax - totalLength / output.length);
        const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
        const columns = Math.min(Math.round(Math.sqrt(2.5 * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
        if (columns <= 1) {
            return output;
        }
        const tmp = [];
        const maxLineLength = [];
        for(let i60 = 0; i60 < columns; i60++){
            let lineMaxLength = 0;
            for(let j = i60; j < output.length; j += columns){
                if (dataLen[j] > lineMaxLength) {
                    lineMaxLength = dataLen[j];
                }
            }
            lineMaxLength += separatorSpace;
            maxLineLength[i60] = lineMaxLength;
        }
        let order = String.prototype.padStart;
        if (value !== undefined) {
            for(let i61 = 0; i61 < output.length; i61++){
                if (typeof value[i61] !== "number" && typeof value[i61] !== "bigint") {
                    order = String.prototype.padEnd;
                    break;
                }
            }
        }
        for(let i1 = 0; i1 < outputLength; i1 += columns){
            const max = Math.min(i1 + columns, outputLength);
            let str = "";
            let j = i1;
            for(; j < max - 1; j++){
                const padding = maxLineLength[j - i1] + output[j].length - dataLen[j];
                str += `${output[j]}, `.padStart(padding, " ");
            }
            if (order === String.prototype.padStart) {
                const padding = maxLineLength[j - i1] + output[j].length - dataLen[j] - 2;
                str += output[j].padStart(padding, " ");
            } else {
                str += output[j];
            }
            Array.prototype.push(tmp, str);
        }
        if (ctx.maxArrayLength < output.length) {
            Array.prototype.push(tmp, output[outputLength]);
        }
        output = tmp;
    }
    return output;
}
function formatMapIterInner(ctx, recurseTimes, entries, state) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const len = entries.length / 2;
    const remaining = len - maxArrayLength;
    const maxLength = Math.min(maxArrayLength, len);
    let output = new Array(maxLength);
    let i62 = 0;
    ctx.indentationLvl += 2;
    if (state === 0) {
        for(; i62 < maxLength; i62++){
            const pos = i62 * 2;
            output[i62] = `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
        }
        if (!ctx.sorted) {
            output = output.sort();
        }
    } else {
        for(; i62 < maxLength; i62++){
            const pos = i62 * 2;
            const res = [
                formatValue(ctx, entries[pos], recurseTimes),
                formatValue(ctx, entries[pos + 1], recurseTimes), 
            ];
            output[i62] = reduceToSingleString(ctx, res, "", [
                "[",
                "]"
            ], kArrayExtrasType, recurseTimes);
        }
    }
    ctx.indentationLvl -= 2;
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function formatSetIterInner(ctx, recurseTimes, entries, state) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const maxLength = Math.min(maxArrayLength, entries.length);
    const output = new Array(maxLength);
    ctx.indentationLvl += 2;
    for(let i63 = 0; i63 < maxLength; i63++){
        output[i63] = formatValue(ctx, entries[i63], recurseTimes);
    }
    ctx.indentationLvl -= 2;
    if (state === 0 && !ctx.sorted) {
        output.sort();
    }
    const remaining = entries.length - maxLength;
    if (remaining > 0) {
        Array.prototype.push(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
const ansiPattern = "[\\u001B\\u009B][[\\]()#;?]*" + "(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*" + "|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)" + "|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
const ansi = new RegExp(ansiPattern, "g");
function getStringWidth(str, removeControlChars = true) {
    let width = 0;
    if (removeControlChars) {
        str = stripVTControlCharacters(str);
    }
    str = str.normalize("NFC");
    for (const __char of str[Symbol.iterator]()){
        const code = __char.codePointAt(0);
        if (isFullWidthCodePoint(code)) {
            width += 2;
        } else if (!isZeroWidthCodePoint(code)) {
            width++;
        }
    }
    return width;
}
const isFullWidthCodePoint = (code)=>{
    return code >= 0x1100 && (code <= 0x115f || code === 0x2329 || code === 0x232a || code >= 0x2e80 && code <= 0x3247 && code !== 0x303f || code >= 0x3250 && code <= 0x4dbf || code >= 0x4e00 && code <= 0xa4c6 || code >= 0xa960 && code <= 0xa97c || code >= 0xac00 && code <= 0xd7a3 || code >= 0xf900 && code <= 0xfaff || code >= 0xfe10 && code <= 0xfe19 || code >= 0xfe30 && code <= 0xfe6b || code >= 0xff01 && code <= 0xff60 || code >= 0xffe0 && code <= 0xffe6 || code >= 0x1b000 && code <= 0x1b001 || code >= 0x1f200 && code <= 0x1f251 || code >= 0x1f300 && code <= 0x1f64f || code >= 0x20000 && code <= 0x3fffd);
};
const isZeroWidthCodePoint = (code)=>{
    return code <= 0x1F || code >= 0x7F && code <= 0x9F || code >= 0x300 && code <= 0x36F || code >= 0x200B && code <= 0x200F || code >= 0x20D0 && code <= 0x20FF || code >= 0xFE00 && code <= 0xFE0F || code >= 0xFE20 && code <= 0xFE2F || code >= 0xE0100 && code <= 0xE01EF;
};
function stripVTControlCharacters(str) {
    validateString(str, "str");
    return str.replace(ansi, "");
}
let debugImpls;
let testEnabled;
function initializeDebugEnv(debugEnv1) {
    debugImpls = Object.create(null);
    if (debugEnv1) {
        debugEnv1 = debugEnv1.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
        const debugEnvRegex = new RegExp(`^${debugEnv1}$`, "i");
        testEnabled = (str)=>debugEnvRegex.exec(str) !== null
        ;
    } else {
        testEnabled = ()=>false
        ;
    }
}
function emitWarningIfNeeded(set) {
    if ("HTTP" === set || "HTTP2" === set) {
        console.warn("Setting the NODE_DEBUG environment variable " + "to '" + set.toLowerCase() + "' can expose sensitive " + "data (such as passwords, tokens and authentication headers) " + "in the resulting log.");
    }
}
const noop = ()=>{};
function debuglogImpl(enabled, set) {
    if (debugImpls[set] === undefined) {
        if (enabled) {
            emitWarningIfNeeded(set);
            debugImpls[set] = function debug(...args) {
                const msg = args.map((arg)=>inspect(arg)
                ).join(" ");
                console.error(sprintf("%s %s: %s", set, String(Deno.pid), msg));
            };
        } else {
            debugImpls[set] = noop;
        }
    }
    return debugImpls[set];
}
function debuglog(set, cb) {
    function init() {
        set = set.toUpperCase();
        enabled = testEnabled(set);
    }
    let debug1 = (...args)=>{
        init();
        debug1 = debuglogImpl(enabled, set);
        if (typeof cb === "function") {
            cb(debug1);
        }
        return debug1(...args);
    };
    let enabled;
    let test = ()=>{
        init();
        test = ()=>enabled
        ;
        return enabled;
    };
    const logger = (...args)=>debug1(...args)
    ;
    Object.defineProperty(logger, "enabled", {
        get () {
            return test();
        },
        configurable: true,
        enumerable: true
    });
    return logger;
}
let debugEnv;
try {
    debugEnv = Deno.env.get("NODE_DEBUG") ?? "";
} catch (error1) {
    if (error1 instanceof Deno.errors.PermissionDenied) {
        debugEnv = "";
    } else {
        throw error1;
    }
}
initializeDebugEnv(debugEnv);
function uvTranslateSysError(sysErrno) {
    switch(sysErrno){
        case 5:
            return "EACCES";
        case 998:
            return "EACCES";
        case 10013:
            return "EACCES";
        case 1920:
            return "EACCES";
        case 1227:
            return "EADDRINUSE";
        case 10048:
            return "EADDRINUSE";
        case 10049:
            return "EADDRNOTAVAIL";
        case 10047:
            return "EAFNOSUPPORT";
        case 10035:
            return "EAGAIN";
        case 10037:
            return "EALREADY";
        case 1004:
            return "EBADF";
        case 6:
            return "EBADF";
        case 33:
            return "EBUSY";
        case 231:
            return "EBUSY";
        case 32:
            return "EBUSY";
        case 995:
            return "ECANCELED";
        case 10004:
            return "ECANCELED";
        case 1113:
            return "ECHARSET";
        case 1236:
            return "ECONNABORTED";
        case 10053:
            return "ECONNABORTED";
        case 1225:
            return "ECONNREFUSED";
        case 10061:
            return "ECONNREFUSED";
        case 64:
            return "ECONNRESET";
        case 10054:
            return "ECONNRESET";
        case 183:
            return "EEXIST";
        case 80:
            return "EEXIST";
        case 111:
            return "EFAULT";
        case 10014:
            return "EFAULT";
        case 1232:
            return "EHOSTUNREACH";
        case 10065:
            return "EHOSTUNREACH";
        case 122:
            return "EINVAL";
        case 13:
            return "EINVAL";
        case 123:
            return "EINVAL";
        case 87:
            return "EINVAL";
        case 10022:
            return "EINVAL";
        case 10046:
            return "EINVAL";
        case 1102:
            return "EIO";
        case 1111:
            return "EIO";
        case 23:
            return "EIO";
        case 1166:
            return "EIO";
        case 1165:
            return "EIO";
        case 1393:
            return "EIO";
        case 1129:
            return "EIO";
        case 1101:
            return "EIO";
        case 31:
            return "EIO";
        case 1106:
            return "EIO";
        case 1117:
            return "EIO";
        case 1104:
            return "EIO";
        case 205:
            return "EIO";
        case 110:
            return "EIO";
        case 1103:
            return "EIO";
        case 156:
            return "EIO";
        case 10056:
            return "EISCONN";
        case 1921:
            return "ELOOP";
        case 4:
            return "EMFILE";
        case 10024:
            return "EMFILE";
        case 10040:
            return "EMSGSIZE";
        case 206:
            return "ENAMETOOLONG";
        case 1231:
            return "ENETUNREACH";
        case 10051:
            return "ENETUNREACH";
        case 10055:
            return "ENOBUFS";
        case 161:
            return "ENOENT";
        case 267:
            return "ENOTDIR";
        case 203:
            return "ENOENT";
        case 2:
            return "ENOENT";
        case 15:
            return "ENOENT";
        case 4392:
            return "ENOENT";
        case 126:
            return "ENOENT";
        case 3:
            return "ENOENT";
        case 11001:
            return "ENOENT";
        case 11004:
            return "ENOENT";
        case 8:
            return "ENOMEM";
        case 14:
            return "ENOMEM";
        case 82:
            return "ENOSPC";
        case 112:
            return "ENOSPC";
        case 277:
            return "ENOSPC";
        case 1100:
            return "ENOSPC";
        case 39:
            return "ENOSPC";
        case 2250:
            return "ENOTCONN";
        case 10057:
            return "ENOTCONN";
        case 145:
            return "ENOTEMPTY";
        case 10038:
            return "ENOTSOCK";
        case 50:
            return "ENOTSUP";
        case 109:
            return "EOF";
        case 1314:
            return "EPERM";
        case 230:
            return "EPIPE";
        case 232:
            return "EPIPE";
        case 233:
            return "EPIPE";
        case 10058:
            return "EPIPE";
        case 10043:
            return "EPROTONOSUPPORT";
        case 19:
            return "EROFS";
        case 121:
            return "ETIMEDOUT";
        case 10060:
            return "ETIMEDOUT";
        case 17:
            return "EXDEV";
        case 1:
            return "EISDIR";
        case 208:
            return "E2BIG";
        case 10044:
            return "ESOCKTNOSUPPORT";
        default:
            return "UNKNOWN";
    }
}
const UV_EEXIST = os.errno.EEXIST;
const UV_ENOENT = os.errno.ENOENT;
const codeToErrorWindows = [
    [
        -4093,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -4092,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -4091,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -4090,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -4089,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -4088,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -4084,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -4083,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -4082,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -4081,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -4079,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -4078,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -4077,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -4076,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -4075,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -4074,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -4036,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -4073,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4072,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -4071,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -4070,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -4069,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -4068,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -4067,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -4066,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -4065,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -4064,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -4063,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -4062,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -4061,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -4060,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -4059,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -4058,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -4057,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -4035,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -4055,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -4054,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -4053,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -4052,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -4051,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -4050,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -4049,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -4048,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -4047,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -4046,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -4045,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -4044,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -4034,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -4043,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -4042,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -4041,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -4040,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -4039,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -4038,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -4037,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -4033,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -4032,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -4031,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -4029,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -4027,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeWindows = codeToErrorWindows.map(([status, [error2]])=>[
        error2,
        status
    ]
);
const codeToErrorDarwin = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -48,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -49,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -47,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -35,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -37,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -89,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -53,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -61,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -54,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -39,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -65,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -56,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -62,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -40,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -63,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -50,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -51,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -55,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -42,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -78,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -57,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -66,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -38,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -45,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -100,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -43,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -41,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -58,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -60,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -64,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -79,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -92,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeDarwin = codeToErrorDarwin.map(([status, [code]])=>[
        code,
        status
    ]
);
const codeToErrorLinux = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -98,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -99,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -97,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -11,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -114,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -125,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -103,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -111,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -104,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -89,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -113,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -106,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -40,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -90,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -36,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -100,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -101,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -105,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -64,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -92,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -38,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -107,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -39,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -88,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -95,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -71,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -93,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -91,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -108,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -110,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -112,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -121,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -84,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeLinux = codeToErrorLinux.map(([status, [code]])=>[
        code,
        status
    ]
);
const errorMap = new Map(osType === "windows" ? codeToErrorWindows : osType === "darwin" ? codeToErrorDarwin : osType === "linux" ? codeToErrorLinux : unreachable());
const codeMap = new Map(osType === "windows" ? errorToCodeWindows : osType === "darwin" ? errorToCodeDarwin : osType === "linux" ? errorToCodeLinux : unreachable());
function mapSysErrnoToUvErrno(sysErrno) {
    if (osType === "windows") {
        const code = uvTranslateSysError(sysErrno);
        return codeMap.get(code) ?? -sysErrno;
    } else {
        return -sysErrno;
    }
}
const UV_EAI_MEMORY = codeMap.get("EAI_MEMORY");
const UV_UNKNOWN = codeMap.get("UNKNOWN");
const UV_EBADF = codeMap.get("EBADF");
const UV_EINVAL = codeMap.get("EINVAL");
const UV_ENOTSOCK = codeMap.get("ENOTSOCK");
const mod7 = {
    UV_EEXIST: UV_EEXIST,
    UV_ENOENT: UV_ENOENT,
    errorMap: errorMap,
    codeMap: codeMap,
    mapSysErrnoToUvErrno: mapSysErrnoToUvErrno,
    UV_EAI_MEMORY: UV_EAI_MEMORY,
    UV_UNKNOWN: UV_UNKNOWN,
    UV_EBADF: UV_EBADF,
    UV_EINVAL: UV_EINVAL,
    UV_ENOTSOCK: UV_ENOTSOCK
};
var valueType;
(function(valueType1) {
    valueType1[valueType1["noIterator"] = 0] = "noIterator";
    valueType1[valueType1["isArray"] = 1] = "isArray";
    valueType1[valueType1["isSet"] = 2] = "isSet";
    valueType1[valueType1["isMap"] = 3] = "isMap";
})(valueType || (valueType = {}));
let memo;
function innerDeepEqual(val1, val2, strict, memos = memo) {
    if (val1 === val2) {
        if (val1 !== 0) return true;
        return strict ? Object.is(val1, val2) : true;
    }
    if (strict) {
        if (typeof val1 !== "object") {
            return typeof val1 === "number" && Number.isNaN(val1) && Number.isNaN(val2);
        }
        if (typeof val2 !== "object" || val1 === null || val2 === null) {
            return false;
        }
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
            return false;
        }
    } else {
        if (val1 === null || typeof val1 !== "object") {
            if (val2 === null || typeof val2 !== "object") {
                return val1 == val2 || Number.isNaN(val1) && Number.isNaN(val2);
            }
            return false;
        }
        if (val2 === null || typeof val2 !== "object") {
            return false;
        }
    }
    const val1Tag = Object.prototype.toString.call(val1);
    const val2Tag = Object.prototype.toString.call(val2);
    if (val1Tag !== val2Tag) {
        return false;
    }
    if (Array.isArray(val1)) {
        if (!Array.isArray(val2) || val1.length !== val2.length) {
            return false;
        }
        const filter = strict ? 2 : 2 | 16;
        const keys1 = getOwnNonIndexProperties(val1, filter);
        const keys2 = getOwnNonIndexProperties(val2, filter);
        if (keys1.length !== keys2.length) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isArray, keys1);
    } else if (val1Tag === "[object Object]") {
        return keyCheck(val1, val2, strict, memos, valueType.noIterator);
    } else if (val1 instanceof Date) {
        if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
            return false;
        }
    } else if (val1 instanceof RegExp) {
        if (!(val2 instanceof RegExp) || !areSimilarRegExps(val1, val2)) {
            return false;
        }
    } else if (isNativeError1(val1) || val1 instanceof Error) {
        if (!isNativeError1(val2) && !(val2 instanceof Error) || val1.message !== val2.message || val1.name !== val2.name) {
            return false;
        }
    } else if (isArrayBufferView(val1)) {
        const TypedArrayPrototypeGetSymbolToStringTag = (val)=>Object.getOwnPropertySymbols(val).map((item)=>item.toString()
            ).toString()
        ;
        if (isTypedArray(val1) && isTypedArray(val2) && TypedArrayPrototypeGetSymbolToStringTag(val1) !== TypedArrayPrototypeGetSymbolToStringTag(val2)) {
            return false;
        }
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
            if (!areSimilarFloatArrays(val1, val2)) {
                return false;
            }
        } else if (!areSimilarTypedArrays(val1, val2)) {
            return false;
        }
        const filter = strict ? 2 : 2 | 16;
        const keysVal1 = getOwnNonIndexProperties(val1, filter);
        const keysVal2 = getOwnNonIndexProperties(val2, filter);
        if (keysVal1.length !== keysVal2.length) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.noIterator, keysVal1);
    } else if (isSet1(val1)) {
        if (!isSet1(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isSet);
    } else if (isMap1(val1)) {
        if (!isMap1(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isMap);
    } else if (isAnyArrayBuffer1(val1)) {
        if (!isAnyArrayBuffer1(val2) || !areEqualArrayBuffers(val1, val2)) {
            return false;
        }
    } else if (isBoxedPrimitive1(val1)) {
        if (!isEqualBoxedPrimitive(val1, val2)) {
            return false;
        }
    } else if (Array.isArray(val2) || isArrayBufferView(val2) || isSet1(val2) || isMap1(val2) || isDate1(val2) || isRegExp1(val2) || isAnyArrayBuffer1(val2) || isBoxedPrimitive1(val2) || isNativeError1(val2) || val2 instanceof Error) {
        return false;
    }
    return keyCheck(val1, val2, strict, memos, valueType.noIterator);
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys = []) {
    if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        const bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length) {
            return false;
        }
    }
    let i64 = 0;
    for(; i64 < aKeys.length; i64++){
        if (!val2.propertyIsEnumerable(aKeys[i64])) {
            return false;
        }
    }
    if (strict && arguments.length === 5) {
        const symbolKeysA = Object.getOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
            let count = 0;
            for(i64 = 0; i64 < symbolKeysA.length; i64++){
                const key = symbolKeysA[i64];
                if (val1.propertyIsEnumerable(key)) {
                    if (!val2.propertyIsEnumerable(key)) {
                        return false;
                    }
                    aKeys.push(key.toString());
                    count++;
                } else if (val2.propertyIsEnumerable(key)) {
                    return false;
                }
            }
            const symbolKeysB = Object.getOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                return false;
            }
        } else {
            const symbolKeysB = Object.getOwnPropertySymbols(val2);
            if (symbolKeysB.length !== 0 && getEnumerables(val2, symbolKeysB).length !== 0) {
                return false;
            }
        }
    }
    if (aKeys.length === 0 && (iterationType === valueType.noIterator || iterationType === valueType.isArray && val1.length === 0 || val1.size === 0)) {
        return true;
    }
    if (memos === undefined) {
        memos = {
            val1: new Map(),
            val2: new Map(),
            position: 0
        };
    } else {
        const val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== undefined) {
            const val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== undefined) {
                return val2MemoA === val2MemoB;
            }
        }
        memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    const areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
}
function areSimilarRegExps(a, b) {
    return a.source === b.source && a.flags === b.flags && a.lastIndex === b.lastIndex;
}
function areSimilarFloatArrays(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    for(let i65 = 0; i65 < arr1.byteLength; i65++){
        if (arr1[i65] !== arr2[i65]) {
            return false;
        }
    }
    return true;
}
function areSimilarTypedArrays(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    return Buffer.compare(new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength), new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && Buffer.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(a, b) {
    if (Object.getOwnPropertyNames(a).length !== Object.getOwnPropertyNames(b).length) {
        return false;
    }
    if (Object.getOwnPropertySymbols(a).length !== Object.getOwnPropertySymbols(b).length) {
        return false;
    }
    if (isNumberObject1(a)) {
        return isNumberObject1(b) && Object.is(Number.prototype.valueOf.call(a), Number.prototype.valueOf.call(b));
    }
    if (isStringObject1(a)) {
        return isStringObject1(b) && String.prototype.valueOf.call(a) === String.prototype.valueOf.call(b);
    }
    if (isBooleanObject1(a)) {
        return isBooleanObject1(b) && Boolean.prototype.valueOf.call(a) === Boolean.prototype.valueOf.call(b);
    }
    if (isBigIntObject1(a)) {
        return isBigIntObject1(b) && BigInt.prototype.valueOf.call(a) === BigInt.prototype.valueOf.call(b);
    }
    if (isSymbolObject1(a)) {
        return isSymbolObject1(b) && Symbol.prototype.valueOf.call(a) === Symbol.prototype.valueOf.call(b);
    }
    throw Error(`Unknown boxed type`);
}
function getEnumerables(val, keys) {
    return keys.filter((key)=>val.propertyIsEnumerable(key)
    );
}
function objEquiv(obj1, obj2, strict, keys, memos, iterationType) {
    let i66 = 0;
    if (iterationType === valueType.isSet) {
        if (!setEquiv(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType.isMap) {
        if (!mapEquiv(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType.isArray) {
        for(; i66 < obj1.length; i66++){
            if (obj1.hasOwnProperty(i66)) {
                if (!obj2.hasOwnProperty(i66) || !innerDeepEqual(obj1[i66], obj2[i66], strict, memos)) {
                    return false;
                }
            } else if (obj2.hasOwnProperty(i66)) {
                return false;
            } else {
                const keys1 = Object.keys(obj1);
                for(; i66 < keys1.length; i66++){
                    const key = keys1[i66];
                    if (!obj2.hasOwnProperty(key) || !innerDeepEqual(obj1[key], obj2[key], strict, memos)) {
                        return false;
                    }
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                return true;
            }
        }
    }
    for(i66 = 0; i66 < keys.length; i66++){
        const key = keys[i66];
        if (!innerDeepEqual(obj1[key], obj2[key], strict, memos)) {
            return false;
        }
    }
    return true;
}
function findLooseMatchingPrimitives(primitive) {
    switch(typeof primitive){
        case "undefined":
            return null;
        case "object":
            return undefined;
        case "symbol":
            return false;
        case "string":
            primitive = +primitive;
        case "number":
            if (Number.isNaN(primitive)) {
                return false;
            }
    }
    return true;
}
function setMightHaveLoosePrim(set1, set2, primitive) {
    const altValue = findLooseMatchingPrimitives(primitive);
    if (altValue != null) return altValue;
    return set2.has(altValue) && !set1.has(altValue);
}
function setHasEqualElement(set, val1, strict, memos) {
    for (const val2 of set){
        if (innerDeepEqual(val1, val2, strict, memos)) {
            set.delete(val2);
            return true;
        }
    }
    return false;
}
function setEquiv(set1, set2, strict, memos) {
    let set = null;
    for (const item of set1){
        if (typeof item === "object" && item !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        } else if (!set2.has(item)) {
            if (strict) return false;
            if (!setMightHaveLoosePrim(set1, set2, item)) {
                return false;
            }
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        }
    }
    if (set !== null) {
        for (const item of set2){
            if (typeof item === "object" && item !== null) {
                if (!setHasEqualElement(set, item, strict, memos)) return false;
            } else if (!strict && !set1.has(item) && !setHasEqualElement(set, item, strict, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapMightHaveLoosePrimitive(map1, map2, primitive, item, memos) {
    const altValue = findLooseMatchingPrimitives(primitive);
    if (altValue != null) {
        return altValue;
    }
    const curB = map2.get(altValue);
    if (curB === undefined && !map2.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
        return false;
    }
    return !map1.has(altValue) && innerDeepEqual(item, curB, false, memos);
}
function mapEquiv(map1, map2, strict, memos) {
    let set = null;
    for (const { 0: key , 1: item1  } of map1){
        if (typeof key === "object" && key !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(key);
        } else {
            const item2 = map2.get(key);
            if (item2 === undefined && !map2.has(key) || !innerDeepEqual(item1, item2, strict, memos)) {
                if (strict) return false;
                if (!mapMightHaveLoosePrimitive(map1, map2, key, item1, memos)) {
                    return false;
                }
                if (set === null) {
                    set = new Set();
                }
                set.add(key);
            }
        }
    }
    if (set !== null) {
        for (const { 0: key , 1: item  } of map2){
            if (typeof key === "object" && key !== null) {
                if (!mapHasEqualEntry(set, map1, key, item, strict, memos)) {
                    return false;
                }
            } else if (!strict && (!map1.has(key) || !innerDeepEqual(map1.get(key), item, false, memos)) && !mapHasEqualEntry(set, map1, key, item, false, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memos) {
    for (const key2 of set){
        if (innerDeepEqual(key1, key2, strict, memos) && innerDeepEqual(item1, map.get(key2), strict, memos)) {
            set.delete(key2);
            return true;
        }
    }
    return false;
}
const NumberIsSafeInteger = Number.isSafeInteger;
function getSystemErrorName(code) {
    if (typeof code !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE("err", "number", code);
    }
    if (code >= 0 || !NumberIsSafeInteger(code)) {
        throw new codes.ERR_OUT_OF_RANGE("err", "a negative integer", code);
    }
    return errorMap.get(code)?.[0];
}
const { errno: { ENOTDIR , ENOENT  } ,  } = os;
const kIsNodeError = Symbol("kIsNodeError");
const classRegExp1 = /^([A-Z][a-z0-9]*)+$/;
const kTypes = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol", 
];
class AbortError extends Error {
    code;
    constructor(){
        super("The operation was aborted");
        this.code = "ABORT_ERR";
        this.name = "AbortError";
    }
}
function addNumericalSeparator(val) {
    let res = "";
    let i67 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i67 >= start + 4; i67 -= 3){
        res = `_${val.slice(i67 - 3, i67)}${res}`;
    }
    return `${val.slice(0, i67)}${res}`;
}
const captureLargerStackTrace = hideStackFrames(function captureLargerStackTrace(err) {
    Error.captureStackTrace(err);
    return err;
});
hideStackFrames(function uvExceptionWithHostPort(err, syscall, address, port) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet(err) || uvUnmappedError;
    const message = `${syscall} ${code}: ${uvmsg}`;
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    const ex = new Error(`${message}${details}`);
    ex.code = code;
    ex.errno = err;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
hideStackFrames(function errnoException(err, syscall, original) {
    const code = getSystemErrorName(err);
    const message = original ? `${syscall} ${code} ${original}` : `${syscall} ${code}`;
    const ex = new Error(message);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    return captureLargerStackTrace(ex);
});
function uvErrmapGet(name19) {
    return errorMap.get(name19);
}
const uvUnmappedError = [
    "UNKNOWN",
    "unknown error"
];
const uvException = hideStackFrames(function uvException(ctx) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet(ctx.errno) || uvUnmappedError;
    let message = `${code}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
    let path27;
    let dest;
    if (ctx.path) {
        path27 = ctx.path.toString();
        message += ` '${path27}'`;
    }
    if (ctx.dest) {
        dest = ctx.dest.toString();
        message += ` -> '${dest}'`;
    }
    const err = new Error(message);
    for (const prop of Object.keys(ctx)){
        if (prop === "message" || prop === "path" || prop === "dest") {
            continue;
        }
        err[prop] = ctx[prop];
    }
    err.code = code;
    if (path27) {
        err.path = path27;
    }
    if (dest) {
        err.dest = dest;
    }
    return captureLargerStackTrace(err);
});
hideStackFrames(function exceptionWithHostPort(err, syscall, address, port, additional) {
    const code = getSystemErrorName(err);
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    if (additional) {
        details += ` - Local (${additional})`;
    }
    const ex = new Error(`${syscall} ${code}${details}`);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
hideStackFrames(function(code, syscall, hostname3) {
    let errno;
    if (typeof code === "number") {
        errno = code;
        if (code === codeMap.get("EAI_NODATA") || code === codeMap.get("EAI_NONAME")) {
            code = "ENOTFOUND";
        } else {
            code = getSystemErrorName(code);
        }
    }
    const message = `${syscall} ${code}${hostname3 ? ` ${hostname3}` : ""}`;
    const ex = new Error(message);
    ex.errno = errno;
    ex.code = code;
    ex.syscall = syscall;
    if (hostname3) {
        ex.hostname = hostname3;
    }
    return captureLargerStackTrace(ex);
});
class NodeErrorAbstraction extends Error {
    code;
    constructor(name20, code, message){
        super(message);
        this.code = code;
        this.name = name20;
        this.stack = this.stack && `${name20} [${this.code}]${this.stack.slice(20)}`;
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
class NodeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(Error.prototype.name, code, message);
    }
}
class NodeRangeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(RangeError.prototype.name, code, message);
        Object.setPrototypeOf(this, RangeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeTypeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(TypeError.prototype.name, code, message);
        Object.setPrototypeOf(this, TypeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeURIError extends NodeErrorAbstraction {
    constructor(code, message){
        super(URIError.prototype.name, code, message);
        Object.setPrototypeOf(this, URIError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeSystemError extends NodeErrorAbstraction {
    constructor(key, context, msgPrefix){
        let message = `${msgPrefix}: ${context.syscall} returned ` + `${context.code} (${context.message})`;
        if (context.path !== undefined) {
            message += ` ${context.path}`;
        }
        if (context.dest !== undefined) {
            message += ` => ${context.dest}`;
        }
        super("SystemError", key, message);
        captureLargerStackTrace(this);
        Object.defineProperties(this, {
            [kIsNodeError]: {
                value: true,
                enumerable: false,
                writable: false,
                configurable: true
            },
            info: {
                value: context,
                enumerable: true,
                configurable: true,
                writable: false
            },
            errno: {
                get () {
                    return context.errno;
                },
                set: (value)=>{
                    context.errno = value;
                },
                enumerable: true,
                configurable: true
            },
            syscall: {
                get () {
                    return context.syscall;
                },
                set: (value)=>{
                    context.syscall = value;
                },
                enumerable: true,
                configurable: true
            }
        });
        if (context.path !== undefined) {
            Object.defineProperty(this, "path", {
                get () {
                    return context.path;
                },
                set: (value)=>{
                    context.path = value;
                },
                enumerable: true,
                configurable: true
            });
        }
        if (context.dest !== undefined) {
            Object.defineProperty(this, "dest", {
                get () {
                    return context.dest;
                },
                set: (value)=>{
                    context.dest = value;
                },
                enumerable: true,
                configurable: true
            });
        }
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
function makeSystemErrorWithCode(key, msgPrfix) {
    return class NodeError extends NodeSystemError {
        constructor(ctx){
            super(key, ctx, msgPrfix);
        }
    };
}
const ERR_FS_EISDIR = makeSystemErrorWithCode("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType(name21, expected) {
    expected = Array.isArray(expected) ? expected : [
        expected
    ];
    let msg = "The ";
    if (name21.endsWith(" argument")) {
        msg += `${name21} `;
    } else {
        const type7 = name21.includes(".") ? "property" : "argument";
        msg += `"${name21}" ${type7} `;
    }
    msg += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected){
        if (kTypes.includes(value)) {
            types.push(value.toLocaleLowerCase());
        } else if (classRegExp1.test(value)) {
            instances.push(value);
        } else {
            other.push(value);
        }
    }
    if (instances.length > 0) {
        const pos = types.indexOf("object");
        if (pos !== -1) {
            types.splice(pos, 1);
            instances.push("Object");
        }
    }
    if (types.length > 0) {
        if (types.length > 2) {
            const last = types.pop();
            msg += `one of type ${types.join(", ")}, or ${last}`;
        } else if (types.length === 2) {
            msg += `one of type ${types[0]} or ${types[1]}`;
        } else {
            msg += `of type ${types[0]}`;
        }
        if (instances.length > 0 || other.length > 0) {
            msg += " or ";
        }
    }
    if (instances.length > 0) {
        if (instances.length > 2) {
            const last = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last}`;
        } else {
            msg += `an instance of ${instances[0]}`;
            if (instances.length === 2) {
                msg += ` or ${instances[1]}`;
            }
        }
        if (other.length > 0) {
            msg += " or ";
        }
    }
    if (other.length > 0) {
        if (other.length > 2) {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
        } else if (other.length === 2) {
            msg += `one of ${other[0]} or ${other[1]}`;
        } else {
            if (other[0].toLowerCase() !== other[0]) {
                msg += "an ";
            }
            msg += `${other[0]}`;
        }
    }
    return msg;
}
class ERR_INVALID_ARG_TYPE_RANGE extends NodeRangeError {
    constructor(name22, expected, actual){
        const msg = createInvalidArgType(name22, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
}
class ERR_INVALID_ARG_TYPE extends NodeTypeError {
    constructor(name23, expected, actual){
        const msg = createInvalidArgType(name23, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
    static RangeError = ERR_INVALID_ARG_TYPE_RANGE;
}
class ERR_INVALID_ARG_VALUE_RANGE extends NodeRangeError {
    constructor(name24, value, reason = "is invalid"){
        const type8 = name24.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type8} '${name24}' ${reason}. Received ${inspected}`);
    }
}
class ERR_INVALID_ARG_VALUE extends NodeTypeError {
    constructor(name25, value, reason = "is invalid"){
        const type9 = name25.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type9} '${name25}' ${reason}. Received ${inspected}`);
    }
    static RangeError = ERR_INVALID_ARG_VALUE_RANGE;
}
function invalidArgTypeHelper(input) {
    if (input == null) {
        return ` Received ${input}`;
    }
    if (typeof input === "function" && input.name) {
        return ` Received function ${input.name}`;
    }
    if (typeof input === "object") {
        if (input.constructor && input.constructor.name) {
            return ` Received an instance of ${input.constructor.name}`;
        }
        return ` Received ${inspect(input, {
            depth: -1
        })}`;
    }
    let inspected = inspect(input, {
        colors: false
    });
    if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
    }
    return ` Received type ${typeof input} (${inspected})`;
}
class ERR_OUT_OF_RANGE extends RangeError {
    code = "ERR_OUT_OF_RANGE";
    constructor(str, range, input, replaceDefaultBoolean = false){
        assert(range, 'Missing "range" argument');
        let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
            received = String(input);
            if (input > 2n ** 32n || input < -(2n ** 32n)) {
                received = addNumericalSeparator(received);
            }
            received += "n";
        } else {
            received = inspect(input);
        }
        msg += ` It must be ${range}. Received ${received}`;
        super(msg);
        const { name: name26  } = this;
        this.name = `${name26} [${this.code}]`;
        this.stack;
        this.name = name26;
    }
}
class ERR_BUFFER_OUT_OF_BOUNDS extends NodeRangeError {
    constructor(name27){
        super("ERR_BUFFER_OUT_OF_BOUNDS", name27 ? `"${name27}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
    }
}
class ERR_FS_INVALID_SYMLINK_TYPE extends NodeError {
    constructor(x){
        super("ERR_FS_INVALID_SYMLINK_TYPE", `Symlink type must be one of "dir", "file", or "junction". Received "${x}"`);
    }
}
class ERR_INVALID_CALLBACK extends NodeTypeError {
    constructor(object){
        super("ERR_INVALID_CALLBACK", `Callback must be a function. Received ${inspect(object)}`);
    }
}
class ERR_INVALID_CURSOR_POS extends NodeTypeError {
    constructor(){
        super("ERR_INVALID_CURSOR_POS", `Cannot set cursor row without setting its column`);
    }
}
class ERR_INVALID_FILE_URL_HOST extends NodeTypeError {
    constructor(x){
        super("ERR_INVALID_FILE_URL_HOST", `File URL host must be "localhost" or empty on ${x}`);
    }
}
class ERR_INVALID_FILE_URL_PATH extends NodeTypeError {
    constructor(x){
        super("ERR_INVALID_FILE_URL_PATH", `File URL path ${x}`);
    }
}
class ERR_INVALID_OPT_VALUE_ENCODING extends NodeTypeError {
    constructor(x){
        super("ERR_INVALID_OPT_VALUE_ENCODING", `The value "${x}" is invalid for option "encoding"`);
    }
}
class ERR_INVALID_URI extends NodeURIError {
    constructor(){
        super("ERR_INVALID_URI", `URI malformed`);
    }
}
class ERR_IPC_CHANNEL_CLOSED extends NodeError {
    constructor(){
        super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
    }
}
class ERR_METHOD_NOT_IMPLEMENTED extends NodeError {
    constructor(x){
        super("ERR_METHOD_NOT_IMPLEMENTED", `The ${x} method is not implemented`);
    }
}
class ERR_MISSING_ARGS extends NodeTypeError {
    constructor(...args){
        let msg = "The ";
        const len = args.length;
        const wrap1 = (a)=>`"${a}"`
        ;
        args = args.map((a)=>Array.isArray(a) ? a.map(wrap1).join(" or ") : wrap1(a)
        );
        switch(len){
            case 1:
                msg += `${args[0]} argument`;
                break;
            case 2:
                msg += `${args[0]} and ${args[1]} arguments`;
                break;
            default:
                msg += args.slice(0, len - 1).join(", ");
                msg += `, and ${args[len - 1]} arguments`;
                break;
        }
        super("ERR_MISSING_ARGS", `${msg} must be specified`);
    }
}
class ERR_MULTIPLE_CALLBACK extends NodeError {
    constructor(){
        super("ERR_MULTIPLE_CALLBACK", `Callback called multiple times`);
    }
}
class ERR_SOCKET_BAD_PORT extends NodeRangeError {
    constructor(name28, port, allowZero = true){
        assert(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
        const operator = allowZero ? ">=" : ">";
        super("ERR_SOCKET_BAD_PORT", `${name28} should be ${operator} 0 and < 65536. Received ${port}.`);
    }
}
class ERR_STREAM_ALREADY_FINISHED extends NodeError {
    constructor(x){
        super("ERR_STREAM_ALREADY_FINISHED", `Cannot call ${x} after a stream was finished`);
    }
}
class ERR_STREAM_CANNOT_PIPE extends NodeError {
    constructor(){
        super("ERR_STREAM_CANNOT_PIPE", `Cannot pipe, not readable`);
    }
}
class ERR_STREAM_DESTROYED extends NodeError {
    constructor(x){
        super("ERR_STREAM_DESTROYED", `Cannot call ${x} after a stream was destroyed`);
    }
}
class ERR_STREAM_NULL_VALUES extends NodeTypeError {
    constructor(){
        super("ERR_STREAM_NULL_VALUES", `May not write null values to stream`);
    }
}
class ERR_STREAM_PREMATURE_CLOSE extends NodeError {
    constructor(){
        super("ERR_STREAM_PREMATURE_CLOSE", `Premature close`);
    }
}
class ERR_STREAM_PUSH_AFTER_EOF extends NodeError {
    constructor(){
        super("ERR_STREAM_PUSH_AFTER_EOF", `stream.push() after EOF`);
    }
}
class ERR_STREAM_UNSHIFT_AFTER_END_EVENT extends NodeError {
    constructor(){
        super("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", `stream.unshift() after end event`);
    }
}
class ERR_STREAM_WRITE_AFTER_END extends NodeError {
    constructor(){
        super("ERR_STREAM_WRITE_AFTER_END", `write after end`);
    }
}
class ERR_UNHANDLED_ERROR extends NodeError {
    constructor(x){
        super("ERR_UNHANDLED_ERROR", `Unhandled error. (${x})`);
    }
}
class ERR_UNKNOWN_ENCODING extends NodeTypeError {
    constructor(x){
        super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x}`);
    }
}
class ERR_UNKNOWN_SIGNAL extends NodeTypeError {
    constructor(x){
        super("ERR_UNKNOWN_SIGNAL", `Unknown signal: ${x}`);
    }
}
function buildReturnPropertyType(value) {
    if (value && value.constructor && value.constructor.name) {
        return `instance of ${value.constructor.name}`;
    } else {
        return `type ${typeof value}`;
    }
}
class ERR_INVALID_RETURN_VALUE extends NodeTypeError {
    constructor(input, name29, value){
        super("ERR_INVALID_RETURN_VALUE", `Expected ${input} to be returned from the "${name29}" function but got ${buildReturnPropertyType(value)}.`);
    }
}
class ERR_INVALID_URL_SCHEME extends NodeTypeError {
    constructor(expected){
        expected = Array.isArray(expected) ? expected : [
            expected
        ];
        const res = expected.length === 2 ? `one of scheme ${expected[0]} or ${expected[1]}` : `of scheme ${expected[0]}`;
        super("ERR_INVALID_URL_SCHEME", `The URL must be ${res}`);
    }
}
class ERR_INTERNAL_ASSERTION extends NodeError {
    constructor(message){
        const suffix = "This is caused by either a bug in Node.js " + "or incorrect usage of Node.js internals.\n" + "Please open an issue with this stack trace at " + "https://github.com/nodejs/node/issues\n";
        super("ERR_INTERNAL_ASSERTION", message === undefined ? suffix : `${message}\n${suffix}`);
    }
}
class ERR_FS_RMDIR_ENOTDIR extends NodeSystemError {
    constructor(path28){
        const code = isWindows ? "ENOENT" : "ENOTDIR";
        const ctx = {
            message: "not a directory",
            path: path28,
            syscall: "rmdir",
            code,
            errno: isWindows ? ENOENT : ENOTDIR
        };
        super(code, ctx, "Path is not a directory");
    }
}
function denoErrorToNodeError(e, ctx) {
    const errno = extractOsErrorNumberFromErrorMessage(e);
    if (typeof errno === "undefined") {
        return e;
    }
    const ex = uvException({
        errno: mapSysErrnoToUvErrno(errno),
        ...ctx
    });
    return ex;
}
function extractOsErrorNumberFromErrorMessage(e) {
    const match = e instanceof Error ? e.message.match(/\(os error (\d+)\)/) : false;
    if (match) {
        return +match[1];
    }
    return undefined;
}
function aggregateTwoErrors(innerError, outerError) {
    if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
            outerError.errors.push(innerError);
            return outerError;
        }
        const err = new AggregateError([
            outerError,
            innerError, 
        ], outerError.message);
        err.code = outerError.code;
        return err;
    }
    return innerError || outerError;
}
codes.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED;
codes.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
codes.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE;
codes.ERR_INVALID_CALLBACK = ERR_INVALID_CALLBACK;
codes.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE;
codes.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT;
codes.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS;
codes.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING;
hideStackFrames(function genericNodeError(message, errorProperties) {
    const err = new Error(message);
    Object.assign(err, errorProperties);
    return err;
});
const CHAR_FORWARD_SLASH1 = 47;
function assertPath1(path29) {
    if (typeof path29 !== "string") {
        throw new ERR_INVALID_ARG_TYPE("path", [
            "string"
        ], path29);
    }
}
function isPosixPathSeparator1(code) {
    return code === 47;
}
function isPathSeparator1(code) {
    return isPosixPathSeparator1(code) || code === 92;
}
function isWindowsDeviceRoot1(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString1(path30, allowAboveRoot, separator, isPathSeparator11) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i68 = 0, len = path30.length; i68 <= len; ++i68){
        if (i68 < len) code = path30.charCodeAt(i68);
        else if (isPathSeparator11(code)) break;
        else code = CHAR_FORWARD_SLASH1;
        if (isPathSeparator11(code)) {
            if (lastSlash === i68 - 1 || dots === 1) {} else if (lastSlash !== i68 - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i68;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i68;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path30.slice(lastSlash + 1, i68);
                else res = path30.slice(lastSlash + 1, i68);
                lastSegmentLength = i68 - lastSlash - 1;
            }
            lastSlash = i68;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format1(sep7, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base8 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base8;
    if (dir === pathObject.root) return dir + base8;
    return dir + sep7 + base8;
}
const WHITESPACE_ENCODINGS1 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace1(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS1[c] ?? c;
    });
}
const sep3 = "\\";
const delimiter3 = ";";
function resolve3(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i69 = pathSegments.length - 1; i69 >= -1; i69--){
        let path31;
        const { Deno  } = globalThis;
        if (i69 >= 0) {
            path31 = pathSegments[i69];
        } else if (!resolvedDevice) {
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path31 = Deno.cwd();
        } else {
            if (typeof Deno?.env?.get !== "function" || typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path31 = Deno.cwd();
            if (path31 === undefined || path31.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path31 = `${resolvedDevice}\\`;
            }
        }
        assertPath1(path31);
        const len = path31.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute11 = false;
        const code = path31.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator1(code)) {
                isAbsolute11 = true;
                if (isPathSeparator1(path31.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator1(path31.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path31.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator1(path31.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator1(path31.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path31.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path31.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot1(code)) {
                if (path31.charCodeAt(1) === 58) {
                    device = path31.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator1(path31.charCodeAt(2))) {
                            isAbsolute11 = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator1(code)) {
            rootEnd = 1;
            isAbsolute11 = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path31.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute11;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString1(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator1);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize4(path32) {
    assertPath1(path32);
    const len = path32.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute21 = false;
    const code = path32.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            isAbsolute21 = true;
            if (isPathSeparator1(path32.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path32.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path32.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path32.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path32.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path32.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path32.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path32.charCodeAt(1) === 58) {
                device = path32.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path32.charCodeAt(2))) {
                        isAbsolute21 = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString1(path32.slice(rootEnd), !isAbsolute21, "\\", isPathSeparator1);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute21) tail = ".";
    if (tail.length > 0 && isPathSeparator1(path32.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute21) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute21) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute3(path33) {
    assertPath1(path33);
    const len = path33.length;
    if (len === 0) return false;
    const code = path33.charCodeAt(0);
    if (isPathSeparator1(code)) {
        return true;
    } else if (isWindowsDeviceRoot1(code)) {
        if (len > 2 && path33.charCodeAt(1) === 58) {
            if (isPathSeparator1(path33.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join5(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i70 = 0; i70 < pathsCount; ++i70){
        const path34 = paths[i70];
        assertPath1(path34);
        if (path34.length > 0) {
            if (joined === undefined) joined = firstPart = path34;
            else joined += `\\${path34}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert(firstPart != null);
    if (isPathSeparator1(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator1(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator1(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator1(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize4(joined);
}
function relative3(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    const fromOrig = resolve3(from);
    const toOrig = resolve3(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i71 = 0;
    for(; i71 <= length; ++i71){
        if (i71 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i71) === 92) {
                    return toOrig.slice(toStart + i71 + 1);
                } else if (i71 === 2) {
                    return toOrig.slice(toStart + i71);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i71) === 92) {
                    lastCommonSep = i71;
                } else if (i71 === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i71);
        const toCode = to.charCodeAt(toStart + i71);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i71;
    }
    if (i71 !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i71 = fromStart + lastCommonSep + 1; i71 <= fromEnd; ++i71){
        if (i71 === fromEnd || from.charCodeAt(i71) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath3(path35) {
    if (typeof path35 !== "string") return path35;
    if (path35.length === 0) return "";
    const resolvedPath = resolve3(path35);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot1(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path35;
}
function dirname3(path36) {
    assertPath1(path36);
    const len = path36.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path36.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator1(path36.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path36.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path36.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path36.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path36;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path36.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator1(path36.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        return path36;
    }
    for(let i72 = len - 1; i72 >= offset; --i72){
        if (isPathSeparator1(path36.charCodeAt(i72))) {
            if (!matchedSlash) {
                end = i72;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path36.slice(0, end);
}
function basename3(path37, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE("ext", [
            "string"
        ], ext);
    }
    assertPath1(path37);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i73;
    if (path37.length >= 2) {
        const drive = path37.charCodeAt(0);
        if (isWindowsDeviceRoot1(drive)) {
            if (path37.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path37.length) {
        if (ext.length === path37.length && ext === path37) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i73 = path37.length - 1; i73 >= start; --i73){
            const code = path37.charCodeAt(i73);
            if (isPathSeparator1(code)) {
                if (!matchedSlash) {
                    start = i73 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i73 + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i73;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path37.length;
        return path37.slice(start, end);
    } else {
        for(i73 = path37.length - 1; i73 >= start; --i73){
            if (isPathSeparator1(path37.charCodeAt(i73))) {
                if (!matchedSlash) {
                    start = i73 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i73 + 1;
            }
        }
        if (end === -1) return "";
        return path37.slice(start, end);
    }
}
function extname3(path38) {
    assertPath1(path38);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path38.length >= 2 && path38.charCodeAt(1) === 58 && isWindowsDeviceRoot1(path38.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i74 = path38.length - 1; i74 >= start; --i74){
        const code = path38.charCodeAt(i74);
        if (isPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i74 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i74 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i74;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path38.slice(startDot, end);
}
function format3(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE("pathObject", [
            "Object"
        ], pathObject);
    }
    return _format1("\\", pathObject);
}
function parse3(path39) {
    assertPath1(path39);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path39.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path39.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            rootEnd = 1;
            if (isPathSeparator1(path39.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path39.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path39.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path39.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path39.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path39.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path39;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path39;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        ret.root = ret.dir = path39;
        return ret;
    }
    if (rootEnd > 0) ret.root = path39.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i75 = path39.length - 1;
    let preDotState = 0;
    for(; i75 >= rootEnd; --i75){
        code = path39.charCodeAt(i75);
        if (isPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i75 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i75 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i75;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path39.slice(startPart, end);
        }
    } else {
        ret.name = path39.slice(startPart, startDot);
        ret.base = path39.slice(startPart, end);
        ret.ext = path39.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path39.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl3(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path40 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path40 = `\\\\${url.hostname}${path40}`;
    }
    return path40;
}
function toFileUrl3(path41) {
    if (!isAbsolute3(path41)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname4, pathname] = path41.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(pathname.replace(/%/g, "%25"));
    if (hostname4 != null && hostname4 != "localhost") {
        url.hostname = hostname4;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const __default3 = {
    basename: basename3,
    delimiter: delimiter3,
    dirname: dirname3,
    extname: extname3,
    format: format3,
    fromFileUrl: fromFileUrl3,
    isAbsolute: isAbsolute3,
    join: join5,
    normalize: normalize4,
    parse: parse3,
    relative: relative3,
    resolve: resolve3,
    sep: sep3,
    toFileUrl: toFileUrl3,
    toNamespacedPath: toNamespacedPath3
};
const mod8 = {
    sep: sep3,
    delimiter: delimiter3,
    resolve: resolve3,
    normalize: normalize4,
    isAbsolute: isAbsolute3,
    join: join5,
    relative: relative3,
    toNamespacedPath: toNamespacedPath3,
    dirname: dirname3,
    basename: basename3,
    extname: extname3,
    format: format3,
    parse: parse3,
    fromFileUrl: fromFileUrl3,
    toFileUrl: toFileUrl3,
    default: __default3
};
const sep4 = "/";
const delimiter4 = ":";
function resolve4(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i76 = pathSegments.length - 1; i76 >= -1 && !resolvedAbsolute; i76--){
        let path42;
        if (i76 >= 0) path42 = pathSegments[i76];
        else {
            const { Deno  } = globalThis;
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path42 = Deno.cwd();
        }
        assertPath1(path42);
        if (path42.length === 0) {
            continue;
        }
        resolvedPath = `${path42}/${resolvedPath}`;
        resolvedAbsolute = path42.charCodeAt(0) === CHAR_FORWARD_SLASH1;
    }
    resolvedPath = normalizeString1(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator1);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize5(path43) {
    assertPath1(path43);
    if (path43.length === 0) return ".";
    const isAbsolute12 = path43.charCodeAt(0) === 47;
    const trailingSeparator = path43.charCodeAt(path43.length - 1) === 47;
    path43 = normalizeString1(path43, !isAbsolute12, "/", isPosixPathSeparator1);
    if (path43.length === 0 && !isAbsolute12) path43 = ".";
    if (path43.length > 0 && trailingSeparator) path43 += "/";
    if (isAbsolute12) return `/${path43}`;
    return path43;
}
function isAbsolute4(path44) {
    assertPath1(path44);
    return path44.length > 0 && path44.charCodeAt(0) === 47;
}
function join6(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i77 = 0, len = paths.length; i77 < len; ++i77){
        const path45 = paths[i77];
        assertPath1(path45);
        if (path45.length > 0) {
            if (!joined) joined = path45;
            else joined += `/${path45}`;
        }
    }
    if (!joined) return ".";
    return normalize5(joined);
}
function relative4(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    from = resolve4(from);
    to = resolve4(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i78 = 0;
    for(; i78 <= length; ++i78){
        if (i78 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i78) === 47) {
                    return to.slice(toStart + i78 + 1);
                } else if (i78 === 0) {
                    return to.slice(toStart + i78);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i78) === 47) {
                    lastCommonSep = i78;
                } else if (i78 === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i78);
        const toCode = to.charCodeAt(toStart + i78);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i78;
    }
    let out = "";
    for(i78 = fromStart + lastCommonSep + 1; i78 <= fromEnd; ++i78){
        if (i78 === fromEnd || from.charCodeAt(i78) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath4(path46) {
    return path46;
}
function dirname4(path47) {
    assertPath1(path47);
    if (path47.length === 0) return ".";
    const hasRoot = path47.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i79 = path47.length - 1; i79 >= 1; --i79){
        if (path47.charCodeAt(i79) === 47) {
            if (!matchedSlash) {
                end = i79;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path47.slice(0, end);
}
function basename4(path48, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE("ext", [
            "string"
        ], ext);
    }
    assertPath1(path48);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i80;
    if (ext !== undefined && ext.length > 0 && ext.length <= path48.length) {
        if (ext.length === path48.length && ext === path48) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i80 = path48.length - 1; i80 >= 0; --i80){
            const code = path48.charCodeAt(i80);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i80 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i80 + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i80;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path48.length;
        return path48.slice(start, end);
    } else {
        for(i80 = path48.length - 1; i80 >= 0; --i80){
            if (path48.charCodeAt(i80) === 47) {
                if (!matchedSlash) {
                    start = i80 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i80 + 1;
            }
        }
        if (end === -1) return "";
        return path48.slice(start, end);
    }
}
function extname4(path49) {
    assertPath1(path49);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i81 = path49.length - 1; i81 >= 0; --i81){
        const code = path49.charCodeAt(i81);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i81 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i81 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i81;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path49.slice(startDot, end);
}
function format4(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE("pathObject", [
            "Object"
        ], pathObject);
    }
    return _format1("/", pathObject);
}
function parse4(path50) {
    assertPath1(path50);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path50.length === 0) return ret;
    const isAbsolute22 = path50.charCodeAt(0) === 47;
    let start;
    if (isAbsolute22) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i82 = path50.length - 1;
    let preDotState = 0;
    for(; i82 >= start; --i82){
        const code = path50.charCodeAt(i82);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i82 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i82 + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i82;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute22) {
                ret.base = ret.name = path50.slice(1, end);
            } else {
                ret.base = ret.name = path50.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute22) {
            ret.name = path50.slice(1, startDot);
            ret.base = path50.slice(1, end);
        } else {
            ret.name = path50.slice(startPart, startDot);
            ret.base = path50.slice(startPart, end);
        }
        ret.ext = path50.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path50.slice(0, startPart - 1);
    else if (isAbsolute22) ret.dir = "/";
    return ret;
}
function fromFileUrl4(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl4(path51) {
    if (!isAbsolute4(path51)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(path51.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const __default4 = {
    basename: basename4,
    delimiter: delimiter4,
    dirname: dirname4,
    extname: extname4,
    format: format4,
    fromFileUrl: fromFileUrl4,
    isAbsolute: isAbsolute4,
    join: join6,
    normalize: normalize5,
    parse: parse4,
    relative: relative4,
    resolve: resolve4,
    sep: sep4,
    toFileUrl: toFileUrl4,
    toNamespacedPath: toNamespacedPath4
};
const mod9 = {
    sep: sep4,
    delimiter: delimiter4,
    resolve: resolve4,
    normalize: normalize5,
    isAbsolute: isAbsolute4,
    join: join6,
    relative: relative4,
    toNamespacedPath: toNamespacedPath4,
    dirname: dirname4,
    basename: basename4,
    extname: extname4,
    format: format4,
    parse: parse4,
    fromFileUrl: fromFileUrl4,
    toFileUrl: toFileUrl4,
    default: __default4
};
const SEP = isWindows ? "\\" : "/";
const SEP_PATTERN = isWindows ? /[\\/]+/ : /\/+/;
function common(paths, sep8 = SEP) {
    const [first = "", ...remaining] = paths;
    if (first === "" || remaining.length === 0) {
        return first.substring(0, first.lastIndexOf(sep8) + 1);
    }
    const parts = first.split(sep8);
    let endOfPrefix = parts.length;
    for (const path52 of remaining){
        const compare = path52.split(sep8);
        for(let i83 = 0; i83 < endOfPrefix; i83++){
            if (compare[i83] !== parts[i83]) {
                endOfPrefix = i83;
            }
        }
        if (endOfPrefix === 0) {
            return "";
        }
    }
    const prefix = parts.slice(0, endOfPrefix).join(sep8);
    return prefix.endsWith(sep8) ? prefix : `${prefix}${sep8}`;
}
const path2 = isWindows ? mod8 : mod9;
const { join: join7 , normalize: normalize6  } = path2;
const regExpEscapeChars = [
    "!",
    "$",
    "(",
    ")",
    "*",
    "+",
    ".",
    "=",
    "?",
    "[",
    "\\",
    "^",
    "{",
    "|", 
];
const rangeEscapeChars = [
    "-",
    "\\",
    "]"
];
function globToRegExp(glob, { extended =true , globstar: globstarOption = true , os: os1 = osType , caseInsensitive =false  } = {}) {
    if (glob == "") {
        return /(?!)/;
    }
    const sep9 = os1 == "windows" ? "(?:\\\\|/)+" : "/+";
    const sepMaybe = os1 == "windows" ? "(?:\\\\|/)*" : "/*";
    const seps = os1 == "windows" ? [
        "\\",
        "/"
    ] : [
        "/"
    ];
    const globstar = os1 == "windows" ? "(?:[^\\\\/]*(?:\\\\|/|$)+)*" : "(?:[^/]*(?:/|$)+)*";
    const wildcard = os1 == "windows" ? "[^\\\\/]*" : "[^/]*";
    const escapePrefix = os1 == "windows" ? "`" : "\\";
    let newLength = glob.length;
    for(; newLength > 1 && seps.includes(glob[newLength - 1]); newLength--);
    glob = glob.slice(0, newLength);
    let regExpString = "";
    for(let j = 0; j < glob.length;){
        let segment = "";
        const groupStack = [];
        let inRange = false;
        let inEscape = false;
        let endsWithSep = false;
        let i84 = j;
        for(; i84 < glob.length && !seps.includes(glob[i84]); i84++){
            if (inEscape) {
                inEscape = false;
                const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;
                segment += escapeChars.includes(glob[i84]) ? `\\${glob[i84]}` : glob[i84];
                continue;
            }
            if (glob[i84] == escapePrefix) {
                inEscape = true;
                continue;
            }
            if (glob[i84] == "[") {
                if (!inRange) {
                    inRange = true;
                    segment += "[";
                    if (glob[i84 + 1] == "!") {
                        i84++;
                        segment += "^";
                    } else if (glob[i84 + 1] == "^") {
                        i84++;
                        segment += "\\^";
                    }
                    continue;
                } else if (glob[i84 + 1] == ":") {
                    let k = i84 + 1;
                    let value = "";
                    while(glob[k + 1] != null && glob[k + 1] != ":"){
                        value += glob[k + 1];
                        k++;
                    }
                    if (glob[k + 1] == ":" && glob[k + 2] == "]") {
                        i84 = k + 2;
                        if (value == "alnum") segment += "\\dA-Za-z";
                        else if (value == "alpha") segment += "A-Za-z";
                        else if (value == "ascii") segment += "\x00-\x7F";
                        else if (value == "blank") segment += "\t ";
                        else if (value == "cntrl") segment += "\x00-\x1F\x7F";
                        else if (value == "digit") segment += "\\d";
                        else if (value == "graph") segment += "\x21-\x7E";
                        else if (value == "lower") segment += "a-z";
                        else if (value == "print") segment += "\x20-\x7E";
                        else if (value == "punct") {
                            segment += "!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_{|}~";
                        } else if (value == "space") segment += "\\s\v";
                        else if (value == "upper") segment += "A-Z";
                        else if (value == "word") segment += "\\w";
                        else if (value == "xdigit") segment += "\\dA-Fa-f";
                        continue;
                    }
                }
            }
            if (glob[i84] == "]" && inRange) {
                inRange = false;
                segment += "]";
                continue;
            }
            if (inRange) {
                if (glob[i84] == "\\") {
                    segment += `\\\\`;
                } else {
                    segment += glob[i84];
                }
                continue;
            }
            if (glob[i84] == ")" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
                segment += ")";
                const type10 = groupStack.pop();
                if (type10 == "!") {
                    segment += wildcard;
                } else if (type10 != "@") {
                    segment += type10;
                }
                continue;
            }
            if (glob[i84] == "|" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
                segment += "|";
                continue;
            }
            if (glob[i84] == "+" && extended && glob[i84 + 1] == "(") {
                i84++;
                groupStack.push("+");
                segment += "(?:";
                continue;
            }
            if (glob[i84] == "@" && extended && glob[i84 + 1] == "(") {
                i84++;
                groupStack.push("@");
                segment += "(?:";
                continue;
            }
            if (glob[i84] == "?") {
                if (extended && glob[i84 + 1] == "(") {
                    i84++;
                    groupStack.push("?");
                    segment += "(?:";
                } else {
                    segment += ".";
                }
                continue;
            }
            if (glob[i84] == "!" && extended && glob[i84 + 1] == "(") {
                i84++;
                groupStack.push("!");
                segment += "(?!";
                continue;
            }
            if (glob[i84] == "{") {
                groupStack.push("BRACE");
                segment += "(?:";
                continue;
            }
            if (glob[i84] == "}" && groupStack[groupStack.length - 1] == "BRACE") {
                groupStack.pop();
                segment += ")";
                continue;
            }
            if (glob[i84] == "," && groupStack[groupStack.length - 1] == "BRACE") {
                segment += "|";
                continue;
            }
            if (glob[i84] == "*") {
                if (extended && glob[i84 + 1] == "(") {
                    i84++;
                    groupStack.push("*");
                    segment += "(?:";
                } else {
                    const prevChar = glob[i84 - 1];
                    let numStars = 1;
                    while(glob[i84 + 1] == "*"){
                        i84++;
                        numStars++;
                    }
                    const nextChar = glob[i84 + 1];
                    if (globstarOption && numStars == 2 && [
                        ...seps,
                        undefined
                    ].includes(prevChar) && [
                        ...seps,
                        undefined
                    ].includes(nextChar)) {
                        segment += globstar;
                        endsWithSep = true;
                    } else {
                        segment += wildcard;
                    }
                }
                continue;
            }
            segment += regExpEscapeChars.includes(glob[i84]) ? `\\${glob[i84]}` : glob[i84];
        }
        if (groupStack.length > 0 || inRange || inEscape) {
            segment = "";
            for (const c of glob.slice(j, i84)){
                segment += regExpEscapeChars.includes(c) ? `\\${c}` : c;
                endsWithSep = false;
            }
        }
        regExpString += segment;
        if (!endsWithSep) {
            regExpString += i84 < glob.length ? sep9 : sepMaybe;
            endsWithSep = true;
        }
        while(seps.includes(glob[i84]))i84++;
        if (!(i84 > j)) {
            throw new Error("Assertion failure: i > j (potential infinite loop)");
        }
        j = i84;
    }
    regExpString = `^${regExpString}$`;
    return new RegExp(regExpString, caseInsensitive ? "i" : "");
}
function isGlob(str) {
    const chars = {
        "{": "}",
        "(": ")",
        "[": "]"
    };
    const regex = /\\(.)|(^!|\*|\?|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
    if (str === "") {
        return false;
    }
    let match;
    while(match = regex.exec(str)){
        if (match[2]) return true;
        let idx = match.index + match[0].length;
        const open1 = match[1];
        const close1 = open1 ? chars[open1] : null;
        if (open1 && close1) {
            const n = str.indexOf(close1, idx);
            if (n !== -1) {
                idx = n + 1;
            }
        }
        str = str.slice(idx);
    }
    return false;
}
function normalizeGlob(glob, { globstar =false  } = {}) {
    if (glob.match(/\0/g)) {
        throw new Error(`Glob contains invalid characters: "${glob}"`);
    }
    if (!globstar) {
        return normalize6(glob);
    }
    const s = SEP_PATTERN.source;
    const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
    return normalize6(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
}
function joinGlobs(globs, { extended =true , globstar =false  } = {}) {
    if (!globstar || globs.length == 0) {
        return join7(...globs);
    }
    if (globs.length === 0) return ".";
    let joined;
    for (const glob of globs){
        const path110 = glob;
        if (path110.length > 0) {
            if (!joined) joined = path110;
            else joined += `${SEP}${path110}`;
        }
    }
    if (!joined) return ".";
    return normalizeGlob(joined, {
        extended,
        globstar
    });
}
const path3 = isWindows ? __default3 : __default4;
const { basename: basename5 , delimiter: delimiter5 , dirname: dirname5 , extname: extname5 , format: format5 , fromFileUrl: fromFileUrl5 , isAbsolute: isAbsolute5 , join: join8 , normalize: normalize7 , parse: parse5 , relative: relative5 , resolve: resolve5 , sep: sep5 , toFileUrl: toFileUrl5 , toNamespacedPath: toNamespacedPath5 ,  } = path3;
const mod10 = {
    SEP: SEP,
    SEP_PATTERN: SEP_PATTERN,
    win32: __default3,
    posix: __default4,
    basename: basename5,
    delimiter: delimiter5,
    dirname: dirname5,
    extname: extname5,
    format: format5,
    fromFileUrl: fromFileUrl5,
    isAbsolute: isAbsolute5,
    join: join8,
    normalize: normalize7,
    parse: parse5,
    relative: relative5,
    resolve: resolve5,
    sep: sep5,
    toFileUrl: toFileUrl5,
    toNamespacedPath: toNamespacedPath5,
    common,
    globToRegExp,
    isGlob,
    normalizeGlob,
    joinGlobs
};
const __default5 = {
    ...mod10
};
"use strict";
const base = 36;
const damp = 700;
const delimiter6 = "-";
const regexNonASCII = /[^\0-\x7E]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors = {
    "overflow": "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
};
const baseMinusTMin = 36 - 1;
function error(type11) {
    throw new RangeError(errors[type11]);
}
function mapDomain(str, fn) {
    const parts = str.split("@");
    let result = "";
    if (parts.length > 1) {
        result = parts[0] + "@";
        str = parts[1];
    }
    str = str.replace(regexSeparators, "\x2E");
    const labels = str.split(".");
    const encoded = labels.map(fn).join(".");
    return result + encoded;
}
function ucs2decode(str) {
    const output = [];
    let counter = 0;
    const length = str.length;
    while(counter < length){
        const value = str.charCodeAt(counter++);
        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
            const extra = str.charCodeAt(counter++);
            if ((extra & 0xFC00) == 0xDC00) {
                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            } else {
                output.push(value);
                counter--;
            }
        } else {
            output.push(value);
        }
    }
    return output;
}
function digitToBasic(digit, flag) {
    return digit + 22 + 75 * Number(digit < 26) - (Number(flag != 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
    let k = 0;
    delta = firstTime ? Math.floor(delta / damp) : delta >> 1;
    delta += Math.floor(delta / numPoints);
    for(; delta > baseMinusTMin * 26 >> 1; k += base){
        delta = Math.floor(delta / baseMinusTMin);
    }
    return Math.floor(k + (baseMinusTMin + 1) * delta / (delta + 38));
}
function encode2(str) {
    const output = [];
    const input = ucs2decode(str);
    const inputLength = input.length;
    let n = 128;
    let delta = 0;
    let bias = 72;
    for (const currentValue of input){
        if (currentValue < 0x80) {
            output.push(String.fromCharCode(currentValue));
        }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
        output.push(delimiter6);
    }
    while(handledCPCount < inputLength){
        let m = 2147483647;
        for (const currentValue of input){
            if (currentValue >= n && currentValue < m) {
                m = currentValue;
            }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > Math.floor((2147483647 - delta) / handledCPCountPlusOne)) {
            error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue1 of input){
            if (currentValue1 < n && ++delta > 2147483647) {
                error("overflow");
            }
            if (currentValue1 == n) {
                let q = delta;
                for(let k = 36;; k += base){
                    const t = k <= bias ? 1 : k >= bias + 26 ? 26 : k - bias;
                    if (q < t) {
                        break;
                    }
                    const qMinusT = q - t;
                    const baseMinusT = 36 - t;
                    output.push(String.fromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                    q = Math.floor(qMinusT / baseMinusT);
                }
                output.push(String.fromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
            }
        }
        ++delta;
        ++n;
    }
    return output.join("");
}
function toASCII(input) {
    return mapDomain(input, function(str) {
        return regexNonASCII.test(str) ? "xn--" + encode2(str) : str;
    });
}
const hexTable = new Array(256);
for(let i1 = 0; i1 < 256; ++i1){
    hexTable[i1] = "%" + ((i1 < 16 ? "0" : "") + i1.toString(16)).toUpperCase();
}
new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
function encodeStr(str, noEscapeTable, hexTable1) {
    const len = str.length;
    if (len === 0) return "";
    let out = "";
    let lastPos = 0;
    for(let i110 = 0; i110 < len; i110++){
        let c = str.charCodeAt(i110);
        if (c < 0x80) {
            if (noEscapeTable[c] === 1) continue;
            if (lastPos < i110) out += str.slice(lastPos, i110);
            lastPos = i110 + 1;
            out += hexTable1[c];
            continue;
        }
        if (lastPos < i110) out += str.slice(lastPos, i110);
        if (c < 0x800) {
            lastPos = i110 + 1;
            out += hexTable1[0xc0 | c >> 6] + hexTable1[0x80 | c & 0x3f];
            continue;
        }
        if (c < 0xd800 || c >= 0xe000) {
            lastPos = i110 + 1;
            out += hexTable1[0xe0 | c >> 12] + hexTable1[0x80 | c >> 6 & 0x3f] + hexTable1[0x80 | c & 0x3f];
            continue;
        }
        ++i110;
        if (i110 >= len) throw new ERR_INVALID_URI();
        const c2 = str.charCodeAt(i110) & 0x3ff;
        lastPos = i110 + 1;
        c = 0x10000 + ((c & 0x3ff) << 10 | c2);
        out += hexTable1[0xf0 | c >> 18] + hexTable1[0x80 | c >> 12 & 0x3f] + hexTable1[0x80 | c >> 6 & 0x3f] + hexTable1[0x80 | c & 0x3f];
    }
    if (lastPos === 0) return str;
    if (lastPos < len) return out + str.slice(lastPos);
    return out;
}
const decode2 = parse6;
const encode3 = stringify;
function qsEscape(str) {
    if (typeof str !== "string") {
        if (typeof str === "object") {
            str = String(str);
        } else {
            str += "";
        }
    }
    return encodeStr(str, noEscape, hexTable);
}
const escape = qsEscape;
const isHexTable = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
function charCodes(str) {
    const ret = new Array(str.length);
    for(let i85 = 0; i85 < str.length; ++i85){
        ret[i85] = str.charCodeAt(i85);
    }
    return ret;
}
function addKeyVal(obj, key, value, keyEncoded, valEncoded, decode11) {
    if (key.length > 0 && keyEncoded) {
        key = decode11(key);
    }
    if (value.length > 0 && valEncoded) {
        value = decode11(value);
    }
    if (obj[key] === undefined) {
        obj[key] = value;
    } else {
        const curValue = obj[key];
        if (curValue.pop) {
            curValue[curValue.length] = value;
        } else {
            obj[key] = [
                curValue,
                value
            ];
        }
    }
}
function parse6(str, sep10 = "&", eq = "=", { decodeURIComponent =unescape , maxKeys =1000  } = {}) {
    const obj = Object.create(null);
    if (typeof str !== "string" || str.length === 0) {
        return obj;
    }
    const sepCodes = !sep10 ? [
        38
    ] : charCodes(String(sep10));
    const eqCodes = !eq ? [
        61
    ] : charCodes(String(eq));
    const sepLen = sepCodes.length;
    const eqLen = eqCodes.length;
    let pairs = 1000;
    if (typeof maxKeys === "number") {
        pairs = maxKeys > 0 ? maxKeys : -1;
    }
    let decode21 = unescape;
    if (decodeURIComponent) {
        decode21 = decodeURIComponent;
    }
    const customDecode = decode21 !== unescape;
    let lastPos = 0;
    let sepIdx = 0;
    let eqIdx = 0;
    let key = "";
    let value = "";
    let keyEncoded = customDecode;
    let valEncoded = customDecode;
    const plusChar = customDecode ? "%20" : " ";
    let encodeCheck = 0;
    for(let i86 = 0; i86 < str.length; ++i86){
        const code = str.charCodeAt(i86);
        if (code === sepCodes[sepIdx]) {
            if (++sepIdx === sepLen) {
                const end = i86 - sepIdx + 1;
                if (eqIdx < eqLen) {
                    if (lastPos < end) {
                        key += str.slice(lastPos, end);
                    } else if (key.length === 0) {
                        if (--pairs === 0) {
                            return obj;
                        }
                        lastPos = i86 + 1;
                        sepIdx = eqIdx = 0;
                        continue;
                    }
                } else if (lastPos < end) {
                    value += str.slice(lastPos, end);
                }
                addKeyVal(obj, key, value, keyEncoded, valEncoded, decode21);
                if (--pairs === 0) {
                    return obj;
                }
                key = value = "";
                encodeCheck = 0;
                lastPos = i86 + 1;
                sepIdx = eqIdx = 0;
            }
        } else {
            sepIdx = 0;
            if (eqIdx < eqLen) {
                if (code === eqCodes[eqIdx]) {
                    if (++eqIdx === eqLen) {
                        const end = i86 - eqIdx + 1;
                        if (lastPos < end) {
                            key += str.slice(lastPos, end);
                        }
                        encodeCheck = 0;
                        lastPos = i86 + 1;
                    }
                    continue;
                } else {
                    eqIdx = 0;
                    if (!keyEncoded) {
                        if (code === 37) {
                            encodeCheck = 1;
                            continue;
                        } else if (encodeCheck > 0) {
                            if (isHexTable[code] === 1) {
                                if (++encodeCheck === 3) {
                                    keyEncoded = true;
                                }
                                continue;
                            } else {
                                encodeCheck = 0;
                            }
                        }
                    }
                }
                if (code === 43) {
                    if (lastPos < i86) {
                        key += str.slice(lastPos, i86);
                    }
                    key += plusChar;
                    lastPos = i86 + 1;
                    continue;
                }
            }
            if (code === 43) {
                if (lastPos < i86) {
                    value += str.slice(lastPos, i86);
                }
                value += plusChar;
                lastPos = i86 + 1;
            } else if (!valEncoded) {
                if (code === 37) {
                    encodeCheck = 1;
                } else if (encodeCheck > 0) {
                    if (isHexTable[code] === 1) {
                        if (++encodeCheck === 3) {
                            valEncoded = true;
                        }
                    } else {
                        encodeCheck = 0;
                    }
                }
            }
        }
    }
    if (lastPos < str.length) {
        if (eqIdx < eqLen) {
            key += str.slice(lastPos);
        } else if (sepIdx < sepLen) {
            value += str.slice(lastPos);
        }
    } else if (eqIdx === 0 && key.length === 0) {
        return obj;
    }
    addKeyVal(obj, key, value, keyEncoded, valEncoded, decode21);
    return obj;
}
const noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
]);
function stringifyPrimitive(v) {
    if (typeof v === "string") {
        return v;
    }
    if (typeof v === "number" && isFinite(v)) {
        return "" + v;
    }
    if (typeof v === "bigint") {
        return "" + v;
    }
    if (typeof v === "boolean") {
        return v ? "true" : "false";
    }
    return "";
}
function encodeStringifiedCustom(v, encode11) {
    return encode11(stringifyPrimitive(v));
}
function encodeStringified(v, encode21) {
    if (typeof v === "string") {
        return v.length ? encode21(v) : "";
    }
    if (typeof v === "number" && isFinite(v)) {
        return Math.abs(v) < 1e21 ? "" + v : encode21("" + v);
    }
    if (typeof v === "bigint") {
        return "" + v;
    }
    if (typeof v === "boolean") {
        return v ? "true" : "false";
    }
    return "";
}
function stringify(obj, sep11, eq, options) {
    sep11 ||= "&";
    eq ||= "=";
    const encode31 = options ? options.encodeURIComponent : qsEscape;
    const convert = options ? encodeStringifiedCustom : encodeStringified;
    if (obj !== null && typeof obj === "object") {
        const keys = Object.keys(obj);
        const len = keys.length;
        let fields = "";
        for(let i87 = 0; i87 < len; ++i87){
            const k = keys[i87];
            const v = obj[k];
            let ks = convert(k, encode31);
            ks += eq;
            if (Array.isArray(v)) {
                const vlen = v.length;
                if (vlen === 0) continue;
                if (fields) {
                    fields += sep11;
                }
                for(let j = 0; j < vlen; ++j){
                    if (j) {
                        fields += sep11;
                    }
                    fields += ks;
                    fields += convert(v[j], encode31);
                }
            } else {
                if (fields) {
                    fields += sep11;
                }
                fields += ks;
                fields += convert(v, encode31);
            }
        }
        return fields;
    }
    return "";
}
const unhexTable = new Int8Array([
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    +0,
    +1,
    +2,
    +3,
    +4,
    +5,
    +6,
    +7,
    +8,
    +9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
]);
function unescapeBuffer(s, decodeSpaces = false) {
    const out = new Buffer(s.length);
    let index = 0;
    let outIndex = 0;
    let currentChar;
    let nextChar;
    let hexHigh;
    let hexLow;
    const maxLength = s.length - 2;
    let hasHex = false;
    while(index < s.length){
        currentChar = s.charCodeAt(index);
        if (currentChar === 43 && decodeSpaces) {
            out[outIndex++] = 32;
            index++;
            continue;
        }
        if (currentChar === 37 && index < maxLength) {
            currentChar = s.charCodeAt(++index);
            hexHigh = unhexTable[currentChar];
            if (!(hexHigh >= 0)) {
                out[outIndex++] = 37;
                continue;
            } else {
                nextChar = s.charCodeAt(++index);
                hexLow = unhexTable[nextChar];
                if (!(hexLow >= 0)) {
                    out[outIndex++] = 37;
                    index--;
                } else {
                    hasHex = true;
                    currentChar = hexHigh * 16 + hexLow;
                }
            }
        }
        out[outIndex++] = currentChar;
        index++;
    }
    return hasHex ? out.slice(0, outIndex) : out;
}
function qsUnescape(s) {
    try {
        return decodeURIComponent(s);
    } catch  {
        return unescapeBuffer(s).toString();
    }
}
const unescape = qsUnescape;
const __default6 = {
    parse: parse6,
    stringify,
    decode: decode2,
    encode: encode3,
    unescape,
    escape,
    unescapeBuffer
};
const forwardSlashRegEx = /\//g;
const protocolPattern = /^[a-z0-9.+-]+:/i;
const portPattern = /:[0-9]*$/;
const hostPattern = /^\/\/[^@/]+@[^@/]+/;
const simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
const unsafeProtocol = new Set([
    "javascript",
    "javascript:"
]);
const hostlessProtocol = new Set([
    "javascript",
    "javascript:"
]);
const slashedProtocol = new Set([
    "http",
    "http:",
    "https",
    "https:",
    "ftp",
    "ftp:",
    "gopher",
    "gopher:",
    "file",
    "file:",
    "ws",
    "ws:",
    "wss",
    "wss:", 
]);
const noEscapeAuth = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
]);
class Url {
    protocol;
    slashes;
    auth;
    host;
    port;
    hostname;
    hash;
    search;
    query;
    pathname;
    path;
    href;
    constructor(){
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
    }
     #parseHost() {
        let host = this.host || "";
        let port = portPattern.exec(host);
        if (port) {
            port = port[0];
            if (port !== ":") {
                this.port = port.slice(1);
            }
            host = host.slice(0, host.length - port.length);
        }
        if (host) this.hostname = host;
    }
    resolve(relative6) {
        return this.resolveObject(parse7(relative6, false, true)).format();
    }
    resolveObject(relative7) {
        if (typeof relative7 === "string") {
            const rel = new Url();
            rel.urlParse(relative7, false, true);
            relative7 = rel;
        }
        const result = new Url();
        const tkeys = Object.keys(this);
        for(let tk = 0; tk < tkeys.length; tk++){
            const tkey = tkeys[tk];
            result[tkey] = this[tkey];
        }
        result.hash = relative7.hash;
        if (relative7.href === "") {
            result.href = result.format();
            return result;
        }
        if (relative7.slashes && !relative7.protocol) {
            const rkeys = Object.keys(relative7);
            for(let rk = 0; rk < rkeys.length; rk++){
                const rkey = rkeys[rk];
                if (rkey !== "protocol") result[rkey] = relative7[rkey];
            }
            if (result.protocol && slashedProtocol.has(result.protocol) && result.hostname && !result.pathname) {
                result.path = result.pathname = "/";
            }
            result.href = result.format();
            return result;
        }
        if (relative7.protocol && relative7.protocol !== result.protocol) {
            if (!slashedProtocol.has(relative7.protocol)) {
                const keys = Object.keys(relative7);
                for(let v = 0; v < keys.length; v++){
                    const k = keys[v];
                    result[k] = relative7[k];
                }
                result.href = result.format();
                return result;
            }
            result.protocol = relative7.protocol;
            if (!relative7.host && !/^file:?$/.test(relative7.protocol) && !hostlessProtocol.has(relative7.protocol)) {
                const relPath = (relative7.pathname || "").split("/");
                while(relPath.length && !(relative7.host = relPath.shift() || null));
                if (!relative7.host) relative7.host = "";
                if (!relative7.hostname) relative7.hostname = "";
                if (relPath[0] !== "") relPath.unshift("");
                if (relPath.length < 2) relPath.unshift("");
                result.pathname = relPath.join("/");
            } else {
                result.pathname = relative7.pathname;
            }
            result.search = relative7.search;
            result.query = relative7.query;
            result.host = relative7.host || "";
            result.auth = relative7.auth;
            result.hostname = relative7.hostname || relative7.host;
            result.port = relative7.port;
            if (result.pathname || result.search) {
                const p = result.pathname || "";
                const s = result.search || "";
                result.path = p + s;
            }
            result.slashes = result.slashes || relative7.slashes;
            result.href = result.format();
            return result;
        }
        const isSourceAbs = result.pathname && result.pathname.charAt(0) === "/";
        const isRelAbs = relative7.host || relative7.pathname && relative7.pathname.charAt(0) === "/";
        let mustEndAbs = isRelAbs || isSourceAbs || result.host && relative7.pathname;
        const removeAllDots = mustEndAbs;
        let srcPath = result.pathname && result.pathname.split("/") || [];
        const relPath = relative7.pathname && relative7.pathname.split("/") || [];
        const noLeadingSlashes = result.protocol && !slashedProtocol.has(result.protocol);
        if (noLeadingSlashes) {
            result.hostname = "";
            result.port = null;
            if (result.host) {
                if (srcPath[0] === "") srcPath[0] = result.host;
                else srcPath.unshift(result.host);
            }
            result.host = "";
            if (relative7.protocol) {
                relative7.hostname = null;
                relative7.port = null;
                result.auth = null;
                if (relative7.host) {
                    if (relPath[0] === "") relPath[0] = relative7.host;
                    else relPath.unshift(relative7.host);
                }
                relative7.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
        }
        if (isRelAbs) {
            if (relative7.host || relative7.host === "") {
                if (result.host !== relative7.host) result.auth = null;
                result.host = relative7.host;
                result.port = relative7.port;
            }
            if (relative7.hostname || relative7.hostname === "") {
                if (result.hostname !== relative7.hostname) result.auth = null;
                result.hostname = relative7.hostname;
            }
            result.search = relative7.search;
            result.query = relative7.query;
            srcPath = relPath;
        } else if (relPath.length) {
            if (!srcPath) srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative7.search;
            result.query = relative7.query;
        } else if (relative7.search !== null && relative7.search !== undefined) {
            if (noLeadingSlashes) {
                result.hostname = result.host = srcPath.shift() || null;
                const authInHost = result.host && result.host.indexOf("@") > 0 && result.host.split("@");
                if (authInHost) {
                    result.auth = authInHost.shift() || null;
                    result.host = result.hostname = authInHost.shift() || null;
                }
            }
            result.search = relative7.search;
            result.query = relative7.query;
            if (result.pathname !== null || result.search !== null) {
                result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
            }
            result.href = result.format();
            return result;
        }
        if (!srcPath.length) {
            result.pathname = null;
            if (result.search) {
                result.path = "/" + result.search;
            } else {
                result.path = null;
            }
            result.href = result.format();
            return result;
        }
        let last = srcPath.slice(-1)[0];
        const hasTrailingSlash = (result.host || relative7.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
        let up = 0;
        for(let i88 = srcPath.length - 1; i88 >= 0; i88--){
            last = srcPath[i88];
            if (last === ".") {
                srcPath.splice(i88, 1);
            } else if (last === "..") {
                srcPath.splice(i88, 1);
                up++;
            } else if (up) {
                srcPath.splice(i88, 1);
                up--;
            }
        }
        if (!mustEndAbs && !removeAllDots) {
            while(up--){
                srcPath.unshift("..");
            }
        }
        if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
            srcPath.unshift("");
        }
        if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
            srcPath.push("");
        }
        const isAbsolute6 = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
        if (noLeadingSlashes) {
            result.hostname = result.host = isAbsolute6 ? "" : srcPath.length ? srcPath.shift() || null : "";
            const authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
                result.auth = authInHost.shift() || null;
                result.host = result.hostname = authInHost.shift() || null;
            }
        }
        mustEndAbs = mustEndAbs || result.host && srcPath.length;
        if (mustEndAbs && !isAbsolute6) {
            srcPath.unshift("");
        }
        if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
        } else {
            result.pathname = srcPath.join("/");
        }
        if (result.pathname !== null || result.search !== null) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.auth = relative7.auth || result.auth;
        result.slashes = result.slashes || relative7.slashes;
        result.href = result.format();
        return result;
    }
    format() {
        let auth = this.auth || "";
        if (auth) {
            auth = encodeStr(auth, noEscapeAuth, hexTable);
            auth += "@";
        }
        let protocol = this.protocol || "";
        let pathname = this.pathname || "";
        let hash = this.hash || "";
        let host = "";
        let query = "";
        if (this.host) {
            host = auth + this.host;
        } else if (this.hostname) {
            host = auth + (this.hostname.includes(":") && !isIpv6Hostname(this.hostname) ? "[" + this.hostname + "]" : this.hostname);
            if (this.port) {
                host += ":" + this.port;
            }
        }
        if (this.query !== null && typeof this.query === "object") {
            query = __default6.stringify(this.query);
        }
        let search = this.search || query && "?" + query || "";
        if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58) {
            protocol += ":";
        }
        let newPathname = "";
        let lastPos = 0;
        for(let i89 = 0; i89 < pathname.length; ++i89){
            switch(pathname.charCodeAt(i89)){
                case 35:
                    if (i89 - lastPos > 0) {
                        newPathname += pathname.slice(lastPos, i89);
                    }
                    newPathname += "%23";
                    lastPos = i89 + 1;
                    break;
                case 63:
                    if (i89 - lastPos > 0) {
                        newPathname += pathname.slice(lastPos, i89);
                    }
                    newPathname += "%3F";
                    lastPos = i89 + 1;
                    break;
            }
        }
        if (lastPos > 0) {
            if (lastPos !== pathname.length) {
                pathname = newPathname + pathname.slice(lastPos);
            } else pathname = newPathname;
        }
        if (this.slashes || slashedProtocol.has(protocol)) {
            if (this.slashes || host) {
                if (pathname && pathname.charCodeAt(0) !== 47) {
                    pathname = "/" + pathname;
                }
                host = "//" + host;
            } else if (protocol.length >= 4 && protocol.charCodeAt(0) === 102 && protocol.charCodeAt(1) === 105 && protocol.charCodeAt(2) === 108 && protocol.charCodeAt(3) === 101) {
                host = "//";
            }
        }
        search = search.replace(/#/g, "%23");
        if (hash && hash.charCodeAt(0) !== 35) {
            hash = "#" + hash;
        }
        if (search && search.charCodeAt(0) !== 63) {
            search = "?" + search;
        }
        return protocol + host + pathname + search + hash;
    }
    urlParse(url, parseQueryString, slashesDenoteHost) {
        let hasHash = false;
        let start = -1;
        let end = -1;
        let rest = "";
        let lastPos = 0;
        for(let i90 = 0, inWs = false, split = false; i90 < url.length; ++i90){
            const code = url.charCodeAt(i90);
            const isWs = code === 32 || code === 9 || code === 13 || code === 10 || code === 12 || code === 160 || code === 65279;
            if (start === -1) {
                if (isWs) continue;
                lastPos = start = i90;
            } else if (inWs) {
                if (!isWs) {
                    end = -1;
                    inWs = false;
                }
            } else if (isWs) {
                end = i90;
                inWs = true;
            }
            if (!split) {
                switch(code){
                    case 35:
                        hasHash = true;
                    case 63:
                        split = true;
                        break;
                    case 92:
                        if (i90 - lastPos > 0) rest += url.slice(lastPos, i90);
                        rest += "/";
                        lastPos = i90 + 1;
                        break;
                }
            } else if (!hasHash && code === 35) {
                hasHash = true;
            }
        }
        if (start !== -1) {
            if (lastPos === start) {
                if (end === -1) {
                    if (start === 0) rest = url;
                    else rest = url.slice(start);
                } else {
                    rest = url.slice(start, end);
                }
            } else if (end === -1 && lastPos < url.length) {
                rest += url.slice(lastPos);
            } else if (end !== -1 && lastPos < end) {
                rest += url.slice(lastPos, end);
            }
        }
        if (!slashesDenoteHost && !hasHash) {
            const simplePath = simplePathPattern.exec(rest);
            if (simplePath) {
                this.path = rest;
                this.href = rest;
                this.pathname = simplePath[1];
                if (simplePath[2]) {
                    this.search = simplePath[2];
                    if (parseQueryString) {
                        this.query = __default6.parse(this.search.slice(1));
                    } else {
                        this.query = this.search.slice(1);
                    }
                } else if (parseQueryString) {
                    this.search = null;
                    this.query = Object.create(null);
                }
                return this;
            }
        }
        let proto = protocolPattern.exec(rest);
        let lowerProto = "";
        if (proto) {
            proto = proto[0];
            lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.slice(proto.length);
        }
        let slashes;
        if (slashesDenoteHost || proto || hostPattern.test(rest)) {
            slashes = rest.charCodeAt(0) === CHAR_FORWARD_SLASH && rest.charCodeAt(1) === CHAR_FORWARD_SLASH;
            if (slashes && !(proto && hostlessProtocol.has(lowerProto))) {
                rest = rest.slice(2);
                this.slashes = true;
            }
        }
        if (!hostlessProtocol.has(lowerProto) && (slashes || proto && !slashedProtocol.has(proto))) {
            let hostEnd = -1;
            let atSign = -1;
            let nonHost = -1;
            for(let i91 = 0; i91 < rest.length; ++i91){
                switch(rest.charCodeAt(i91)){
                    case 9:
                    case 10:
                    case 13:
                    case 32:
                    case 34:
                    case 37:
                    case 39:
                    case 59:
                    case 60:
                    case 62:
                    case 92:
                    case 94:
                    case 96:
                    case 123:
                    case 124:
                    case 125:
                        if (nonHost === -1) nonHost = i91;
                        break;
                    case 35:
                    case 47:
                    case 63:
                        if (nonHost === -1) nonHost = i91;
                        hostEnd = i91;
                        break;
                    case 64:
                        atSign = i91;
                        nonHost = -1;
                        break;
                }
                if (hostEnd !== -1) break;
            }
            start = 0;
            if (atSign !== -1) {
                this.auth = decodeURIComponent(rest.slice(0, atSign));
                start = atSign + 1;
            }
            if (nonHost === -1) {
                this.host = rest.slice(start);
                rest = "";
            } else {
                this.host = rest.slice(start, nonHost);
                rest = rest.slice(nonHost);
            }
            this.#parseHost();
            if (typeof this.hostname !== "string") this.hostname = "";
            const hostname5 = this.hostname;
            const ipv6Hostname = isIpv6Hostname(hostname5);
            if (!ipv6Hostname) {
                rest = getHostname(this, rest, hostname5);
            }
            if (this.hostname.length > 255) {
                this.hostname = "";
            } else {
                this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
                this.hostname = toASCII(this.hostname);
            }
            const p = this.port ? ":" + this.port : "";
            const h = this.hostname || "";
            this.host = h + p;
            if (ipv6Hostname) {
                this.hostname = this.hostname.slice(1, -1);
                if (rest[0] !== "/") {
                    rest = "/" + rest;
                }
            }
        }
        if (!unsafeProtocol.has(lowerProto)) {
            rest = autoEscapeStr(rest);
        }
        let questionIdx = -1;
        let hashIdx = -1;
        for(let i111 = 0; i111 < rest.length; ++i111){
            const code = rest.charCodeAt(i111);
            if (code === 35) {
                this.hash = rest.slice(i111);
                hashIdx = i111;
                break;
            } else if (code === 63 && questionIdx === -1) {
                questionIdx = i111;
            }
        }
        if (questionIdx !== -1) {
            if (hashIdx === -1) {
                this.search = rest.slice(questionIdx);
                this.query = rest.slice(questionIdx + 1);
            } else {
                this.search = rest.slice(questionIdx, hashIdx);
                this.query = rest.slice(questionIdx + 1, hashIdx);
            }
            if (parseQueryString) {
                this.query = __default6.parse(this.query);
            }
        } else if (parseQueryString) {
            this.search = null;
            this.query = Object.create(null);
        }
        const useQuestionIdx = questionIdx !== -1 && (hashIdx === -1 || questionIdx < hashIdx);
        const firstIdx = useQuestionIdx ? questionIdx : hashIdx;
        if (firstIdx === -1) {
            if (rest.length > 0) this.pathname = rest;
        } else if (firstIdx > 0) {
            this.pathname = rest.slice(0, firstIdx);
        }
        if (slashedProtocol.has(lowerProto) && this.hostname && !this.pathname) {
            this.pathname = "/";
        }
        if (this.pathname || this.search) {
            const p = this.pathname || "";
            const s = this.search || "";
            this.path = p + s;
        }
        this.href = this.format();
        return this;
    }
}
function isIpv6Hostname(hostname6) {
    return hostname6.charCodeAt(0) === 91 && hostname6.charCodeAt(hostname6.length - 1) === 93;
}
function getHostname(self, rest, hostname7) {
    for(let i92 = 0; i92 < hostname7.length; ++i92){
        const code = hostname7.charCodeAt(i92);
        const isValid = code >= 97 && code <= 122 || code === 46 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 43 || code === 95 || code > 127;
        if (!isValid) {
            self.hostname = hostname7.slice(0, i92);
            return `/${hostname7.slice(i92)}${rest}`;
        }
    }
    return rest;
}
const escapedCodes = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%09",
    "%0A",
    "",
    "",
    "%0D",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%20",
    "",
    "%22",
    "",
    "",
    "",
    "",
    "%27",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%3C",
    "",
    "%3E",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%5C",
    "",
    "%5E",
    "",
    "%60",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%7B",
    "%7C",
    "%7D"
];
function autoEscapeStr(rest) {
    let escaped = "";
    let lastEscapedPos = 0;
    for(let i93 = 0; i93 < rest.length; ++i93){
        const escapedChar = escapedCodes[rest.charCodeAt(i93)];
        if (escapedChar) {
            if (i93 > lastEscapedPos) {
                escaped += rest.slice(lastEscapedPos, i93);
            }
            escaped += escapedChar;
            lastEscapedPos = i93 + 1;
        }
    }
    if (lastEscapedPos === 0) {
        return rest;
    }
    if (lastEscapedPos < rest.length) {
        escaped += rest.slice(lastEscapedPos);
    }
    return escaped;
}
function parse7(url, parseQueryString, slashesDenoteHost) {
    if (url instanceof Url) return url;
    const urlObject = new Url();
    urlObject.urlParse(url, parseQueryString, slashesDenoteHost);
    return urlObject;
}
function fileURLToPath(path111) {
    if (typeof path111 === "string") path111 = new URL(path111);
    else if (!(path111 instanceof URL)) {
        throw new ERR_INVALID_ARG_TYPE("path", [
            "string",
            "URL"
        ], path111);
    }
    if (path111.protocol !== "file:") {
        throw new ERR_INVALID_URL_SCHEME("file");
    }
    return isWindows ? getPathFromURLWin(path111) : getPathFromURLPosix(path111);
}
function getPathFromURLWin(url) {
    const hostname8 = url.hostname;
    let pathname = url.pathname;
    for(let n = 0; n < pathname.length; n++){
        if (pathname[n] === "%") {
            const third = pathname.codePointAt(n + 2) | 0x20;
            if (pathname[n + 1] === "2" && third === 102 || pathname[n + 1] === "5" && third === 99) {
                throw new ERR_INVALID_FILE_URL_PATH("must not include encoded \\ or / characters");
            }
        }
    }
    pathname = pathname.replace(forwardSlashRegEx, "\\");
    pathname = decodeURIComponent(pathname);
    if (hostname8 !== "") {
        return `\\\\${hostname8}${pathname}`;
    } else {
        const letter = pathname.codePointAt(1) | 0x20;
        const sep12 = pathname[2];
        if (letter < 97 || letter > 122 || sep12 !== ":") {
            throw new ERR_INVALID_FILE_URL_PATH("must be absolute");
        }
        return pathname.slice(1);
    }
}
function getPathFromURLPosix(url) {
    if (url.hostname !== "") {
        throw new ERR_INVALID_FILE_URL_HOST(osType);
    }
    const pathname = url.pathname;
    for(let n = 0; n < pathname.length; n++){
        if (pathname[n] === "%") {
            const third = pathname.codePointAt(n + 2) | 0x20;
            if (pathname[n + 1] === "2" && third === 102) {
                throw new ERR_INVALID_FILE_URL_PATH("must not include encoded / characters");
            }
        }
    }
    return decodeURIComponent(pathname);
}
Symbol("query");
function toPathIfFileURL(fileURLOrPath) {
    if (!(fileURLOrPath instanceof URL)) {
        return fileURLOrPath;
    }
    return fileURLToPath(fileURLOrPath);
}
function assert1(value, message) {
    if (!value) {
        throw new ERR_INTERNAL_ASSERTION(message);
    }
}
function fail(message) {
    throw new ERR_INTERNAL_ASSERTION(message);
}
assert1.fail = fail;
function convertFileInfoToStats(origin) {
    return {
        dev: origin.dev,
        ino: origin.ino,
        mode: origin.mode,
        nlink: origin.nlink,
        uid: origin.uid,
        gid: origin.gid,
        rdev: origin.rdev,
        size: origin.size,
        blksize: origin.blksize,
        blocks: origin.blocks,
        mtime: origin.mtime,
        atime: origin.atime,
        birthtime: origin.birthtime,
        mtimeMs: origin.mtime?.getTime() || null,
        atimeMs: origin.atime?.getTime() || null,
        birthtimeMs: origin.birthtime?.getTime() || null,
        isFile: ()=>origin.isFile
        ,
        isDirectory: ()=>origin.isDirectory
        ,
        isSymbolicLink: ()=>origin.isSymlink
        ,
        isBlockDevice: ()=>false
        ,
        isFIFO: ()=>false
        ,
        isCharacterDevice: ()=>false
        ,
        isSocket: ()=>false
        ,
        ctime: origin.mtime,
        ctimeMs: origin.mtime?.getTime() || null
    };
}
function toBigInt(number) {
    if (number === null || number === undefined) return null;
    return BigInt(number);
}
function convertFileInfoToBigIntStats(origin) {
    return {
        dev: toBigInt(origin.dev),
        ino: toBigInt(origin.ino),
        mode: toBigInt(origin.mode),
        nlink: toBigInt(origin.nlink),
        uid: toBigInt(origin.uid),
        gid: toBigInt(origin.gid),
        rdev: toBigInt(origin.rdev),
        size: toBigInt(origin.size) || 0n,
        blksize: toBigInt(origin.blksize),
        blocks: toBigInt(origin.blocks),
        mtime: origin.mtime,
        atime: origin.atime,
        birthtime: origin.birthtime,
        mtimeMs: origin.mtime ? BigInt(origin.mtime.getTime()) : null,
        atimeMs: origin.atime ? BigInt(origin.atime.getTime()) : null,
        birthtimeMs: origin.birthtime ? BigInt(origin.birthtime.getTime()) : null,
        mtimeNs: origin.mtime ? BigInt(origin.mtime.getTime()) * 1000000n : null,
        atimeNs: origin.atime ? BigInt(origin.atime.getTime()) * 1000000n : null,
        birthtimeNs: origin.birthtime ? BigInt(origin.birthtime.getTime()) * 1000000n : null,
        isFile: ()=>origin.isFile
        ,
        isDirectory: ()=>origin.isDirectory
        ,
        isSymbolicLink: ()=>origin.isSymlink
        ,
        isBlockDevice: ()=>false
        ,
        isFIFO: ()=>false
        ,
        isCharacterDevice: ()=>false
        ,
        isSocket: ()=>false
        ,
        ctime: origin.mtime,
        ctimeMs: origin.mtime ? BigInt(origin.mtime.getTime()) : null,
        ctimeNs: origin.mtime ? BigInt(origin.mtime.getTime()) * 1000000n : null
    };
}
function CFISBIS(fileInfo, bigInt) {
    if (bigInt) return convertFileInfoToBigIntStats(fileInfo);
    return convertFileInfoToStats(fileInfo);
}
function stat(path53, optionsOrCallback, maybeCallback1) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback1;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : {
        bigint: false
    };
    if (!callback) throw new Error("No callback function supplied");
    Deno.stat(path53).then((stat1)=>callback(null, CFISBIS(stat1, options.bigint))
    , (err)=>callback(denoErrorToNodeError(err, {
            syscall: "stat"
        }))
    );
}
function statSync(path54, options = {
    bigint: false,
    throwIfNoEntry: true
}) {
    try {
        const origin = Deno.statSync(path54);
        return CFISBIS(origin, options.bigint);
    } catch (err) {
        if (options?.throwIfNoEntry === false && err instanceof Deno.errors.NotFound) {
            return;
        }
        if (err instanceof Error) {
            throw denoErrorToNodeError(err, {
                syscall: "stat"
            });
        } else {
            throw err;
        }
    }
}
function lstat(path55, optionsOrCallback, maybeCallback2) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback2;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : {
        bigint: false
    };
    if (!callback) throw new Error("No callback function supplied");
    Deno.lstat(path55).then((stat2)=>callback(null, CFISBIS(stat2, options.bigint))
    , (err)=>callback(err)
    );
}
function lstatSync(path56, options) {
    const origin = Deno.lstatSync(path56);
    return CFISBIS(origin, options?.bigint || false);
}
"use strict";
const kRejection = Symbol.for("nodejs.rejection");
const kCapture = Symbol("kCapture");
const kErrorMonitor = Symbol("events.errorMonitor");
const kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
const kMaxEventTargetListenersWarned = Symbol("events.maxEventTargetListenersWarned");
function EventEmitter(opts) {
    EventEmitter.init.call(this, opts);
}
EventEmitter.on = on;
EventEmitter.once = once1;
EventEmitter.getEventListeners = getEventListeners;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.captureRejectionSymbol = kRejection;
EventEmitter.captureRejectionSymbol;
EventEmitter.errorMonitor;
Object.defineProperty(EventEmitter, "captureRejections", {
    get () {
        return EventEmitter.prototype[kCapture];
    },
    set (value) {
        validateBoolean(value, "EventEmitter.captureRejections");
        EventEmitter.prototype[kCapture] = value;
    },
    enumerable: true
});
EventEmitter.errorMonitor = kErrorMonitor;
Object.defineProperty(EventEmitter.prototype, kCapture, {
    value: false,
    writable: true,
    enumerable: false
});
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
let defaultMaxListeners = 10;
function checkListener(listener) {
    validateFunction(listener, "listener");
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || Number.isNaN(arg)) {
            throw new ERR_OUT_OF_RANGE("defaultMaxListeners", "a non-negative number", arg);
        }
        defaultMaxListeners = arg;
    }
});
Object.defineProperties(EventEmitter, {
    kMaxEventTargetListeners: {
        value: kMaxEventTargetListeners,
        enumerable: false,
        configurable: false,
        writable: false
    },
    kMaxEventTargetListenersWarned: {
        value: kMaxEventTargetListenersWarned,
        enumerable: false,
        configurable: false,
        writable: false
    }
});
EventEmitter.setMaxListeners = function(n = defaultMaxListeners, ...eventTargets) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
    }
    if (eventTargets.length === 0) {
        defaultMaxListeners = n;
    } else {
        for(let i94 = 0; i94 < eventTargets.length; i94++){
            const target = eventTargets[i94];
            if (target instanceof EventTarget) {
                target[kMaxEventTargetListeners] = n;
                target[kMaxEventTargetListenersWarned] = false;
            } else if (typeof target.setMaxListeners === "function") {
                target.setMaxListeners(n);
            } else {
                throw new ERR_INVALID_ARG_TYPE("eventTargets", [
                    "EventEmitter",
                    "EventTarget"
                ], target);
            }
        }
    }
};
EventEmitter.init = function(opts) {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
    if (opts?.captureRejections) {
        validateBoolean(opts.captureRejections, "options.captureRejections");
        this[kCapture] = Boolean(opts.captureRejections);
    } else {
        this[kCapture] = EventEmitter.prototype[kCapture];
    }
};
function addCatch(that, promise, type12, args) {
    if (!that[kCapture]) {
        return;
    }
    try {
        const then = promise.then;
        if (typeof then === "function") {
            then.call(promise, undefined, function(err) {
                process.nextTick(emitUnhandledRejectionOrErr, that, err, type12, args);
            });
        }
    } catch (err) {
        that.emit("error", err);
    }
}
function emitUnhandledRejectionOrErr(ee, err, type13, args) {
    if (typeof ee[kRejection] === "function") {
        ee[kRejection](err, type13, ...args);
    } else {
        const prev = ee[kCapture];
        try {
            ee[kCapture] = false;
            ee.emit("error", err);
        } finally{
            ee[kCapture] = prev;
        }
    }
}
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
    }
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) {
        return EventEmitter.defaultMaxListeners;
    }
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type14, ...args) {
    let doError = type14 === "error";
    const events = this._events;
    if (events !== undefined) {
        if (doError && events[kErrorMonitor] !== undefined) {
            this.emit(kErrorMonitor, ...args);
        }
        doError = doError && events.error === undefined;
    } else if (!doError) {
        return false;
    }
    if (doError) {
        let er;
        if (args.length > 0) {
            er = args[0];
        }
        if (er instanceof Error) {
            try {
                const capture = {};
                Error.captureStackTrace(capture, EventEmitter.prototype.emit);
            } catch  {}
            throw er;
        }
        let stringifiedEr;
        try {
            stringifiedEr = inspect(er);
        } catch  {
            stringifiedEr = er;
        }
        const err = new ERR_UNHANDLED_ERROR(stringifiedEr);
        err.context = er;
        throw err;
    }
    const handler = events[type14];
    if (handler === undefined) {
        return false;
    }
    if (typeof handler === "function") {
        const result = handler.apply(this, args);
        if (result !== undefined && result !== null) {
            addCatch(this, result, type14, args);
        }
    } else {
        const len = handler.length;
        const listeners = arrayClone(handler);
        for(let i95 = 0; i95 < len; ++i95){
            const result = listeners[i95].apply(this, args);
            if (result !== undefined && result !== null) {
                addCatch(this, result, type14, args);
            }
        }
    }
    return true;
};
function _addListener(target, type15, listener, prepend) {
    let m;
    let events;
    let existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        if (events.newListener !== undefined) {
            target.emit("newListener", type15, listener.listener ?? listener);
            events = target._events;
        }
        existing = events[type15];
    }
    if (existing === undefined) {
        events[type15] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") {
            existing = events[type15] = prepend ? [
                listener,
                existing
            ] : [
                existing,
                listener
            ];
        } else if (prepend) {
            existing.unshift(listener);
        } else {
            existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            const w = new Error("Possible EventEmitter memory leak detected. " + `${existing.length} ${String(type15)} listeners ` + `added to ${inspect(target, {
                depth: -1
            })}. Use ` + "emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type15;
            w.count = existing.length;
            process.emitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type16, listener) {
    return _addListener(this, type16, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type17, listener) {
    return _addListener(this, type17, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) {
            return this.listener.call(this.target);
        }
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type18, listener) {
    const state = {
        fired: false,
        wrapFn: undefined,
        target,
        type: type18,
        listener
    };
    const wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type19, listener) {
    checkListener(listener);
    this.on(type19, _onceWrap(this, type19, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type20, listener) {
    checkListener(listener);
    this.prependListener(type20, _onceWrap(this, type20, listener));
    return this;
};
EventEmitter.prototype.removeListener = function removeListener(type21, listener) {
    checkListener(listener);
    const events = this._events;
    if (events === undefined) {
        return this;
    }
    const list = events[type21];
    if (list === undefined) {
        return this;
    }
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) {
            this._events = Object.create(null);
        } else {
            delete events[type21];
            if (events.removeListener) {
                this.emit("removeListener", type21, list.listener || listener);
            }
        }
    } else if (typeof list !== "function") {
        let position = -1;
        for(let i96 = list.length - 1; i96 >= 0; i96--){
            if (list[i96] === listener || list[i96].listener === listener) {
                position = i96;
                break;
            }
        }
        if (position < 0) {
            return this;
        }
        if (position === 0) {
            list.shift();
        } else {
            spliceOne(list, position);
        }
        if (list.length === 1) {
            events[type21] = list[0];
        }
        if (events.removeListener !== undefined) {
            this.emit("removeListener", type21, listener);
        }
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type22) {
    const events = this._events;
    if (events === undefined) {
        return this;
    }
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type22] !== undefined) {
            if (--this._eventsCount === 0) {
                this._events = Object.create(null);
            } else {
                delete events[type22];
            }
        }
        return this;
    }
    if (arguments.length === 0) {
        for (const key of Reflect.ownKeys(events)){
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    const listeners = events[type22];
    if (typeof listeners === "function") {
        this.removeListener(type22, listeners);
    } else if (listeners !== undefined) {
        for(let i97 = listeners.length - 1; i97 >= 0; i97--){
            this.removeListener(type22, listeners[i97]);
        }
    }
    return this;
};
function _listeners(target, type23, unwrap) {
    const events = target._events;
    if (events === undefined) {
        return [];
    }
    const evlistener = events[type23];
    if (evlistener === undefined) {
        return [];
    }
    if (typeof evlistener === "function") {
        return unwrap ? [
            evlistener.listener || evlistener
        ] : [
            evlistener
        ];
    }
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener);
}
EventEmitter.prototype.listeners = function listeners(type24) {
    return _listeners(this, type24, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type25) {
    return _listeners(this, type25, false);
};
EventEmitter.listenerCount = function(emitter, type26) {
    if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type26);
    }
    return listenerCount.call(emitter, type26);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type27) {
    const events = this._events;
    if (events !== undefined) {
        const evlistener = events[type27];
        if (typeof evlistener === "function") {
            return 1;
        } else if (evlistener !== undefined) {
            return evlistener.length;
        }
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function arrayClone(arr) {
    switch(arr.length){
        case 2:
            return [
                arr[0],
                arr[1]
            ];
        case 3:
            return [
                arr[0],
                arr[1],
                arr[2]
            ];
        case 4:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3]
            ];
        case 5:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4]
            ];
        case 6:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4],
                arr[5]
            ];
    }
    return arr.slice();
}
function unwrapListeners(arr) {
    const ret = arrayClone(arr);
    for(let i98 = 0; i98 < ret.length; ++i98){
        const orig = ret[i98].listener;
        if (typeof orig === "function") {
            ret[i98] = orig;
        }
    }
    return ret;
}
function getEventListeners(emitterOrTarget, type28) {
    if (typeof emitterOrTarget.listeners === "function") {
        return emitterOrTarget.listeners(type28);
    }
    if (emitterOrTarget instanceof EventTarget) {
        const root = emitterOrTarget[kEvents].get(type28);
        const listeners = [];
        let handler = root?.next;
        while(handler?.listener !== undefined){
            const listener = handler.listener?.deref ? handler.listener.deref() : handler.listener;
            listeners.push(listener);
            handler = handler.next;
        }
        return listeners;
    }
    throw new ERR_INVALID_ARG_TYPE("emitter", [
        "EventEmitter",
        "EventTarget"
    ], emitterOrTarget);
}
async function once1(emitter, name30, options = {}) {
    const signal = options?.signal;
    validateAbortSignal(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError();
    }
    return new Promise((resolve9, reject)=>{
        const errorListener = (err)=>{
            emitter.removeListener(name30, resolver);
            if (signal != null) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            reject(err);
        };
        const resolver = (...args)=>{
            if (typeof emitter.removeListener === "function") {
                emitter.removeListener("error", errorListener);
            }
            if (signal != null) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            resolve9(args);
        };
        eventTargetAgnosticAddListener(emitter, name30, resolver, {
            once: true
        });
        if (name30 !== "error" && typeof emitter.once === "function") {
            emitter.once("error", errorListener);
        }
        function abortListener() {
            eventTargetAgnosticRemoveListener(emitter, name30, resolver);
            eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
            reject(new AbortError());
        }
        if (signal != null) {
            eventTargetAgnosticAddListener(signal, "abort", abortListener, {
                once: true
            });
        }
    });
}
const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);
function createIterResult(value, done) {
    return {
        value,
        done
    };
}
function eventTargetAgnosticRemoveListener(emitter, name31, listener, flags) {
    if (typeof emitter.removeListener === "function") {
        emitter.removeListener(name31, listener);
    } else if (typeof emitter.removeEventListener === "function") {
        emitter.removeEventListener(name31, listener, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
    }
}
function eventTargetAgnosticAddListener(emitter, name32, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags?.once) {
            emitter.once(name32, listener);
        } else {
            emitter.on(name32, listener);
        }
    } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name32, (arg)=>{
            listener(arg);
        }, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
    }
}
function on(emitter, event, options) {
    const signal = options?.signal;
    validateAbortSignal(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError();
    }
    const unconsumedEvents = [];
    const unconsumedPromises = [];
    let error3 = null;
    let finished1 = false;
    const iterator = Object.setPrototypeOf({
        next () {
            const value = unconsumedEvents.shift();
            if (value) {
                return Promise.resolve(createIterResult(value, false));
            }
            if (error3) {
                const p = Promise.reject(error3);
                error3 = null;
                return p;
            }
            if (finished1) {
                return Promise.resolve(createIterResult(undefined, true));
            }
            return new Promise(function(resolve10, reject) {
                unconsumedPromises.push({
                    resolve: resolve10,
                    reject
                });
            });
        },
        return () {
            eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
            if (signal) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener, {
                    once: true
                });
            }
            finished1 = true;
            for (const promise of unconsumedPromises){
                promise.resolve(createIterResult(undefined, true));
            }
            return Promise.resolve(createIterResult(undefined, true));
        },
        throw (err) {
            if (!err || !(err instanceof Error)) {
                throw new ERR_INVALID_ARG_TYPE("EventEmitter.AsyncIterator", "Error", err);
            }
            error3 = err;
            eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    }, AsyncIteratorPrototype);
    eventTargetAgnosticAddListener(emitter, event, eventHandler);
    if (event !== "error" && typeof emitter.on === "function") {
        emitter.on("error", errorHandler);
    }
    if (signal) {
        eventTargetAgnosticAddListener(signal, "abort", abortListener, {
            once: true
        });
    }
    return iterator;
    function abortListener() {
        errorHandler(new AbortError());
    }
    function eventHandler(...args) {
        const promise = unconsumedPromises.shift();
        if (promise) {
            promise.resolve(createIterResult(args, false));
        } else {
            unconsumedEvents.push(args);
        }
    }
    function errorHandler(err) {
        finished1 = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
            toError.reject(err);
        } else {
            error3 = err;
        }
        iterator.return();
    }
}
const { hasOwn  } = Object;
function get(obj, key) {
    if (hasOwn(obj, key)) {
        return obj[key];
    }
}
function getForce(obj, key) {
    const v = get(obj, key);
    assert(v != null);
    return v;
}
function isNumber(x) {
    if (typeof x === "number") return true;
    if (/^0x[0-9a-f]+$/i.test(String(x))) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x));
}
function hasKey(obj, keys) {
    let o = obj;
    keys.slice(0, -1).forEach((key)=>{
        o = get(o, key) ?? {};
    });
    const key1 = keys[keys.length - 1];
    return key1 in o;
}
function parse8(args, { "--": doubleDash = false , alias: alias3 = {} , boolean: __boolean = false , default: defaults = {} , stopEarly =false , string =[] , collect: collect1 = [] , negatable =[] , unknown =(i99)=>i99
  } = {}) {
    const flags = {
        bools: {},
        strings: {},
        unknownFn: unknown,
        allBools: false,
        collect: {},
        negatable: {}
    };
    if (__boolean !== undefined) {
        if (typeof __boolean === "boolean") {
            flags.allBools = !!__boolean;
        } else {
            const booleanArgs = typeof __boolean === "string" ? [
                __boolean
            ] : __boolean;
            for (const key of booleanArgs.filter(Boolean)){
                flags.bools[key] = true;
            }
        }
    }
    const aliases = {};
    if (alias3 !== undefined) {
        for(const key in alias3){
            const val = getForce(alias3, key);
            if (typeof val === "string") {
                aliases[key] = [
                    val
                ];
            } else {
                aliases[key] = val;
            }
            for (const alias1 of getForce(aliases, key)){
                aliases[alias1] = [
                    key
                ].concat(aliases[key].filter((y)=>alias1 !== y
                ));
            }
        }
    }
    if (string !== undefined) {
        const stringArgs = typeof string === "string" ? [
            string
        ] : string;
        for (const key of stringArgs.filter(Boolean)){
            flags.strings[key] = true;
            const alias = get(aliases, key);
            if (alias) {
                for (const al of alias){
                    flags.strings[al] = true;
                }
            }
        }
    }
    if (collect1 !== undefined) {
        const collectArgs = typeof collect1 === "string" ? [
            collect1
        ] : collect1;
        for (const key of collectArgs.filter(Boolean)){
            flags.collect[key] = true;
            const alias = get(aliases, key);
            if (alias) {
                for (const al of alias){
                    flags.collect[al] = true;
                }
            }
        }
    }
    if (negatable !== undefined) {
        const negatableArgs = typeof negatable === "string" ? [
            negatable
        ] : negatable;
        for (const key of negatableArgs.filter(Boolean)){
            flags.negatable[key] = true;
            const alias = get(aliases, key);
            if (alias) {
                for (const al of alias){
                    flags.negatable[al] = true;
                }
            }
        }
    }
    const argv1 = {
        _: []
    };
    function argDefined(key, arg) {
        return flags.allBools && /^--[^=]+$/.test(arg) || get(flags.bools, key) || !!get(flags.strings, key) || !!get(aliases, key);
    }
    function setKey(obj, name33, value, collect = true) {
        let o = obj;
        const keys = name33.split(".");
        keys.slice(0, -1).forEach(function(key) {
            if (get(o, key) === undefined) {
                o[key] = {};
            }
            o = get(o, key);
        });
        const key5 = keys[keys.length - 1];
        const collectable = collect && !!get(flags.collect, name33);
        if (!collectable) {
            o[key5] = value;
        } else if (get(o, key5) === undefined) {
            o[key5] = [
                value
            ];
        } else if (Array.isArray(get(o, key5))) {
            o[key5].push(value);
        } else {
            o[key5] = [
                get(o, key5),
                value
            ];
        }
    }
    function setArg(key, val, arg = undefined, collect) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg, key, val) === false) return;
        }
        const value = !get(flags.strings, key) && isNumber(val) ? Number(val) : val;
        setKey(argv1, key, value, collect);
        const alias = get(aliases, key);
        if (alias) {
            for (const x of alias){
                setKey(argv1, x, value, collect);
            }
        }
    }
    function aliasIsBoolean(key) {
        return getForce(aliases, key).some((x)=>typeof get(flags.bools, x) === "boolean"
        );
    }
    let notFlags = [];
    if (args.includes("--")) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
    }
    for(let i100 = 0; i100 < args.length; i100++){
        const arg = args[i100];
        if (/^--.+=/.test(arg)) {
            const m = arg.match(/^--([^=]+)=(.*)$/s);
            assert(m != null);
            const [, key, value] = m;
            if (flags.bools[key]) {
                const booleanValue = value !== "false";
                setArg(key, booleanValue, arg);
            } else {
                setArg(key, value, arg);
            }
        } else if (/^--no-.+/.test(arg) && get(flags.negatable, arg.replace(/^--no-/, ""))) {
            const m = arg.match(/^--no-(.+)/);
            assert(m != null);
            setArg(m[1], false, arg, false);
        } else if (/^--.+/.test(arg)) {
            const m = arg.match(/^--(.+)/);
            assert(m != null);
            const [, key] = m;
            const next = args[i100 + 1];
            if (next !== undefined && !/^-/.test(next) && !get(flags.bools, key) && !flags.allBools && (get(aliases, key) ? !aliasIsBoolean(key) : true)) {
                setArg(key, next, arg);
                i100++;
            } else if (/^(true|false)$/.test(next)) {
                setArg(key, next === "true", arg);
                i100++;
            } else {
                setArg(key, get(flags.strings, key) ? "" : true, arg);
            }
        } else if (/^-[^-]+/.test(arg)) {
            const letters = arg.slice(1, -1).split("");
            let broken = false;
            for(let j = 0; j < letters.length; j++){
                const next = arg.slice(j + 2);
                if (next === "-") {
                    setArg(letters[j], next, arg);
                    continue;
                }
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
                    setArg(letters[j], next.split(/=(.+)/)[1], arg);
                    broken = true;
                    break;
                }
                if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j], next, arg);
                    broken = true;
                    break;
                }
                if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j + 2), arg);
                    broken = true;
                    break;
                } else {
                    setArg(letters[j], get(flags.strings, letters[j]) ? "" : true, arg);
                }
            }
            const [key] = arg.slice(-1);
            if (!broken && key !== "-") {
                if (args[i100 + 1] && !/^(-|--)[^-]/.test(args[i100 + 1]) && !get(flags.bools, key) && (get(aliases, key) ? !aliasIsBoolean(key) : true)) {
                    setArg(key, args[i100 + 1], arg);
                    i100++;
                } else if (args[i100 + 1] && /^(true|false)$/.test(args[i100 + 1])) {
                    setArg(key, args[i100 + 1] === "true", arg);
                    i100++;
                } else {
                    setArg(key, get(flags.strings, key) ? "" : true, arg);
                }
            }
        } else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv1._.push(flags.strings["_"] ?? !isNumber(arg) ? arg : Number(arg));
            }
            if (stopEarly) {
                argv1._.push(...args.slice(i100 + 1));
                break;
            }
        }
    }
    for (const [key4, value1] of Object.entries(defaults)){
        if (!hasKey(argv1, key4.split("."))) {
            setKey(argv1, key4, value1);
            if (aliases[key4]) {
                for (const x of aliases[key4]){
                    setKey(argv1, x, value1);
                }
            }
        }
    }
    for (const key2 of Object.keys(flags.bools)){
        if (!hasKey(argv1, key2.split("."))) {
            const value = get(flags.collect, key2) ? [] : false;
            setKey(argv1, key2, value, false);
        }
    }
    for (const key3 of Object.keys(flags.strings)){
        if (!hasKey(argv1, key3.split(".")) && get(flags.collect, key3)) {
            setKey(argv1, key3, [], false);
        }
    }
    if (doubleDash) {
        argv1["--"] = [];
        for (const key of notFlags){
            argv1["--"].push(key);
        }
    } else {
        for (const key of notFlags){
            argv1._.push(key);
        }
    }
    return argv1;
}
function getOptions() {
    const args = parse8(Deno.args);
    const options = new Map(Object.entries(args).map(([key, value])=>[
            key,
            {
                value
            }
        ]
    ));
    return {
        options
    };
}
let optionsMap;
function getOptionsFromBinding() {
    if (!optionsMap) {
        ({ options: optionsMap  } = getOptions());
    }
    return optionsMap;
}
function getOptionValue(optionName) {
    const options = getOptionsFromBinding();
    if (optionName.startsWith("--no-")) {
        const option = options.get("--" + optionName.slice(5));
        return option && !option.value;
    }
    return options.get(optionName)?.value;
}
function _arch() {
    if (Deno.build.arch == "x86_64") {
        return "x64";
    } else if (Deno.build.arch == "aarch64") {
        return "arm64";
    } else {
        throw Error("unreachable");
    }
}
const arch = _arch();
const chdir = Deno.chdir;
const cwd = Deno.cwd;
const nextTick1 = nextTick2;
const env = new Proxy({}, {
    get (_target, prop) {
        return Deno.env.get(String(prop));
    },
    ownKeys: ()=>Reflect.ownKeys(Deno.env.toObject())
    ,
    getOwnPropertyDescriptor: (_target, name34)=>{
        const e = Deno.env.toObject();
        if (name34 in Deno.env.toObject()) {
            const o = {
                enumerable: true,
                configurable: true
            };
            if (typeof name34 === "string") {
                o.value = e[name34];
            }
            return o;
        }
    },
    set (_target, prop, value) {
        Deno.env.set(String(prop), String(value));
        return value;
    }
});
const pid = Deno.pid;
const platform = isWindows ? "win32" : Deno.build.os;
const version = "v16.11.1";
const versions = {
    node: "16.11.1",
    uv: "1.42.0",
    zlib: "1.2.11",
    brotli: "1.0.9",
    ares: "1.17.2",
    modules: "93",
    nghttp2: "1.45.1",
    napi: "8",
    llhttp: "6.0.4",
    openssl: "1.1.1l",
    cldr: "39.0",
    icu: "69.1",
    tz: "2021a",
    unicode: "13.0",
    ...Deno.version
};
"use strict";
const kEscape = "\x1b";
Symbol("kSubstringSearch");
function CSI(strings, ...args) {
    let ret = `${kEscape}[`;
    for(let n = 0; n < strings.length; n++){
        ret += strings[n];
        if (n < args.length) {
            ret += args[n];
        }
    }
    return ret;
}
CSI.kEscape = kEscape;
CSI.kClearToLineBeginning = CSI`1K`;
CSI.kClearToLineEnd = CSI`0K`;
CSI.kClearLine = CSI`2K`;
CSI.kClearScreenDown = CSI`0J`;
"use strict";
const { kClearLine , kClearScreenDown , kClearToLineBeginning , kClearToLineEnd ,  } = CSI;
function cursorTo(stream, x, y, callback) {
    if (callback !== undefined) {
        validateCallback(callback);
    }
    if (typeof y === "function") {
        callback = y;
        y = undefined;
    }
    if (Number.isNaN(x)) throw new ERR_INVALID_ARG_VALUE("x", x);
    if (Number.isNaN(y)) throw new ERR_INVALID_ARG_VALUE("y", y);
    if (stream == null || typeof x !== "number" && typeof y !== "number") {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    if (typeof x !== "number") throw new ERR_INVALID_CURSOR_POS();
    const data = typeof y !== "number" ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;
    return stream.write(data, callback);
}
function moveCursor(stream, dx, dy, callback) {
    if (callback !== undefined) {
        validateCallback(callback);
    }
    if (stream == null || !(dx || dy)) {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    let data = "";
    if (dx < 0) {
        data += CSI`${-dx}D`;
    } else if (dx > 0) {
        data += CSI`${dx}C`;
    }
    if (dy < 0) {
        data += CSI`${-dy}A`;
    } else if (dy > 0) {
        data += CSI`${dy}B`;
    }
    return stream.write(data, callback);
}
function clearLine(stream, dir, callback) {
    if (callback !== undefined) {
        validateCallback(callback);
    }
    if (stream === null || stream === undefined) {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    const type29 = dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;
    return stream.write(type29, callback);
}
function clearScreenDown(stream, callback) {
    if (callback !== undefined) {
        validateCallback(callback);
    }
    if (stream === null || stream === undefined) {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    return stream.write(kClearScreenDown, callback);
}
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function isServerResponse(stream) {
    return typeof stream._sent100 === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean" && typeof stream._removedTE === "boolean" && typeof stream._closed === "boolean";
}
function isReadable(stream) {
    return typeof stream.readable === "boolean" || typeof stream.readableEnded === "boolean" || !!stream._readableState;
}
function isWritable(stream) {
    return typeof stream.writable === "boolean" || typeof stream.writableEnded === "boolean" || !!stream._writableState;
}
function isWritableFinished(stream) {
    if (stream.writableFinished) return true;
    const wState = stream._writableState;
    if (!wState || wState.errored) return false;
    return wState.finished || wState.ended && wState.length === 0;
}
const nop = ()=>{};
function isReadableEnded(stream) {
    if (stream.readableEnded) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    return rState.endEmitted || rState.ended && rState.length === 0;
}
function eos(stream, options, callback) {
    if (arguments.length === 2) {
        callback = options;
        options = {};
    } else if (options == null) {
        options = {};
    } else {
        validateObject(options, "options");
    }
    validateFunction(callback, "callback");
    validateAbortSignal(options.signal, "options.signal");
    callback = once(callback);
    const readable = options.readable || options.readable !== false && isReadable(stream);
    const writable = options.writable || options.writable !== false && isWritable(stream);
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    const onlegacyfinish = ()=>{
        if (!stream.writable) onfinish();
    };
    let willEmitClose = isServerResponse(stream) || state && state.autoDestroy && state.emitClose && state.closed === false && isReadable(stream) === readable && isWritable(stream) === writable;
    let writableFinished = stream.writableFinished || wState && wState.finished;
    const onfinish = ()=>{
        writableFinished = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.readable || readable)) return;
        if (!readable || readableEnded) callback.call(stream);
    };
    let readableEnded = stream.readableEnded || rState && rState.endEmitted;
    const onend = ()=>{
        readableEnded = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.writable || writable)) return;
        if (!writable || writableFinished) callback.call(stream);
    };
    const onerror = (err)=>{
        callback.call(stream, err);
    };
    const onclose = ()=>{
        if (readable && !readableEnded) {
            if (!isReadableEnded(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        if (writable && !writableFinished) {
            if (!isWritableFinished(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        callback.call(stream);
    };
    const onrequest = ()=>{
        stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
            stream.on("abort", onclose);
        }
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (options.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    const closed = !wState && !rState && stream._closed === true || wState && wState.closed || rState && rState.closed || wState && wState.errorEmitted || rState && rState.errorEmitted || rState && stream.req && stream.aborted || (!wState || !willEmitClose || typeof wState.closed !== "boolean") && (!rState || !willEmitClose || typeof rState.closed !== "boolean") && (!writable || wState && wState.finished) && (!readable || rState && rState.endEmitted);
    if (closed) {
        nextTick2(()=>{
            callback();
        });
    }
    const cleanup = ()=>{
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
    if (options.signal && !closed) {
        const abort = ()=>{
            const endCallback = callback;
            cleanup();
            endCallback.call(stream, new AbortError());
        };
        if (options.signal.aborted) {
            nextTick2(abort);
        } else {
            const originalCallback = callback;
            callback = once((...args)=>{
                options.signal.removeEventListener("abort", abort);
                originalCallback.apply(stream, args);
            });
            options.signal.addEventListener("abort", abort);
        }
    }
    return cleanup;
}
const validateAbortSignal1 = (signal, name35)=>{
    if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name35, "AbortSignal", signal);
    }
};
function isStream(obj) {
    return !!(obj && typeof obj.pipe === "function");
}
function addAbortSignal(signal, stream) {
    validateAbortSignal1(signal, "signal");
    if (!isStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", "stream.Stream", stream);
    }
    return addAbortSignalNoValidate(signal, stream);
}
function addAbortSignalNoValidate(signal, stream) {
    if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
    }
    const onAbort = ()=>{
        stream.destroy(new AbortError());
    };
    if (signal.aborted) {
        onAbort();
    } else {
        signal.addEventListener("abort", onAbort);
        eos(stream, ()=>signal.removeEventListener("abort", onAbort)
        );
    }
    return stream;
}
const kDestroy = Symbol("kDestroy");
const kConstruct = Symbol("kConstruct");
function checkError(err, w, r) {
    if (err) {
        err.stack;
        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
    }
}
function destroy2(err, cb) {
    const r = this._readableState;
    const w = this._writableState;
    const s = w || r;
    if (w && w.destroyed || r && r.destroyed) {
        if (typeof cb === "function") {
            cb();
        }
        return this;
    }
    checkError(err, w, r);
    if (w) {
        w.destroyed = true;
    }
    if (r) {
        r.destroyed = true;
    }
    if (!s.constructed) {
        this.once(kDestroy, function(er) {
            _destroy(this, aggregateTwoErrors(er, err), cb);
        });
    } else {
        _destroy(this, err, cb);
    }
    return this;
}
function _destroy(self, err1, cb) {
    let called = false;
    function onDestroy(err) {
        if (called) {
            return;
        }
        called = true;
        const r = self._readableState;
        const w = self._writableState;
        checkError(err, w, r);
        if (w) {
            w.closed = true;
        }
        if (r) {
            r.closed = true;
        }
        if (typeof cb === "function") {
            cb(err);
        }
        if (err) {
            nextTick2(emitErrorCloseNT, self, err);
        } else {
            nextTick2(emitCloseNT, self);
        }
    }
    try {
        const result = self._destroy(err1 || null, onDestroy);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick2(onDestroy, null);
                }, function(err) {
                    nextTick2(onDestroy, err);
                });
            }
        }
    } catch (err) {
        onDestroy(err);
    }
}
function emitErrorCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
}
function emitCloseNT(self) {
    const r = self._readableState;
    const w = self._writableState;
    if (w) {
        w.closeEmitted = true;
    }
    if (r) {
        r.closeEmitted = true;
    }
    if (w && w.emitClose || r && r.emitClose) {
        self.emit("close");
    }
}
function emitErrorNT(self, err) {
    const r = self._readableState;
    const w = self._writableState;
    if (w && w.errorEmitted || r && r.errorEmitted) {
        return;
    }
    if (w) {
        w.errorEmitted = true;
    }
    if (r) {
        r.errorEmitted = true;
    }
    self.emit("error", err);
}
function undestroy() {
    const r = this._readableState;
    const w = this._writableState;
    if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = false;
        r.endEmitted = false;
    }
    if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.ended = false;
        w.ending = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.finished = false;
    }
}
function errorOrDestroy(stream, err, sync) {
    const r = stream._readableState;
    const w = stream._writableState;
    if (w && w.destroyed || r && r.destroyed) {
        return this;
    }
    if (r && r.autoDestroy || w && w.autoDestroy) {
        stream.destroy(err);
    } else if (err) {
        err.stack;
        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
        if (sync) {
            nextTick2(emitErrorNT, stream, err);
        } else {
            emitErrorNT(stream, err);
        }
    }
}
function construct(stream, cb) {
    if (typeof stream._construct !== "function") {
        return;
    }
    const r = stream._readableState;
    const w = stream._writableState;
    if (r) {
        r.constructed = false;
    }
    if (w) {
        w.constructed = false;
    }
    stream.once(kConstruct, cb);
    if (stream.listenerCount(kConstruct) > 1) {
        return;
    }
    nextTick2(constructNT, stream);
}
function constructNT(stream) {
    let called = false;
    function onConstruct(err) {
        if (called) {
            errorOrDestroy(stream, err ?? new ERR_MULTIPLE_CALLBACK());
            return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
            r.constructed = true;
        }
        if (w) {
            w.constructed = true;
        }
        if (s.destroyed) {
            stream.emit(kDestroy, err);
        } else if (err) {
            errorOrDestroy(stream, err, true);
        } else {
            nextTick2(emitConstructNT, stream);
        }
    }
    try {
        const result = stream._construct(onConstruct);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick2(onConstruct, null);
                }, function(err) {
                    nextTick2(onConstruct, err);
                });
            }
        }
    } catch (err) {
        onConstruct(err);
    }
}
function emitConstructNT(stream) {
    stream.emit(kConstruct);
}
function isRequest1(stream) {
    return stream && stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, err) {
    if (!stream) return;
    if (isRequest1(stream)) return stream.abort();
    if (isRequest1(stream.req)) return stream.req.abort();
    if (typeof stream.destroy === "function") return stream.destroy(err);
    if (typeof stream.close === "function") return stream.close();
}
const __default7 = {
    construct,
    destroyer,
    destroy: destroy2,
    undestroy,
    errorOrDestroy
};
const kIsDisturbed = Symbol("kIsDisturbed");
function isReadableNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!obj._writableState || obj._readableState?.readable !== false) && (!obj._writableState || obj._readableState));
}
function isWritableNodeStream(obj) {
    return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || obj._writableState?.writable !== false));
}
function isDuplexNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
}
function isNodeStream(obj) {
    return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
}
function isIterable(obj, isAsync) {
    if (obj == null) return false;
    if (isAsync === true) return typeof obj[Symbol.asyncIterator] === "function";
    if (isAsync === false) return typeof obj[Symbol.iterator] === "function";
    return typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function";
}
function isDestroyed(stream) {
    if (!isNodeStream(stream)) return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    return !!(stream.destroyed || state?.destroyed);
}
function isWritableEnded(stream) {
    if (!isWritableNodeStream(stream)) return null;
    if (stream.writableEnded === true) return true;
    const wState = stream._writableState;
    if (wState?.errored) return false;
    if (typeof wState?.ended !== "boolean") return null;
    return wState.ended;
}
function isReadableEnded1(stream) {
    if (!isReadableNodeStream(stream)) return null;
    if (stream.readableEnded === true) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    if (typeof rState?.ended !== "boolean") return null;
    return rState.ended;
}
function isReadableFinished(stream, strict) {
    if (!isReadableNodeStream(stream)) return null;
    const rState = stream._readableState;
    if (rState?.errored) return false;
    if (typeof rState?.endEmitted !== "boolean") return null;
    return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
}
function isDisturbed(stream) {
    return !!(stream && (stream.readableDidRead || stream.readableAborted || stream[kIsDisturbed]));
}
function isReadable1(stream) {
    const r = isReadableNodeStream(stream);
    if (r === null || typeof stream?.readable !== "boolean") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.readable && !isReadableFinished(stream);
}
function isWritable1(stream) {
    const r = isWritableNodeStream(stream);
    if (r === null || typeof stream?.writable !== "boolean") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.writable && !isWritableEnded(stream);
}
const stdio = {};
function isBlob(object) {
    return object instanceof Blob;
}
function _from1(Readable1, iterable, opts) {
    let iterator;
    if (typeof iterable === "string" || iterable instanceof Buffer) {
        return new Readable1({
            objectMode: true,
            ...opts,
            read () {
                this.push(iterable);
                this.push(null);
            }
        });
    }
    let isAsync;
    if (iterable && iterable[Symbol.asyncIterator]) {
        isAsync = true;
        iterator = iterable[Symbol.asyncIterator]();
    } else if (iterable && iterable[Symbol.iterator]) {
        isAsync = false;
        iterator = iterable[Symbol.iterator]();
    } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", [
            "Iterable"
        ], iterable);
    }
    const readable = new Readable1({
        objectMode: true,
        highWaterMark: 1,
        ...opts
    });
    let reading = false;
    readable._read = function() {
        if (!reading) {
            reading = true;
            next();
        }
    };
    readable._destroy = function(error4, cb) {
        close2(error4).then(()=>nextTick1(cb, error4)
        , (e)=>nextTick1(cb, e || error4)
        );
    };
    async function close2(error5) {
        const hadError = error5 !== undefined && error5 !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
            const { value , done  } = await iterator.throw(error5);
            await value;
            if (done) {
                return;
            }
        }
        if (typeof iterator.return === "function") {
            const { value  } = await iterator.return();
            await value;
        }
    }
    async function next() {
        for(;;){
            try {
                const { value , done  } = isAsync ? await iterator.next() : iterator.next();
                if (done) {
                    readable.push(null);
                } else {
                    const res = value && typeof value.then === "function" ? await value : value;
                    if (res === null) {
                        reading = false;
                        throw new ERR_STREAM_NULL_VALUES();
                    } else if (readable.push(res)) {
                        continue;
                    } else {
                        reading = false;
                    }
                }
            } catch (err) {
                readable.destroy(err);
            }
            break;
        }
    }
    return readable;
}
function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getDefaultHighWaterMark(objectMode) {
    return objectMode ? 16 : 16 * 1024;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
    const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!Number.isInteger(hwm) || hwm < 0) {
            const name36 = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
            throw new ERR_INVALID_ARG_VALUE(name36, hwm);
        }
        return Math.floor(hwm);
    }
    return getDefaultHighWaterMark(state.objectMode);
}
function Stream(opts) {
    EventEmitter.call(this, opts);
}
Object.setPrototypeOf(Stream.prototype, EventEmitter.prototype);
Object.setPrototypeOf(Stream, EventEmitter);
Stream.prototype.pipe = function(dest, options) {
    const source = this;
    function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
            source.pause();
        }
    }
    source.on("data", ondata);
    function ondrain() {
        if (source.readable && source.resume) {
            source.resume();
        }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
    }
    let didOnEnd = false;
    function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
    }
    function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
    }
    function onerror(er) {
        cleanup();
        if (EventEmitter.listenerCount(this, "error") === 0) {
            this.emit("error", er);
        }
    }
    prependListener(source, "error", onerror);
    prependListener(dest, "error", onerror);
    function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
};
function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") {
        return emitter.prependListener(event, fn);
    }
    if (!emitter._events || !emitter._events[event]) {
        emitter.on(event, fn);
    } else if (Array.isArray(emitter._events[event])) {
        emitter._events[event].unshift(fn);
    } else {
        emitter._events[event] = [
            fn,
            emitter._events[event]
        ];
    }
}
var NotImplemented;
(function(NotImplemented1) {
    NotImplemented1[NotImplemented1["ascii"] = 0] = "ascii";
    NotImplemented1[NotImplemented1["latin1"] = 1] = "latin1";
    NotImplemented1[NotImplemented1["utf16le"] = 2] = "utf16le";
})(NotImplemented || (NotImplemented = {}));
function normalizeEncoding2(enc) {
    const encoding = normalizeEncoding1(enc ?? null);
    if (encoding && encoding in NotImplemented) notImplemented(encoding);
    if (!encoding && typeof enc === "string" && enc.toLowerCase() !== "raw") {
        throw new Error(`Unknown encoding: ${enc}`);
    }
    return String(encoding);
}
function utf8CheckByte(__byte) {
    if (__byte <= 0x7f) return 0;
    else if (__byte >> 5 === 0x06) return 2;
    else if (__byte >> 4 === 0x0e) return 3;
    else if (__byte >> 3 === 0x1e) return 4;
    return __byte >> 6 === 0x02 ? -1 : -2;
}
function utf8CheckIncomplete(self, buf, i101) {
    let j = buf.length - 1;
    if (j < i101) return 0;
    let nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i101 || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i101 || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
function utf8CheckExtraBytes(self, buf) {
    if ((buf[0] & 0xc0) !== 0x80) {
        self.lastNeed = 0;
        return "\ufffd";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xc0) !== 0x80) {
            self.lastNeed = 1;
            return "\ufffd";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xc0) !== 0x80) {
                self.lastNeed = 2;
                return "\ufffd";
            }
        }
    }
}
function utf8FillLastComplete(buf) {
    const p = this.lastTotal - this.lastNeed;
    const r = utf8CheckExtraBytes(this, buf);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8FillLastIncomplete(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8Text(buf, i102) {
    const total = utf8CheckIncomplete(this, buf, i102);
    if (!this.lastNeed) return buf.toString("utf8", i102);
    this.lastTotal = total;
    const end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i102, end);
}
function utf8End(buf) {
    const r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "\ufffd";
    return r;
}
function utf8Write(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    if (buf.length === 0) return "";
    let r;
    let i103;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i103 = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i103 = 0;
    }
    if (i103 < buf.length) return r ? r + this.text(buf, i103) : this.text(buf, i103);
    return r || "";
}
function base64Text(buf, i104) {
    const n = (buf.length - i104) % 3;
    if (n === 0) return buf.toString("base64", i104);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i104, buf.length - n);
}
function base64End(buf) {
    const r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    }
    return r;
}
function simpleWrite(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}
class StringDecoderBase {
    lastChar;
    lastNeed;
    lastTotal;
    constructor(encoding, nb){
        this.encoding = encoding;
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer.allocUnsafe(nb);
    }
    encoding;
}
class Base64Decoder extends StringDecoderBase {
    end = base64End;
    fillLast = utf8FillLastIncomplete;
    text = base64Text;
    write = utf8Write;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 3);
    }
}
class GenericDecoder extends StringDecoderBase {
    end = simpleEnd;
    fillLast = undefined;
    text = utf8Text;
    write = simpleWrite;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 4);
    }
}
class Utf8Decoder extends StringDecoderBase {
    end = utf8End;
    fillLast = utf8FillLastComplete;
    text = utf8Text;
    write = utf8Write;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 4);
    }
}
class StringDecoder {
    encoding;
    end;
    fillLast;
    lastChar;
    lastNeed;
    lastTotal;
    text;
    write;
    constructor(encoding){
        let decoder;
        switch(encoding){
            case "utf8":
                decoder = new Utf8Decoder(encoding);
                break;
            case "base64":
                decoder = new Base64Decoder(encoding);
                break;
            default:
                decoder = new GenericDecoder(encoding);
        }
        this.encoding = decoder.encoding;
        this.end = decoder.end;
        this.fillLast = decoder.fillLast;
        this.lastChar = decoder.lastChar;
        this.lastNeed = decoder.lastNeed;
        this.lastTotal = decoder.lastTotal;
        this.text = decoder.text;
        this.write = decoder.write;
    }
}
new Proxy(StringDecoder, {
    apply (_target, thisArg, args) {
        return Object.assign(thisArg, new StringDecoder(...args));
    }
});
class BufferList {
    constructor(){
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    push(v) {
        const entry = {
            data: v,
            next: null
        };
        if (this.length > 0) {
            this.tail.next = entry;
        } else {
            this.head = entry;
        }
        this.tail = entry;
        ++this.length;
    }
    unshift(v) {
        const entry = {
            data: v,
            next: this.head
        };
        if (this.length === 0) {
            this.tail = entry;
        }
        this.head = entry;
        ++this.length;
    }
    shift() {
        if (this.length === 0) {
            return;
        }
        const ret = this.head.data;
        if (this.length === 1) {
            this.head = this.tail = null;
        } else {
            this.head = this.head.next;
        }
        --this.length;
        return ret;
    }
    clear() {
        this.head = this.tail = null;
        this.length = 0;
    }
    join(s) {
        if (this.length === 0) {
            return "";
        }
        let p = this.head;
        let ret = "" + p.data;
        while(p = p.next){
            ret += s + p.data;
        }
        return ret;
    }
    concat(n) {
        if (this.length === 0) {
            return Buffer.alloc(0);
        }
        const ret = Buffer.allocUnsafe(n >>> 0);
        let p = this.head;
        let i105 = 0;
        while(p){
            ret.set(p.data, i105);
            i105 += p.data.length;
            p = p.next;
        }
        return ret;
    }
    consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
            const slice = data.slice(0, n);
            this.head.data = data.slice(n);
            return slice;
        }
        if (n === data.length) {
            return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
    }
    first() {
        return this.head.data;
    }
    *[Symbol.iterator]() {
        for(let p = this.head; p; p = p.next){
            yield p.data;
        }
    }
    _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
            const str = p.data;
            if (n > str.length) {
                ret += str;
                n -= str.length;
            } else {
                if (n === str.length) {
                    ret += str;
                    ++c;
                    if (p.next) {
                        this.head = p.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret += str.slice(0, n);
                    this.head = p;
                    p.data = str.slice(n);
                }
                break;
            }
            ++c;
        }while (p = p.next)
        this.length -= c;
        return ret;
    }
    _getBuffer(n) {
        const ret = Buffer.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
            const buf = p.data;
            if (n > buf.length) {
                ret.set(buf, retLen - n);
                n -= buf.length;
            } else {
                if (n === buf.length) {
                    ret.set(buf, retLen - n);
                    ++c;
                    if (p.next) {
                        this.head = p.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret.set(new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n);
                    this.head = p;
                    p.data = buf.slice(n);
                }
                break;
            }
            ++c;
        }while (p = p.next)
        this.length -= c;
        return ret;
    }
    [inspect.custom](_, options) {
        return inspect(this, {
            ...options,
            depth: 0,
            customInspect: false
        });
    }
}
let debug = debuglog("stream", (fn)=>{
    debug = fn;
});
const kPaused = Symbol("kPaused");
Object.setPrototypeOf(Readable.prototype, Stream.prototype);
Object.setPrototypeOf(Readable, Stream);
const nop1 = ()=>{};
const { errorOrDestroy: errorOrDestroy1  } = __default7;
function ReadableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean") {
        isDuplex = stream instanceof Stream.Duplex;
    }
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex) {
        this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
    }
    this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = [];
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.constructed = true;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this[kPaused] = null;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.destroyed = false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.awaitDrainWriters = null;
    this.multiAwaitDrain = false;
    this.readingMore = false;
    this.dataEmitted = false;
    this.decoder = null;
    this.encoding = null;
    if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    if (!(this instanceof Readable)) {
        return new Readable(options);
    }
    const isDuplex = this instanceof Stream.Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    if (options) {
        if (typeof options.read === "function") {
            this._read = options.read;
        }
        if (typeof options.destroy === "function") {
            this._destroy = options.destroy;
        }
        if (typeof options.construct === "function") {
            this._construct = options.construct;
        }
        if (options.signal && !isDuplex) {
            addAbortSignalNoValidate(options.signal, this);
        }
    }
    Stream.call(this, options);
    __default7.construct(this, ()=>{
        if (this._readableState.needReadable) {
            maybeReadMore(this, this._readableState);
        }
    });
}
Readable.prototype.destroy = __default7.destroy;
Readable.prototype._undestroy = __default7.undestroy;
Readable.prototype._destroy = function(err, cb) {
    cb(err);
};
Readable.prototype[EventEmitter.captureRejectionSymbol] = function(err) {
    this.destroy(err);
};
Readable.prototype.push = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, false);
};
Readable.prototype.unshift = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, true);
};
function readableAddChunk(stream, chunk, encoding, addToFront) {
    debug("readableAddChunk", chunk);
    const state = stream._readableState;
    let err;
    if (!state.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (state.encoding !== encoding) {
                if (addToFront && state.encoding) {
                    chunk = Buffer.from(chunk, encoding).toString(state.encoding);
                } else {
                    chunk = Buffer.from(chunk, encoding);
                    encoding = "";
                }
            }
        } else if (chunk instanceof Buffer) {
            encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
            chunk = Stream._uint8ArrayToBuffer(chunk);
            encoding = "";
        } else if (chunk != null) {
            err = new ERR_INVALID_ARG_TYPE("chunk", [
                "string",
                "Buffer",
                "Uint8Array"
            ], chunk);
        }
    }
    if (err) {
        errorOrDestroy1(stream, err);
    } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else if (state.objectMode || chunk && chunk.length > 0) {
        if (addToFront) {
            if (state.endEmitted) {
                errorOrDestroy1(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            } else {
                addChunk(stream, state, chunk, true);
            }
        } else if (state.ended) {
            errorOrDestroy1(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
            return false;
        } else {
            state.reading = false;
            if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0) {
                    addChunk(stream, state, chunk, false);
                } else {
                    maybeReadMore(stream, state);
                }
            } else {
                addChunk(stream, state, chunk, false);
            }
        }
    } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if (state.multiAwaitDrain) {
            state.awaitDrainWriters.clear();
        } else {
            state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
    } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) {
            state.buffer.unshift(chunk);
        } else {
            state.buffer.push(chunk);
        }
        if (state.needReadable) {
            emitReadable(stream);
        }
    }
    maybeReadMore(stream, state);
}
Readable.prototype.isPaused = function() {
    const state = this._readableState;
    return state[kPaused] === true || state.flowing === false;
};
Readable.prototype.setEncoding = function(enc) {
    const decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    const buffer = this._readableState.buffer;
    let content = "";
    for (const data of buffer){
        content += decoder.write(data);
    }
    buffer.clear();
    if (content !== "") {
        buffer.push(content);
    }
    this._readableState.length = content.length;
    return this;
};
const MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
    if (n >= 0x40000000) {
        n = MAX_HWM;
    } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) {
        return 0;
    }
    if (state.objectMode) {
        return 1;
    }
    if (Number.isNaN(n)) {
        if (state.flowing && state.length) {
            return state.buffer.first().length;
        }
        return state.length;
    }
    if (n <= state.length) {
        return n;
    }
    return state.ended ? state.length : 0;
}
Readable.prototype.read = function(n) {
    debug("read", n);
    if (n === undefined) {
        n = NaN;
    } else if (!Number.isInteger(n)) {
        n = Number.parseInt(n, 10);
    }
    const state = this._readableState;
    const nOrig = n;
    if (n > state.highWaterMark) {
        state.highWaterMark = computeNewHighWaterMark(n);
    }
    if (n !== 0) {
        state.emittedReadable = false;
    }
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) {
            endReadable(this);
        } else {
            emitReadable(this);
        }
        return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
        if (state.length === 0) {
            endReadable(this);
        }
        return null;
    }
    let doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
    } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) {
            state.needReadable = true;
        }
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) {
            n = howMuchToRead(nOrig, state);
        }
    }
    let ret;
    if (n > 0) {
        ret = fromList(n, state);
    } else {
        ret = null;
    }
    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
            state.awaitDrainWriters.clear();
        } else {
            state.awaitDrainWriters = null;
        }
    }
    if (state.length === 0) {
        if (!state.ended) {
            state.needReadable = true;
        }
        if (nOrig !== n && state.ended) {
            endReadable(this);
        }
    }
    if (ret !== null) {
        state.dataEmitted = true;
        this.emit("data", ret);
    }
    return ret;
};
function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended) return;
    if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    if (state.sync) {
        emitReadable(stream);
    } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
    }
}
function emitReadable(stream) {
    const state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        nextTick2(emitReadable_, stream);
    }
}
function emitReadable_(stream) {
    const state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
}
function maybeReadMore(stream, state) {
    if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        nextTick2(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) {
            break;
        }
    }
    state.readingMore = false;
}
Readable.prototype._read = function(n) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    const src = this;
    const state = this._readableState;
    if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
            state.multiAwaitDrain = true;
            state.awaitDrainWriters = new Set(state.awaitDrainWriters ? [
                state.awaitDrainWriters
            ] : []);
        }
    }
    state.pipes.push(dest);
    debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
    const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== stdio.stdout && dest !== stdio.stderr;
    const endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) {
        nextTick2(endFn);
    } else {
        src.once("end", endFn);
    }
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug("onend");
        dest.end();
    }
    let ondrain;
    let cleanedUp = false;
    function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
            dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) {
            ondrain();
        }
    }
    function pause() {
        if (!cleanedUp) {
            if (state.pipes.length === 1 && state.pipes[0] === dest) {
                debug("false write response, pause", 0);
                state.awaitDrainWriters = dest;
                state.multiAwaitDrain = false;
            } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
                debug("false write response, pause", state.awaitDrainWriters.size);
                state.awaitDrainWriters.add(dest);
            }
            src.pause();
        }
        if (!ondrain) {
            ondrain = pipeOnDrain(src, dest);
            dest.on("drain", ondrain);
        }
    }
    src.on("data", ondata);
    function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
            pause();
        }
    }
    function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EventEmitter.listenerCount(dest, "error") === 0) {
            const s = dest._writableState || dest._readableState;
            if (s && !s.errorEmitted) {
                errorOrDestroy1(dest, er);
            } else {
                dest.emit("error", er);
            }
        }
    }
    prependListener(dest, "error", onerror);
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (dest.writableNeedDrain === true) {
        if (state.flowing) {
            pause();
        }
    } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src, dest) {
    return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
            debug("pipeOnDrain", 1);
            state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
            debug("pipeOnDrain", state.awaitDrainWriters.size);
            state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && EventEmitter.listenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    const state = this._readableState;
    const unpipeInfo = {
        hasUnpiped: false
    };
    if (state.pipes.length === 0) {
        return this;
    }
    if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for(let i106 = 0; i106 < dests.length; i106++){
            dests[i106].emit("unpipe", this, {
                hasUnpiped: false
            });
        }
        return this;
    }
    const index = state.pipes.indexOf(dest);
    if (index === -1) {
        return this;
    }
    state.pipes.splice(index, 1);
    if (state.pipes.length === 0) {
        this.pause();
    }
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
Readable.prototype.on = function(ev, fn) {
    const res = Stream.prototype.on.call(this, ev, fn);
    const state = this._readableState;
    if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) {
            this.resume();
        }
    } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
                emitReadable(this);
            } else if (!state.reading) {
                nextTick2(nReadingNextTick, this);
            }
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
    const res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
        nextTick2(updateReadableListening, this);
    }
    return res;
};
Readable.prototype.off = Readable.prototype.removeListener;
Readable.prototype.removeAllListeners = function(ev) {
    const res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
        nextTick2(updateReadableListening, this);
    }
    return res;
};
function updateReadableListening(self) {
    const state = self._readableState;
    state.readableListening = self.listenerCount("readable") > 0;
    if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
    } else if (self.listenerCount("data") > 0) {
        self.resume();
    } else if (!state.readableListening) {
        state.flowing = null;
    }
}
function nReadingNextTick(self) {
    debug("readable nexttick read 0");
    self.read(0);
}
Readable.prototype.resume = function() {
    const state = this._readableState;
    if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
    }
    state[kPaused] = false;
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        nextTick2(resume_, stream, state);
    }
}
function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
        stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) {
        stream.read(0);
    }
}
Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    this._readableState[kPaused] = true;
    return this;
};
function flow(stream) {
    const state = stream._readableState;
    debug("flow", state.flowing);
    while(state.flowing && stream.read() !== null);
}
Readable.prototype.wrap = function(stream) {
    let paused = false;
    stream.on("data", (chunk)=>{
        if (!this.push(chunk) && stream.pause) {
            paused = true;
            stream.pause();
        }
    });
    stream.on("end", ()=>{
        this.push(null);
    });
    stream.on("error", (err)=>{
        errorOrDestroy1(this, err);
    });
    stream.on("close", ()=>{
        this.destroy();
    });
    stream.on("destroy", ()=>{
        this.destroy();
    });
    this._read = ()=>{
        if (paused && stream.resume) {
            paused = false;
            stream.resume();
        }
    };
    const streamKeys = Object.keys(stream);
    for(let j = 1; j < streamKeys.length; j++){
        const i107 = streamKeys[j];
        if (this[i107] === undefined && typeof stream[i107] === "function") {
            this[i107] = stream[i107].bind(stream);
        }
    }
    return this;
};
Readable.prototype[Symbol.asyncIterator] = function() {
    return streamToAsyncIterator(this);
};
Readable.prototype.iterator = function(options) {
    if (options !== undefined) {
        validateObject(options, "options");
    }
    return streamToAsyncIterator(this, options);
};
function streamToAsyncIterator(stream, options) {
    if (typeof stream.read !== "function") {
        stream = Readable.wrap(stream, {
            objectMode: true
        });
    }
    const iter = createAsyncIterator(stream, options);
    iter.stream = stream;
    return iter;
}
async function* createAsyncIterator(stream, options) {
    let callback = nop1;
    const opts = {
        destroyOnReturn: true,
        destroyOnError: true,
        ...options
    };
    function next(resolve11) {
        if (this === stream) {
            callback();
            callback = nop1;
        } else {
            callback = resolve11;
        }
    }
    const state = stream._readableState;
    let error6 = state.errored;
    let errorEmitted = state.errorEmitted;
    let endEmitted = state.endEmitted;
    let closeEmitted = state.closeEmitted;
    stream.on("readable", next).on("error", function(err) {
        error6 = err;
        errorEmitted = true;
        next.call(this);
    }).on("end", function() {
        endEmitted = true;
        next.call(this);
    }).on("close", function() {
        closeEmitted = true;
        next.call(this);
    });
    let errorThrown = false;
    try {
        while(true){
            const chunk = stream.destroyed ? null : stream.read();
            if (chunk !== null) {
                yield chunk;
            } else if (errorEmitted) {
                throw error6;
            } else if (endEmitted) {
                break;
            } else if (closeEmitted) {
                break;
            } else {
                await new Promise(next);
            }
        }
    } catch (err) {
        if (opts.destroyOnError) {
            __default7.destroyer(stream, err);
        }
        errorThrown = true;
        throw err;
    } finally{
        if (!errorThrown && opts.destroyOnReturn) {
            if (state.autoDestroy || !endEmitted) {
                __default7.destroyer(stream, null);
            }
        }
    }
}
Object.defineProperties(Readable.prototype, {
    readable: {
        get () {
            const r = this._readableState;
            return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set (val) {
            if (this._readableState) {
                this._readableState.readable = !!val;
            }
        }
    },
    readableDidRead: {
        enumerable: false,
        get: function() {
            return this._readableState.dataEmitted;
        }
    },
    readableAborted: {
        enumerable: false,
        get: function() {
            return !!(this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted;
        }
    },
    readableHighWaterMark: {
        enumerable: false,
        get: function() {
            return this._readableState.highWaterMark;
        }
    },
    readableBuffer: {
        enumerable: false,
        get: function() {
            return this._readableState && this._readableState.buffer;
        }
    },
    readableFlowing: {
        enumerable: false,
        get: function() {
            return this._readableState.flowing;
        },
        set: function(state) {
            if (this._readableState) {
                this._readableState.flowing = state;
            }
        }
    },
    readableLength: {
        enumerable: false,
        get () {
            return this._readableState.length;
        }
    },
    readableObjectMode: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.objectMode : false;
        }
    },
    readableEncoding: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.encoding : null;
        }
    },
    destroyed: {
        enumerable: false,
        get () {
            if (this._readableState === undefined) {
                return false;
            }
            return this._readableState.destroyed;
        },
        set (value) {
            if (!this._readableState) {
                return;
            }
            this._readableState.destroyed = value;
        }
    },
    readableEnded: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.endEmitted : false;
        }
    }
});
Object.defineProperties(ReadableState.prototype, {
    pipesCount: {
        get () {
            return this.pipes.length;
        }
    },
    paused: {
        get () {
            return this[kPaused] !== false;
        },
        set (value) {
            this[kPaused] = !!value;
        }
    }
});
function fromList(n, state) {
    if (state.length === 0) {
        return null;
    }
    let ret;
    if (state.objectMode) {
        ret = state.buffer.shift();
    } else if (!n || n >= state.length) {
        if (state.decoder) {
            ret = state.buffer.join("");
        } else if (state.buffer.length === 1) {
            ret = state.buffer.first();
        } else {
            ret = state.buffer.concat(state.length);
        }
        state.buffer.clear();
    } else {
        ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
}
function endReadable(stream) {
    const state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        nextTick2(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.errorEmitted && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
            nextTick2(endWritableNT, stream);
        } else if (state.autoDestroy) {
            const wState = stream._writableState;
            const autoDestroy = !wState || wState.autoDestroy && (wState.finished || wState.writable === false);
            if (autoDestroy) {
                stream.destroy();
            }
        }
    }
}
function endWritableNT(stream) {
    const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
    if (writable) {
        stream.end();
    }
}
function readableFrom(iterable, opts) {
    return _from1(Readable, iterable, opts);
}
function wrap(src, options) {
    return new Readable({
        objectMode: (src.readableObjectMode ?? src.objectMode) ?? true,
        ...options,
        destroy (err, callback) {
            __default7.destroyer(src, err);
            callback(err);
        }
    }).wrap(src);
}
Readable._fromList = fromList;
Readable.ReadableState = ReadableState;
Readable.from = readableFrom;
Readable.wrap = wrap;
const { errorOrDestroy: errorOrDestroy2  } = __default7;
function isDuplexStream(maybe_duplex) {
    const isReadable2 = Readable.prototype.isPrototypeOf(maybe_duplex);
    let prototype = maybe_duplex;
    let isDuplex = false;
    while(prototype?.constructor && prototype.constructor.name !== "Object"){
        if (prototype.constructor.name === "Duplex") {
            isDuplex = true;
            break;
        }
        prototype = Object.getPrototypeOf(prototype);
    }
    return isReadable2 && isDuplex;
}
Object.setPrototypeOf(Writable.prototype, Stream.prototype);
Object.setPrototypeOf(Writable, Stream);
function nop2() {}
const kOnFinished = Symbol("kOnFinished");
function WritableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean") {
        isDuplex = isDuplexStream(stream);
    }
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex) {
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
    }
    this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    const noDecode = !!(options && options.decodeStrings === false);
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = onwrite.bind(undefined, stream);
    this.writecb = null;
    this.writelen = 0;
    this.afterWriteTickInfo = null;
    resetBuffer(this);
    this.pendingcb = 0;
    this.constructed = true;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this[kOnFinished] = [];
}
function resetBuffer(state) {
    state.buffered = [];
    state.bufferedIndex = 0;
    state.allBuffers = true;
    state.allNoop = true;
}
WritableState.prototype.getBuffer = function getBuffer() {
    return this.buffered.slice(this.bufferedIndex);
};
Object.defineProperty(WritableState.prototype, "bufferedRequestCount", {
    get () {
        return this.buffered.length - this.bufferedIndex;
    }
});
function Writable(options) {
    const isDuplex = isDuplexStream(this);
    if (!isDuplex && !Function.prototype[Symbol.hasInstance].call(Writable, this)) {
        return new Writable(options);
    }
    this._writableState = new WritableState(options, this, isDuplex);
    if (options) {
        if (typeof options.write === "function") {
            this._write = options.write;
        }
        if (typeof options.writev === "function") {
            this._writev = options.writev;
        }
        if (typeof options.destroy === "function") {
            this._destroy = options.destroy;
        }
        if (typeof options.final === "function") {
            this._final = options.final;
        }
        if (typeof options.construct === "function") {
            this._construct = options.construct;
        }
        if (options.signal) {
            addAbortSignalNoValidate(options.signal, this);
        }
    }
    Stream.call(this, options);
    __default7.construct(this, ()=>{
        const state = this._writableState;
        if (!state.writing) {
            clearBuffer(this, state);
        }
        finishMaybe(this, state);
    });
}
Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function(object) {
        if (Function.prototype[Symbol.hasInstance].call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
    }
});
Writable.prototype.pipe = function() {
    errorOrDestroy2(this, new ERR_STREAM_CANNOT_PIPE());
};
function _write(stream, chunk, encoding, cb) {
    const state = stream._writableState;
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
    } else {
        if (!encoding) {
            encoding = state.defaultEncoding;
        } else if (encoding !== "buffer" && !Buffer.isEncoding(encoding)) {
            throw new ERR_UNKNOWN_ENCODING(encoding);
        }
        if (typeof cb !== "function") {
            cb = nop2;
        }
    }
    if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
    } else if (!state.objectMode) {
        if (typeof chunk === "string") {
            if (state.decodeStrings !== false) {
                chunk = Buffer.from(chunk, encoding);
                encoding = "buffer";
            }
        } else if (chunk instanceof Buffer) {
            encoding = "buffer";
        } else if (isUint8Array(chunk)) {
            chunk = _uint8ArrayToBuffer(chunk);
            encoding = "buffer";
        } else {
            throw new ERR_INVALID_ARG_TYPE("chunk", [
                "string",
                "Buffer",
                "Uint8Array"
            ], chunk);
        }
    }
    let err;
    if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
    } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
    }
    if (err) {
        nextTick2(cb, err);
        errorOrDestroy2(stream, err, true);
        return err;
    }
    state.pendingcb++;
    return writeOrBuffer(stream, state, chunk, encoding, cb);
}
Writable.prototype.write = function(chunk, encoding, cb) {
    return _write(this, chunk, encoding, cb) === true;
};
Writable.prototype.cork = function() {
    this._writableState.corked++;
};
Writable.prototype.uncork = function() {
    const state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing) {
            clearBuffer(this, state);
        }
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") {
        encoding = encoding.toLowerCase();
    }
    if (!Buffer.isEncoding(encoding)) {
        throw new ERR_UNKNOWN_ENCODING(encoding);
    }
    this._writableState.defaultEncoding = encoding;
    return this;
};
function writeOrBuffer(stream, state, chunk, encoding, callback) {
    const len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    const ret = state.length < state.highWaterMark;
    if (!ret) {
        state.needDrain = true;
    }
    if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
            chunk,
            encoding,
            callback
        });
        if (state.allBuffers && encoding !== "buffer") {
            state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop2) {
            state.allNoop = false;
        }
    } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
    }
    return ret && !state.errored && !state.destroyed;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) {
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
    } else if (writev) {
        stream._writev(chunk, state.onwrite);
    } else {
        stream._write(chunk, encoding, state.onwrite);
    }
    state.sync = false;
}
function onwriteError(stream, state, er, cb) {
    --state.pendingcb;
    cb(er);
    errorBuffer(state);
    errorOrDestroy2(stream, er);
}
function onwrite(stream, er) {
    const state = stream._writableState;
    const sync = state.sync;
    const cb = state.writecb;
    if (typeof cb !== "function") {
        errorOrDestroy2(stream, new ERR_MULTIPLE_CALLBACK());
        return;
    }
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
    if (er) {
        er.stack;
        if (!state.errored) {
            state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
            stream._readableState.errored = er;
        }
        if (sync) {
            nextTick2(onwriteError, stream, state, er, cb);
        } else {
            onwriteError(stream, state, er, cb);
        }
    } else {
        if (state.buffered.length > state.bufferedIndex) {
            clearBuffer(stream, state);
        }
        if (sync) {
            if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
                state.afterWriteTickInfo.count++;
            } else {
                state.afterWriteTickInfo = {
                    count: 1,
                    cb,
                    stream,
                    state
                };
                nextTick2(afterWriteTick, state.afterWriteTickInfo);
            }
        } else {
            afterWrite(stream, state, 1, cb);
        }
    }
}
function afterWriteTick({ stream , state , count , cb  }) {
    state.afterWriteTickInfo = null;
    return afterWrite(stream, state, count, cb);
}
function afterWrite(stream, state, count, cb) {
    const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
    if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
    }
    while(count-- > 0){
        state.pendingcb--;
        cb();
    }
    if (state.destroyed) {
        errorBuffer(state);
    }
    finishMaybe(stream, state);
}
function errorBuffer(state) {
    if (state.writing) {
        return;
    }
    for(let n = state.bufferedIndex; n < state.buffered.length; ++n){
        const { chunk , callback  } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(new ERR_STREAM_DESTROYED("write"));
    }
    const onfinishCallbacks = state[kOnFinished].splice(0);
    for(let i108 = 0; i108 < onfinishCallbacks.length; i108++){
        onfinishCallbacks[i108](new ERR_STREAM_DESTROYED("end"));
    }
    resetBuffer(state);
}
function clearBuffer(stream, state) {
    if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
    }
    const { buffered , bufferedIndex , objectMode  } = state;
    const bufferedLength = buffered.length - bufferedIndex;
    if (!bufferedLength) {
        return;
    }
    let i109 = bufferedIndex;
    state.bufferProcessing = true;
    if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop2 : (err)=>{
            for(let n = i109; n < buffered.length; ++n){
                buffered[n].callback(err);
            }
        };
        const chunks = state.allNoop && i109 === 0 ? buffered : buffered.slice(i109);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
    } else {
        do {
            const { chunk , encoding , callback  } = buffered[i109];
            buffered[i109++] = null;
            const len = objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, callback);
        }while (i109 < buffered.length && !state.writing)
        if (i109 === buffered.length) {
            resetBuffer(state);
        } else if (i109 > 256) {
            buffered.splice(0, i109);
            state.bufferedIndex = 0;
        } else {
            state.bufferedIndex = i109;
        }
    }
    state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    if (this._writev) {
        this._writev([
            {
                chunk,
                encoding
            }
        ], cb);
    } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
    }
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    const state = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    let err;
    if (chunk !== null && chunk !== undefined) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error) {
            err = ret;
        }
    }
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    if (err) {} else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
    } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
    } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
    }
    if (typeof cb === "function") {
        if (err || state.finished) {
            nextTick1(cb, err);
        } else {
            state[kOnFinished].push(cb);
        }
    }
    return this;
};
function needFinish(state) {
    return state.ending && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
}
function callFinal(stream, state) {
    let called = false;
    function onFinish(err) {
        if (called) {
            errorOrDestroy2(stream, err ?? ERR_MULTIPLE_CALLBACK());
            return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
            const onfinishCallbacks = state[kOnFinished].splice(0);
            for(let i112 = 0; i112 < onfinishCallbacks.length; i112++){
                onfinishCallbacks[i112](err);
            }
            errorOrDestroy2(stream, err, state.sync);
        } else if (needFinish(state)) {
            state.prefinished = true;
            stream.emit("prefinish");
            state.pendingcb++;
            nextTick2(finish, stream, state);
        }
    }
    state.sync = true;
    state.pendingcb++;
    try {
        const result = stream._final(onFinish);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick2(onFinish, null);
                }, function(err) {
                    nextTick2(onFinish, err);
                });
            }
        }
    } catch (err) {
        onFinish(stream, state, err);
    }
    state.sync = false;
}
function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
            state.finalCalled = true;
            callFinal(stream, state);
        } else {
            state.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function finishMaybe(stream, state, sync) {
    if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0 && needFinish(state)) {
            state.pendingcb++;
            if (sync) {
                nextTick2(finish, stream, state);
            } else {
                finish(stream, state);
            }
        }
    }
}
function finish(stream, state) {
    state.pendingcb--;
    state.finished = true;
    const onfinishCallbacks = state[kOnFinished].splice(0);
    for(let i113 = 0; i113 < onfinishCallbacks.length; i113++){
        onfinishCallbacks[i113]();
    }
    stream.emit("finish");
    if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
            stream.destroy();
        }
    }
}
Object.defineProperties(Writable.prototype, {
    destroyed: {
        get () {
            return this._writableState ? this._writableState.destroyed : false;
        },
        set (value) {
            if (this._writableState) {
                this._writableState.destroyed = value;
            }
        }
    },
    writable: {
        get () {
            const w = this._writableState;
            return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set (val) {
            if (this._writableState) {
                this._writableState.writable = !!val;
            }
        }
    },
    writableFinished: {
        get () {
            return this._writableState ? this._writableState.finished : false;
        }
    },
    writableObjectMode: {
        get () {
            return this._writableState ? this._writableState.objectMode : false;
        }
    },
    writableBuffer: {
        get () {
            return this._writableState && this._writableState.getBuffer();
        }
    },
    writableEnded: {
        get () {
            return this._writableState ? this._writableState.ending : false;
        }
    },
    writableNeedDrain: {
        get () {
            const wState = this._writableState;
            if (!wState) return false;
            return !wState.destroyed && !wState.ending && wState.needDrain;
        }
    },
    writableHighWaterMark: {
        get () {
            return this._writableState && this._writableState.highWaterMark;
        }
    },
    writableCorked: {
        get () {
            return this._writableState ? this._writableState.corked : 0;
        }
    },
    writableLength: {
        get () {
            return this._writableState && this._writableState.length;
        }
    }
});
const destroy1 = __default7.destroy;
Writable.prototype.destroy = function(err, cb) {
    const state = this._writableState;
    if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        nextTick1(errorBuffer, state);
    }
    destroy1.call(this, err, cb);
    return this;
};
Writable.prototype._undestroy = __default7.undestroy;
Writable.prototype._destroy = function(err, cb) {
    cb(err);
};
Writable.prototype[EventEmitter.captureRejectionSymbol] = function(err) {
    this.destroy(err);
};
Writable.WritableState = WritableState;
Object.setPrototypeOf(Duplex.prototype, Readable.prototype);
Object.setPrototypeOf(Duplex, Readable);
{
    for (const method of Object.keys(Writable.prototype)){
        if (!Duplex.prototype[method]) {
            Duplex.prototype[method] = Writable.prototype[method];
        }
    }
}function Duplex(options) {
    if (!(this instanceof Duplex)) {
        return new Duplex(options);
    }
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) {
            this.readable = false;
        }
        if (options.writable === false) {
            this.writable = false;
        }
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
        }
    }
}
Object.defineProperties(Duplex.prototype, {
    writable: Object.getOwnPropertyDescriptor(Writable.prototype, "writable"),
    writableHighWaterMark: Object.getOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark"),
    writableObjectMode: Object.getOwnPropertyDescriptor(Writable.prototype, "writableObjectMode"),
    writableBuffer: Object.getOwnPropertyDescriptor(Writable.prototype, "writableBuffer"),
    writableLength: Object.getOwnPropertyDescriptor(Writable.prototype, "writableLength"),
    writableFinished: Object.getOwnPropertyDescriptor(Writable.prototype, "writableFinished"),
    writableCorked: Object.getOwnPropertyDescriptor(Writable.prototype, "writableCorked"),
    writableEnded: Object.getOwnPropertyDescriptor(Writable.prototype, "writableEnded"),
    writableNeedDrain: Object.getOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain"),
    destroyed: {
        get () {
            if (this._readableState === undefined || this._writableState === undefined) {
                return false;
            }
            return this._readableState.destroyed && this._writableState.destroyed;
        },
        set (value) {
            if (this._readableState && this._writableState) {
                this._readableState.destroyed = value;
                this._writableState.destroyed = value;
            }
        }
    }
});
function isReadableStream(object) {
    return object instanceof ReadableStream;
}
function isWritableStream(object) {
    return object instanceof WritableStream;
}
Duplex.fromWeb = function(pair, options) {
    validateObject(pair, "pair");
    const { readable: readableStream , writable: writableStream ,  } = pair;
    if (!isReadableStream(readableStream)) {
        throw new ERR_INVALID_ARG_TYPE("pair.readable", "ReadableStream", readableStream);
    }
    if (!isWritableStream(writableStream)) {
        throw new ERR_INVALID_ARG_TYPE("pair.writable", "WritableStream", writableStream);
    }
    validateObject(options, "options");
    const { allowHalfOpen =false , objectMode =false , encoding: encoding1 , decodeStrings =true , highWaterMark , signal ,  } = options;
    validateBoolean(objectMode, "options.objectMode");
    if (encoding1 !== undefined && !Buffer.isEncoding(encoding1)) {
        throw new ERR_INVALID_ARG_VALUE(encoding1, "options.encoding");
    }
    const writer = writableStream.getWriter();
    const reader = readableStream.getReader();
    let writableClosed = false;
    let readableClosed = false;
    const duplex = new Duplex({
        allowHalfOpen,
        highWaterMark,
        objectMode,
        encoding: encoding1,
        decodeStrings,
        signal,
        writev (chunks, callback) {
            function done(error7) {
                error7 = error7.filter((e)=>e
                );
                try {
                    callback(error7.length === 0 ? undefined : error7);
                } catch (error1) {
                    nextTick1(()=>destroy(duplex, error1)
                    );
                }
            }
            writer.ready.then(()=>Promise.All(chunks.map((data)=>writer.write(data.chunk)
                )).then(done, done)
            , done);
        },
        write (chunk, encoding, callback) {
            if (typeof chunk === "string" && decodeStrings && !objectMode) {
                chunk = Buffer.from(chunk, encoding);
                chunk = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            function done(error8) {
                try {
                    callback(error8);
                } catch (error2) {
                    destroy(duplex, error2);
                }
            }
            writer.ready.then(()=>writer.write(chunk).then(done, done)
            , done);
        },
        final (callback) {
            function done(error9) {
                try {
                    callback(error9);
                } catch (error3) {
                    nextTick1(()=>destroy(duplex, error3)
                    );
                }
            }
            if (!writableClosed) {
                writer.close().then(done, done);
            }
        },
        read () {
            reader.read().then((chunk)=>{
                if (chunk.done) {
                    duplex.push(null);
                } else {
                    duplex.push(chunk.value);
                }
            }, (error10)=>destroy(duplex, error10)
            );
        },
        destroy (error4, callback) {
            function done() {
                try {
                    callback(error4);
                } catch (error11) {
                    nextTick1(()=>{
                        throw error11;
                    });
                }
            }
            async function closeWriter() {
                if (!writableClosed) {
                    await writer.abort(error4);
                }
            }
            async function closeReader() {
                if (!readableClosed) {
                    await reader.cancel(error4);
                }
            }
            if (!writableClosed || !readableClosed) {
                Promise.All([
                    closeWriter(),
                    closeReader(), 
                ]).then(done, done);
                return;
            }
            done();
        }
    });
    writer.closed.then(()=>{
        writableClosed = true;
        if (!isWritableEnded(duplex)) {
            destroy(duplex, new ERR_STREAM_PREMATURE_CLOSE());
        }
    }, (error12)=>{
        writableClosed = true;
        readableClosed = true;
        destroy(duplex, error12);
    });
    reader.closed.then(()=>{
        readableClosed = true;
        if (!isReadableEnded1(duplex)) {
            duplex.push(null);
        }
    }, (error13)=>{
        writableClosed = true;
        readableClosed = true;
        destroy(duplex, error13);
    });
    return duplex;
};
class Duplexify extends Duplex {
    constructor(options){
        super(options);
        if (options?.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
        }
        if (options?.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
        }
    }
}
function duplexify(body, name37) {
    if (isDuplexNodeStream(body)) {
        return body;
    }
    if (isReadableNodeStream(body)) {
        return _duplexify({
            readable: body
        });
    }
    if (isWritableNodeStream(body)) {
        return _duplexify({
            writable: body
        });
    }
    if (isNodeStream(body)) {
        return _duplexify({
            writable: false,
            readable: false
        });
    }
    if (typeof body === "function") {
        const { value , write: write1 , final: __final1 , destroy  } = fromAsyncGen(body);
        if (isIterable(value)) {
            return _from1(Duplexify, value, {
                objectMode: true,
                write: write1,
                final: __final1,
                destroy
            });
        }
        const then = value?.then;
        if (typeof then === "function") {
            let d;
            const promise = then.call(value, (val)=>{
                if (val != null) {
                    throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
                }
            }, (err)=>{
                destroyer(d, err);
            });
            return d = new Duplexify({
                objectMode: true,
                readable: false,
                write: write1,
                final (cb) {
                    __final1(async ()=>{
                        try {
                            await promise;
                            nextTick1(cb, null);
                        } catch (err) {
                            nextTick1(cb, err);
                        }
                    });
                },
                destroy
            });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name37, value);
    }
    if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
    }
    if (isIterable(body)) {
        return _from1(Duplexify, body, {
            objectMode: true,
            writable: false
        });
    }
    if (typeof body?.writable === "object" || typeof body?.readable === "object") {
        const readable = body?.readable ? isReadableNodeStream(body?.readable) ? body?.readable : duplexify(body.readable) : undefined;
        const writable = body?.writable ? isWritableNodeStream(body?.writable) ? body?.writable : duplexify(body.writable) : undefined;
        return _duplexify({
            readable,
            writable
        });
    }
    const then = body?.then;
    if (typeof then === "function") {
        let d;
        then.call(body, (val)=>{
            if (val != null) {
                d.push(val);
            }
            d.push(null);
        }, (err)=>{
            destroyer(d, err);
        });
        return d = new Duplexify({
            objectMode: true,
            writable: false,
            read () {}
        });
    }
    throw new ERR_INVALID_ARG_TYPE(name37, [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise", 
    ], body);
}
function fromAsyncGen(fn) {
    let { promise , resolve: resolve12  } = createDeferredPromise();
    const ac = new AbortController();
    const signal = ac.signal;
    const value = fn(async function*() {
        while(true){
            const _promise = promise;
            promise = null;
            const { chunk , done , cb  } = await _promise;
            nextTick2(cb);
            if (done) return;
            if (signal.aborted) throw new AbortError();
            ({ promise , resolve: resolve12  } = createDeferredPromise());
            yield chunk;
        }
    }(), {
        signal
    });
    return {
        value,
        write (chunk, encoding, cb) {
            const _resolve = resolve12;
            resolve12 = null;
            _resolve({
                chunk,
                done: false,
                cb
            });
        },
        final (cb) {
            const _resolve = resolve12;
            resolve12 = null;
            _resolve({
                done: true,
                cb
            });
        },
        destroy (err, cb) {
            ac.abort();
            cb(err);
        }
    };
}
function _duplexify(pair) {
    const r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
    const w = pair.writable;
    let readable = !!isReadable1(r);
    let writable = !!isWritable1(w);
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;
    function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
            cb(err);
        } else if (err) {
            d.destroy(err);
        } else if (!readable && !writable) {
            d.destroy();
        }
    }
    d = new Duplexify({
        readableObjectMode: !!r?.readableObjectMode,
        writableObjectMode: !!w?.writableObjectMode,
        readable,
        writable
    });
    if (writable) {
        eos(w, (err)=>{
            writable = false;
            if (err) {
                destroyer(r, err);
            }
            onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
            if (w.write(chunk, encoding)) {
                callback();
            } else {
                ondrain = callback;
            }
        };
        d._final = function(callback) {
            w.end();
            onfinish = callback;
        };
        w.on("drain", function() {
            if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
            }
        });
        w.on("finish", function() {
            if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
            }
        });
    }
    if (readable) {
        eos(r, (err)=>{
            readable = false;
            if (err) {
                destroyer(r, err);
            }
            onfinished(err);
        });
        r.on("readable", function() {
            if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
            }
        });
        r.on("end", function() {
            d.push(null);
        });
        d._read = function() {
            while(true){
                const buf = r.read();
                if (buf === null) {
                    onreadable = d._read;
                    return;
                }
                if (!d.push(buf)) {
                    return;
                }
            }
        };
    }
    d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
            err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
            callback(err);
        } else {
            onclose = callback;
            destroyer(w, err);
            destroyer(r, err);
        }
    };
    return d;
}
function duplexFrom(body) {
    return duplexify(body, "body");
}
Duplex.from = duplexFrom;
Object.setPrototypeOf(Transform.prototype, Duplex.prototype);
Object.setPrototypeOf(Transform, Duplex);
const kCallback = Symbol("kCallback");
function Transform(options) {
    if (!(this instanceof Transform)) {
        return new Transform(options);
    }
    Duplex.call(this, options);
    this._readableState.sync = false;
    this[kCallback] = null;
    if (options) {
        if (typeof options.transform === "function") {
            this._transform = options.transform;
        }
        if (typeof options.flush === "function") {
            this._flush = options.flush;
        }
    }
    this.on("prefinish", prefinish1);
}
function __final(cb) {
    let called = false;
    if (typeof this._flush === "function" && !this.destroyed) {
        const result = this._flush((er, data)=>{
            called = true;
            if (er) {
                if (cb) {
                    cb(er);
                } else {
                    this.destroy(er);
                }
                return;
            }
            if (data != null) {
                this.push(data);
            }
            this.push(null);
            if (cb) {
                cb();
            }
        });
        if (result !== undefined && result !== null) {
            try {
                const then = result.then;
                if (typeof then === "function") {
                    then.call(result, (data)=>{
                        if (called) {
                            return;
                        }
                        if (data != null) {
                            this.push(data);
                        }
                        this.push(null);
                        if (cb) {
                            nextTick2(cb);
                        }
                    }, (err)=>{
                        if (cb) {
                            nextTick2(cb, err);
                        } else {
                            nextTick2(()=>this.destroy(err)
                            );
                        }
                    });
                }
            } catch (err) {
                nextTick2(()=>this.destroy(err)
                );
            }
        }
    } else {
        this.push(null);
        if (cb) {
            cb();
        }
    }
}
function prefinish1() {
    if (this._final !== __final) {
        __final.call(this);
    }
}
Transform.prototype._final = __final;
Transform.prototype._transform = function(chunk, encoding, callback) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
};
Transform.prototype._write = function(chunk, encoding, callback) {
    const rState = this._readableState;
    const wState = this._writableState;
    const length = rState.length;
    let called = false;
    const result = this._transform(chunk, encoding, (err, val)=>{
        called = true;
        if (err) {
            callback(err);
            return;
        }
        if (val != null) {
            this.push(val);
        }
        if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
            callback();
        } else {
            this[kCallback] = callback;
        }
    });
    if (result !== undefined && result != null) {
        try {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, (val)=>{
                    if (called) {
                        return;
                    }
                    if (val != null) {
                        this.push(val);
                    }
                    if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
                        nextTick1(callback);
                    } else {
                        this[kCallback] = callback;
                    }
                }, (err)=>{
                    nextTick1(callback, err);
                });
            }
        } catch (err) {
            nextTick1(callback, err);
        }
    }
};
Transform.prototype._read = function() {
    if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
    }
};
Object.setPrototypeOf(PassThrough.prototype, Transform.prototype);
Object.setPrototypeOf(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) {
        return new PassThrough(options);
    }
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};
function destroyer1(stream, reading, writing, callback) {
    callback = once(callback);
    let finished2 = false;
    stream.on("close", ()=>{
        finished2 = true;
    });
    eos(stream, {
        readable: reading,
        writable: writing
    }, (err)=>{
        finished2 = !err;
        const rState = stream._readableState;
        if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && reading && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            stream.once("end", callback).once("error", callback);
        } else {
            callback(err);
        }
    });
    return (err)=>{
        if (finished2) return;
        finished2 = true;
        __default7.destroyer(stream, err);
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
}
function popCallback(streams) {
    validateCallback(streams[streams.length - 1]);
    return streams.pop();
}
function makeAsyncIterable(val) {
    if (isIterable(val)) {
        return val;
    } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
    }
    throw new ERR_INVALID_ARG_TYPE("val", [
        "Readable",
        "Iterable",
        "AsyncIterable"
    ], val);
}
async function* fromReadable(val) {
    yield* Readable.prototype[Symbol.asyncIterator].call(val);
}
async function pump(iterable, writable, finish1) {
    let error14;
    let onresolve = null;
    const resume1 = (err)=>{
        if (err) {
            error14 = err;
        }
        if (onresolve) {
            const callback = onresolve;
            onresolve = null;
            callback();
        }
    };
    const wait = ()=>new Promise((resolve13, reject)=>{
            if (error14) {
                reject(error14);
            } else {
                onresolve = ()=>{
                    if (error14) {
                        reject(error14);
                    } else {
                        resolve13();
                    }
                };
            }
        })
    ;
    writable.on("drain", resume1);
    const cleanup = eos(writable, {
        readable: false
    }, resume1);
    try {
        if (writable.writableNeedDrain) {
            await wait();
        }
        for await (const chunk of iterable){
            if (!writable.write(chunk)) {
                await wait();
            }
        }
        writable.end();
        await wait();
        finish1();
    } catch (err) {
        finish1(error14 !== err ? aggregateTwoErrors(error14, err) : err);
    } finally{
        cleanup();
        writable.off("drain", resume1);
    }
}
function pipeline(...streams) {
    const callback = once(popCallback(streams));
    if (Array.isArray(streams[0]) && streams.length === 1) {
        streams = streams[0];
    }
    return pipelineImpl(streams, callback);
}
function pipelineImpl(streams, callback, opts) {
    if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
    }
    const ac = new AbortController();
    const signal = ac.signal;
    const outerSignal = opts?.signal;
    validateAbortSignal(outerSignal, "options.signal");
    function abort() {
        finishImpl(new AbortError());
    }
    outerSignal?.addEventListener("abort", abort);
    let error15;
    let value;
    const destroys = [];
    let finishCount = 0;
    function finish2(err) {
        finishImpl(err, --finishCount === 0);
    }
    function finishImpl(err, __final2) {
        if (err && (!error15 || error15.code === "ERR_STREAM_PREMATURE_CLOSE")) {
            error15 = err;
        }
        if (!error15 && !__final2) {
            return;
        }
        while(destroys.length){
            destroys.shift()(error15);
        }
        outerSignal?.removeEventListener("abort", abort);
        ac.abort();
        if (__final2) {
            callback(error15, value);
        }
    }
    let ret;
    for(let i114 = 0; i114 < streams.length; i114++){
        const stream = streams[i114];
        const reading = i114 < streams.length - 1;
        const writing = i114 > 0;
        if (isNodeStream(stream)) {
            finishCount++;
            destroys.push(destroyer1(stream, reading, writing, finish2));
        }
        if (i114 === 0) {
            if (typeof stream === "function") {
                ret = stream({
                    signal
                });
                if (!isIterable(ret)) {
                    throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
                }
            } else if (isIterable(stream) || isReadableNodeStream(stream)) {
                ret = stream;
            } else {
                ret = Duplex.from(stream);
            }
        } else if (typeof stream === "function") {
            ret = makeAsyncIterable(ret);
            ret = stream(ret, {
                signal
            });
            if (reading) {
                if (!isIterable(ret, true)) {
                    throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i114 - 1}]`, ret);
                }
            } else {
                const pt = new PassThrough({
                    objectMode: true
                });
                const then = ret?.then;
                if (typeof then === "function") {
                    then.call(ret, (val)=>{
                        value = val;
                        pt.end(val);
                    }, (err)=>{
                        pt.destroy(err);
                    });
                } else if (isIterable(ret, true)) {
                    finishCount++;
                    pump(ret, pt, finish2);
                } else {
                    throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
                }
                ret = pt;
                finishCount++;
                destroys.push(destroyer1(ret, false, true, finish2));
            }
        } else if (isNodeStream(stream)) {
            if (isReadableNodeStream(ret)) {
                ret.pipe(stream);
                if (stream === stdio.stdout || stream === stdio.stderr) {
                    ret.on("end", ()=>stream.end()
                    );
                }
            } else {
                ret = makeAsyncIterable(ret);
                finishCount++;
                pump(ret, stream, finish2);
            }
            ret = stream;
        } else {
            ret = Duplex.from(stream);
        }
    }
    if (signal?.aborted || outerSignal?.aborted) {
        nextTick2(abort);
    }
    return ret;
}
class ComposeDuplex extends Duplex {
    constructor(options){
        super(options);
        if (options?.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
        }
        if (options?.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
        }
    }
}
function compose(...streams) {
    if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
    }
    if (streams.length === 1) {
        return Duplex.from(streams[0]);
    }
    const orgStreams = [
        ...streams
    ];
    if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
    }
    if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
    }
    for(let n = 0; n < streams.length; ++n){
        if (!isNodeStream(streams[n])) {
            continue;
        }
        if (n < streams.length - 1 && !isReadable1(streams[n])) {
            throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !isWritable1(streams[n])) {
            throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
    }
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;
    function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
            cb(err);
        } else if (err) {
            d.destroy(err);
        } else if (!readable && !writable) {
            d.destroy();
        }
    }
    const head = streams[0];
    const tail = pipeline(streams, onfinished);
    const writable = !!isWritable1(head);
    const readable = !!isReadable1(tail);
    d = new ComposeDuplex({
        writableObjectMode: !!head?.writableObjectMode,
        readableObjectMode: !!tail?.writableObjectMode,
        writable,
        readable
    });
    if (writable) {
        d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
                callback();
            } else {
                ondrain = callback;
            }
        };
        d._final = function(callback) {
            head.end();
            onfinish = callback;
        };
        head.on("drain", function() {
            if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
            }
        });
        tail.on("finish", function() {
            if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
            }
        });
    }
    if (readable) {
        tail.on("readable", function() {
            if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
            }
        });
        tail.on("end", function() {
            d.push(null);
        });
        d._read = function() {
            while(true){
                const buf = tail.read();
                if (buf === null) {
                    onreadable = d._read;
                    return;
                }
                if (!d.push(buf)) {
                    return;
                }
            }
        };
    }
    d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
            err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
            callback(err);
        } else {
            onclose = callback;
            destroyer(tail, err);
        }
    };
    return d;
}
function pipeline1(...streams) {
    return new Promise((resolve14, reject)=>{
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg)) {
            const options = streams.pop();
            signal = options.signal;
            end = options.end;
        }
        pipelineImpl(streams, (err, value)=>{
            if (err) {
                reject(err);
            } else {
                resolve14(value);
            }
        }, {
            signal,
            end
        });
    });
}
function finished(stream, opts) {
    return new Promise((resolve15, reject)=>{
        eos(stream, opts, (err)=>{
            if (err) {
                reject(err);
            } else {
                resolve15();
            }
        });
    });
}
const __default8 = {
    finished,
    pipeline: pipeline1
};
const { custom: customPromisify  } = promisify;
Stream.isDisturbed = isDisturbed;
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform;
Stream.PassThrough = PassThrough;
Stream.pipeline = pipeline;
Stream.addAbortSignal = addAbortSignal;
Stream.finished = eos;
Stream.destroy = destroyer;
Stream.compose = compose;
Object.defineProperty(Stream, "promises", {
    configurable: true,
    enumerable: true,
    get () {
        return __default8;
    }
});
Object.defineProperty(pipeline, customPromisify, {
    enumerable: true,
    get () {
        return __default8.pipeline;
    }
});
Object.defineProperty(eos, customPromisify, {
    enumerable: true,
    get () {
        return __default8.finished;
    }
});
Stream.Stream = Stream;
Stream._isUint8Array = isUint8Array;
Stream._uint8ArrayToBuffer = _uint8ArrayToBuffer;
function createWritableStdioStream(writer, name38) {
    const stream = new Writable({
        write (buf, enc, cb) {
            if (!writer) {
                this.destroy(new Error(`Deno.${name38} is not available in this environment`));
                return;
            }
            writer.writeSync(buf instanceof Uint8Array ? buf : Buffer.from(buf, enc));
            cb();
        },
        destroy (err, cb) {
            cb(err);
            this._undestroy();
            if (!this._writableState.emitClose) {
                nextTick(()=>this.emit("close")
                );
            }
        }
    });
    stream.fd = writer?.rid ?? -1;
    stream.destroySoon = stream.destroy;
    stream._isStdio = true;
    stream.once("close", ()=>writer?.close()
    );
    Object.defineProperties(stream, {
        columns: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).columns : undefined
        },
        rows: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).rows : undefined
        },
        isTTY: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid)
        },
        getWindowSize: {
            enumerable: true,
            configurable: true,
            value: ()=>Deno.isatty?.(writer?.rid) ? Object.values(Deno.consoleSize?.(writer?.rid)) : undefined
        }
    });
    if (Deno.isatty?.(writer?.rid)) {
        stream.cursorTo = function(x, y, callback) {
            return cursorTo(this, x, y, callback);
        };
        stream.moveCursor = function(dx, dy, callback) {
            return moveCursor(this, dx, dy, callback);
        };
        stream.clearLine = function(dir, callback) {
            return clearLine(this, dir, callback);
        };
        stream.clearScreenDown = function(callback) {
            return clearScreenDown(this, callback);
        };
    }
    return stream;
}
const stderr = stdio.stderr = createWritableStdioStream(Deno.stderr, "stderr");
const stdout = stdio.stdout = createWritableStdioStream(Deno.stdout, "stdout");
const stdin = stdio.stdin = new Readable({
    highWaterMark: 0,
    emitClose: false,
    read (size) {
        const p = Buffer.alloc(size || 16 * 1024);
        if (!Deno.stdin) {
            this.destroy(new Error("Deno.stdin is not available in this environment"));
            return;
        }
        Deno.stdin.read(p).then((length)=>{
            this.push(length === null ? null : p.slice(0, length));
        }, (error16)=>{
            this.destroy(error16);
        });
    }
});
stdin.on("close", ()=>Deno.stdin?.close()
);
stdin.fd = Deno.stdin?.rid ?? -1;
Object.defineProperty(stdin, "isTTY", {
    enumerable: true,
    configurable: true,
    get () {
        return Deno.isatty?.(Deno.stdin.rid);
    }
});
stdin._isRawMode = false;
stdin.setRawMode = (enable)=>{
    setRaw?.(Deno.stdin?.rid, enable);
    stdin._isRawMode = enable;
    return stdin;
};
Object.defineProperty(stdin, "isRaw", {
    enumerable: true,
    configurable: true,
    get () {
        return stdin._isRawMode;
    }
});
function registerDestroyHook(_target, _asyncId, _prop) {}
var constants;
(function(constants3) {
    constants3[constants3["kInit"] = 0] = "kInit";
    constants3[constants3["kBefore"] = 1] = "kBefore";
    constants3[constants3["kAfter"] = 2] = "kAfter";
    constants3[constants3["kDestroy"] = 3] = "kDestroy";
    constants3[constants3["kPromiseResolve"] = 4] = "kPromiseResolve";
    constants3[constants3["kTotals"] = 5] = "kTotals";
    constants3[constants3["kCheck"] = 6] = "kCheck";
    constants3[constants3["kExecutionAsyncId"] = 7] = "kExecutionAsyncId";
    constants3[constants3["kTriggerAsyncId"] = 8] = "kTriggerAsyncId";
    constants3[constants3["kAsyncIdCounter"] = 9] = "kAsyncIdCounter";
    constants3[constants3["kDefaultTriggerAsyncId"] = 10] = "kDefaultTriggerAsyncId";
    constants3[constants3["kUsesExecutionAsyncResource"] = 11] = "kUsesExecutionAsyncResource";
    constants3[constants3["kStackLength"] = 12] = "kStackLength";
})(constants || (constants = {}));
const asyncHookFields = new Uint32Array(Object.keys(constants).length);
function newAsyncId() {
    return ++asyncIdFields[constants.kAsyncIdCounter];
}
var UidFields;
(function(UidFields1) {
    UidFields1[UidFields1["kExecutionAsyncId"] = 0] = "kExecutionAsyncId";
    UidFields1[UidFields1["kTriggerAsyncId"] = 1] = "kTriggerAsyncId";
    UidFields1[UidFields1["kAsyncIdCounter"] = 2] = "kAsyncIdCounter";
    UidFields1[UidFields1["kDefaultTriggerAsyncId"] = 3] = "kDefaultTriggerAsyncId";
    UidFields1[UidFields1["kUidFieldsCount"] = 4] = "kUidFieldsCount";
})(UidFields || (UidFields = {}));
const asyncIdFields = new Float64Array(Object.keys(UidFields).length);
asyncIdFields[UidFields.kAsyncIdCounter] = 1;
asyncIdFields[UidFields.kDefaultTriggerAsyncId] = -1;
var providerType;
(function(providerType1) {
    providerType1[providerType1["NONE"] = 0] = "NONE";
    providerType1[providerType1["DIRHANDLE"] = 1] = "DIRHANDLE";
    providerType1[providerType1["DNSCHANNEL"] = 2] = "DNSCHANNEL";
    providerType1[providerType1["ELDHISTOGRAM"] = 3] = "ELDHISTOGRAM";
    providerType1[providerType1["FILEHANDLE"] = 4] = "FILEHANDLE";
    providerType1[providerType1["FILEHANDLECLOSEREQ"] = 5] = "FILEHANDLECLOSEREQ";
    providerType1[providerType1["FIXEDSIZEBLOBCOPY"] = 6] = "FIXEDSIZEBLOBCOPY";
    providerType1[providerType1["FSEVENTWRAP"] = 7] = "FSEVENTWRAP";
    providerType1[providerType1["FSREQCALLBACK"] = 8] = "FSREQCALLBACK";
    providerType1[providerType1["FSREQPROMISE"] = 9] = "FSREQPROMISE";
    providerType1[providerType1["GETADDRINFOREQWRAP"] = 10] = "GETADDRINFOREQWRAP";
    providerType1[providerType1["GETNAMEINFOREQWRAP"] = 11] = "GETNAMEINFOREQWRAP";
    providerType1[providerType1["HEAPSNAPSHOT"] = 12] = "HEAPSNAPSHOT";
    providerType1[providerType1["HTTP2SESSION"] = 13] = "HTTP2SESSION";
    providerType1[providerType1["HTTP2STREAM"] = 14] = "HTTP2STREAM";
    providerType1[providerType1["HTTP2PING"] = 15] = "HTTP2PING";
    providerType1[providerType1["HTTP2SETTINGS"] = 16] = "HTTP2SETTINGS";
    providerType1[providerType1["HTTPINCOMINGMESSAGE"] = 17] = "HTTPINCOMINGMESSAGE";
    providerType1[providerType1["HTTPCLIENTREQUEST"] = 18] = "HTTPCLIENTREQUEST";
    providerType1[providerType1["JSSTREAM"] = 19] = "JSSTREAM";
    providerType1[providerType1["JSUDPWRAP"] = 20] = "JSUDPWRAP";
    providerType1[providerType1["MESSAGEPORT"] = 21] = "MESSAGEPORT";
    providerType1[providerType1["PIPECONNECTWRAP"] = 22] = "PIPECONNECTWRAP";
    providerType1[providerType1["PIPESERVERWRAP"] = 23] = "PIPESERVERWRAP";
    providerType1[providerType1["PIPEWRAP"] = 24] = "PIPEWRAP";
    providerType1[providerType1["PROCESSWRAP"] = 25] = "PROCESSWRAP";
    providerType1[providerType1["PROMISE"] = 26] = "PROMISE";
    providerType1[providerType1["QUERYWRAP"] = 27] = "QUERYWRAP";
    providerType1[providerType1["SHUTDOWNWRAP"] = 28] = "SHUTDOWNWRAP";
    providerType1[providerType1["SIGNALWRAP"] = 29] = "SIGNALWRAP";
    providerType1[providerType1["STATWATCHER"] = 30] = "STATWATCHER";
    providerType1[providerType1["STREAMPIPE"] = 31] = "STREAMPIPE";
    providerType1[providerType1["TCPCONNECTWRAP"] = 32] = "TCPCONNECTWRAP";
    providerType1[providerType1["TCPSERVERWRAP"] = 33] = "TCPSERVERWRAP";
    providerType1[providerType1["TCPWRAP"] = 34] = "TCPWRAP";
    providerType1[providerType1["TTYWRAP"] = 35] = "TTYWRAP";
    providerType1[providerType1["UDPSENDWRAP"] = 36] = "UDPSENDWRAP";
    providerType1[providerType1["UDPWRAP"] = 37] = "UDPWRAP";
    providerType1[providerType1["SIGINTWATCHDOG"] = 38] = "SIGINTWATCHDOG";
    providerType1[providerType1["WORKER"] = 39] = "WORKER";
    providerType1[providerType1["WORKERHEAPSNAPSHOT"] = 40] = "WORKERHEAPSNAPSHOT";
    providerType1[providerType1["WRITEWRAP"] = 41] = "WRITEWRAP";
    providerType1[providerType1["ZLIB"] = 42] = "ZLIB";
})(providerType || (providerType = {}));
const kInvalidAsyncId = -1;
class AsyncWrap {
    provider = providerType.NONE;
    asyncId = kInvalidAsyncId;
    constructor(provider){
        this.provider = provider;
        this.getAsyncId();
    }
    getAsyncId() {
        this.asyncId = this.asyncId === kInvalidAsyncId ? newAsyncId() : this.asyncId;
        return this.asyncId;
    }
    getProviderType() {
        return this.provider;
    }
}
const mod11 = {
    async_hook_fields: asyncHookFields,
    asyncIdFields: asyncIdFields,
    registerDestroyHook: registerDestroyHook,
    constants: constants,
    newAsyncId: newAsyncId,
    UidFields: UidFields,
    providerType: providerType,
    AsyncWrap: AsyncWrap
};
const mod12 = {};
const v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
const v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
const IPv4Reg = new RegExp(`^${v4Str}$`);
const v6Seg = "(?:[0-9a-fA-F]{1,4})";
const IPv6Reg = new RegExp("^(" + `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` + `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` + `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` + `(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` + `(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` + `(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` + `(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` + `(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` + ")(%[0-9a-zA-Z-.:]{1,})?$");
function isIPv4(ip) {
    return RegExp.prototype.test.call(IPv4Reg, ip);
}
function isIPv6(ip) {
    return RegExp.prototype.test.call(IPv6Reg, ip);
}
function isIP(ip) {
    if (isIPv4(ip)) {
        return 4;
    }
    if (isIPv6(ip)) {
        return 6;
    }
    return 0;
}
Symbol("normalizedArgs");
function ares_strerror(code) {
    const errorText = [
        "Successful completion",
        "DNS server returned answer with no data",
        "DNS server claims query was misformatted",
        "DNS server returned general failure",
        "Domain name not found",
        "DNS server does not implement requested operation",
        "DNS server refused query",
        "Misformatted DNS query",
        "Misformatted domain name",
        "Unsupported address family",
        "Misformatted DNS reply",
        "Could not contact DNS servers",
        "Timeout while contacting DNS servers",
        "End of file",
        "Error reading file",
        "Out of memory",
        "Channel is being destroyed",
        "Misformatted string",
        "Illegal flags specified",
        "Given hostname is not numeric",
        "Illegal hints flags specified",
        "c-ares library initialization not yet performed",
        "Error loading iphlpapi.dll",
        "Could not find GetNetworkParams function",
        "DNS query cancelled", 
    ];
    if (code >= 0 && code < errorText.length) {
        return errorText[code];
    } else {
        return "unknown";
    }
}
class GetAddrInfoReqWrap extends AsyncWrap {
    family;
    hostname;
    callback;
    resolve;
    reject;
    oncomplete;
    constructor(){
        super(providerType.GETADDRINFOREQWRAP);
    }
}
function getaddrinfo(req, hostname9, family, _hints, verbatim) {
    let addresses = [];
    const recordTypes = [];
    if (family === 0 || family === 4) {
        recordTypes.push("A");
    }
    if (family === 0 || family === 6) {
        recordTypes.push("AAAA");
    }
    (async ()=>{
        await Promise.allSettled(recordTypes.map((recordType)=>Deno.resolveDns(hostname9, recordType).then((records)=>{
                records.forEach((record)=>addresses.push(record)
                );
            })
        ));
        const error17 = addresses.length ? 0 : codeMap.get("EAI_NODATA");
        if (!verbatim) {
            addresses.sort((a, b)=>{
                if (isIPv4(a)) {
                    return -1;
                } else if (isIPv4(b)) {
                    return 1;
                }
                return 0;
            });
        }
        if (isWindows && hostname9 === "localhost") {
            addresses = addresses.filter((address)=>isIPv4(address)
            );
        }
        req.oncomplete(error17, addresses);
    })();
    return 0;
}
class QueryReqWrap extends AsyncWrap {
    bindingName;
    hostname;
    ttl;
    callback;
    resolve;
    reject;
    oncomplete;
    constructor(){
        super(providerType.QUERYWRAP);
    }
}
function fqdnToHostname(fqdn) {
    return fqdn.replace(/\.$/, "");
}
function compressIPv6(address) {
    const formatted = address.replace(/\b(?:0+:){2,}/, ":");
    const finalAddress = formatted.split(":").map((octet)=>{
        if (octet.match(/^\d+\.\d+\.\d+\.\d+$/)) {
            return Number(octet.replaceAll(".", "")).toString(16);
        }
        return octet.replace(/\b0+/g, "");
    }).join(":");
    return finalAddress;
}
class ChannelWrap extends AsyncWrap {
    #servers = [];
    #timeout;
    #tries;
    constructor(timeout, tries){
        super(providerType.DNSCHANNEL);
        this.#timeout = timeout;
        this.#tries = tries;
    }
    async #query(query, recordType) {
        let code;
        let ret;
        if (this.#servers.length) {
            for (const [ipAddr, port] of this.#servers){
                const resolveOptions = {
                    nameServer: {
                        ipAddr,
                        port
                    }
                };
                ({ code , ret  } = await this.#resolve(query, recordType, resolveOptions));
                if (code === 0 || code === codeMap.get("EAI_NODATA")) {
                    break;
                }
            }
        } else {
            ({ code , ret  } = await this.#resolve(query, recordType));
        }
        return {
            code: code,
            ret: ret
        };
    }
    async #resolve(query1, recordType1, resolveOptions) {
        let ret = [];
        let code = 0;
        try {
            ret = await Deno.resolveDns(query1, recordType1, resolveOptions);
        } catch (e) {
            if (e instanceof Deno.errors.NotFound) {
                code = codeMap.get("EAI_NODATA");
            } else {
                code = codeMap.get("UNKNOWN");
            }
        }
        return {
            code,
            ret
        };
    }
    queryAny(req, name39) {
        (async ()=>{
            const records = [];
            await Promise.allSettled([
                this.#query(name39, "A").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "A",
                            address: record
                        })
                    );
                }),
                this.#query(name39, "AAAA").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "AAAA",
                            address: compressIPv6(record)
                        })
                    );
                }),
                this.#query(name39, "CAA").then(({ ret  })=>{
                    ret.forEach(({ critical , tag , value  })=>records.push({
                            type: "CAA",
                            [tag]: value,
                            critical: +critical && 128
                        })
                    );
                }),
                this.#query(name39, "CNAME").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "CNAME",
                            value: record
                        })
                    );
                }),
                this.#query(name39, "MX").then(({ ret  })=>{
                    ret.forEach(({ preference , exchange  })=>records.push({
                            type: "MX",
                            priority: preference,
                            exchange: fqdnToHostname(exchange)
                        })
                    );
                }),
                this.#query(name39, "NAPTR").then(({ ret  })=>{
                    ret.forEach(({ order , preference , flags , services , regexp , replacement  })=>records.push({
                            type: "NAPTR",
                            order,
                            preference,
                            flags,
                            service: services,
                            regexp,
                            replacement
                        })
                    );
                }),
                this.#query(name39, "NS").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "NS",
                            value: fqdnToHostname(record)
                        })
                    );
                }),
                this.#query(name39, "PTR").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "PTR",
                            value: fqdnToHostname(record)
                        })
                    );
                }),
                this.#query(name39, "SOA").then(({ ret  })=>{
                    ret.forEach(({ mname , rname , serial , refresh , retry , expire , minimum  })=>records.push({
                            type: "SOA",
                            nsname: fqdnToHostname(mname),
                            hostmaster: fqdnToHostname(rname),
                            serial,
                            refresh,
                            retry,
                            expire,
                            minttl: minimum
                        })
                    );
                }),
                this.#query(name39, "SRV").then(({ ret  })=>{
                    ret.forEach(({ priority , weight , port , target  })=>records.push({
                            type: "SRV",
                            priority,
                            weight,
                            port,
                            name: target
                        })
                    );
                }),
                this.#query(name39, "TXT").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "TXT",
                            entries: record
                        })
                    );
                }), 
            ]);
            const err = records.length ? 0 : codeMap.get("EAI_NODATA");
            req.oncomplete(err, records);
        })();
        return 0;
    }
    queryA(req, name40) {
        this.#query(name40, "A").then(({ code , ret  })=>{
            req.oncomplete(code, ret);
        });
        return 0;
    }
    queryAaaa(req, name41) {
        this.#query(name41, "AAAA").then(({ code , ret  })=>{
            const records = ret.map((record)=>compressIPv6(record)
            );
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryCaa(req, name42) {
        this.#query(name42, "CAA").then(({ code , ret  })=>{
            const records = ret.map(({ critical , tag , value  })=>({
                    [tag]: value,
                    critical: +critical && 128
                })
            );
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryCname(req, name43) {
        this.#query(name43, "CNAME").then(({ code , ret  })=>{
            req.oncomplete(code, ret);
        });
        return 0;
    }
    queryMx(req, name44) {
        this.#query(name44, "MX").then(({ code , ret  })=>{
            const records = ret.map(({ preference , exchange  })=>({
                    priority: preference,
                    exchange: fqdnToHostname(exchange)
                })
            );
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryNaptr(req, name45) {
        this.#query(name45, "NAPTR").then(({ code , ret  })=>{
            const records = ret.map(({ order , preference , flags , services , regexp , replacement  })=>({
                    flags,
                    service: services,
                    regexp,
                    replacement,
                    order,
                    preference
                })
            );
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryNs(req, name46) {
        this.#query(name46, "NS").then(({ code , ret  })=>{
            const records = ret.map((record)=>fqdnToHostname(record)
            );
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryPtr(req, name47) {
        this.#query(name47, "PTR").then(({ code , ret  })=>{
            const records = ret.map((record)=>fqdnToHostname(record)
            );
            req.oncomplete(code, records);
        });
        return 0;
    }
    querySoa(req, name48) {
        this.#query(name48, "SOA").then(({ code , ret  })=>{
            let record = {};
            if (ret.length) {
                const { mname , rname , serial , refresh , retry , expire , minimum  } = ret[0];
                record = {
                    nsname: fqdnToHostname(mname),
                    hostmaster: fqdnToHostname(rname),
                    serial,
                    refresh,
                    retry,
                    expire,
                    minttl: minimum
                };
            }
            req.oncomplete(code, record);
        });
        return 0;
    }
    querySrv(req, name49) {
        this.#query(name49, "SRV").then(({ code , ret  })=>{
            const records = ret.map(({ priority , weight , port , target  })=>({
                    priority,
                    weight,
                    port,
                    name: target
                })
            );
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryTxt(req, name50) {
        this.#query(name50, "TXT").then(({ code , ret  })=>{
            req.oncomplete(code, ret);
        });
        return 0;
    }
    getHostByAddr(_req, _name) {
        notImplemented("cares.ChannelWrap.prototype.getHostByAddr");
    }
    getServers() {
        return this.#servers;
    }
    setServers(servers) {
        if (typeof servers === "string") {
            const tuples = [];
            for(let i115 = 0; i115 < servers.length; i115 += 2){
                tuples.push([
                    servers[i115],
                    parseInt(servers[i115 + 1])
                ]);
            }
            this.#servers = tuples;
        } else {
            this.#servers = servers.map(([_ipVersion, ip, port])=>[
                    ip,
                    port
                ]
            );
        }
        return 0;
    }
    setLocalAddress(_addr0, _addr1) {
        notImplemented("cares.ChannelWrap.prototype.setLocalAddress");
    }
    cancel() {
        notImplemented("cares.ChannelWrap.prototype.cancel");
    }
}
const DNS_ESETSRVPENDING = -1000;
const EMSG_ESETSRVPENDING = "There are pending queries.";
function strerror(code) {
    return code === DNS_ESETSRVPENDING ? EMSG_ESETSRVPENDING : ares_strerror(code);
}
const mod13 = {
    GetAddrInfoReqWrap: GetAddrInfoReqWrap,
    getaddrinfo: getaddrinfo,
    QueryReqWrap: QueryReqWrap,
    ChannelWrap: ChannelWrap,
    strerror: strerror
};
const mod14 = {};
const timingSafeEqual = (a, b)=>{
    if (a instanceof DataView) a = Buffer.from(a.buffer);
    if (b instanceof DataView) b = Buffer.from(b.buffer);
    if (a instanceof ArrayBuffer) a = Buffer.from(a);
    if (b instanceof ArrayBuffer) b = Buffer.from(b);
    let result = 0;
    if (a.byteLength !== b.byteLength) {
        b = a;
        result = 1;
    }
    for(let i116 = 0; i116 < a.byteLength; i116++){
        result |= a[i116] ^ b[i116];
    }
    return result === 0;
};
function getFipsCrypto() {
    notImplemented("crypto.getFipsCrypto");
}
function setFipsCrypto(_fips) {
    notImplemented("crypto.setFipsCrypto");
}
const mod15 = {
    timingSafeEqual: timingSafeEqual,
    getFipsCrypto: getFipsCrypto,
    setFipsCrypto: setFipsCrypto
};
const mod16 = {};
const mod17 = {};
const mod18 = {};
const mod19 = {};
const mod20 = {};
const mod21 = {};
const mod22 = {};
const mod23 = {};
const mod24 = {};
const mod25 = {};
const mod26 = {};
const mod27 = {};
const mod28 = {};
const mod29 = {};
const mod30 = {};
const mod31 = {};
class HandleWrap extends AsyncWrap {
    constructor(provider){
        super(provider);
    }
    close(cb = ()=>{}) {
        this._onClose();
        cb();
    }
    ref() {
        unreachable();
    }
    unref() {
        unreachable();
    }
    _onClose() {}
}
const MIN_BUF_SIZE = 16;
const CR = "\r".charCodeAt(0);
const LF = "\n".charCodeAt(0);
class BufferFullError extends Error {
    name;
    constructor(partial){
        super("Buffer full");
        this.partial = partial;
        this.name = "BufferFullError";
    }
    partial;
}
class PartialReadError extends Error {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader {
    #buf;
    #rd;
    #r = 0;
    #w = 0;
    #eof = false;
    static create(r, size = 4096) {
        return r instanceof BufReader ? r : new BufReader(r, size);
    }
    constructor(rd, size = 4096){
        if (size < 16) {
            size = MIN_BUF_SIZE;
        }
        this.#reset(new Uint8Array(size), rd);
    }
    size() {
        return this.#buf.byteLength;
    }
    buffered() {
        return this.#w - this.#r;
    }
    #fill = async ()=>{
        if (this.#r > 0) {
            this.#buf.copyWithin(0, this.#r, this.#w);
            this.#w -= this.#r;
            this.#r = 0;
        }
        if (this.#w >= this.#buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i117 = 100; i117 > 0; i117--){
            const rr = await this.#rd.read(this.#buf.subarray(this.#w));
            if (rr === null) {
                this.#eof = true;
                return;
            }
            assert(rr >= 0, "negative read");
            this.#w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    };
    reset(r) {
        this.#reset(this.#buf, r);
    }
    #reset = (buf, rd)=>{
        this.#buf = buf;
        this.#rd = rd;
        this.#eof = false;
    };
    async read(p) {
        let rr = p.byteLength;
        if (p.byteLength === 0) return rr;
        if (this.#r === this.#w) {
            if (p.byteLength >= this.#buf.byteLength) {
                const rr = await this.#rd.read(p);
                const nread = rr ?? 0;
                assert(nread >= 0, "negative read");
                return rr;
            }
            this.#r = 0;
            this.#w = 0;
            rr = await this.#rd.read(this.#buf);
            if (rr === 0 || rr === null) return rr;
            assert(rr >= 0, "negative read");
            this.#w += rr;
        }
        const copied = copy(this.#buf.subarray(this.#r, this.#w), p, 0);
        this.#r += copied;
        return copied;
    }
    async readFull(p) {
        let bytesRead = 0;
        while(bytesRead < p.length){
            try {
                const rr = await this.read(p.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = p.subarray(0, bytesRead);
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = p.subarray(0, bytesRead);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return p;
    }
    async readByte() {
        while(this.#r === this.#w){
            if (this.#eof) return null;
            await this.#fill();
        }
        const c = this.#buf[this.#r];
        this.#r++;
        return c;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer = await this.readSlice(delim.charCodeAt(0));
        if (buffer === null) return null;
        return new TextDecoder().decode(buffer);
    }
    async readLine() {
        let line = null;
        try {
            line = await this.readSlice(LF);
        } catch (err) {
            if (err instanceof Deno.errors.BadResource) {
                throw err;
            }
            let partial;
            if (err instanceof PartialReadError) {
                partial = err.partial;
                assert(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            }
            if (!(err instanceof BufferFullError)) {
                throw err;
            }
            partial = err.partial;
            if (!this.#eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR) {
                assert(this.#r > 0, "bufio: tried to rewind past start of buffer");
                this.#r--;
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            if (partial) {
                return {
                    line: partial,
                    more: !this.#eof
                };
            }
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s = 0;
        let slice;
        while(true){
            let i118 = this.#buf.subarray(this.#r + s, this.#w).indexOf(delim);
            if (i118 >= 0) {
                i118 += s;
                slice = this.#buf.subarray(this.#r, this.#r + i118 + 1);
                this.#r += i118 + 1;
                break;
            }
            if (this.#eof) {
                if (this.#r === this.#w) {
                    return null;
                }
                slice = this.#buf.subarray(this.#r, this.#w);
                this.#r = this.#w;
                break;
            }
            if (this.buffered() >= this.#buf.byteLength) {
                this.#r = this.#w;
                const oldbuf = this.#buf;
                const newbuf = this.#buf.slice(0);
                this.#buf = newbuf;
                throw new BufferFullError(oldbuf);
            }
            s = this.#w - this.#r;
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = slice;
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = slice;
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return slice;
    }
    async peek(n6) {
        if (n6 < 0) {
            throw Error("negative count");
        }
        let avail = this.#w - this.#r;
        while(avail < n6 && avail < this.#buf.byteLength && !this.#eof){
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = this.#buf.subarray(this.#r, this.#w);
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = this.#buf.subarray(this.#r, this.#w);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
            avail = this.#w - this.#r;
        }
        if (avail === 0 && this.#eof) {
            return null;
        } else if (avail < n6 && this.#eof) {
            return this.#buf.subarray(this.#r, this.#r + avail);
        } else if (avail < n6) {
            throw new BufferFullError(this.#buf.subarray(this.#r, this.#w));
        }
        return this.#buf.subarray(this.#r, this.#r + n6);
    }
}
class AbstractBufBase {
    buf;
    usedBufferBytes = 0;
    err = null;
    constructor(buf){
        this.buf = buf;
    }
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter extends AbstractBufBase {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += await this.#writer.write(p.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.#writer.write(data);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class BufWriterSync extends AbstractBufBase {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync ? writer : new BufWriterSync(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += this.#writer.writeSync(p.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.#writer.writeSync(data);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
async function writeAll(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += await w.write(arr.subarray(nwritten));
    }
}
function writeAllSync(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += w.writeSync(arr.subarray(nwritten));
    }
}
var StreamBaseStateFields;
(function(StreamBaseStateFields1) {
    StreamBaseStateFields1[StreamBaseStateFields1["kReadBytesOrError"] = 0] = "kReadBytesOrError";
    StreamBaseStateFields1[StreamBaseStateFields1["kArrayBufferOffset"] = 1] = "kArrayBufferOffset";
    StreamBaseStateFields1[StreamBaseStateFields1["kBytesWritten"] = 2] = "kBytesWritten";
    StreamBaseStateFields1[StreamBaseStateFields1["kLastWriteWasAsync"] = 3] = "kLastWriteWasAsync";
    StreamBaseStateFields1[StreamBaseStateFields1["kNumStreamBaseStateFields"] = 4] = "kNumStreamBaseStateFields";
})(StreamBaseStateFields || (StreamBaseStateFields = {}));
const kReadBytesOrError = StreamBaseStateFields.kReadBytesOrError;
const kArrayBufferOffset = StreamBaseStateFields.kArrayBufferOffset;
const kBytesWritten = StreamBaseStateFields.kBytesWritten;
const kLastWriteWasAsync = StreamBaseStateFields.kLastWriteWasAsync;
const kNumStreamBaseStateFields = StreamBaseStateFields.kNumStreamBaseStateFields;
const streamBaseState = new Uint8Array(5);
streamBaseState[kLastWriteWasAsync] = 1;
class WriteWrap extends AsyncWrap {
    handle;
    oncomplete;
    async;
    bytes;
    buffer;
    callback;
    _chunks;
    constructor(){
        super(providerType.WRITEWRAP);
    }
}
class ShutdownWrap extends AsyncWrap {
    handle;
    oncomplete;
    callback;
    constructor(){
        super(providerType.SHUTDOWNWRAP);
    }
}
const kStreamBaseField = Symbol("kStreamBaseField");
const SUGGESTED_SIZE = 64 * 1024;
class LibuvStreamWrap extends HandleWrap {
    [kStreamBaseField];
    reading;
    #reading = false;
    destroyed = false;
    writeQueueSize = 0;
    bytesRead = 0;
    bytesWritten = 0;
    onread;
    constructor(provider, stream){
        super(provider);
        this.#attachToObject(stream);
    }
    readStart() {
        if (!this.#reading) {
            this.#reading = true;
            this.#read();
        }
        return 0;
    }
    readStop() {
        this.#reading = false;
        return 0;
    }
    shutdown(req) {
        const status = this._onClose();
        try {
            req.oncomplete(status);
        } catch  {}
        return 0;
    }
    useUserBuffer(_userBuf) {
        notImplemented("LibuvStreamWrap.prototype.useUserBuffer");
    }
    writeBuffer(req, data) {
        this.#write(req, data);
        return 0;
    }
    writev(req, chunks, allBuffers) {
        const count = allBuffers ? chunks.length : chunks.length >> 1;
        const buffers = new Array(count);
        if (!allBuffers) {
            for(let i119 = 0; i119 < count; i119++){
                const chunk = chunks[i119 * 2];
                if (Buffer.isBuffer(chunk)) {
                    buffers[i119] = chunk;
                }
                const encoding = chunks[i119 * 2 + 1];
                buffers[i119] = Buffer.from(chunk, encoding);
            }
        } else {
            for(let i120 = 0; i120 < count; i120++){
                buffers[i120] = chunks[i120];
            }
        }
        return this.writeBuffer(req, Buffer.concat(buffers));
    }
    writeAsciiString(req, data) {
        const buffer = new TextEncoder().encode(data);
        return this.writeBuffer(req, buffer);
    }
    writeUtf8String(req, data) {
        const buffer = new TextEncoder().encode(data);
        return this.writeBuffer(req, buffer);
    }
    writeUcs2String(_req, _data) {
        notImplemented("LibuvStreamWrap.prototype.writeUcs2String");
    }
    writeLatin1String(req, data) {
        const buffer = Buffer.from(data, "latin1");
        return this.writeBuffer(req, buffer);
    }
    _onClose() {
        let status = 0;
        this.#reading = false;
        try {
            this[kStreamBaseField]?.close();
        } catch  {
            status = codeMap.get("ENOTCONN");
        }
        return status;
    }
     #attachToObject(stream) {
        this[kStreamBaseField] = stream;
    }
    async #read() {
        let buf = new Uint8Array(SUGGESTED_SIZE);
        let nread;
        try {
            nread = await this[kStreamBaseField].read(buf);
        } catch (e) {
            if (e instanceof Deno.errors.Interrupted || e instanceof Deno.errors.BadResource) {
                nread = codeMap.get("EOF");
            } else if (e instanceof Deno.errors.ConnectionReset || e instanceof Deno.errors.ConnectionAborted) {
                nread = codeMap.get("ECONNRESET");
            } else {
                nread = codeMap.get("UNKNOWN");
            }
            buf = new Uint8Array(0);
        }
        nread ??= codeMap.get("EOF");
        streamBaseState[kReadBytesOrError] = nread;
        if (nread > 0) {
            this.bytesRead += nread;
        }
        buf = buf.slice(0, nread);
        streamBaseState[kArrayBufferOffset] = 0;
        try {
            this.onread(buf, nread);
        } catch  {}
        if (nread >= 0 && this.#reading) {
            this.#read();
        }
    }
    async #write(req, data) {
        const { byteLength  } = data;
        try {
            await writeAll(this[kStreamBaseField], data);
        } catch (e) {
            let status;
            if (e instanceof Deno.errors.BadResource || e instanceof Deno.errors.BrokenPipe) {
                status = codeMap.get("EBADF");
            } else {
                status = codeMap.get("UNKNOWN");
            }
            try {
                req.oncomplete(status);
            } catch  {}
            return;
        }
        streamBaseState[kBytesWritten] = byteLength;
        this.bytesWritten += byteLength;
        try {
            req.oncomplete(0);
        } catch  {}
        return;
    }
}
const mod32 = {
    kReadBytesOrError: kReadBytesOrError,
    kArrayBufferOffset: kArrayBufferOffset,
    kBytesWritten: kBytesWritten,
    kLastWriteWasAsync: kLastWriteWasAsync,
    kNumStreamBaseStateFields: kNumStreamBaseStateFields,
    streamBaseState: streamBaseState,
    WriteWrap: WriteWrap,
    ShutdownWrap: ShutdownWrap,
    kStreamBaseField: kStreamBaseField,
    LibuvStreamWrap: LibuvStreamWrap
};
class ConnectionWrap extends LibuvStreamWrap {
    onconnection = null;
    constructor(provider, object){
        super(provider, object);
    }
    afterConnect(req1, status) {
        const isSuccessStatus = !status;
        const readable = isSuccessStatus;
        const writable = isSuccessStatus;
        try {
            req1.oncomplete(status, this, req1, readable, writable);
        } catch  {}
        return;
    }
}
function ceilPowOf2(n) {
    const roundPowOf2 = 1 << 31 - Math.clz32(n);
    return roundPowOf2 < n ? roundPowOf2 * 2 : roundPowOf2;
}
const INITIAL_ACCEPT_BACKOFF_DELAY = 5;
const MAX_ACCEPT_BACKOFF_DELAY = 1000;
var socketType;
(function(socketType2) {
    socketType2[socketType2["SOCKET"] = 0] = "SOCKET";
    socketType2[socketType2["SERVER"] = 1] = "SERVER";
    socketType2[socketType2["IPC"] = 2] = "IPC";
})(socketType || (socketType = {}));
class Pipe extends ConnectionWrap {
    reading = false;
    ipc;
    #pendingInstances = 4;
    #address;
    #backlog;
    #listener;
    #connections = 0;
    #closed = false;
    #acceptBackoffDelay;
    constructor(type30, conn){
        let provider;
        let ipc;
        switch(type30){
            case socketType.SOCKET:
                {
                    provider = providerType.PIPEWRAP;
                    ipc = false;
                    break;
                }
            case socketType.SERVER:
                {
                    provider = providerType.PIPESERVERWRAP;
                    ipc = false;
                    break;
                }
            case socketType.IPC:
                {
                    provider = providerType.PIPEWRAP;
                    ipc = true;
                    break;
                }
            default:
                {
                    unreachable();
                }
        }
        super(provider, conn);
        this.ipc = ipc;
        if (conn && provider === providerType.PIPEWRAP) {
            const localAddr = conn.localAddr;
            this.#address = localAddr.path;
        }
    }
    open(_fd) {
        notImplemented("Pipe.prototype.open");
    }
    bind(name51) {
        this.#address = name51;
        return 0;
    }
    connect(req2, address) {
        if (isWindows) {
            notImplemented("Pipe.prototype.connect - Windows");
        }
        const connectOptions = {
            path: address,
            transport: "unix"
        };
        connect(connectOptions).then((conn)=>{
            const localAddr = conn.localAddr;
            this.#address = req2.address = localAddr.path;
            this[kStreamBaseField] = conn;
            try {
                this.afterConnect(req2, 0);
            } catch  {}
        }, (e)=>{
            let code;
            if (e instanceof Deno.errors.NotFound) {
                code = codeMap.get("ENOENT");
            } else if (e instanceof Deno.errors.PermissionDenied) {
                code = codeMap.get("EACCES");
            } else {
                code = codeMap.get("ECONNREFUSED");
            }
            try {
                this.afterConnect(req2, code);
            } catch  {}
        });
        return 0;
    }
    listen(backlog) {
        if (isWindows) {
            notImplemented("Pipe.prototype.listen - Windows");
        }
        this.#backlog = isWindows ? this.#pendingInstances : ceilPowOf2(backlog + 1);
        const listenOptions = {
            path: this.#address,
            transport: "unix"
        };
        let listener;
        try {
            listener = listen(listenOptions);
        } catch (e) {
            if (e instanceof Deno.errors.AddrInUse) {
                return codeMap.get("EADDRINUSE");
            } else if (e instanceof Deno.errors.AddrNotAvailable) {
                return codeMap.get("EADDRNOTAVAIL");
            }
            return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.path;
        this.#listener = listener;
        this.#accept();
        return 0;
    }
    ref() {
        if (this.#listener) {
            ListenerRef(this.#listener);
        }
    }
    unref() {
        if (this.#listener) {
            ListenerUnref(this.#listener);
        }
    }
    setPendingInstances(instances) {
        this.#pendingInstances = instances;
    }
    fchmod(mode) {
        if (mode != constants1.UV_READABLE && mode != constants1.UV_WRITABLE && mode != (constants1.UV_WRITABLE | constants1.UV_READABLE)) {
            return codeMap.get("EINVAL");
        }
        let desired_mode = 0;
        if (mode & constants1.UV_READABLE) {
            desired_mode |= fs.S_IRUSR | fs.S_IRGRP | fs.S_IROTH;
        }
        if (mode & constants1.UV_WRITABLE) {
            desired_mode |= fs.S_IWUSR | fs.S_IWGRP | fs.S_IWOTH;
        }
        try {
            Deno.chmodSync(this.#address, desired_mode);
        } catch  {
            return codeMap.get("UNKNOWN");
        }
        return 0;
    }
    async #acceptBackoff() {
        if (!this.#acceptBackoffDelay) {
            this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
        } else {
            this.#acceptBackoffDelay *= 2;
        }
        if (this.#acceptBackoffDelay >= 1000) {
            this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
        }
        await delay(this.#acceptBackoffDelay);
        this.#accept();
    }
    async #accept() {
        if (this.#closed) {
            return;
        }
        if (this.#connections > this.#backlog) {
            this.#acceptBackoff();
            return;
        }
        let connection;
        try {
            connection = await this.#listener.accept();
        } catch (e) {
            if (e instanceof Deno.errors.BadResource && this.#closed) {
                return;
            }
            try {
                this.onconnection(codeMap.get("UNKNOWN"), undefined);
            } catch  {}
            this.#acceptBackoff();
            return;
        }
        this.#acceptBackoffDelay = undefined;
        const connectionHandle = new Pipe(socketType.SOCKET, connection);
        this.#connections++;
        try {
            this.onconnection(0, connectionHandle);
        } catch  {}
        return this.#accept();
    }
    _onClose() {
        this.#closed = true;
        this.reading = false;
        this.#address = undefined;
        this.#backlog = undefined;
        this.#connections = 0;
        this.#acceptBackoffDelay = undefined;
        if (this.provider === providerType.PIPESERVERWRAP) {
            try {
                this.#listener.close();
            } catch  {}
        }
        return LibuvStreamWrap.prototype._onClose.call(this);
    }
}
class PipeConnectWrap extends AsyncWrap {
    oncomplete;
    address;
    constructor(){
        super(providerType.PIPECONNECTWRAP);
    }
}
var constants1;
(function(constants4) {
    constants4[constants4["SOCKET"] = socketType.SOCKET] = "SOCKET";
    constants4[constants4["SERVER"] = socketType.SERVER] = "SERVER";
    constants4[constants4["IPC"] = socketType.IPC] = "IPC";
    constants4[constants4["UV_READABLE"] = 1] = "UV_READABLE";
    constants4[constants4["UV_WRITABLE"] = 2] = "UV_WRITABLE";
})(constants1 || (constants1 = {}));
const mod33 = {
    socketType: socketType,
    Pipe: Pipe,
    PipeConnectWrap: PipeConnectWrap,
    constants: constants1
};
const mod34 = {};
const mod35 = {};
const mod36 = {};
const mod37 = {};
const mod38 = {};
const mod39 = {};
const asyncIdSymbol = Symbol("asyncIdSymbol");
const ownerSymbol = Symbol("ownerSymbol");
const mod40 = {
    asyncIdSymbol: asyncIdSymbol,
    ownerSymbol: ownerSymbol
};
const mod41 = {};
var socketType1;
(function(socketType3) {
    socketType3[socketType3["SOCKET"] = 0] = "SOCKET";
    socketType3[socketType3["SERVER"] = 1] = "SERVER";
})(socketType1 || (socketType1 = {}));
class TCPConnectWrap extends AsyncWrap {
    oncomplete;
    address;
    port;
    localAddress;
    localPort;
    constructor(){
        super(providerType.TCPCONNECTWRAP);
    }
}
var constants2;
(function(constants5) {
    constants5[constants5["SOCKET"] = socketType1.SOCKET] = "SOCKET";
    constants5[constants5["SERVER"] = socketType1.SERVER] = "SERVER";
    constants5[constants5["UV_TCP_IPV6ONLY"] = 0] = "UV_TCP_IPV6ONLY";
})(constants2 || (constants2 = {}));
class TCP extends ConnectionWrap {
    [ownerSymbol] = null;
    reading = false;
    #address;
    #port;
    #remoteAddress;
    #remoteFamily;
    #remotePort;
    #backlog;
    #listener;
    #connections = 0;
    #closed = false;
    #acceptBackoffDelay;
    constructor(type31, conn){
        let provider;
        switch(type31){
            case socketType1.SOCKET:
                {
                    provider = providerType.TCPWRAP;
                    break;
                }
            case socketType1.SERVER:
                {
                    provider = providerType.TCPSERVERWRAP;
                    break;
                }
            default:
                {
                    unreachable();
                }
        }
        super(provider, conn);
        if (conn && provider === providerType.TCPWRAP) {
            const localAddr = conn.localAddr;
            this.#address = localAddr.hostname;
            this.#port = localAddr.port;
            const remoteAddr = conn.remoteAddr;
            this.#remoteAddress = remoteAddr.hostname;
            this.#remotePort = remoteAddr.port;
            this.#remoteFamily = isIP(remoteAddr.hostname);
        }
    }
    open(_fd) {
        notImplemented("TCP.prototype.open");
    }
    bind(address, port) {
        return this.#bind(address, port, 0);
    }
    bind6(address, port, flags) {
        return this.#bind(address, port, flags);
    }
    connect(req3, address, port) {
        return this.#connect(req3, address, port);
    }
    connect6(req4, address, port) {
        return this.#connect(req4, address, port);
    }
    listen(backlog) {
        this.#backlog = ceilPowOf2(backlog + 1);
        const listenOptions = {
            hostname: this.#address,
            port: this.#port,
            transport: "tcp"
        };
        let listener;
        try {
            listener = Deno.listen(listenOptions);
        } catch (e) {
            if (e instanceof Deno.errors.AddrInUse) {
                return codeMap.get("EADDRINUSE");
            } else if (e instanceof Deno.errors.AddrNotAvailable) {
                return codeMap.get("EADDRNOTAVAIL");
            }
            return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.hostname;
        this.#port = address.port;
        this.#listener = listener;
        this.#accept();
        return 0;
    }
    ref() {
        if (this.#listener) {
            ListenerRef(this.#listener);
        }
    }
    unref() {
        if (this.#listener) {
            ListenerUnref(this.#listener);
        }
    }
    getsockname(sockname) {
        if (typeof this.#address === "undefined" || typeof this.#port === "undefined") {
            return codeMap.get("EADDRNOTAVAIL");
        }
        sockname.address = this.#address;
        sockname.port = this.#port;
        sockname.family = isIP(this.#address);
        return 0;
    }
    getpeername(peername) {
        if (typeof this.#remoteAddress === "undefined" || typeof this.#remotePort === "undefined") {
            return codeMap.get("EADDRNOTAVAIL");
        }
        peername.address = this.#remoteAddress;
        peername.port = this.#remotePort;
        peername.family = this.#remoteFamily;
        return 0;
    }
    setNoDelay(_noDelay) {
        return 0;
    }
    setKeepAlive(_enable, _initialDelay) {
        return 0;
    }
    setSimultaneousAccepts(_enable) {
        notImplemented("TCP.prototype.setSimultaneousAccepts");
    }
     #bind(address, port, _flags) {
        this.#address = address;
        this.#port = port;
        return 0;
    }
     #connect(req5, address1, port1) {
        this.#remoteAddress = address1;
        this.#remotePort = port1;
        this.#remoteFamily = isIP(address1);
        const connectOptions = {
            hostname: address1,
            port: port1,
            transport: "tcp"
        };
        Deno.connect(connectOptions).then((conn)=>{
            const localAddr = conn.localAddr;
            this.#address = req5.localAddress = localAddr.hostname;
            this.#port = req5.localPort = localAddr.port;
            this[kStreamBaseField] = conn;
            try {
                this.afterConnect(req5, 0);
            } catch  {}
        }, ()=>{
            try {
                this.afterConnect(req5, codeMap.get("ECONNREFUSED"));
            } catch  {}
        });
        return 0;
    }
    async #acceptBackoff() {
        if (!this.#acceptBackoffDelay) {
            this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
        } else {
            this.#acceptBackoffDelay *= 2;
        }
        if (this.#acceptBackoffDelay >= 1000) {
            this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
        }
        await delay(this.#acceptBackoffDelay);
        this.#accept();
    }
    async #accept() {
        if (this.#closed) {
            return;
        }
        if (this.#connections > this.#backlog) {
            this.#acceptBackoff();
            return;
        }
        let connection;
        try {
            connection = await this.#listener.accept();
        } catch (e) {
            if (e instanceof Deno.errors.BadResource && this.#closed) {
                return;
            }
            try {
                this.onconnection(codeMap.get("UNKNOWN"), undefined);
            } catch  {}
            this.#acceptBackoff();
            return;
        }
        this.#acceptBackoffDelay = undefined;
        const connectionHandle = new TCP(socketType1.SOCKET, connection);
        this.#connections++;
        try {
            this.onconnection(0, connectionHandle);
        } catch  {}
        return this.#accept();
    }
    _onClose() {
        this.#closed = true;
        this.reading = false;
        this.#address = undefined;
        this.#port = undefined;
        this.#remoteAddress = undefined;
        this.#remoteFamily = undefined;
        this.#remotePort = undefined;
        this.#backlog = undefined;
        this.#connections = 0;
        this.#acceptBackoffDelay = undefined;
        if (this.provider === providerType.TCPSERVERWRAP) {
            try {
                this.#listener.close();
            } catch  {}
        }
        return LibuvStreamWrap.prototype._onClose.call(this);
    }
}
const mod42 = {
    TCPConnectWrap: TCPConnectWrap,
    constants: constants2,
    TCP: TCP
};
const mod43 = {};
const mod44 = {};
const mod45 = {};
const mod46 = {};
const AF_INET6 = 10;
const UDP_DGRAM_MAXSIZE = 64 * 1024;
class SendWrap extends AsyncWrap {
    list;
    address;
    port;
    callback;
    oncomplete;
    constructor(){
        super(providerType.UDPSENDWRAP);
    }
}
class UDP extends HandleWrap {
    [ownerSymbol] = null;
    #address;
    #family;
    #port;
    #remoteAddress;
    #remoteFamily;
    #remotePort;
    #listener;
    #receiving = false;
    #recvBufferSize = UDP_DGRAM_MAXSIZE;
    #sendBufferSize = UDP_DGRAM_MAXSIZE;
    onmessage;
    lookup;
    constructor(){
        super(providerType.UDPWRAP);
    }
    addMembership(_multicastAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.addMembership");
    }
    addSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.addSourceSpecificMembership");
    }
    bind(ip, port2, flags) {
        return this.#doBind(ip, port2, flags, 2);
    }
    bind6(ip, port3, flags) {
        return this.#doBind(ip, port3, flags, 10);
    }
    bufferSize(size, buffer, ctx) {
        let err;
        if (size > UDP_DGRAM_MAXSIZE) {
            err = "EINVAL";
        } else if (!this.#address) {
            err = isWindows ? "ENOTSOCK" : "EBADF";
        }
        if (err) {
            ctx.errno = codeMap.get(err);
            ctx.code = err;
            ctx.message = errorMap.get(ctx.errno)[1];
            ctx.syscall = buffer ? "uv_recv_buffer_size" : "uv_send_buffer_size";
            return;
        }
        if (size !== 0) {
            size = isLinux ? size * 2 : size;
            if (buffer) {
                return this.#recvBufferSize = size;
            }
            return this.#sendBufferSize = size;
        }
        return buffer ? this.#recvBufferSize : this.#sendBufferSize;
    }
    connect(ip, port4) {
        return this.#doConnect(ip, port4, 2);
    }
    connect6(ip, port5) {
        return this.#doConnect(ip, port5, 10);
    }
    disconnect() {
        this.#remoteAddress = undefined;
        this.#remotePort = undefined;
        this.#remoteFamily = undefined;
        return 0;
    }
    dropMembership(_multicastAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.dropMembership");
    }
    dropSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.dropSourceSpecificMembership");
    }
    getpeername(peername) {
        if (this.#remoteAddress === undefined) {
            return codeMap.get("EBADF");
        }
        peername.address = this.#remoteAddress;
        peername.port = this.#remotePort;
        peername.family = this.#remoteFamily;
        return 0;
    }
    getsockname(sockname) {
        if (this.#address === undefined) {
            return codeMap.get("EBADF");
        }
        sockname.address = this.#address;
        sockname.port = this.#port;
        sockname.family = this.#family;
        return 0;
    }
    open(_fd) {
        notImplemented("udp.UDP.prototype.open");
    }
    recvStart() {
        if (!this.#receiving) {
            this.#receiving = true;
            this.#receive();
        }
        return 0;
    }
    recvStop() {
        this.#receiving = false;
        return 0;
    }
    ref() {
        notImplemented("udp.UDP.prototype.ref");
    }
    send(req6, bufs, count, ...args) {
        return this.#doSend(req6, bufs, count, args, 2);
    }
    send6(req7, bufs, count, ...args) {
        return this.#doSend(req7, bufs, count, args, 10);
    }
    setBroadcast(_bool) {
        notImplemented("udp.UDP.prototype.setBroadcast");
    }
    setMulticastInterface(_interfaceAddress) {
        notImplemented("udp.UDP.prototype.setMulticastInterface");
    }
    setMulticastLoopback(_bool) {
        notImplemented("udp.UDP.prototype.setMulticastLoopback");
    }
    setMulticastTTL(_ttl) {
        notImplemented("udp.UDP.prototype.setMulticastTTL");
    }
    setTTL(_ttl) {
        notImplemented("udp.UDP.prototype.setTTL");
    }
    unref() {
        notImplemented("udp.UDP.prototype.unref");
    }
     #doBind(ip, port6, _flags1, family) {
        const listenOptions = {
            port: port6,
            hostname: ip,
            transport: "udp"
        };
        let listener;
        try {
            listener = listenDatagram(listenOptions);
        } catch (e) {
            if (e instanceof Deno.errors.AddrInUse) {
                return codeMap.get("EADDRINUSE");
            } else if (e instanceof Deno.errors.AddrNotAvailable) {
                return codeMap.get("EADDRNOTAVAIL");
            }
            return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.hostname;
        this.#port = address.port;
        this.#family = family === AF_INET6 ? "IPv6" : "IPv4";
        this.#listener = listener;
        return 0;
    }
     #doConnect(ip1, port11, family1) {
        this.#remoteAddress = ip1;
        this.#remotePort = port11;
        this.#remoteFamily = family1 === AF_INET6 ? "IPv6" : "IPv4";
        return 0;
    }
     #doSend(req8, bufs, _count, args, _family) {
        let hasCallback;
        if (args.length === 3) {
            this.#remotePort = args[0];
            this.#remoteAddress = args[1];
            hasCallback = args[2];
        } else {
            hasCallback = args[0];
        }
        const addr = {
            hostname: this.#remoteAddress,
            port: this.#remotePort,
            transport: "udp"
        };
        const payload = new Uint8Array(Buffer.concat(bufs.map((buf)=>{
            if (typeof buf === "string") {
                return Buffer.from(buf);
            }
            return Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
        })));
        (async ()=>{
            let sent;
            let err = null;
            try {
                sent = await this.#listener.send(payload, addr);
            } catch (e) {
                if (e instanceof Deno.errors.BadResource) {
                    err = codeMap.get("EBADF");
                } else if (e instanceof Error && e.message.match(/os error (40|90|10040)/)) {
                    err = codeMap.get("EMSGSIZE");
                } else {
                    err = codeMap.get("UNKNOWN");
                }
                sent = 0;
            }
            if (hasCallback) {
                try {
                    req8.oncomplete(err, sent);
                } catch  {}
            }
        })();
        return 0;
    }
    async #receive() {
        if (!this.#receiving) {
            return;
        }
        const p = new Uint8Array(this.#recvBufferSize);
        let buf;
        let remoteAddr;
        let nread;
        try {
            [buf, remoteAddr] = await this.#listener.receive(p);
            nread = buf.length;
        } catch (e) {
            if (e instanceof Deno.errors.Interrupted || e instanceof Deno.errors.BadResource) {
                nread = 0;
            } else {
                nread = codeMap.get("UNKNOWN");
            }
            buf = new Uint8Array(0);
            remoteAddr = null;
        }
        nread ??= 0;
        const rinfo = remoteAddr ? {
            address: remoteAddr.hostname,
            port: remoteAddr.port,
            family: isIP(remoteAddr.hostname) === 6 ? "IPv6" : "IPv4"
        } : undefined;
        try {
            this.onmessage(nread, this, Buffer.from(buf), rinfo);
        } catch  {}
        this.#receive();
    }
    _onClose() {
        this.#receiving = false;
        this.#address = undefined;
        this.#port = undefined;
        this.#family = undefined;
        try {
            this.#listener.close();
        } catch  {}
        this.#listener = undefined;
        return 0;
    }
}
const mod47 = {
    SendWrap: SendWrap,
    UDP: UDP
};
const mod48 = {};
const mod49 = {};
const mod50 = {};
const mod51 = {};
const modules = {
    "async_wrap": mod11,
    buffer: mod5,
    "cares_wrap": mod13,
    config: mod12,
    constants: mod3,
    contextify: mod14,
    credentials: mod16,
    crypto: mod15,
    errors: mod17,
    fs: mod18,
    "fs_dir": mod19,
    "fs_event_wrap": mod20,
    "heap_utils": mod21,
    "http_parser": mod22,
    icu: mod23,
    inspector: mod24,
    "js_stream": mod25,
    messaging: mod26,
    "module_wrap": mod27,
    "native_module": mod28,
    natives: mod29,
    options: mod30,
    os: mod31,
    performance: mod34,
    "pipe_wrap": mod33,
    "process_methods": mod35,
    report: mod36,
    serdes: mod37,
    "signal_wrap": mod38,
    "spawn_sync": mod39,
    "stream_wrap": mod32,
    "string_decoder": mod4,
    symbols: mod40,
    "task_queue": mod41,
    "tcp_wrap": mod42,
    timers: mod43,
    "tls_wrap": mod44,
    "trace_events": mod45,
    "tty_wrap": mod46,
    types: mod2,
    "udp_wrap": mod47,
    url: mod48,
    util: mod6,
    uv: mod7,
    v8: mod49,
    worker: mod50,
    zlib: mod51
};
function getBinding(name52) {
    const mod53 = modules[name52];
    if (!mod53) {
        throw new Error(`No such module: ${name52}`);
    }
    return mod53;
}
const kInternal = Symbol("internal properties");
const replaceUnderscoresRegex = /_/g;
const leadingDashesRegex = /^--?/;
const trailingValuesRegex = /=.*$/;
function buildAllowedFlags() {
    const allowedNodeEnvironmentFlags = [
        "--track-heap-objects",
        "--no-track-heap-objects",
        "--node-snapshot",
        "--no-node-snapshot",
        "--require",
        "--max-old-space-size",
        "--trace-exit",
        "--no-trace-exit",
        "--disallow-code-generation-from-strings",
        "--experimental-json-modules",
        "--no-experimental-json-modules",
        "--interpreted-frames-native-stack",
        "--inspect-brk",
        "--no-inspect-brk",
        "--trace-tls",
        "--no-trace-tls",
        "--stack-trace-limit",
        "--experimental-repl-await",
        "--no-experimental-repl-await",
        "--preserve-symlinks",
        "--no-preserve-symlinks",
        "--report-uncaught-exception",
        "--no-report-uncaught-exception",
        "--experimental-modules",
        "--no-experimental-modules",
        "--report-signal",
        "--jitless",
        "--inspect-port",
        "--heapsnapshot-near-heap-limit",
        "--tls-keylog",
        "--force-context-aware",
        "--no-force-context-aware",
        "--napi-modules",
        "--abort-on-uncaught-exception",
        "--diagnostic-dir",
        "--verify-base-objects",
        "--no-verify-base-objects",
        "--unhandled-rejections",
        "--perf-basic-prof",
        "--trace-atomics-wait",
        "--no-trace-atomics-wait",
        "--deprecation",
        "--no-deprecation",
        "--perf-basic-prof-only-functions",
        "--perf-prof",
        "--max-http-header-size",
        "--report-on-signal",
        "--no-report-on-signal",
        "--throw-deprecation",
        "--no-throw-deprecation",
        "--warnings",
        "--no-warnings",
        "--force-fips",
        "--no-force-fips",
        "--pending-deprecation",
        "--no-pending-deprecation",
        "--input-type",
        "--tls-max-v1.3",
        "--no-tls-max-v1.3",
        "--tls-min-v1.2",
        "--no-tls-min-v1.2",
        "--inspect",
        "--no-inspect",
        "--heapsnapshot-signal",
        "--trace-warnings",
        "--no-trace-warnings",
        "--trace-event-categories",
        "--experimental-worker",
        "--tls-max-v1.2",
        "--no-tls-max-v1.2",
        "--perf-prof-unwinding-info",
        "--preserve-symlinks-main",
        "--no-preserve-symlinks-main",
        "--policy-integrity",
        "--experimental-wasm-modules",
        "--no-experimental-wasm-modules",
        "--node-memory-debug",
        "--inspect-publish-uid",
        "--tls-min-v1.3",
        "--no-tls-min-v1.3",
        "--experimental-specifier-resolution",
        "--secure-heap",
        "--tls-min-v1.0",
        "--no-tls-min-v1.0",
        "--redirect-warnings",
        "--experimental-report",
        "--trace-event-file-pattern",
        "--trace-uncaught",
        "--no-trace-uncaught",
        "--experimental-loader",
        "--http-parser",
        "--dns-result-order",
        "--trace-sigint",
        "--no-trace-sigint",
        "--secure-heap-min",
        "--enable-fips",
        "--no-enable-fips",
        "--enable-source-maps",
        "--no-enable-source-maps",
        "--insecure-http-parser",
        "--no-insecure-http-parser",
        "--use-openssl-ca",
        "--no-use-openssl-ca",
        "--tls-cipher-list",
        "--experimental-top-level-await",
        "--no-experimental-top-level-await",
        "--openssl-config",
        "--icu-data-dir",
        "--v8-pool-size",
        "--report-on-fatalerror",
        "--no-report-on-fatalerror",
        "--title",
        "--tls-min-v1.1",
        "--no-tls-min-v1.1",
        "--report-filename",
        "--trace-deprecation",
        "--no-trace-deprecation",
        "--report-compact",
        "--no-report-compact",
        "--experimental-policy",
        "--experimental-import-meta-resolve",
        "--no-experimental-import-meta-resolve",
        "--zero-fill-buffers",
        "--no-zero-fill-buffers",
        "--report-dir",
        "--use-bundled-ca",
        "--no-use-bundled-ca",
        "--experimental-vm-modules",
        "--no-experimental-vm-modules",
        "--force-async-hooks-checks",
        "--no-force-async-hooks-checks",
        "--frozen-intrinsics",
        "--no-frozen-intrinsics",
        "--huge-max-old-generation-size",
        "--disable-proto",
        "--debug-arraybuffer-allocations",
        "--no-debug-arraybuffer-allocations",
        "--conditions",
        "--experimental-wasi-unstable-preview1",
        "--no-experimental-wasi-unstable-preview1",
        "--trace-sync-io",
        "--no-trace-sync-io",
        "--use-largepages",
        "--experimental-abortcontroller",
        "--debug-port",
        "--es-module-specifier-resolution",
        "--prof-process",
        "-C",
        "--loader",
        "--report-directory",
        "-r",
        "--trace-events-enabled", 
    ];
    const trimLeadingDashes = (flag)=>flag.replace(leadingDashesRegex, "")
    ;
    const nodeFlags = allowedNodeEnvironmentFlags.map(trimLeadingDashes);
    class NodeEnvironmentFlagsSet extends Set {
        constructor(array){
            super();
            this[kInternal] = {
                array
            };
        }
        add() {
            return this;
        }
        delete() {
            return false;
        }
        clear() {}
        has(key) {
            if (typeof key === "string") {
                key = key.replace(replaceUnderscoresRegex, "-");
                if (leadingDashesRegex.test(key)) {
                    key = key.replace(trailingValuesRegex, "");
                    return this[kInternal].array.includes(key);
                }
                return nodeFlags.includes(key);
            }
            return false;
        }
        entries() {
            this[kInternal].set ??= new Set(this[kInternal].array);
            return this[kInternal].set.entries();
        }
        forEach(callback, thisArg = undefined) {
            this[kInternal].array.forEach((v)=>Reflect.apply(callback, thisArg, [
                    v,
                    v,
                    this
                ])
            );
        }
        get size() {
            return this[kInternal].array.length;
        }
        values() {
            this[kInternal].set ??= new Set(this[kInternal].array);
            return this[kInternal].set.values();
        }
    }
    NodeEnvironmentFlagsSet.prototype.keys = NodeEnvironmentFlagsSet.prototype[Symbol.iterator] = NodeEnvironmentFlagsSet.prototype.values;
    Object.freeze(NodeEnvironmentFlagsSet.prototype.constructor);
    Object.freeze(NodeEnvironmentFlagsSet.prototype);
    return Object.freeze(new NodeEnvironmentFlagsSet(allowedNodeEnvironmentFlags));
}
const notImplementedEvents = [
    "beforeExit",
    "disconnect",
    "message",
    "multipleResolves",
    "rejectionHandled",
    "uncaughtException",
    "uncaughtExceptionMonitor",
    "unhandledRejection",
    "worker", 
];
const argv = [
    "",
    "",
    ...Deno.args
];
Object.defineProperty(argv, "0", {
    get: Deno.execPath
});
Object.defineProperty(argv, "1", {
    get: ()=>fromFileUrl2(Deno.mainModule)
});
const exit = (code)=>{
    if (code || code === 0) {
        if (typeof code === "string") {
            const parsedCode = parseInt(code);
            process1.exitCode = isNaN(parsedCode) ? undefined : parsedCode;
        } else {
            process1.exitCode = code;
        }
    }
    if (!process1._exiting) {
        process1._exiting = true;
        process1.emit("exit", process1.exitCode || 0);
    }
    Deno.exit(process1.exitCode || 0);
};
function addReadOnlyProcessAlias(name53, option, enumerable = true) {
    const value = getOptionValue(option);
    if (value) {
        Object.defineProperty(process1, name53, {
            writable: false,
            configurable: true,
            enumerable,
            value
        });
    }
}
function createWarningObject(warning, type32, code, ctor, detail) {
    assert(typeof warning === "string");
    const warningErr = new Error(warning);
    warningErr.name = String(type32 || "Warning");
    if (code !== undefined) {
        warningErr.code = code;
    }
    if (detail !== undefined) {
        warningErr.detail = detail;
    }
    Error.captureStackTrace(warningErr, ctor || process1.emitWarning);
    return warningErr;
}
function doEmitWarning(warning) {
    process1.emit("warning", warning);
}
function emitWarning(warning, type33, code, ctor) {
    let detail;
    if (type33 !== null && typeof type33 === "object" && !Array.isArray(type33)) {
        ctor = type33.ctor;
        code = type33.code;
        if (typeof type33.detail === "string") {
            detail = type33.detail;
        }
        type33 = type33.type || "Warning";
    } else if (typeof type33 === "function") {
        ctor = type33;
        code = undefined;
        type33 = "Warning";
    }
    if (type33 !== undefined) {
        validateString(type33, "type");
    }
    if (typeof code === "function") {
        ctor = code;
        code = undefined;
    } else if (code !== undefined) {
        validateString(code, "code");
    }
    if (typeof warning === "string") {
        warning = createWarningObject(warning, type33, code, ctor, detail);
    } else if (!(warning instanceof Error)) {
        throw new ERR_INVALID_ARG_TYPE("warning", [
            "Error",
            "string"
        ], warning);
    }
    if (warning.name === "DeprecationWarning") {
        if (process1.noDeprecation) {
            return;
        }
        if (process1.throwDeprecation) {
            return process1.nextTick(()=>{
                throw warning;
            });
        }
    }
    process1.nextTick(doEmitWarning, warning);
}
function hrtime(time) {
    const milli = performance.now();
    const sec = Math.floor(milli / 1000);
    const nano = Math.floor(milli * 1_000_000 - sec * 1_000_000_000);
    if (!time) {
        return [
            sec,
            nano
        ];
    }
    const [prevSec, prevNano] = time;
    return [
        sec - prevSec,
        nano - prevNano
    ];
}
hrtime.bigint = function() {
    const [sec, nano] = hrtime();
    return BigInt(sec) * 1_000_000_000n + BigInt(nano);
};
function memoryUsage() {
    return {
        ...Deno.memoryUsage(),
        arrayBuffers: 0
    };
}
memoryUsage.rss = function() {
    return memoryUsage().rss;
};
function kill(pid1, sig = "SIGTERM") {
    if (pid1 != (pid1 | 0)) {
        throw new ERR_INVALID_ARG_TYPE("pid", "number", pid1);
    }
    if (typeof sig === "string") {
        try {
            Deno.kill(pid1, sig);
        } catch (e) {
            if (e instanceof TypeError) {
                throw new ERR_UNKNOWN_SIGNAL(sig);
            }
            throw e;
        }
    } else {
        throw new ERR_UNKNOWN_SIGNAL(sig.toString());
    }
    return true;
}
class Process extends EventEmitter {
    constructor(){
        super();
        globalThis.addEventListener("unload", ()=>{
            if (!process1._exiting) {
                process1._exiting = true;
                super.emit("exit", process1.exitCode || 0);
            }
        });
    }
    arch = arch;
    argv = argv;
    chdir = chdir;
    config = {
        target_defaults: {},
        variables: {}
    };
    cwd = cwd;
    env = env;
    execArgv = [];
    exit = exit;
    _exiting = _exiting;
    exitCode = undefined;
    mainModule = undefined;
    nextTick = nextTick2;
    on(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.on("${event}")`);
            super.on(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                addSignalListener(event, listener);
            }
        } else {
            super.on(event, listener);
        }
        return this;
    }
    off(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.off("${event}")`);
            super.off(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                removeSignalListener(event, listener);
            }
        } else {
            super.off(event, listener);
        }
        return this;
    }
    emit(event, ...args1) {
        if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                Deno.kill(Deno.pid, event);
            }
        } else {
            return super.emit(event, ...args1);
        }
        return true;
    }
    prependListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.prependListener("${event}")`);
            super.prependListener(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                addSignalListener(event, listener);
            }
        } else {
            super.prependListener(event, listener);
        }
        return this;
    }
    pid = pid;
    platform = platform;
    addListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.addListener("${event}")`);
        }
        return this.on(event, listener);
    }
    removeListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.removeListener("${event}")`);
        }
        return this.off(event, listener);
    }
    hrtime = hrtime;
    kill = kill;
    memoryUsage = memoryUsage;
    stderr = stderr;
    stdin = stdin;
    stdout = stdout;
    version = version;
    versions = versions;
    emitWarning = emitWarning;
    binding(name54) {
        return getBinding(name54);
    }
    umask() {
        return 0o22;
    }
    getuid() {
        return NaN;
    }
    getgid() {
        return NaN;
    }
    _eval = undefined;
    get execPath() {
        return argv[0];
    }
    #startTime = Date.now();
    uptime() {
        return (Date.now() - this.#startTime) / 1000;
    }
    #allowedFlags = buildAllowedFlags();
    get allowedNodeEnvironmentFlags() {
        return this.#allowedFlags;
    }
    features = {
        inspector: false
    };
}
const process1 = new Process();
Object.defineProperty(process1, Symbol.toStringTag, {
    enumerable: false,
    writable: true,
    configurable: false,
    value: "process"
});
addReadOnlyProcessAlias("noDeprecation", "--no-deprecation");
addReadOnlyProcessAlias("throwDeprecation", "--throw-deprecation");
process1.removeListener;
process1.removeAllListeners;
"use strict";
const kType = Symbol("type");
const kStats = Symbol("stats");
const { F_OK =0 , W_OK =0 , R_OK =0 , X_OK =0 , COPYFILE_EXCL , COPYFILE_FICLONE , COPYFILE_FICLONE_FORCE , O_APPEND , O_CREAT , O_EXCL , O_RDONLY , O_RDWR , O_SYNC , O_TRUNC , O_WRONLY , S_IFBLK , S_IFCHR , S_IFDIR , S_IFIFO , S_IFLNK , S_IFMT , S_IFREG , S_IFSOCK , UV_FS_SYMLINK_DIR , UV_FS_SYMLINK_JUNCTION , UV_DIRENT_UNKNOWN , UV_DIRENT_FILE , UV_DIRENT_DIR , UV_DIRENT_LINK , UV_DIRENT_FIFO , UV_DIRENT_SOCKET , UV_DIRENT_CHAR , UV_DIRENT_BLOCK ,  } = fs;
const { errno: { EISDIR ,  } ,  } = os;
const kMinimumAccessMode = Math.min(F_OK, W_OK, R_OK, X_OK);
const kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;
const kDefaultCopyMode = 0;
const kMinimumCopyMode = Math.min(0, COPYFILE_EXCL, COPYFILE_FICLONE, COPYFILE_FICLONE_FORCE);
const kMaximumCopyMode = COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE;
const kIoMaxLength = 2 ** 31 - 1;
const kReadFileUnknownBufferLength = 64 * 1024;
const kReadFileBufferLength = 512 * 1024;
const kWriteFileMaxChunkSize = 512 * 1024;
const kMaxUserId = 2 ** 32 - 1;
function assertEncoding(encoding) {
    if (encoding && !Buffer.isEncoding(encoding)) {
        const reason = "is invalid encoding";
        throw new ERR_INVALID_ARG_VALUE(encoding, "encoding", reason);
    }
}
class Dirent {
    constructor(name1, type34){
        this.name = name1;
        this[kType] = type34;
    }
    isDirectory() {
        return this[kType] === UV_DIRENT_DIR;
    }
    isFile() {
        return this[kType] === UV_DIRENT_FILE;
    }
    isBlockDevice() {
        return this[kType] === UV_DIRENT_BLOCK;
    }
    isCharacterDevice() {
        return this[kType] === UV_DIRENT_CHAR;
    }
    isSymbolicLink() {
        return this[kType] === UV_DIRENT_LINK;
    }
    isFIFO() {
        return this[kType] === UV_DIRENT_FIFO;
    }
    isSocket() {
        return this[kType] === UV_DIRENT_SOCKET;
    }
}
class DirentFromStats extends Dirent {
    constructor(name2, stats){
        super(name2, null);
        this[kStats] = stats;
    }
}
for (const name of Reflect.ownKeys(Dirent.prototype)){
    if (name === "constructor") {
        continue;
    }
    DirentFromStats.prototype[name] = function() {
        return this[kStats][name]();
    };
}
function copyObject(source) {
    const target = {};
    for(const key in source){
        target[key] = source[key];
    }
    return target;
}
const bufferSep = Buffer.from(__default5.sep);
function join9(path57, name3) {
    if ((typeof path57 === "string" || isUint8Array(path57)) && name3 === undefined) {
        return path57;
    }
    if (typeof path57 === "string" && isUint8Array(name3)) {
        const pathBuffer = Buffer.from(__default5.join(path57, __default5.sep));
        return Buffer.concat([
            pathBuffer,
            name3
        ]);
    }
    if (typeof path57 === "string" && typeof name3 === "string") {
        return __default5.join(path57, name3);
    }
    if (isUint8Array(path57) && isUint8Array(name3)) {
        return Buffer.concat([
            path57,
            bufferSep,
            name3
        ]);
    }
    throw new ERR_INVALID_ARG_TYPE("path", [
        "string",
        "Buffer"
    ], path57);
}
function getDirents(path58, { 0: names , 1: types  }, callback) {
    let i121;
    if (typeof callback === "function") {
        const len = names.length;
        let toFinish = 0;
        callback = once(callback);
        for(i121 = 0; i121 < len; i121++){
            const type35 = types[i121];
            if (type35 === UV_DIRENT_UNKNOWN) {
                const name4 = names[i121];
                const idx = i121;
                toFinish++;
                let filepath;
                try {
                    filepath = join9(path58, name4);
                } catch (err1) {
                    callback(err1);
                    return;
                }
                lstat(filepath, (err, stats)=>{
                    if (err) {
                        callback(err);
                        return;
                    }
                    names[idx] = new DirentFromStats(name4, stats);
                    if (--toFinish === 0) {
                        callback(null, names);
                    }
                });
            } else {
                names[i121] = new Dirent(names[i121], types[i121]);
            }
        }
        if (toFinish === 0) {
            callback(null, names);
        }
    } else {
        const len = names.length;
        for(i121 = 0; i121 < len; i121++){
            names[i121] = getDirent(path58, names[i121], types[i121]);
        }
        return names;
    }
}
function getDirent(path59, name5, type36, callback) {
    if (typeof callback === "function") {
        if (type36 === UV_DIRENT_UNKNOWN) {
            let filepath;
            try {
                filepath = join9(path59, name5);
            } catch (err5) {
                callback(err5);
                return;
            }
            lstat(filepath, (err, stats)=>{
                if (err) {
                    callback(err);
                    return;
                }
                callback(null, new DirentFromStats(name5, stats));
            });
        } else {
            callback(null, new Dirent(name5, type36));
        }
    } else if (type36 === UV_DIRENT_UNKNOWN) {
        const stats = lstatSync(join9(path59, name5));
        return new DirentFromStats(name5, stats);
    } else {
        return new Dirent(name5, type36);
    }
}
function getOptions1(options, defaultOptions) {
    if (options === null || options === undefined || typeof options === "function") {
        return defaultOptions;
    }
    if (typeof options === "string") {
        defaultOptions = {
            ...defaultOptions
        };
        defaultOptions.encoding = options;
        options = defaultOptions;
    } else if (typeof options !== "object") {
        throw new ERR_INVALID_ARG_TYPE("options", [
            "string",
            "Object"
        ], options);
    }
    if (options.encoding !== "buffer") {
        assertEncoding(options.encoding);
    }
    if (options.signal !== undefined) {
        validateAbortSignal(options.signal, "options.signal");
    }
    return options;
}
function handleErrorFromBinding(ctx) {
    if (ctx.errno !== undefined) {
        const err = uvException(ctx);
        Error.captureStackTrace(err, handleErrorFromBinding);
        throw err;
    }
    if (ctx.error !== undefined) {
        Error.captureStackTrace(ctx.error, handleErrorFromBinding);
        throw ctx.error;
    }
}
const nullCheck = hideStackFrames((path60, propName, throwError = true)=>{
    const pathIsString = typeof path60 === "string";
    const pathIsUint8Array = isUint8Array(path60);
    if (!pathIsString && !pathIsUint8Array || pathIsString && !path60.includes("\u0000") || pathIsUint8Array && !path60.includes(0)) {
        return;
    }
    const err = new ERR_INVALID_ARG_VALUE(propName, path60, "must be a string or Uint8Array without null bytes");
    if (throwError) {
        throw err;
    }
    return err;
});
function preprocessSymlinkDestination(path61, type37, linkPath) {
    if (!isWindows) {
        return path61;
    }
    path61 = "" + path61;
    if (type37 === "junction") {
        path61 = __default5.resolve(linkPath, "..", path61);
        return __default5.toNamespacedPath(path61);
    }
    if (__default5.isAbsolute(path61)) {
        return __default5.toNamespacedPath(path61);
    }
    return path61.replace(/\//g, "\\");
}
function StatsBase(dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks) {
    this.dev = dev;
    this.mode = mode;
    this.nlink = nlink;
    this.uid = uid;
    this.gid = gid;
    this.rdev = rdev;
    this.blksize = blksize;
    this.ino = ino;
    this.size = size;
    this.blocks = blocks;
}
StatsBase.prototype.isDirectory = function() {
    return this._checkModeProperty(S_IFDIR);
};
StatsBase.prototype.isFile = function() {
    return this._checkModeProperty(S_IFREG);
};
StatsBase.prototype.isBlockDevice = function() {
    return this._checkModeProperty(S_IFBLK);
};
StatsBase.prototype.isCharacterDevice = function() {
    return this._checkModeProperty(S_IFCHR);
};
StatsBase.prototype.isSymbolicLink = function() {
    return this._checkModeProperty(S_IFLNK);
};
StatsBase.prototype.isFIFO = function() {
    return this._checkModeProperty(S_IFIFO);
};
StatsBase.prototype.isSocket = function() {
    return this._checkModeProperty(S_IFSOCK);
};
const kNsPerMsBigInt = 10n ** 6n;
const kNsPerSecBigInt = 10n ** 9n;
const kMsPerSec = 10 ** 3;
const kNsPerMs = 10 ** 6;
function msFromTimeSpec(sec, nsec) {
    return sec * kMsPerSec + nsec / kNsPerMs;
}
function nsFromTimeSpecBigInt(sec, nsec) {
    return sec * kNsPerSecBigInt + nsec;
}
function dateFromMs(ms) {
    return new Date(Number(ms) + 0.5);
}
function BigIntStats(dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atimeNs, mtimeNs, ctimeNs, birthtimeNs) {
    Reflect.apply(StatsBase, this, [
        dev,
        mode,
        nlink,
        uid,
        gid,
        rdev,
        blksize,
        ino,
        size,
        blocks, 
    ]);
    this.atimeMs = atimeNs / kNsPerMsBigInt;
    this.mtimeMs = mtimeNs / kNsPerMsBigInt;
    this.ctimeMs = ctimeNs / kNsPerMsBigInt;
    this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;
    this.atimeNs = atimeNs;
    this.mtimeNs = mtimeNs;
    this.ctimeNs = ctimeNs;
    this.birthtimeNs = birthtimeNs;
    this.atime = dateFromMs(this.atimeMs);
    this.mtime = dateFromMs(this.mtimeMs);
    this.ctime = dateFromMs(this.ctimeMs);
    this.birthtime = dateFromMs(this.birthtimeMs);
}
Object.setPrototypeOf(BigIntStats.prototype, StatsBase.prototype);
Object.setPrototypeOf(BigIntStats, StatsBase);
BigIntStats.prototype._checkModeProperty = function(property) {
    if (isWindows && (property === S_IFIFO || property === S_IFBLK || property === S_IFSOCK)) {
        return false;
    }
    return (this.mode & BigInt(S_IFMT)) === BigInt(property);
};
function Stats(dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atimeMs, mtimeMs, ctimeMs, birthtimeMs) {
    StatsBase.call(this, dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks);
    this.atimeMs = atimeMs;
    this.mtimeMs = mtimeMs;
    this.ctimeMs = ctimeMs;
    this.birthtimeMs = birthtimeMs;
    this.atime = dateFromMs(atimeMs);
    this.mtime = dateFromMs(mtimeMs);
    this.ctime = dateFromMs(ctimeMs);
    this.birthtime = dateFromMs(birthtimeMs);
}
Object.setPrototypeOf(Stats.prototype, StatsBase.prototype);
Object.setPrototypeOf(Stats, StatsBase);
Stats.prototype.isFile = StatsBase.prototype.isFile;
Stats.prototype._checkModeProperty = function(property) {
    if (isWindows && (property === S_IFIFO || property === S_IFBLK || property === S_IFSOCK)) {
        return false;
    }
    return (this.mode & S_IFMT) === property;
};
function getStatsFromBinding(stats, offset = 0) {
    if (isBigUint64Array(stats)) {
        return new BigIntStats(stats[0 + offset], stats[1 + offset], stats[2 + offset], stats[3 + offset], stats[4 + offset], stats[5 + offset], stats[6 + offset], stats[7 + offset], stats[8 + offset], stats[9 + offset], nsFromTimeSpecBigInt(stats[10 + offset], stats[11 + offset]), nsFromTimeSpecBigInt(stats[12 + offset], stats[13 + offset]), nsFromTimeSpecBigInt(stats[14 + offset], stats[15 + offset]), nsFromTimeSpecBigInt(stats[16 + offset], stats[17 + offset]));
    }
    return new Stats(stats[0 + offset], stats[1 + offset], stats[2 + offset], stats[3 + offset], stats[4 + offset], stats[5 + offset], stats[6 + offset], stats[7 + offset], stats[8 + offset], stats[9 + offset], msFromTimeSpec(stats[10 + offset], stats[11 + offset]), msFromTimeSpec(stats[12 + offset], stats[13 + offset]), msFromTimeSpec(stats[14 + offset], stats[15 + offset]), msFromTimeSpec(stats[16 + offset], stats[17 + offset]));
}
function stringToFlags(flags, name6 = "flags") {
    if (typeof flags === "number") {
        validateInt32(flags, name6);
        return flags;
    }
    if (flags == null) {
        return O_RDONLY;
    }
    switch(flags){
        case "r":
            return O_RDONLY;
        case "rs":
        case "sr":
            return O_RDONLY | O_SYNC;
        case "r+":
            return O_RDWR;
        case "rs+":
        case "sr+":
            return O_RDWR | O_SYNC;
        case "w":
            return O_TRUNC | O_CREAT | O_WRONLY;
        case "wx":
        case "xw":
            return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;
        case "w+":
            return O_TRUNC | O_CREAT | O_RDWR;
        case "wx+":
        case "xw+":
            return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;
        case "a":
            return O_APPEND | O_CREAT | O_WRONLY;
        case "ax":
        case "xa":
            return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;
        case "as":
        case "sa":
            return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;
        case "a+":
            return O_APPEND | O_CREAT | O_RDWR;
        case "ax+":
        case "xa+":
            return O_APPEND | O_CREAT | O_RDWR | O_EXCL;
        case "as+":
        case "sa+":
            return O_APPEND | O_CREAT | O_RDWR | O_SYNC;
    }
    throw new ERR_INVALID_ARG_VALUE("flags", flags);
}
const stringToSymlinkType = hideStackFrames((type38)=>{
    let flags = 0;
    if (typeof type38 === "string") {
        switch(type38){
            case "dir":
                flags |= UV_FS_SYMLINK_DIR;
                break;
            case "junction":
                flags |= UV_FS_SYMLINK_JUNCTION;
                break;
            case "file":
                break;
            default:
                throw new ERR_FS_INVALID_SYMLINK_TYPE(type38);
        }
    }
    return flags;
});
function toUnixTimestamp(time, name7 = "time") {
    if (typeof time === "string" && +time == time) {
        return +time;
    }
    if (Number.isFinite(time)) {
        if (time < 0) {
            return Date.now() / 1000;
        }
        return time;
    }
    if (isDate1(time)) {
        return Date.getTime(time) / 1000;
    }
    throw new ERR_INVALID_ARG_TYPE(name7, [
        "Date",
        "Time in seconds"
    ], time);
}
const validateOffsetLengthRead = hideStackFrames((offset, length, bufferLength)=>{
    if (offset < 0) {
        throw new ERR_OUT_OF_RANGE("offset", ">= 0", offset);
    }
    if (length < 0) {
        throw new ERR_OUT_OF_RANGE("length", ">= 0", length);
    }
    if (offset + length > bufferLength) {
        throw new ERR_OUT_OF_RANGE("length", `<= ${bufferLength - offset}`, length);
    }
});
const validateOffsetLengthWrite = hideStackFrames((offset, length, byteLength10)=>{
    if (offset > byteLength10) {
        throw new ERR_OUT_OF_RANGE("offset", `<= ${byteLength10}`, offset);
    }
    if (length > byteLength10 - offset) {
        throw new ERR_OUT_OF_RANGE("length", `<= ${byteLength10 - offset}`, length);
    }
    if (length < 0) {
        throw new ERR_OUT_OF_RANGE("length", ">= 0", length);
    }
    validateInt32(length, "length", 0);
});
const validatePath = hideStackFrames((path62, propName = "path")=>{
    if (typeof path62 !== "string" && !isUint8Array(path62)) {
        throw new ERR_INVALID_ARG_TYPE(propName, [
            "string",
            "Buffer",
            "URL"
        ], path62);
    }
    const err = nullCheck(path62, propName, false);
    if (err !== undefined) {
        throw err;
    }
});
const getValidatedPath = hideStackFrames((fileURLOrPath, propName = "path")=>{
    const path63 = toPathIfFileURL(fileURLOrPath);
    validatePath(path63, propName);
    return path63;
});
const getValidatedFd = hideStackFrames((fd, propName = "fd")=>{
    if (Object.is(fd, -0)) {
        return 0;
    }
    validateInt32(fd, propName, 0);
    return fd;
});
const validateBufferArray = hideStackFrames((buffers, propName = "buffers")=>{
    if (!Array.isArray(buffers)) {
        throw new ERR_INVALID_ARG_TYPE(propName, "ArrayBufferView[]", buffers);
    }
    for(let i122 = 0; i122 < buffers.length; i122++){
        if (!isArrayBufferView(buffers[i122])) {
            throw new ERR_INVALID_ARG_TYPE(propName, "ArrayBufferView[]", buffers);
        }
    }
    return buffers;
});
let nonPortableTemplateWarn = true;
function warnOnNonPortableTemplate(template) {
    if (nonPortableTemplateWarn && template.endsWith("X")) {
        process1.emitWarning("mkdtemp() templates ending with X are not portable. " + "For details see: https://nodejs.org/api/fs.html");
        nonPortableTemplateWarn = false;
    }
}
const defaultCpOptions = {
    dereference: false,
    errorOnExist: false,
    filter: undefined,
    force: true,
    preserveTimestamps: false,
    recursive: false
};
const defaultRmOptions = {
    recursive: false,
    force: false,
    retryDelay: 100,
    maxRetries: 0
};
const defaultRmdirOptions = {
    retryDelay: 100,
    maxRetries: 0,
    recursive: false
};
const validateCpOptions = hideStackFrames((options)=>{
    if (options === undefined) {
        return {
            ...defaultCpOptions
        };
    }
    validateObject(options, "options");
    options = {
        ...defaultCpOptions,
        ...options
    };
    validateBoolean(options.dereference, "options.dereference");
    validateBoolean(options.errorOnExist, "options.errorOnExist");
    validateBoolean(options.force, "options.force");
    validateBoolean(options.preserveTimestamps, "options.preserveTimestamps");
    validateBoolean(options.recursive, "options.recursive");
    if (options.filter !== undefined) {
        validateFunction(options.filter, "options.filter");
    }
    return options;
});
const validateRmOptions = hideStackFrames((path64, options, expectDir, cb)=>{
    options = validateRmdirOptions(options, defaultRmOptions);
    validateBoolean(options.force, "options.force");
    stat(path64, (err, stats)=>{
        if (err) {
            if (options.force && err.code === "ENOENT") {
                return cb(null, options);
            }
            return cb(err, options);
        }
        if (expectDir && !stats.isDirectory()) {
            return cb(false);
        }
        if (stats.isDirectory() && !options.recursive) {
            return cb(new ERR_FS_EISDIR({
                code: "EISDIR",
                message: "is a directory",
                path: path64,
                syscall: "rm",
                errno: EISDIR
            }));
        }
        return cb(null, options);
    });
});
const validateRmOptionsSync = hideStackFrames((path65, options, expectDir)=>{
    options = validateRmdirOptions(options, defaultRmOptions);
    validateBoolean(options.force, "options.force");
    if (!options.force || expectDir || !options.recursive) {
        const isDirectory = statSync(path65, {
            throwIfNoEntry: !options.force
        })?.isDirectory();
        if (expectDir && !isDirectory) {
            return false;
        }
        if (isDirectory && !options.recursive) {
            throw new ERR_FS_EISDIR({
                code: "EISDIR",
                message: "is a directory",
                path: path65,
                syscall: "rm",
                errno: EISDIR
            });
        }
    }
    return options;
});
let recursiveRmdirWarned = process1.noDeprecation;
function emitRecursiveRmdirWarning() {
    if (!recursiveRmdirWarned) {
        process1.emitWarning("In future versions of Node.js, fs.rmdir(path, { recursive: true }) " + "will be removed. Use fs.rm(path, { recursive: true }) instead", "DeprecationWarning", "DEP0147");
        recursiveRmdirWarned = true;
    }
}
const validateRmdirOptions = hideStackFrames((options, defaults = defaultRmdirOptions)=>{
    if (options === undefined) {
        return defaults;
    }
    validateObject(options, "options");
    options = {
        ...defaults,
        ...options
    };
    validateBoolean(options.recursive, "options.recursive");
    validateInt32(options.retryDelay, "options.retryDelay", 0);
    validateUint32(options.maxRetries, "options.maxRetries");
    return options;
});
const getValidMode = hideStackFrames((mode, type39)=>{
    let min22 = kMinimumAccessMode;
    let max = kMaximumAccessMode;
    let def = F_OK;
    if (type39 === "copyFile") {
        min22 = kMinimumCopyMode;
        max = kMaximumCopyMode;
        def = mode || kDefaultCopyMode;
    } else {
        assert1(type39 === "access");
    }
    if (mode == null) {
        return def;
    }
    if (Number.isInteger(mode) && mode >= min22 && mode <= max) {
        return mode;
    }
    if (typeof mode !== "number") {
        throw new ERR_INVALID_ARG_TYPE("mode", "integer", mode);
    }
    throw new ERR_OUT_OF_RANGE("mode", `an integer >= ${min22} && <= ${max}`, mode);
});
const validateStringAfterArrayBufferView = hideStackFrames((buffer, name8)=>{
    if (typeof buffer === "string") {
        return;
    }
    if (typeof buffer === "object" && buffer !== null && typeof buffer.toString === "function" && Object.prototype.hasOwnProperty.call(buffer, "toString")) {
        return;
    }
    throw new ERR_INVALID_ARG_TYPE(name8, [
        "string",
        "Buffer",
        "TypedArray",
        "DataView"
    ], buffer);
});
const validatePosition = hideStackFrames((position)=>{
    if (typeof position === "number") {
        validateInteger(position, "position");
    } else if (typeof position === "bigint") {
        if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {
            throw new ERR_OUT_OF_RANGE("position", `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`, position);
        }
    } else {
        throw new ERR_INVALID_ARG_TYPE("position", [
            "integer",
            "bigint"
        ], position);
    }
});
({
    constants: {
        kIoMaxLength,
        kMaxUserId,
        kReadFileBufferLength,
        kReadFileUnknownBufferLength,
        kWriteFileMaxChunkSize
    },
    assertEncoding,
    BigIntStats,
    copyObject,
    Dirent,
    emitRecursiveRmdirWarning,
    getDirent,
    getDirents,
    getOptions: getOptions1,
    getValidatedFd,
    getValidatedPath,
    getValidMode,
    handleErrorFromBinding,
    nullCheck,
    preprocessSymlinkDestination,
    realpathCacheKey: Symbol("realpathCacheKey"),
    getStatsFromBinding,
    stringToFlags,
    stringToSymlinkType,
    Stats,
    toUnixTimestamp,
    validateBufferArray,
    validateCpOptions,
    validateOffsetLengthRead,
    validateOffsetLengthWrite,
    validatePath,
    validatePosition,
    validateRmOptions,
    validateRmOptionsSync,
    validateRmdirOptions,
    validateStringAfterArrayBufferView,
    warnOnNonPortableTemplate
});
function access(path66, mode, callback) {
    if (typeof mode === "function") {
        callback = mode;
        mode = fs.F_OK;
    }
    path66 = getValidatedPath(path66).toString();
    mode = getValidMode(mode, "access");
    const cb = makeCallback(callback);
    Deno.lstat(path66).then((info)=>{
        const m = +mode || 0;
        let fileMode = +info.mode || 0;
        if (Deno.build.os !== "windows" && info.uid === getUid()) {
            fileMode >>= 6;
        }
        if ((m & fileMode) === m) {
            cb(null);
        } else {
            const e = new Error(`EACCES: permission denied, access '${path66}'`);
            e.path = path66;
            e.syscall = "access";
            e.errno = os.errno.EACCES;
            e.code = "EACCES";
            cb(e);
        }
    }, (err)=>{
        if (err instanceof Deno.errors.NotFound) {
            const e = new Error(`ENOENT: no such file or directory, access '${path66}'`);
            e.path = path66;
            e.syscall = "access";
            e.errno = os.errno.ENOENT;
            e.code = "ENOENT";
            cb(e);
        } else {
            cb(err);
        }
    });
}
function writeFile(pathOrRid, data1, optOrCallback, callback) {
    const callbackFn = optOrCallback instanceof Function ? optOrCallback : callback;
    const options = optOrCallback instanceof Function ? undefined : optOrCallback;
    if (!callbackFn) {
        throw new TypeError("Callback must be a function.");
    }
    pathOrRid = pathOrRid instanceof URL ? fromFileUrl5(pathOrRid) : pathOrRid;
    const flag = isFileOptions(options) ? options.flag : undefined;
    const mode = isFileOptions(options) ? options.mode : undefined;
    const encoding = checkEncoding(getEncoding(options)) || "utf8";
    const openOptions = getOpenOptions(flag || "w");
    if (!ArrayBuffer.isView(data1)) {
        validateStringAfterArrayBufferView(data1, "data");
        data1 = Buffer.from(String(data1), encoding);
    }
    const isRid = typeof pathOrRid === "number";
    let file;
    let error18 = null;
    (async ()=>{
        try {
            file = isRid ? new Deno.FsFile(pathOrRid) : await Deno.open(pathOrRid, openOptions);
            if (!isRid && mode && !isWindows) {
                await Deno.chmod(pathOrRid, mode);
            }
            const signal = isFileOptions(options) ? options.signal : undefined;
            await writeAll1(file, data1, {
                signal
            });
        } catch (e) {
            error18 = e instanceof Error ? denoErrorToNodeError(e, {
                syscall: "write"
            }) : new Error("[non-error thrown]");
        } finally{
            if (!isRid && file) file.close();
            callbackFn(error18);
        }
    })();
}
function writeFileSync(pathOrRid, data2, options) {
    pathOrRid = pathOrRid instanceof URL ? fromFileUrl5(pathOrRid) : pathOrRid;
    const flag = isFileOptions(options) ? options.flag : undefined;
    const mode = isFileOptions(options) ? options.mode : undefined;
    const encoding = checkEncoding(getEncoding(options)) || "utf8";
    const openOptions = getOpenOptions(flag || "w");
    if (!ArrayBuffer.isView(data2)) {
        validateStringAfterArrayBufferView(data2, "data");
        data2 = Buffer.from(String(data2), encoding);
    }
    const isRid = typeof pathOrRid === "number";
    let file;
    let error19 = null;
    try {
        file = isRid ? new Deno.FsFile(pathOrRid) : Deno.openSync(pathOrRid, openOptions);
        if (!isRid && mode && !isWindows) {
            Deno.chmodSync(pathOrRid, mode);
        }
        writeAllSync(file, data2);
    } catch (e) {
        error19 = e instanceof Error ? denoErrorToNodeError(e, {
            syscall: "write"
        }) : new Error("[non-error thrown]");
    } finally{
        if (!isRid && file) file.close();
    }
    if (error19) throw error19;
}
async function writeAll1(w, arr, options = {}) {
    const { offset =0 , length =arr.byteLength , signal  } = options;
    checkAborted(signal);
    const written = await w.write(arr.subarray(offset, offset + length));
    if (written === length) {
        return;
    }
    await writeAll1(w, arr, {
        offset: offset + written,
        length: length - written,
        signal
    });
}
function checkAborted(signal) {
    if (signal?.aborted) {
        throw new AbortError();
    }
}
function appendFile(path67, data3, options, callback) {
    callback = maybeCallback(callback || options);
    options = getOptions1(options, {
        encoding: "utf8",
        mode: 0o666,
        flag: "a"
    });
    options = copyObject(options);
    if (!options.flag || isUint32(path67)) {
        options.flag = "a";
    }
    writeFile(path67, data3, options, callback);
}
function appendFileSync(path68, data4, options) {
    options = getOptions1(options, {
        encoding: "utf8",
        mode: 0o666,
        flag: "a"
    });
    options = copyObject(options);
    if (!options.flag || isUint32(path68)) {
        options.flag = "a";
    }
    writeFileSync(path68, data4, options);
}
function chmod(path69, mode, callback) {
    path69 = getValidatedPath(path69).toString();
    mode = parseFileMode(mode, "mode");
    Deno.chmod(toNamespacedPath2(path69), mode).then(()=>callback(null)
    , callback);
}
function chown(path70, uid, gid, callback) {
    callback = makeCallback(callback);
    path70 = getValidatedPath(path70).toString();
    validateInteger(uid, "uid", -1, kMaxUserId);
    validateInteger(gid, "gid", -1, kMaxUserId);
    Deno.chown(toNamespacedPath2(path70), uid, gid).then(()=>callback(null)
    , callback);
}
function close(fd, callback) {
    fd = getValidatedFd(fd);
    setTimeout(()=>{
        let error20 = null;
        try {
            Deno.close(fd);
        } catch (err) {
            error20 = err instanceof Error ? err : new Error("[non-error thrown]");
        }
        callback(error20);
    }, 0);
}
const { F_OK: F_OK1 , R_OK: R_OK1 , W_OK: W_OK1 , X_OK: X_OK1 , S_IRUSR , S_IWUSR , S_IXUSR , S_IRGRP , S_IWGRP , S_IXGRP , S_IROTH , S_IWOTH , S_IXOTH , COPYFILE_EXCL: COPYFILE_EXCL1 , COPYFILE_FICLONE: COPYFILE_FICLONE1 , COPYFILE_FICLONE_FORCE: COPYFILE_FICLONE_FORCE1 , UV_FS_COPYFILE_EXCL , UV_FS_COPYFILE_FICLONE , UV_FS_COPYFILE_FICLONE_FORCE ,  } = fs;
const mod52 = {
    F_OK: F_OK1,
    R_OK: R_OK1,
    W_OK: W_OK1,
    X_OK: X_OK1,
    S_IRUSR: S_IRUSR,
    S_IWUSR: S_IWUSR,
    S_IXUSR: S_IXUSR,
    S_IRGRP: S_IRGRP,
    S_IWGRP: S_IWGRP,
    S_IXGRP: S_IXGRP,
    S_IROTH: S_IROTH,
    S_IWOTH: S_IWOTH,
    S_IXOTH: S_IXOTH,
    COPYFILE_EXCL: COPYFILE_EXCL1,
    COPYFILE_FICLONE: COPYFILE_FICLONE1,
    COPYFILE_FICLONE_FORCE: COPYFILE_FICLONE_FORCE1,
    UV_FS_COPYFILE_EXCL: UV_FS_COPYFILE_EXCL,
    UV_FS_COPYFILE_FICLONE: UV_FS_COPYFILE_FICLONE,
    UV_FS_COPYFILE_FICLONE_FORCE: UV_FS_COPYFILE_FICLONE_FORCE
};
function copyFile(src, dest, mode, callback) {
    if (typeof mode === "function") {
        callback = mode;
        mode = 0;
    }
    const srcStr = getValidatedPath(src, "src").toString();
    const destStr = getValidatedPath(dest, "dest").toString();
    const modeNum = getValidMode(mode, "copyFile");
    const cb = makeCallback(callback);
    if ((modeNum & fs.COPYFILE_EXCL) === fs.COPYFILE_EXCL) {
        Deno.lstat(destStr).then(()=>{
            const e = new Error(`EEXIST: file already exists, copyfile '${srcStr}' -> '${destStr}'`);
            e.syscall = "copyfile";
            e.errno = os.errno.EEXIST;
            e.code = "EEXIST";
            cb(e);
        }, (e)=>{
            if (e instanceof Deno.errors.NotFound) {
                Deno.copyFile(srcStr, destStr).then(()=>cb(null)
                , cb);
            }
            cb(e);
        });
    } else {
        Deno.copyFile(srcStr, destStr).then(()=>cb(null)
        , cb);
    }
}
class Dirent1 {
    constructor(entry){
        this.entry = entry;
    }
    isBlockDevice() {
        notImplemented("Deno does not yet support identification of block devices");
        return false;
    }
    isCharacterDevice() {
        notImplemented("Deno does not yet support identification of character devices");
        return false;
    }
    isDirectory() {
        return this.entry.isDirectory;
    }
    isFIFO() {
        notImplemented("Deno does not yet support identification of FIFO named pipes");
        return false;
    }
    isFile() {
        return this.entry.isFile;
    }
    isSocket() {
        notImplemented("Deno does not yet support identification of sockets");
        return false;
    }
    isSymbolicLink() {
        return this.entry.isSymlink;
    }
    get name() {
        return this.entry.name;
    }
    entry;
}
function existsSync(path71) {
    path71 = path71 instanceof URL ? fromFileUrl5(path71) : path71;
    try {
        Deno.lstatSync(path71);
        return true;
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return false;
        }
        throw err;
    }
}
function link(existingPath, newPath, callback) {
    existingPath = existingPath instanceof URL ? fromFileUrl5(existingPath) : existingPath;
    newPath = newPath instanceof URL ? fromFileUrl5(newPath) : newPath;
    Deno.link(existingPath, newPath).then(()=>callback(null)
    , callback);
}
function mkdir(path72, options, callback) {
    path72 = path72 instanceof URL ? fromFileUrl5(path72) : path72;
    let mode = 0o777;
    let recursive = false;
    if (typeof options == "function") {
        callback = options;
    } else if (typeof options === "number") {
        mode = options;
    } else if (typeof options === "boolean") {
        recursive = options;
    } else if (options) {
        if (options.recursive !== undefined) recursive = options.recursive;
        if (options.mode !== undefined) mode = options.mode;
    }
    if (typeof recursive !== "boolean") {
        throw new Deno.errors.InvalidData("invalid recursive option , must be a boolean");
    }
    Deno.mkdir(path72, {
        recursive,
        mode
    }).then(()=>{
        if (typeof callback === "function") {
            callback(null);
        }
    }, (err)=>{
        if (typeof callback === "function") {
            callback(err);
        }
    });
}
function mkdtemp(prefix, optionsOrCallback, maybeCallback3) {
    const callback = typeof optionsOrCallback == "function" ? optionsOrCallback : maybeCallback3;
    if (!callback) throw new ERR_INVALID_CALLBACK(callback);
    const encoding = parseEncoding(optionsOrCallback);
    const path73 = tempDirPath(prefix);
    mkdir(path73, {
        recursive: false,
        mode: 0o700
    }, (err)=>{
        if (err) callback(err);
        else callback(null, decode3(path73, encoding));
    });
}
function parseEncoding(optionsOrCallback) {
    let encoding;
    if (typeof optionsOrCallback == "function") encoding = undefined;
    else if (optionsOrCallback instanceof Object) {
        encoding = optionsOrCallback?.encoding;
    } else encoding = optionsOrCallback;
    if (encoding) {
        try {
            new TextDecoder(encoding);
        } catch  {
            throw new ERR_INVALID_OPT_VALUE_ENCODING(encoding);
        }
    }
    return encoding;
}
function decode3(str, encoding) {
    if (!encoding) return str;
    else {
        const decoder = new TextDecoder(encoding);
        const encoder = new TextEncoder();
        return decoder.decode(encoder.encode(str));
    }
}
const CHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function randomName() {
    return [
        ...Array(6)
    ].map(()=>CHARS[Math.floor(Math.random() * CHARS.length)]
    ).join("");
}
function tempDirPath(prefix) {
    let path74;
    do {
        path74 = prefix + randomName();
    }while (existsSync(path74))
    return path74;
}
function existsSync1(filePath) {
    try {
        Deno.lstatSync(filePath);
        return true;
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return false;
        }
        throw err;
    }
}
function convertFlagAndModeToOptions(flag, mode) {
    if (!flag && !mode) return undefined;
    if (!flag && mode) return {
        mode
    };
    return {
        ...getOpenOptions(flag),
        mode
    };
}
function open(path75, flagsOrCallback, callbackOrMode, maybeCallback4) {
    const flags = typeof flagsOrCallback === "string" ? flagsOrCallback : undefined;
    const callback = typeof flagsOrCallback === "function" ? flagsOrCallback : typeof callbackOrMode === "function" ? callbackOrMode : maybeCallback4;
    const mode = typeof callbackOrMode === "number" ? callbackOrMode : undefined;
    path75 = path75 instanceof URL ? fromFileUrl5(path75) : path75;
    if (!callback) throw new Error("No callback function supplied");
    if ([
        "ax",
        "ax+",
        "wx",
        "wx+"
    ].includes(flags || "") && existsSync1(path75)) {
        const err = new Error(`EEXIST: file already exists, open '${path75}'`);
        callback(err);
    } else {
        if (flags === "as" || flags === "as+") {
            let err = null, res;
            try {
                res = openSync(path75, flags, mode);
            } catch (error21) {
                err = error21 instanceof Error ? error21 : new Error("[non-error thrown]");
            }
            if (err) {
                callback(err);
            } else {
                callback(null, res);
            }
            return;
        }
        Deno.open(path75, convertFlagAndModeToOptions(flags, mode)).then((file)=>callback(null, file.rid)
        , (err)=>callback(err)
        );
    }
}
function openSync(path76, flagsOrMode, maybeMode) {
    const flags = typeof flagsOrMode === "string" ? flagsOrMode : undefined;
    const mode = typeof flagsOrMode === "number" ? flagsOrMode : maybeMode;
    path76 = path76 instanceof URL ? fromFileUrl5(path76) : path76;
    if ([
        "ax",
        "ax+",
        "wx",
        "wx+"
    ].includes(flags || "") && existsSync1(path76)) {
        throw new Error(`EEXIST: file already exists, open '${path76}'`);
    }
    return Deno.openSync(path76, convertFlagAndModeToOptions(flags, mode)).rid;
}
function asyncIterableToCallback(iter, callback, errCallback) {
    const iterator = iter[Symbol.asyncIterator]();
    function next() {
        iterator.next().then((obj)=>{
            if (obj.done) {
                callback(obj.value, true);
                return;
            }
            callback(obj.value);
            next();
        }, errCallback);
    }
    next();
}
function watch(filename, optionsOrListener, optionsOrListener2) {
    const listener = typeof optionsOrListener === "function" ? optionsOrListener : typeof optionsOrListener2 === "function" ? optionsOrListener2 : undefined;
    const options = typeof optionsOrListener === "object" ? optionsOrListener : typeof optionsOrListener2 === "object" ? optionsOrListener2 : undefined;
    filename = filename instanceof URL ? fromFileUrl5(filename) : filename;
    const iterator = Deno.watchFs(filename, {
        recursive: options?.recursive || false
    });
    if (!listener) throw new Error("No callback function supplied");
    const fsWatcher = new FSWatcher(()=>{
        if (iterator.return) iterator.return();
    });
    fsWatcher.on("change", listener);
    asyncIterableToCallback(iterator, (val, done)=>{
        if (done) return;
        fsWatcher.emit("change", val.kind, val.paths[0]);
    }, (e)=>{
        fsWatcher.emit("error", e);
    });
    return fsWatcher;
}
class FSWatcher extends EventEmitter {
    close;
    constructor(closer){
        super();
        this.close = closer;
    }
    ref() {
        notImplemented("FSWatcher.ref() is not implemented");
    }
    unref() {
        notImplemented("FSWatcher.unref() is not implemented");
    }
}
function toDirent(val) {
    return new Dirent1(val);
}
function readdir(path77, optionsOrCallback, maybeCallback5) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback5;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : null;
    const result = [];
    path77 = getValidatedPath(path77);
    if (!callback) throw new Error("No callback function supplied");
    if (options?.encoding) {
        try {
            new TextDecoder(options.encoding);
        } catch  {
            throw new Error(`TypeError [ERR_INVALID_OPT_VALUE_ENCODING]: The value "${options.encoding}" is invalid for option "encoding"`);
        }
    }
    try {
        asyncIterableToCallback(Deno.readDir(path77.toString()), (val, done)=>{
            if (typeof path77 !== "string") return;
            if (done) {
                callback(null, result);
                return;
            }
            if (options?.withFileTypes) {
                result.push(toDirent(val));
            } else result.push(decode4(val.name));
        }, (e)=>{
            callback(denoErrorToNodeError(e, {
                syscall: "readdir"
            }));
        });
    } catch (e) {
        callback(denoErrorToNodeError(e, {
            syscall: "readdir"
        }));
    }
}
function decode4(str, encoding) {
    if (!encoding) return str;
    else {
        const decoder = new TextDecoder(encoding);
        const encoder = new TextEncoder();
        return decoder.decode(encoder.encode(str));
    }
}
function maybeDecode(data5, encoding) {
    const buffer = Buffer.from(data5.buffer, data5.byteOffset, data5.byteLength);
    if (encoding && encoding !== "binary") return buffer.toString(encoding);
    return buffer;
}
function readFile(path78, optOrCallback, callback) {
    path78 = path78 instanceof URL ? fromFileUrl5(path78) : path78;
    let cb;
    if (typeof optOrCallback === "function") {
        cb = optOrCallback;
    } else {
        cb = callback;
    }
    const encoding = getEncoding(optOrCallback);
    const p = Deno.readFile(path78);
    if (cb) {
        p.then((data6)=>{
            if (encoding && encoding !== "binary") {
                const text = maybeDecode(data6, encoding);
                return cb(null, text);
            }
            const buffer = maybeDecode(data6, encoding);
            cb(null, buffer);
        }, (err)=>cb && cb(err)
        );
    }
}
function readFileSync(path79, opt) {
    path79 = path79 instanceof URL ? fromFileUrl5(path79) : path79;
    const data7 = Deno.readFileSync(path79);
    const encoding = getEncoding(opt);
    if (encoding && encoding !== "binary") {
        const text = maybeDecode(data7, encoding);
        return text;
    }
    const buffer = maybeDecode(data7, encoding);
    return buffer;
}
function maybeEncode(data8, encoding) {
    if (encoding === "buffer") {
        return new TextEncoder().encode(data8);
    }
    return data8;
}
function getEncoding1(optOrCallback) {
    if (!optOrCallback || typeof optOrCallback === "function") {
        return null;
    } else {
        if (optOrCallback.encoding) {
            if (optOrCallback.encoding === "utf8" || optOrCallback.encoding === "utf-8") {
                return "utf8";
            } else if (optOrCallback.encoding === "buffer") {
                return "buffer";
            } else {
                notImplemented(`fs.readlink encoding=${optOrCallback.encoding}`);
            }
        }
        return null;
    }
}
function readlink(path80, optOrCallback, callback) {
    path80 = path80 instanceof URL ? fromFileUrl5(path80) : path80;
    let cb;
    if (typeof optOrCallback === "function") {
        cb = optOrCallback;
    } else {
        cb = callback;
    }
    const encoding = getEncoding1(optOrCallback);
    intoCallbackAPIWithIntercept(Deno.readLink, (data9)=>maybeEncode(data9, encoding)
    , cb, path80);
}
function realpath(path112, options, callback) {
    if (typeof options === "function") {
        callback = options;
    }
    if (!callback) {
        throw new Error("No callback function supplied");
    }
    Deno.realPath(path112).then((path81)=>callback(null, path81)
    , (err)=>callback(err)
    );
}
realpath.native = realpath;
function realpathSync(path82) {
    return Deno.realPathSync(path82);
}
realpathSync.native = realpathSync;
function rename(oldPath, newPath, callback) {
    oldPath = oldPath instanceof URL ? fromFileUrl5(oldPath) : oldPath;
    newPath = newPath instanceof URL ? fromFileUrl5(newPath) : newPath;
    if (!callback) throw new Error("No callback function supplied");
    Deno.rename(oldPath, newPath).then((_)=>callback()
    , callback);
}
function rmdir(path83, optionsOrCallback, maybeCallback6) {
    path83 = toNamespacedPath5(getValidatedPath(path83));
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback6;
    const options1 = typeof optionsOrCallback === "object" ? optionsOrCallback : undefined;
    if (!callback) throw new Error("No callback function supplied");
    if (options1?.recursive) {
        emitRecursiveRmdirWarning();
        validateRmOptions(path83, {
            ...options1,
            force: false
        }, true, (err, options)=>{
            if (err === false) {
                return callback(new ERR_FS_RMDIR_ENOTDIR(path83.toString()));
            }
            if (err) {
                return callback(err);
            }
            Deno.remove(path83, {
                recursive: options?.recursive
            }).then((_)=>callback()
            , callback);
        });
    } else {
        validateRmdirOptions(options1);
        Deno.remove(path83, {
            recursive: options1?.recursive
        }).then((_)=>callback()
        , (err)=>{
            callback(err instanceof Error ? denoErrorToNodeError(err, {
                syscall: "rmdir"
            }) : err);
        });
    }
}
function rm(path84, optionsOrCallback, maybeCallback7) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback7;
    const options1 = typeof optionsOrCallback === "object" ? optionsOrCallback : undefined;
    if (!callback) throw new Error("No callback function supplied");
    validateRmOptions(path84, options1, false, (err1, options)=>{
        if (err1) {
            return callback(err1);
        }
        Deno.remove(path84, {
            recursive: options?.recursive
        }).then((_)=>callback(null)
        , (err)=>{
            if (options?.force && err instanceof Deno.errors.NotFound) {
                callback(null);
            } else {
                callback(err instanceof Error ? denoErrorToNodeError(err, {
                    syscall: "rm"
                }) : err);
            }
        });
    });
}
function symlink(target, path85, typeOrCallback, maybeCallback8) {
    target = target instanceof URL ? fromFileUrl5(target) : target;
    path85 = path85 instanceof URL ? fromFileUrl5(path85) : path85;
    const type40 = typeof typeOrCallback === "string" ? typeOrCallback : "file";
    const callback = typeof typeOrCallback === "function" ? typeOrCallback : maybeCallback8;
    if (!callback) throw new Error("No callback function supplied");
    Deno.symlink(target, path85, {
        type: type40
    }).then(()=>callback(null)
    , callback);
}
function truncate(path86, lenOrCallback, maybeCallback9) {
    path86 = path86 instanceof URL ? fromFileUrl5(path86) : path86;
    const len = typeof lenOrCallback === "number" ? lenOrCallback : undefined;
    const callback = typeof lenOrCallback === "function" ? lenOrCallback : maybeCallback9;
    if (!callback) throw new Error("No callback function supplied");
    Deno.truncate(path86, len).then(()=>callback(null)
    , callback);
}
function unlink(path87, callback) {
    if (!callback) throw new Error("No callback function supplied");
    Deno.remove(path87).then((_)=>callback()
    , callback);
}
function getValidTime(time, name55) {
    if (typeof time === "string") {
        time = Number(time);
    }
    if (typeof time === "number" && (Number.isNaN(time) || !Number.isFinite(time))) {
        throw new Deno.errors.InvalidData(`invalid ${name55}, must not be infinity or NaN`);
    }
    return time;
}
function utimes(path88, atime, mtime, callback) {
    path88 = path88 instanceof URL ? fromFileUrl5(path88) : path88;
    if (!callback) {
        throw new Deno.errors.InvalidData("No callback function supplied");
    }
    atime = getValidTime(atime, "atime");
    mtime = getValidTime(mtime, "mtime");
    utime(path88, atime, mtime).then(()=>callback(null)
    , callback);
}
function write(fd2, buffer2, offset2, length2, position2, callback) {
    fd2 = getValidatedFd(fd2);
    const innerWrite = async (fd, buffer, offset, length, position)=>{
        if (buffer instanceof DataView) {
            buffer = new Uint8Array(buffer.buffer);
        }
        if (typeof position === "number") {
            await Deno.seek(fd, position, Deno.SeekMode.Start);
        }
        let currentOffset = offset;
        const end = offset + length;
        while(currentOffset - offset < length){
            currentOffset += await Deno.write(fd, buffer.subarray(currentOffset, end));
        }
        return currentOffset - offset;
    };
    if (isArrayBufferView(buffer2)) {
        callback = maybeCallback(callback || position2 || length2 || offset2);
        if (offset2 == null || typeof offset2 === "function") {
            offset2 = 0;
        } else {
            validateInteger(offset2, "offset", 0);
        }
        if (typeof length2 !== "number") {
            length2 = buffer2.byteLength - offset2;
        }
        if (typeof position2 !== "number") {
            position2 = null;
        }
        validateOffsetLengthWrite(offset2, length2, buffer2.byteLength);
        innerWrite(fd2, buffer2, offset2, length2, position2).then((nwritten)=>{
            callback(null, nwritten, buffer2);
        }, (err)=>callback(err)
        );
        return;
    }
    validateStringAfterArrayBufferView(buffer2, "buffer");
    if (typeof position2 !== "function") {
        if (typeof offset2 === "function") {
            position2 = offset2;
            offset2 = null;
        } else {
            position2 = length2;
        }
        length2 = "utf-8";
    }
    const str = String(buffer2);
    validateEncoding(str, length2);
    callback = maybeCallback(position2);
    buffer2 = Buffer.from(str, length2);
    innerWrite(fd2, buffer2, 0, buffer2.length, offset2, callback).then((nwritten)=>{
        callback(null, nwritten, buffer2);
    }, (err)=>callback(err)
    );
}
const kFs = Symbol("kFs");
const kIsPerformingIO = Symbol("kIsPerformingIO");
const kIoDone = Symbol("kIoDone");
class WriteStreamClass extends Writable {
    fd = null;
    path;
    flags;
    mode;
    bytesWritten = 0;
    pos = 0;
    [kFs] = {
        open,
        write
    };
    [kIsPerformingIO] = false;
    constructor(path89, opts = {}){
        super(opts);
        this.path = toPathIfFileURL(path89);
        this.flags = opts.flags || "w";
        this.mode = opts.mode || 0o666;
        this[kFs] = opts.fs ?? {
            open,
            write,
            close
        };
        if (opts.encoding) {
            this.setDefaultEncoding(opts.encoding);
        }
    }
    _construct(callback) {
        this[kFs].open(this.path.toString(), this.flags, this.mode, (err, fd)=>{
            if (err) {
                callback(err);
                return;
            }
            this.fd = fd;
            callback();
            this.emit("open", this.fd);
            this.emit("ready");
        });
    }
    _write(data10, _encoding, cb) {
        this[kIsPerformingIO] = true;
        this[kFs].write(this.fd, data10, 0, data10.length, this.pos, (er, bytes)=>{
            this[kIsPerformingIO] = false;
            if (this.destroyed) {
                cb(er);
                return this.emit(kIoDone, er);
            }
            if (er) {
                return cb(er);
            }
            this.bytesWritten += bytes;
            cb();
        });
        if (this.pos !== undefined) {
            this.pos += data10.length;
        }
    }
    _destroy(err, cb) {
        if (this[kIsPerformingIO]) {
            this.once(kIoDone, (er)=>closeStream(this, err || er, cb)
            );
        } else {
            closeStream(this, err, cb);
        }
    }
}
function closeStream(stream1, err, cb) {
    if (!stream1.fd) {
        cb(err);
    } else {
        stream1[kFs].close(stream1.fd, (er)=>{
            cb(er || err);
        });
        stream1.fd = null;
    }
}
function WriteStream(path90, opts) {
    return new WriteStreamClass(path90, opts);
}
WriteStream.prototype = WriteStreamClass.prototype;
const { F_OK: F_OK2 , R_OK: R_OK2 , W_OK: W_OK2 , X_OK: X_OK2 ,  } = mod52;
({
    access: promisify(access),
    copyFile: promisify(copyFile),
    open: promisify(open),
    rename: promisify(rename),
    truncate: promisify(truncate),
    rm: promisify(rm),
    rmdir: promisify(rmdir),
    mkdir: promisify(mkdir),
    readdir: promisify(readdir),
    readlink: promisify(readlink),
    symlink: promisify(symlink),
    lstat: promisify(lstat),
    stat: promisify(stat),
    link: promisify(link),
    unlink: promisify(unlink),
    chmod: promisify(chmod),
    chown: promisify(chown),
    utimes: promisify(utimes),
    realpath: promisify(realpath),
    mkdtemp: promisify(mkdtemp),
    writeFile: promisify(writeFile),
    appendFile: promisify(appendFile),
    readFile: promisify(readFile),
    watch: promisify(watch)
});
var EOL;
(function(EOL1) {
    EOL1["LF"] = "\n";
    EOL1["CRLF"] = "\r\n";
})(EOL || (EOL = {}));
const SEE_GITHUB_ISSUE = "See https://github.com/denoland/deno_std/issues/1436";
function arch1() {
    return process1.arch;
}
arch1[Symbol.toPrimitive] = ()=>process1.arch
;
endianness[Symbol.toPrimitive] = ()=>endianness()
;
freemem[Symbol.toPrimitive] = ()=>freemem()
;
homedir[Symbol.toPrimitive] = ()=>homedir()
;
hostname1[Symbol.toPrimitive] = ()=>hostname1()
;
platform1[Symbol.toPrimitive] = ()=>platform1()
;
release[Symbol.toPrimitive] = ()=>release()
;
totalmem[Symbol.toPrimitive] = ()=>totalmem()
;
type[Symbol.toPrimitive] = ()=>type()
;
uptime[Symbol.toPrimitive] = ()=>uptime()
;
function endianness() {
    const buffer = new ArrayBuffer(2);
    new DataView(buffer).setInt16(0, 256, true);
    return new Int16Array(buffer)[0] === 256 ? "LE" : "BE";
}
function freemem() {
    return systemMemoryInfo().free;
}
function homedir() {
    switch(osType){
        case "windows":
            return Deno.env.get("USERPROFILE") || null;
        case "linux":
        case "darwin":
            return Deno.env.get("HOME") || null;
        default:
            throw Error("unreachable");
    }
}
function hostname1() {
    return hostname();
}
function platform1() {
    return process1.platform;
}
function release() {
    return osRelease();
}
function totalmem() {
    return systemMemoryInfo().total;
}
function type() {
    switch(Deno.build.os){
        case "windows":
            return "Windows_NT";
        case "linux":
            return "Linux";
        case "darwin":
            return "Darwin";
        default:
            throw Error("unreachable");
    }
}
function uptime() {
    notImplemented(SEE_GITHUB_ISSUE);
}
isWindows ? EOL.CRLF : EOL.LF;
(function(global_object) {
    "use strict";
    var console;
    if (typeof globalThis !== 'undefined') {
        global_object = globalThis;
    } else if (typeof global !== 'undefined') {
        global_object = global;
    } else if (typeof window !== 'undefined') {
        global_object = window;
    }
    if (typeof global_object.console === 'object') {
        console = global_object.console;
    } else if (global_object.console == null) {
        console = global_object.console = {};
    } else {
        console = {};
    }
    if (!('log' in console)) {
        console.log = function() {};
    }
    if (!('warn' in console)) {
        console.warn = console.log;
    }
    if (typeof global_object.Opal !== 'undefined') {
        console.warn('Opal already loaded. Loading twice can cause troubles, please fix your setup.');
        return global_object.Opal;
    }
    var nil;
    var BasicObject;
    var _Object;
    var Module;
    var Class;
    var Opal = global_object.Opal = {};
    Opal.global = global_object;
    global_object.Opal = Opal;
    Opal.config = {
        missing_require_severity: 'error',
        unsupported_features_severity: 'warning',
        enable_stack_trace: true
    };
    var $has_own = Object.hasOwnProperty;
    var $bind = Function.prototype.bind;
    var $set_proto = Object.setPrototypeOf;
    var $slice = Array.prototype.slice;
    var $splice = Array.prototype.splice;
    var nil_id = 4;
    var unique_id = nil_id;
    Opal.uid = function() {
        unique_id += 2;
        return unique_id;
    };
    Opal.id = function(obj) {
        if (obj.$$is_number) return obj * 2 + 1;
        if (obj.$$id != null) {
            return obj.$$id;
        }
        $defineProperty(obj, '$$id', Opal.uid());
        return obj.$$id;
    };
    Opal.gvars = {};
    Opal.exit = function(status) {
        if (Opal.gvars.DEBUG) console.log('Exited with status ' + status);
    };
    Opal.exceptions = [];
    Opal.pop_exception = function() {
        Opal.gvars["!"] = Opal.exceptions.pop() || nil;
    };
    Opal.inspect = function(obj) {
        if (obj === undefined) {
            return "undefined";
        } else if (obj === null) {
            return "null";
        } else if (!obj.$$class) {
            return obj.toString();
        } else {
            return obj.$inspect();
        }
    };
    function $defineProperty(object, name56, initialValue) {
        if (typeof object === "string") {
            object[name56] = initialValue;
        } else {
            Object.defineProperty(object, name56, {
                value: initialValue,
                enumerable: false,
                configurable: true,
                writable: true
            });
        }
    }
    Opal.defineProperty = $defineProperty;
    Opal.slice = $slice;
    Opal.truthy = function(val) {
        return val !== nil && val != null && (!val.$$is_boolean || val == true);
    };
    Opal.falsy = function(val) {
        return val === nil || val == null || val.$$is_boolean && val == false;
    };
    Opal.type_error = function(object, type41, method, coerced) {
        object = object.$$class;
        if (coerced && method) {
            coerced = coerced.$$class;
            return Opal.TypeError.$new("can't convert " + object + " into " + type41 + " (" + object + "#" + method + " gives " + coerced + ")");
        } else {
            return Opal.TypeError.$new("no implicit conversion of " + object + " into " + type41);
        }
    };
    Opal.coerce_to = function(object, type42, method, args2) {
        if (type42['$==='](object)) return object;
        if (!object['$respond_to?'](method)) {
            throw Opal.type_error(object, type42);
        }
        if (args2 == null) args2 = [];
        return Opal.send(object, method, args2);
    };
    Opal.respond_to = function(obj, jsid, include_all) {
        if (obj == null || !obj.$$class) return false;
        include_all = !!include_all;
        var body = obj[jsid];
        if (obj['$respond_to?'].$$pristine) {
            if (obj['$respond_to_missing?'].$$pristine) {
                return typeof body === "function" && !body.$$stub;
            } else {
                return Opal.send(obj, obj['$respond_to_missing?'], [
                    jsid.substr(1),
                    include_all
                ]);
            }
        } else {
            return Opal.send(obj, obj['$respond_to?'], [
                jsid.substr(1),
                include_all
            ]);
        }
    };
    function const_get_name(cref, name57) {
        if (cref) return cref.$$const[name57];
    }
    function const_lookup_nesting(nesting, name58) {
        var i123, ii, constant;
        if (nesting.length === 0) return;
        for(i123 = 0, ii = nesting.length; i123 < ii; i123++){
            constant = nesting[i123].$$const[name58];
            if (constant != null) return constant;
        }
    }
    function const_lookup_ancestors(cref, name59) {
        var i124, ii, ancestors;
        if (cref == null) return;
        ancestors = Opal.ancestors(cref);
        for(i124 = 0, ii = ancestors.length; i124 < ii; i124++){
            if (ancestors[i124].$$const && $has_own.call(ancestors[i124].$$const, name59)) {
                return ancestors[i124].$$const[name59];
            }
        }
    }
    function const_lookup_Object(cref, name60) {
        if (cref == null || cref.$$is_module) {
            return const_lookup_ancestors(_Object, name60);
        }
    }
    function const_missing(cref, name61, skip_missing) {
        if (!skip_missing) {
            return (cref || _Object).$const_missing(name61);
        }
    }
    Opal.const_get_local = function(cref, name62, skip_missing) {
        var result;
        if (cref == null) return;
        if (cref === '::') cref = _Object;
        if (!cref.$$is_module && !cref.$$is_class) {
            throw new Opal.TypeError(cref.toString() + " is not a class/module");
        }
        result = const_get_name(cref, name62);
        if (result != null) return result;
        result = const_missing(cref, name62, skip_missing);
        if (result != null) return result;
    };
    Opal.const_get_qualified = function(cref, name63, skip_missing) {
        var result, cache, cached, current_version = Opal.const_cache_version;
        if (cref == null) return;
        if (cref === '::') cref = _Object;
        if (!cref.$$is_module && !cref.$$is_class) {
            throw new Opal.TypeError(cref.toString() + " is not a class/module");
        }
        if ((cache = cref.$$const_cache) == null) {
            $defineProperty(cref, '$$const_cache', Object.create(null));
            cache = cref.$$const_cache;
        }
        cached = cache[name63];
        if (cached == null || cached[0] !== current_version) {
            (result = const_get_name(cref, name63)) != null || (result = const_lookup_ancestors(cref, name63)) != null;
            cache[name63] = [
                current_version,
                result
            ];
        } else {
            result = cached[1];
        }
        return result != null ? result : const_missing(cref, name63, skip_missing);
    };
    Opal.const_cache_version = 1;
    Opal.const_get_relative = function(nesting, name64, skip_missing) {
        var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;
        if ((cache = nesting.$$const_cache) == null) {
            $defineProperty(nesting, '$$const_cache', Object.create(null));
            cache = nesting.$$const_cache;
        }
        cached = cache[name64];
        if (cached == null || cached[0] !== current_version) {
            (result = const_get_name(cref, name64)) != null || (result = const_lookup_nesting(nesting, name64)) != null || (result = const_lookup_ancestors(cref, name64)) != null || (result = const_lookup_Object(cref, name64)) != null;
            cache[name64] = [
                current_version,
                result
            ];
        } else {
            result = cached[1];
        }
        return result != null ? result : const_missing(cref, name64, skip_missing);
    };
    Opal.const_set = function(cref, name65, value) {
        if (cref == null || cref === '::') cref = _Object;
        if (value.$$is_a_module) {
            if (value.$$name == null || value.$$name === nil) value.$$name = name65;
            if (value.$$base_module == null) value.$$base_module = cref;
        }
        cref.$$const = cref.$$const || Object.create(null);
        cref.$$const[name65] = value;
        cref.$$ = cref.$$const;
        Opal.const_cache_version++;
        if (cref === _Object) Opal[name65] = value;
        $defineProperty(cref, name65, value);
        return value;
    };
    Opal.constants = function(cref, inherit) {
        if (inherit == null) inherit = true;
        var module, modules1 = [
            cref
        ], i125, ii, constants6 = {}, constant;
        if (inherit) modules1 = modules1.concat(Opal.ancestors(cref));
        if (inherit && cref.$$is_module) modules1 = modules1.concat([
            Opal.Object
        ]).concat(Opal.ancestors(Opal.Object));
        for(i125 = 0, ii = modules1.length; i125 < ii; i125++){
            module = modules1[i125];
            if (cref !== _Object && module == _Object) break;
            for(constant in module.$$const){
                constants6[constant] = true;
            }
        }
        return Object.keys(constants6);
    };
    Opal.const_remove = function(cref, name66) {
        Opal.const_cache_version++;
        if (cref.$$const[name66] != null) {
            var old = cref.$$const[name66];
            delete cref.$$const[name66];
            return old;
        }
        if (cref.$$autoload != null && cref.$$autoload[name66] != null) {
            delete cref.$$autoload[name66];
            return nil;
        }
        throw Opal.NameError.$new("constant " + cref + "::" + cref.$name() + " not defined");
    };
    Opal.$$ = Opal.const_get_relative;
    Opal.$$$ = Opal.const_get_qualified;
    Opal.allocate_class = function(name67, superclass) {
        var klass, constructor;
        if (superclass != null && superclass.$$bridge) {
            constructor = function() {
                var args3 = $slice.call(arguments), self = new ($bind.apply(superclass.$$constructor, [
                    null
                ].concat(args3)))();
                $set_proto(self, klass.$$prototype);
                return self;
            };
        } else {
            constructor = function() {};
        }
        if (name67) {
            $defineProperty(constructor, 'displayName', '::' + name67);
        }
        klass = constructor;
        $defineProperty(klass, '$$name', name67);
        $defineProperty(klass, '$$constructor', constructor);
        $defineProperty(klass, '$$prototype', constructor.prototype);
        $defineProperty(klass, '$$const', {});
        $defineProperty(klass, '$$is_class', true);
        $defineProperty(klass, '$$is_a_module', true);
        $defineProperty(klass, '$$super', superclass);
        $defineProperty(klass, '$$cvars', {});
        $defineProperty(klass, '$$own_included_modules', []);
        $defineProperty(klass, '$$own_prepended_modules', []);
        $defineProperty(klass, '$$ancestors', []);
        $defineProperty(klass, '$$ancestors_cache_version', null);
        $defineProperty(klass.$$prototype, '$$class', klass);
        if (Opal.Class) {
            $set_proto(klass, Opal.Class.prototype);
        }
        if (superclass != null) {
            $set_proto(klass.$$prototype, superclass.$$prototype);
            if (superclass.$$meta) {
                Opal.build_class_singleton_class(klass);
            }
        }
        return klass;
    };
    function find_existing_class(scope, name68) {
        var klass = const_get_name(scope, name68);
        if (klass) {
            if (!klass.$$is_class) {
                throw Opal.TypeError.$new(name68 + " is not a class");
            }
            return klass;
        }
    }
    function ensureSuperclassMatch(klass, superclass) {
        if (klass.$$super !== superclass) {
            throw Opal.TypeError.$new("superclass mismatch for class " + klass.$$name);
        }
    }
    Opal.klass = function(scope, superclass, name69) {
        var bridged;
        if (scope == null || scope == '::') {
            scope = _Object;
        } else if (!scope.$$is_class && !scope.$$is_module) {
            scope = scope.$$class;
        }
        if (superclass != null && (!superclass.hasOwnProperty || superclass.hasOwnProperty && !superclass.hasOwnProperty('$$is_class'))) {
            if (superclass.constructor && superclass.constructor.name == "Function") {
                bridged = superclass;
                superclass = _Object;
            } else {
                throw Opal.TypeError.$new("superclass must be a Class (" + (superclass.constructor && (superclass.constructor.name || superclass.constructor.$$name) || typeof superclass) + " given)");
            }
        }
        var klass = find_existing_class(scope, name69);
        if (klass) {
            if (superclass) {
                ensureSuperclassMatch(klass, superclass);
            }
            return klass;
        }
        if (superclass == null) {
            superclass = _Object;
        }
        klass = Opal.allocate_class(name69, superclass);
        Opal.const_set(scope, name69, klass);
        if (superclass.$inherited) {
            superclass.$inherited(klass);
        }
        if (bridged) {
            Opal.bridge(bridged, klass);
        }
        return klass;
    };
    Opal.allocate_module = function(name70) {
        var constructor = function() {};
        if (name70) {
            $defineProperty(constructor, 'displayName', name70 + '.$$constructor');
        }
        var module = constructor;
        if (name70) $defineProperty(constructor, 'displayName', name70 + '.constructor');
        $defineProperty(module, '$$name', name70);
        $defineProperty(module, '$$prototype', constructor.prototype);
        $defineProperty(module, '$$const', {});
        $defineProperty(module, '$$is_module', true);
        $defineProperty(module, '$$is_a_module', true);
        $defineProperty(module, '$$cvars', {});
        $defineProperty(module, '$$iclasses', []);
        $defineProperty(module, '$$own_included_modules', []);
        $defineProperty(module, '$$own_prepended_modules', []);
        $defineProperty(module, '$$ancestors', [
            module
        ]);
        $defineProperty(module, '$$ancestors_cache_version', null);
        $set_proto(module, Opal.Module.prototype);
        return module;
    };
    function find_existing_module(scope, name71) {
        var module = const_get_name(scope, name71);
        if (module == null && scope === _Object) module = const_lookup_ancestors(_Object, name71);
        if (module) {
            if (!module.$$is_module && module !== _Object) {
                throw Opal.TypeError.$new(name71 + " is not a module");
            }
        }
        return module;
    }
    Opal.module = function(scope, name72) {
        var module;
        if (scope == null || scope == '::') {
            scope = _Object;
        } else if (!scope.$$is_class && !scope.$$is_module) {
            scope = scope.$$class;
        }
        module = find_existing_module(scope, name72);
        if (module) {
            return module;
        }
        module = Opal.allocate_module(name72);
        Opal.const_set(scope, name72, module);
        return module;
    };
    Opal.get_singleton_class = function(object) {
        if (object.$$meta) {
            return object.$$meta;
        }
        if (object.hasOwnProperty('$$is_class')) {
            return Opal.build_class_singleton_class(object);
        } else if (object.hasOwnProperty('$$is_module')) {
            return Opal.build_module_singleton_class(object);
        } else {
            return Opal.build_object_singleton_class(object);
        }
    };
    Opal.build_class_singleton_class = function(klass) {
        var superclass, meta1;
        if (klass.$$meta) {
            return klass.$$meta;
        }
        superclass = klass === BasicObject ? Class : Opal.get_singleton_class(klass.$$super);
        meta1 = Opal.allocate_class(null, superclass, function() {});
        $defineProperty(meta1, '$$is_singleton', true);
        $defineProperty(meta1, '$$singleton_of', klass);
        $defineProperty(klass, '$$meta', meta1);
        $set_proto(klass, meta1.$$prototype);
        $defineProperty(klass, '$$class', Opal.Class);
        return meta1;
    };
    Opal.build_module_singleton_class = function(mod54) {
        if (mod54.$$meta) {
            return mod54.$$meta;
        }
        var meta2 = Opal.allocate_class(null, Opal.Module, function() {});
        $defineProperty(meta2, '$$is_singleton', true);
        $defineProperty(meta2, '$$singleton_of', mod54);
        $defineProperty(mod54, '$$meta', meta2);
        $set_proto(mod54, meta2.$$prototype);
        $defineProperty(mod54, '$$class', Opal.Module);
        return meta2;
    };
    Opal.build_object_singleton_class = function(object) {
        var superclass = object.$$class, klass = Opal.allocate_class(nil, superclass, function() {});
        $defineProperty(klass, '$$is_singleton', true);
        $defineProperty(klass, '$$singleton_of', object);
        delete klass.$$prototype.$$class;
        $defineProperty(object, '$$meta', klass);
        $set_proto(object, object.$$meta.$$prototype);
        return klass;
    };
    Opal.is_method = function(prop) {
        return prop[0] === '$' && prop[1] !== '$';
    };
    Opal.instance_methods = function(mod55) {
        var exclude = [], results = [], ancestors = Opal.ancestors(mod55);
        for(var i126 = 0, l = ancestors.length; i126 < l; i126++){
            var ancestor = ancestors[i126], proto = ancestor.$$prototype;
            if (proto.hasOwnProperty('$$dummy')) {
                proto = proto.$$define_methods_on;
            }
            var props = Object.getOwnPropertyNames(proto);
            for(var j = 0, ll = props.length; j < ll; j++){
                var prop = props[j];
                if (Opal.is_method(prop)) {
                    var method_name = prop.slice(1), method = proto[prop];
                    if (method.$$stub && exclude.indexOf(method_name) === -1) {
                        exclude.push(method_name);
                    }
                    if (!method.$$stub && results.indexOf(method_name) === -1 && exclude.indexOf(method_name) === -1) {
                        results.push(method_name);
                    }
                }
            }
        }
        return results;
    };
    Opal.own_instance_methods = function(mod56) {
        var results = [], proto = mod56.$$prototype;
        if (proto.hasOwnProperty('$$dummy')) {
            proto = proto.$$define_methods_on;
        }
        var props = Object.getOwnPropertyNames(proto);
        for(var i127 = 0, length = props.length; i127 < length; i127++){
            var prop = props[i127];
            if (Opal.is_method(prop)) {
                var method = proto[prop];
                if (!method.$$stub) {
                    var method_name = prop.slice(1);
                    results.push(method_name);
                }
            }
        }
        return results;
    };
    Opal.methods = function(obj) {
        return Opal.instance_methods(Opal.get_singleton_class(obj));
    };
    Opal.own_methods = function(obj) {
        return Opal.own_instance_methods(Opal.get_singleton_class(obj));
    };
    Opal.receiver_methods = function(obj) {
        var mod57 = Opal.get_singleton_class(obj);
        var singleton_methods = Opal.own_instance_methods(mod57);
        var instance_methods = Opal.own_instance_methods(mod57.$$super);
        return singleton_methods.concat(instance_methods);
    };
    Opal.class_variables = function(module) {
        var ancestors = Opal.ancestors(module), i128, length = ancestors.length, result = {};
        for(i128 = length - 1; i128 >= 0; i128--){
            var ancestor = ancestors[i128];
            for(var cvar in ancestor.$$cvars){
                result[cvar] = ancestor.$$cvars[cvar];
            }
        }
        return result;
    };
    Opal.class_variable_set = function(module, name73, value) {
        var ancestors = Opal.ancestors(module), i129, length = ancestors.length;
        for(i129 = length - 2; i129 >= 0; i129--){
            var ancestor = ancestors[i129];
            if ($has_own.call(ancestor.$$cvars, name73)) {
                ancestor.$$cvars[name73] = value;
                return value;
            }
        }
        module.$$cvars[name73] = value;
        return value;
    };
    Opal.class_variable_get = function(module, name74, tolerant) {
        if ($has_own.call(module.$$cvars, name74)) return module.$$cvars[name74];
        var ancestors = Opal.ancestors(module), i130, length = ancestors.length;
        for(i130 = 0; i130 < length; i130++){
            var ancestor = ancestors[i130];
            if ($has_own.call(ancestor.$$cvars, name74)) {
                return ancestor.$$cvars[name74];
            }
        }
        if (!tolerant) throw Opal.NameError.$new('uninitialized class variable ' + name74 + ' in ' + module.$name());
        return nil;
    };
    function isRoot(proto) {
        return proto.hasOwnProperty('$$iclass') && proto.hasOwnProperty('$$root');
    }
    function own_included_modules(module) {
        var result = [], mod58, proto = Object.getPrototypeOf(module.$$prototype);
        while(proto){
            if (proto.hasOwnProperty('$$class')) {
                break;
            }
            mod58 = protoToModule(proto);
            if (mod58) {
                result.push(mod58);
            }
            proto = Object.getPrototypeOf(proto);
        }
        return result;
    }
    function own_prepended_modules(module) {
        var result = [], mod59, proto = Object.getPrototypeOf(module.$$prototype);
        if (module.$$prototype.hasOwnProperty('$$dummy')) {
            while(proto){
                if (proto === module.$$prototype.$$define_methods_on) {
                    break;
                }
                mod59 = protoToModule(proto);
                if (mod59) {
                    result.push(mod59);
                }
                proto = Object.getPrototypeOf(proto);
            }
        }
        return result;
    }
    Opal.append_features = function(module, includer) {
        var module_ancestors = Opal.ancestors(module);
        var iclasses = [];
        if (module_ancestors.indexOf(includer) !== -1) {
            throw Opal.ArgumentError.$new('cyclic include detected');
        }
        for(var i131 = 0, length = module_ancestors.length; i131 < length; i131++){
            var ancestor = module_ancestors[i131], iclass = create_iclass(ancestor);
            $defineProperty(iclass, '$$included', true);
            iclasses.push(iclass);
        }
        var includer_ancestors = Opal.ancestors(includer), chain = chain_iclasses(iclasses), start_chain_after, end_chain_on;
        if (includer_ancestors.indexOf(module) === -1) {
            start_chain_after = includer.$$prototype;
            end_chain_on = Object.getPrototypeOf(includer.$$prototype);
        } else {
            var parent = includer.$$prototype, module_iclass = Object.getPrototypeOf(parent);
            while(module_iclass != null){
                if (module_iclass.$$module === module && isRoot(module_iclass)) {
                    break;
                }
                parent = module_iclass;
                module_iclass = Object.getPrototypeOf(module_iclass);
            }
            if (module_iclass) {
                var next_ancestor = Object.getPrototypeOf(module_iclass);
                while(next_ancestor.hasOwnProperty('$$iclass') && !isRoot(next_ancestor)){
                    next_ancestor = Object.getPrototypeOf(next_ancestor);
                }
                start_chain_after = parent;
                end_chain_on = next_ancestor;
            } else {
                start_chain_after = includer.$$prototype;
                end_chain_on = Object.getPrototypeOf(includer.$$prototype);
            }
        }
        $set_proto(start_chain_after, chain.first);
        $set_proto(chain.last, end_chain_on);
        includer.$$own_included_modules = own_included_modules(includer);
        Opal.const_cache_version++;
    };
    Opal.prepend_features = function(module, prepender) {
        var module_ancestors = Opal.ancestors(module);
        var iclasses = [];
        if (module_ancestors.indexOf(prepender) !== -1) {
            throw Opal.ArgumentError.$new('cyclic prepend detected');
        }
        for(var i132 = 0, length = module_ancestors.length; i132 < length; i132++){
            var ancestor = module_ancestors[i132], iclass = create_iclass(ancestor);
            $defineProperty(iclass, '$$prepended', true);
            iclasses.push(iclass);
        }
        var chain = chain_iclasses(iclasses), dummy_prepender = prepender.$$prototype, previous_parent = Object.getPrototypeOf(dummy_prepender), prepender_iclass, start_chain_after, end_chain_on;
        if (dummy_prepender.hasOwnProperty('$$dummy')) {
            prepender_iclass = dummy_prepender.$$define_methods_on;
        } else {
            prepender_iclass = create_dummy_iclass(prepender);
            flush_methods_in(prepender);
            $defineProperty(dummy_prepender, '$$dummy', true);
            $defineProperty(dummy_prepender, '$$define_methods_on', prepender_iclass);
            $set_proto(dummy_prepender, prepender_iclass);
            $set_proto(prepender_iclass, previous_parent);
        }
        var prepender_ancestors = Opal.ancestors(prepender);
        if (prepender_ancestors.indexOf(module) === -1) {
            start_chain_after = dummy_prepender;
            end_chain_on = Object.getPrototypeOf(dummy_prepender);
            while(end_chain_on != null){
                if (end_chain_on.hasOwnProperty('$$root') || end_chain_on === prepender_iclass || !end_chain_on.hasOwnProperty('$$iclass')) {
                    break;
                }
                end_chain_on = Object.getPrototypeOf(end_chain_on);
            }
        } else {
            throw Opal.RuntimeError.$new("Prepending a module multiple times is not supported");
        }
        $set_proto(start_chain_after, chain.first);
        $set_proto(chain.last, end_chain_on);
        prepender.$$own_prepended_modules = own_prepended_modules(prepender);
        Opal.const_cache_version++;
    };
    function flush_methods_in(module) {
        var proto = module.$$prototype, props = Object.getOwnPropertyNames(proto);
        for(var i133 = 0; i133 < props.length; i133++){
            var prop = props[i133];
            if (Opal.is_method(prop)) {
                delete proto[prop];
            }
        }
    }
    function create_iclass(module) {
        var iclass = create_dummy_iclass(module);
        if (module.$$is_module) {
            module.$$iclasses.push(iclass);
        }
        return iclass;
    }
    function create_dummy_iclass(module) {
        var iclass = {}, proto = module.$$prototype;
        if (proto.hasOwnProperty('$$dummy')) {
            proto = proto.$$define_methods_on;
        }
        var props = Object.getOwnPropertyNames(proto), length = props.length, i134;
        for(i134 = 0; i134 < length; i134++){
            var prop = props[i134];
            $defineProperty(iclass, prop, proto[prop]);
        }
        $defineProperty(iclass, '$$iclass', true);
        $defineProperty(iclass, '$$module', module);
        return iclass;
    }
    function chain_iclasses(iclasses) {
        var length = iclasses.length, first = iclasses[0];
        $defineProperty(first, '$$root', true);
        if (length === 1) {
            return {
                first: first,
                last: first
            };
        }
        var previous = first;
        for(var i135 = 1; i135 < length; i135++){
            var current = iclasses[i135];
            $set_proto(previous, current);
            previous = current;
        }
        return {
            first: iclasses[0],
            last: iclasses[length - 1]
        };
    }
    Opal.bridge = function(native_klass, klass) {
        if (native_klass.hasOwnProperty('$$bridge')) {
            throw Opal.ArgumentError.$new("already bridged");
        }
        $defineProperty(native_klass, '$$bridge', klass);
        $set_proto(native_klass.prototype, (klass.$$super || Opal.Object).$$prototype);
        $defineProperty(klass, '$$prototype', native_klass.prototype);
        $defineProperty(klass.$$prototype, '$$class', klass);
        $defineProperty(klass, '$$constructor', native_klass);
        $defineProperty(klass, '$$bridge', true);
    };
    function protoToModule(proto) {
        if (proto.hasOwnProperty('$$dummy')) {
            return;
        } else if (proto.hasOwnProperty('$$iclass')) {
            return proto.$$module;
        } else if (proto.hasOwnProperty('$$class')) {
            return proto.$$class;
        }
    }
    function own_ancestors(module) {
        return module.$$own_prepended_modules.concat([
            module
        ]).concat(module.$$own_included_modules);
    }
    Opal.ancestors = function(module) {
        if (!module) {
            return [];
        }
        if (module.$$ancestors_cache_version === Opal.const_cache_version) {
            return module.$$ancestors;
        }
        var result = [], i136, mods, length;
        for(i136 = 0, mods = own_ancestors(module), length = mods.length; i136 < length; i136++){
            result.push(mods[i136]);
        }
        if (module.$$super) {
            for(i136 = 0, mods = Opal.ancestors(module.$$super), length = mods.length; i136 < length; i136++){
                result.push(mods[i136]);
            }
        }
        module.$$ancestors_cache_version = Opal.const_cache_version;
        module.$$ancestors = result;
        return result;
    };
    Opal.included_modules = function(module) {
        var result = [], mod60 = null, proto = Object.getPrototypeOf(module.$$prototype);
        for(; proto && Object.getPrototypeOf(proto); proto = Object.getPrototypeOf(proto)){
            mod60 = protoToModule(proto);
            if (mod60 && mod60.$$is_module && proto.$$iclass && proto.$$included) {
                result.push(mod60);
            }
        }
        return result;
    };
    Opal.add_stubs = function(stubs) {
        var proto = Opal.BasicObject.$$prototype;
        for(var i137 = 0, length = stubs.length; i137 < length; i137++){
            var stub = stubs[i137], existing_method = proto[stub];
            if (existing_method == null || existing_method.$$stub) {
                Opal.add_stub_for(proto, stub);
            }
        }
    };
    Opal.add_stub_for = function(prototype, stub) {
        var method_missing_stub = Opal.stub_for(stub);
        $defineProperty(prototype, stub, method_missing_stub);
    };
    Opal.stub_for = function(method_name) {
        function method_missing_stub() {
            this.$method_missing.$$p = method_missing_stub.$$p;
            method_missing_stub.$$p = null;
            var args_ary = new Array(arguments.length);
            for(var i138 = 0, l = args_ary.length; i138 < l; i138++){
                args_ary[i138] = arguments[i138];
            }
            return this.$method_missing.apply(this, [
                method_name.slice(1)
            ].concat(args_ary));
        }
        method_missing_stub.$$stub = true;
        return method_missing_stub;
    };
    Opal.ac = function(actual, expected, object, meth) {
        var inspect1 = '';
        if (object.$$is_a_module) {
            inspect1 += object.$$name + '.';
        } else {
            inspect1 += object.$$class.$$name + '#';
        }
        inspect1 += meth;
        throw Opal.ArgumentError.$new('[' + inspect1 + '] wrong number of arguments(' + actual + ' for ' + expected + ')');
    };
    Opal.block_ac = function(actual, expected, context) {
        var inspect2 = "`block in " + context + "'";
        throw Opal.ArgumentError.$new(inspect2 + ': wrong number of arguments (' + actual + ' for ' + expected + ')');
    };
    Opal.find_super_dispatcher = function(obj, mid, current_func, defcheck, allow_stubs) {
        var jsid = '$' + mid, ancestors, super_method;
        if (obj.hasOwnProperty('$$meta')) {
            ancestors = Opal.ancestors(obj.$$meta);
        } else {
            ancestors = Opal.ancestors(obj.$$class);
        }
        var current_index = ancestors.indexOf(current_func.$$owner);
        for(var i139 = current_index + 1; i139 < ancestors.length; i139++){
            var ancestor = ancestors[i139], proto = ancestor.$$prototype;
            if (proto.hasOwnProperty('$$dummy')) {
                proto = proto.$$define_methods_on;
            }
            if (proto.hasOwnProperty(jsid)) {
                super_method = proto[jsid];
                break;
            }
        }
        if (!defcheck && super_method && super_method.$$stub && obj.$method_missing.$$pristine) {
            throw Opal.NoMethodError.$new('super: no superclass method `' + mid + "' for " + obj, mid);
        }
        return super_method.$$stub && !allow_stubs ? null : super_method;
    };
    Opal.find_iter_super_dispatcher = function(obj, jsid, current_func, defcheck, implicit) {
        var call_jsid = jsid;
        if (!current_func) {
            throw Opal.RuntimeError.$new("super called outside of method");
        }
        if (implicit && current_func.$$define_meth) {
            throw Opal.RuntimeError.$new("implicit argument passing of super from method defined by define_method() is not supported. Specify all arguments explicitly");
        }
        if (current_func.$$def) {
            call_jsid = current_func.$$jsid;
        }
        return Opal.find_super_dispatcher(obj, call_jsid, current_func, defcheck);
    };
    Opal.ret = function(val) {
        Opal.returner.$v = val;
        throw Opal.returner;
    };
    Opal.brk = function(val, breaker) {
        breaker.$v = val;
        throw breaker;
    };
    Opal.new_brk = function() {
        return new Error('unexpected break');
    };
    Opal.yield1 = function(block, arg) {
        if (typeof block !== "function") {
            throw Opal.LocalJumpError.$new("no block given");
        }
        var has_mlhs = block.$$has_top_level_mlhs_arg, has_trailing_comma = block.$$has_trailing_comma_in_args;
        if (block.length > 1 || (has_mlhs || has_trailing_comma) && block.length === 1) {
            arg = Opal.to_ary(arg);
        }
        if ((block.length > 1 || has_trailing_comma && block.length === 1) && arg.$$is_array) {
            return block.apply(null, arg);
        } else {
            return block(arg);
        }
    };
    Opal.yieldX = function(block, args4) {
        if (typeof block !== "function") {
            throw Opal.LocalJumpError.$new("no block given");
        }
        if (block.length > 1 && args4.length === 1) {
            if (args4[0].$$is_array) {
                return block.apply(null, args4[0]);
            }
        }
        if (!args4.$$is_array) {
            var args_ary = new Array(args4.length);
            for(var i140 = 0, l = args_ary.length; i140 < l; i140++){
                args_ary[i140] = args4[i140];
            }
            return block.apply(null, args_ary);
        }
        return block.apply(null, args4);
    };
    Opal.rescue = function(exception, candidates) {
        for(var i141 = 0; i141 < candidates.length; i141++){
            var candidate = candidates[i141];
            if (candidate.$$is_array) {
                var result = Opal.rescue(exception, candidate);
                if (result) {
                    return result;
                }
            } else if (candidate === Opal.JS.Error) {
                return candidate;
            } else if (candidate['$==='](exception)) {
                return candidate;
            }
        }
        return null;
    };
    Opal.is_a = function(object, klass) {
        if (klass != null && object.$$meta === klass || object.$$class === klass) {
            return true;
        }
        if (object.$$is_number && klass.$$is_number_class) {
            return klass.$$is_integer_class ? object % 1 === 0 : true;
        }
        var i142, length, ancestors = Opal.ancestors(object.$$is_class ? Opal.get_singleton_class(object) : object.$$meta || object.$$class);
        for(i142 = 0, length = ancestors.length; i142 < length; i142++){
            if (ancestors[i142] === klass) {
                return true;
            }
        }
        return false;
    };
    Opal.to_hash = function(value) {
        if (value.$$is_hash) {
            return value;
        } else if (value['$respond_to?']('to_hash', true)) {
            var hash = value.$to_hash();
            if (hash.$$is_hash) {
                return hash;
            } else {
                throw Opal.TypeError.$new("Can't convert " + value.$$class + " to Hash (" + value.$$class + "#to_hash gives " + hash.$$class + ")");
            }
        } else {
            throw Opal.TypeError.$new("no implicit conversion of " + value.$$class + " into Hash");
        }
    };
    Opal.to_ary = function(value) {
        if (value.$$is_array) {
            return value;
        } else if (value['$respond_to?']('to_ary', true)) {
            var ary = value.$to_ary();
            if (ary === nil) {
                return [
                    value
                ];
            } else if (ary.$$is_array) {
                return ary;
            } else {
                throw Opal.TypeError.$new("Can't convert " + value.$$class + " to Array (" + value.$$class + "#to_ary gives " + ary.$$class + ")");
            }
        } else {
            return [
                value
            ];
        }
    };
    Opal.to_a = function(value) {
        if (value.$$is_array) {
            return value.slice();
        } else if (value['$respond_to?']('to_a', true)) {
            var ary = value.$to_a();
            if (ary === nil) {
                return [
                    value
                ];
            } else if (ary.$$is_array) {
                return ary;
            } else {
                throw Opal.TypeError.$new("Can't convert " + value.$$class + " to Array (" + value.$$class + "#to_a gives " + ary.$$class + ")");
            }
        } else {
            return [
                value
            ];
        }
    };
    Opal.extract_kwargs = function(parameters) {
        var kwargs = parameters[parameters.length - 1];
        if (kwargs != null && Opal.respond_to(kwargs, '$to_hash', true)) {
            $splice.call(parameters, parameters.length - 1, 1);
            return kwargs.$to_hash();
        } else {
            return Opal.hash2([], {});
        }
    };
    Opal.kwrestargs = function(given_args, used_args) {
        var keys = [], map = {}, key, given_map = given_args.$$smap;
        for(key in given_map){
            if (!used_args[key]) {
                keys.push(key);
                map[key] = given_map[key];
            }
        }
        return Opal.hash2(keys, map);
    };
    Opal.send = function(recv, method, args5, block) {
        var body;
        if (typeof method === 'function') {
            body = method;
            method = null;
        } else if (typeof method === 'string') {
            body = recv['$' + method];
        } else {
            throw Opal.NameError.$new("Passed method should be a string or a function");
        }
        return Opal.send2(recv, body, method, args5, block);
    };
    Opal.send2 = function(recv, body, method, args6, block) {
        if (body == null && method != null && recv.$method_missing) {
            body = recv.$method_missing;
            args6 = [
                method
            ].concat(args6);
        }
        if (typeof block === 'function') body.$$p = block;
        return body.apply(recv, args6);
    };
    Opal.lambda = function(block) {
        block.$$is_lambda = true;
        return block;
    };
    Opal.def = function(obj, jsid, body) {
        if (obj === Opal.top) {
            Opal.defn(Opal.Object, jsid, body);
        } else if (!obj.$$eval && obj.$$is_a_module) {
            Opal.defn(obj, jsid, body);
        } else {
            Opal.defs(obj, jsid, body);
        }
    };
    Opal.defn = function(module, jsid, body) {
        body.displayName = jsid;
        body.$$owner = module;
        var proto = module.$$prototype;
        if (proto.hasOwnProperty('$$dummy')) {
            proto = proto.$$define_methods_on;
        }
        $defineProperty(proto, jsid, body);
        if (module.$$is_module) {
            if (module.$$module_function) {
                Opal.defs(module, jsid, body);
            }
            for(var i143 = 0, iclasses = module.$$iclasses, length = iclasses.length; i143 < length; i143++){
                var iclass = iclasses[i143];
                $defineProperty(iclass, jsid, body);
            }
        }
        var singleton_of = module.$$singleton_of;
        if (module.$method_added && !module.$method_added.$$stub && !singleton_of) {
            module.$method_added(jsid.substr(1));
        } else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {
            singleton_of.$singleton_method_added(jsid.substr(1));
        }
    };
    Opal.defs = function(obj, jsid, body) {
        if (obj.$$is_string || obj.$$is_number) {
            throw Opal.TypeError.$new("can't define singleton");
        }
        Opal.defn(Opal.get_singleton_class(obj), jsid, body);
    };
    Opal.rdef = function(obj, jsid) {
        if (!$has_own.call(obj.$$prototype, jsid)) {
            throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
        }
        delete obj.$$prototype[jsid];
        if (obj.$$is_singleton) {
            if (obj.$$prototype.$singleton_method_removed && !obj.$$prototype.$singleton_method_removed.$$stub) {
                obj.$$prototype.$singleton_method_removed(jsid.substr(1));
            }
        } else {
            if (obj.$method_removed && !obj.$method_removed.$$stub) {
                obj.$method_removed(jsid.substr(1));
            }
        }
    };
    Opal.udef = function(obj, jsid) {
        if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
            throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
        }
        Opal.add_stub_for(obj.$$prototype, jsid);
        if (obj.$$is_singleton) {
            if (obj.$$prototype.$singleton_method_undefined && !obj.$$prototype.$singleton_method_undefined.$$stub) {
                obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
            }
        } else {
            if (obj.$method_undefined && !obj.$method_undefined.$$stub) {
                obj.$method_undefined(jsid.substr(1));
            }
        }
    };
    function is_method_body(body) {
        return typeof body === "function" && !body.$$stub;
    }
    Opal.alias = function(obj, name75, old) {
        var id = '$' + name75, old_id = '$' + old, body = obj.$$prototype['$' + old], alias;
        if (obj.$$eval) {
            return Opal.alias(Opal.get_singleton_class(obj), name75, old);
        }
        if (!is_method_body(body)) {
            var ancestor = obj.$$super;
            while(typeof body !== "function" && ancestor){
                body = ancestor[old_id];
                ancestor = ancestor.$$super;
            }
            if (!is_method_body(body) && obj.$$is_module) {
                body = Opal.Object.$$prototype[old_id];
            }
            if (!is_method_body(body)) {
                throw Opal.NameError.$new("undefined method `" + old + "' for class `" + obj.$name() + "'");
            }
        }
        if (body.$$alias_of) body = body.$$alias_of;
        alias = function() {
            var block = alias.$$p, args7, i144, ii;
            args7 = new Array(arguments.length);
            for(i144 = 0, ii = arguments.length; i144 < ii; i144++){
                args7[i144] = arguments[i144];
            }
            if (block != null) {
                alias.$$p = null;
            }
            return Opal.send(this, body, args7, block);
        };
        try {
            Object.defineProperty(alias, 'length', {
                value: body.length
            });
        } catch (e) {}
        alias.displayName = name75;
        alias.$$arity = body.$$arity;
        alias.$$parameters = body.$$parameters;
        alias.$$source_location = body.$$source_location;
        alias.$$alias_of = body;
        alias.$$alias_name = name75;
        Opal.defn(obj, id, alias);
        return obj;
    };
    Opal.alias_native = function(obj, name76, native_name) {
        var id = '$' + name76, body = obj.$$prototype[native_name];
        if (typeof body !== "function" || body.$$stub) {
            throw Opal.NameError.$new("undefined native method `" + native_name + "' for class `" + obj.$name() + "'");
        }
        Opal.defn(obj, id, body);
        return obj;
    };
    Opal.hash_init = function(hash) {
        hash.$$smap = Object.create(null);
        hash.$$map = Object.create(null);
        hash.$$keys = [];
    };
    Opal.hash_clone = function(from_hash, to_hash) {
        to_hash.$$none = from_hash.$$none;
        to_hash.$$proc = from_hash.$$proc;
        for(var i145 = 0, keys = from_hash.$$keys, smap = from_hash.$$smap, len = keys.length, key, value; i145 < len; i145++){
            key = keys[i145];
            if (key.$$is_string) {
                value = smap[key];
            } else {
                value = key.value;
                key = key.key;
            }
            Opal.hash_put(to_hash, key, value);
        }
    };
    Opal.hash_put = function(hash, key, value) {
        if (key.$$is_string) {
            if (!$has_own.call(hash.$$smap, key)) {
                hash.$$keys.push(key);
            }
            hash.$$smap[key] = value;
            return;
        }
        var key_hash, bucket, last_bucket;
        key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();
        if (!$has_own.call(hash.$$map, key_hash)) {
            bucket = {
                key: key,
                key_hash: key_hash,
                value: value
            };
            hash.$$keys.push(bucket);
            hash.$$map[key_hash] = bucket;
            return;
        }
        bucket = hash.$$map[key_hash];
        while(bucket){
            if (key === bucket.key || key['$eql?'](bucket.key)) {
                last_bucket = undefined;
                bucket.value = value;
                break;
            }
            last_bucket = bucket;
            bucket = bucket.next;
        }
        if (last_bucket) {
            bucket = {
                key: key,
                key_hash: key_hash,
                value: value
            };
            hash.$$keys.push(bucket);
            last_bucket.next = bucket;
        }
    };
    Opal.hash_get = function(hash, key) {
        if (key.$$is_string) {
            if ($has_own.call(hash.$$smap, key)) {
                return hash.$$smap[key];
            }
            return;
        }
        var key_hash, bucket;
        key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();
        if ($has_own.call(hash.$$map, key_hash)) {
            bucket = hash.$$map[key_hash];
            while(bucket){
                if (key === bucket.key || key['$eql?'](bucket.key)) {
                    return bucket.value;
                }
                bucket = bucket.next;
            }
        }
    };
    Opal.hash_delete = function(hash, key) {
        var i146, keys = hash.$$keys, length = keys.length, value;
        if (key.$$is_string) {
            if (typeof key !== "string") key = key.valueOf();
            if (!$has_own.call(hash.$$smap, key)) {
                return;
            }
            for(i146 = 0; i146 < length; i146++){
                if (keys[i146] === key) {
                    keys.splice(i146, 1);
                    break;
                }
            }
            value = hash.$$smap[key];
            delete hash.$$smap[key];
            return value;
        }
        var key_hash = key.$hash();
        if (!$has_own.call(hash.$$map, key_hash)) {
            return;
        }
        var bucket = hash.$$map[key_hash], last_bucket;
        while(bucket){
            if (key === bucket.key || key['$eql?'](bucket.key)) {
                value = bucket.value;
                for(i146 = 0; i146 < length; i146++){
                    if (keys[i146] === bucket) {
                        keys.splice(i146, 1);
                        break;
                    }
                }
                if (last_bucket && bucket.next) {
                    last_bucket.next = bucket.next;
                } else if (last_bucket) {
                    delete last_bucket.next;
                } else if (bucket.next) {
                    hash.$$map[key_hash] = bucket.next;
                } else {
                    delete hash.$$map[key_hash];
                }
                return value;
            }
            last_bucket = bucket;
            bucket = bucket.next;
        }
    };
    Opal.hash_rehash = function(hash) {
        for(var i147 = 0, length = hash.$$keys.length, key_hash, bucket, last_bucket; i147 < length; i147++){
            if (hash.$$keys[i147].$$is_string) {
                continue;
            }
            key_hash = hash.$$keys[i147].key.$hash();
            if (key_hash === hash.$$keys[i147].key_hash) {
                continue;
            }
            bucket = hash.$$map[hash.$$keys[i147].key_hash];
            last_bucket = undefined;
            while(bucket){
                if (bucket === hash.$$keys[i147]) {
                    if (last_bucket && bucket.next) {
                        last_bucket.next = bucket.next;
                    } else if (last_bucket) {
                        delete last_bucket.next;
                    } else if (bucket.next) {
                        hash.$$map[hash.$$keys[i147].key_hash] = bucket.next;
                    } else {
                        delete hash.$$map[hash.$$keys[i147].key_hash];
                    }
                    break;
                }
                last_bucket = bucket;
                bucket = bucket.next;
            }
            hash.$$keys[i147].key_hash = key_hash;
            if (!$has_own.call(hash.$$map, key_hash)) {
                hash.$$map[key_hash] = hash.$$keys[i147];
                continue;
            }
            bucket = hash.$$map[key_hash];
            last_bucket = undefined;
            while(bucket){
                if (bucket === hash.$$keys[i147]) {
                    last_bucket = undefined;
                    break;
                }
                last_bucket = bucket;
                bucket = bucket.next;
            }
            if (last_bucket) {
                last_bucket.next = hash.$$keys[i147];
            }
        }
    };
    Opal.hash = function() {
        var arguments_length = arguments.length, args8, hash, i148, length, key, value;
        if (arguments_length === 1 && arguments[0].$$is_hash) {
            return arguments[0];
        }
        hash = new Opal.Hash();
        Opal.hash_init(hash);
        if (arguments_length === 1 && arguments[0].$$is_array) {
            args8 = arguments[0];
            length = args8.length;
            for(i148 = 0; i148 < length; i148++){
                if (args8[i148].length !== 2) {
                    throw Opal.ArgumentError.$new("value not of length 2: " + args8[i148].$inspect());
                }
                key = args8[i148][0];
                value = args8[i148][1];
                Opal.hash_put(hash, key, value);
            }
            return hash;
        }
        if (arguments_length === 1) {
            args8 = arguments[0];
            for(key in args8){
                if ($has_own.call(args8, key)) {
                    value = args8[key];
                    Opal.hash_put(hash, key, value);
                }
            }
            return hash;
        }
        if (arguments_length % 2 !== 0) {
            throw Opal.ArgumentError.$new("odd number of arguments for Hash");
        }
        for(i148 = 0; i148 < arguments_length; i148 += 2){
            key = arguments[i148];
            value = arguments[i148 + 1];
            Opal.hash_put(hash, key, value);
        }
        return hash;
    };
    Opal.hash2 = function(keys, smap) {
        var hash = new Opal.Hash();
        hash.$$smap = smap;
        hash.$$map = Object.create(null);
        hash.$$keys = keys;
        return hash;
    };
    Opal.range = function(first, last, exc) {
        var range = new Opal.Range();
        range.begin = first;
        range.end = last;
        range.excl = exc;
        return range;
    };
    Opal.ivar = function(name77) {
        if (name77 === "constructor" || name77 === "displayName" || name77 === "__count__" || name77 === "__noSuchMethod__" || name77 === "__parent__" || name77 === "__proto__" || name77 === "hasOwnProperty" || name77 === "valueOf") {
            return name77 + "$";
        }
        return name77;
    };
    Opal.escape_regexp = function(str) {
        return str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, '\\$1').replace(/[\n]/g, '\\n').replace(/[\r]/g, '\\r').replace(/[\f]/g, '\\f').replace(/[\t]/g, '\\t');
    };
    Opal.global_regexp = function(pattern) {
        if (pattern.global) {
            return pattern;
        }
        if (pattern.$$g == null) {
            pattern.$$g = new RegExp(pattern.source, (pattern.multiline ? 'gm' : 'g') + (pattern.ignoreCase ? 'i' : ''));
        } else {
            pattern.$$g.lastIndex = null;
        }
        return pattern.$$g;
    };
    Opal.global_multiline_regexp = function(pattern) {
        var result;
        if (pattern.multiline) {
            if (pattern.global) {
                return pattern;
            }
            if (pattern.$$g != null) {
                result = pattern.$$g;
            } else {
                result = pattern.$$g = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
            }
        } else if (pattern.$$gm != null) {
            result = pattern.$$gm;
        } else {
            result = pattern.$$gm = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
        }
        result.lastIndex = null;
        return result;
    };
    Opal.regexp = function(parts, flags) {
        var part;
        var ignoreCase = typeof flags !== 'undefined' && flags && flags.indexOf('i') >= 0;
        for(var i149 = 0, ii = parts.length; i149 < ii; i149++){
            part = parts[i149];
            if (part instanceof RegExp) {
                if (part.ignoreCase !== ignoreCase) Opal.Kernel.$warn("ignore case doesn't match for " + part.source.$inspect(), Opal.hash({
                    uplevel: 1
                }));
                part = part.source;
            }
            if (part === '') part = '(?:' + part + ')';
            parts[i149] = part;
        }
        if (flags) {
            return new RegExp(parts.join(''), flags);
        } else {
            return new RegExp(parts.join(''));
        }
    };
    Opal.modules = {};
    Opal.loaded_features = [
        'corelib/runtime'
    ];
    Opal.current_dir = '.';
    Opal.require_table = {
        'corelib/runtime': true
    };
    Opal.normalize = function(path113) {
        var parts, part, new_parts = [], SEPARATOR = '/';
        if (Opal.current_dir !== '.') {
            path113 = Opal.current_dir.replace(/\/*$/, '/') + path113;
        }
        path113 = path113.replace(/^\.\//, '');
        path113 = path113.replace(/\.(rb|opal|js)$/, '');
        parts = path113.split(SEPARATOR);
        for(var i150 = 0, ii = parts.length; i150 < ii; i150++){
            part = parts[i150];
            if (part === '') continue;
            part === '..' ? new_parts.pop() : new_parts.push(part);
        }
        return new_parts.join(SEPARATOR);
    };
    Opal.loaded = function(paths) {
        var i151, l, path210;
        for(i151 = 0, l = paths.length; i151 < l; i151++){
            path210 = Opal.normalize(paths[i151]);
            if (Opal.require_table[path210]) {
                continue;
            }
            Opal.loaded_features.push(path210);
            Opal.require_table[path210] = true;
        }
    };
    Opal.load = function(path310) {
        path310 = Opal.normalize(path310);
        Opal.loaded([
            path310
        ]);
        var module = Opal.modules[path310];
        if (module) {
            module(Opal);
        } else {
            var severity = Opal.config.missing_require_severity;
            var message = 'cannot load such file -- ' + path310;
            if (severity === "error") {
                if (Opal.LoadError) {
                    throw Opal.LoadError.$new(message);
                } else {
                    throw message;
                }
            } else if (severity === "warning") {
                console.warn('WARNING: LoadError: ' + message);
            }
        }
        return true;
    };
    Opal.require = function(path4) {
        path4 = Opal.normalize(path4);
        if (Opal.require_table[path4]) {
            return false;
        }
        return Opal.load(path4);
    };
    Opal.encodings = Object.create(null);
    Opal.set_encoding = function(str, name78, type43) {
        if (typeof type43 === "undefined") type43 = "encoding";
        if (typeof str === 'string' || str.$$frozen === true) throw Opal.FrozenError.$new("can't modify frozen String");
        var encoding = Opal.find_encoding(name78);
        if (encoding === str[type43]) {
            return str;
        }
        str[type43] = encoding;
        return str;
    };
    Opal.find_encoding = function(name79) {
        var register = Opal.encodings;
        var encoding = register[name79] || register[name79.toUpperCase()];
        if (!encoding) throw Opal.ArgumentError.$new("unknown encoding name - " + name79);
        return encoding;
    };
    Opal.enc = function(str, name80) {
        var dup = new String(str);
        dup = Opal.set_encoding(dup, name80);
        dup.internal_encoding = dup.encoding;
        return dup;
    };
    Opal.binary = function(str) {
        var dup = new String(str);
        return Opal.set_encoding(dup, "binary", "internal_encoding");
    };
    function $BasicObject() {}
    function $Object() {}
    function $Module() {}
    function $Class() {}
    Opal.BasicObject = BasicObject = Opal.allocate_class('BasicObject', null, $BasicObject);
    Opal.Object = _Object = Opal.allocate_class('Object', Opal.BasicObject, $Object);
    Opal.Module = Module = Opal.allocate_class('Module', Opal.Object, $Module);
    Opal.Class = Class = Opal.allocate_class('Class', Opal.Module, $Class);
    $set_proto(Opal.BasicObject, Opal.Class.$$prototype);
    $set_proto(Opal.Object, Opal.Class.$$prototype);
    $set_proto(Opal.Module, Opal.Class.$$prototype);
    $set_proto(Opal.Class, Opal.Class.$$prototype);
    BasicObject.$$const["BasicObject"] = BasicObject;
    Opal.const_set(_Object, "BasicObject", BasicObject);
    Opal.const_set(_Object, "Object", _Object);
    Opal.const_set(_Object, "Module", Module);
    Opal.const_set(_Object, "Class", Class);
    BasicObject.$$class = Class;
    _Object.$$class = Class;
    Module.$$class = Class;
    Class.$$class = Class;
    $defineProperty(_Object.$$prototype, 'toString', function() {
        var to_s = this.$to_s();
        if (to_s.$$is_string && typeof to_s === 'object') {
            return to_s.valueOf();
        } else {
            return to_s;
        }
    });
    $defineProperty(_Object.$$prototype, '$require', Opal.require);
    Opal.top = new _Object();
    Opal.top.$to_s = Opal.top.$inspect = function() {
        return 'main';
    };
    Opal.top.$define_method = top_define_method;
    function top_define_method() {
        var args9 = Opal.slice.call(arguments, 0, arguments.length);
        var block = top_define_method.$$p;
        top_define_method.$$p = null;
        return Opal.send(_Object, 'define_method', args9, block);
    }
    function $NilClass() {}
    Opal.NilClass = Opal.allocate_class('NilClass', Opal.Object, $NilClass);
    Opal.const_set(_Object, 'NilClass', Opal.NilClass);
    nil = Opal.nil = new Opal.NilClass();
    nil.$$id = nil_id;
    nil.call = nil.apply = function() {
        throw Opal.LocalJumpError.$new('no block given');
    };
    Opal.breaker = new Error('unexpected break (old)');
    Opal.returner = new Error('unexpected return');
    TypeError.$$super = Error;
}).call(this);
Opal.loaded([
    "corelib/runtime.js"
]);
Opal.modules["corelib/helpers"] = function(Opal) {
    var self1 = Opal.top, $nesting1 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $type_error = Opal.type_error, $coerce_to = Opal.coerce_to, $module = Opal.module, $truthy = Opal.truthy;
    Opal.add_stubs([
        '$===',
        '$raise',
        '$respond_to?',
        '$nil?',
        '$__send__',
        '$<=>',
        '$class',
        '$coerce_to!',
        '$new',
        '$!=',
        '$[]',
        '$upcase'
    ]);
    return function($base, $parent_nesting) {
        var self2 = $module($base, 'Opal');
        var $nesting = [
            self2
        ].concat($parent_nesting), $Opal_bridge$1, $Opal_coerce_to$excl$2, $Opal_coerce_to$ques$3, $Opal_try_convert$4, $Opal_compare$5, $Opal_destructure$6, $Opal_respond_to$ques$7, $Opal_instance_variable_name$excl$8, $Opal_class_variable_name$excl$9, $Opal_const_name$excl$10, $Opal_pristine$11;
        Opal.defs(self2, '$bridge', $Opal_bridge$1 = function $$bridge(constructor, klass) {
            return Opal.bridge(constructor, klass);
        }, $Opal_bridge$1.$$arity = 2);
        Opal.defs(self2, '$coerce_to!', $Opal_coerce_to$excl$2 = function(object, type44, method, $a) {
            var $post_args, args10, self = this, coerced = nil;
            $post_args = Opal.slice.call(arguments, 3, arguments.length);
            args10 = $post_args;
            coerced = $coerce_to(object, type44, method, args10);
            if ($truthy(type44['$==='](coerced))) {} else {
                self.$raise($type_error(object, type44, method, coerced));
            }
            return coerced;
        }, $Opal_coerce_to$excl$2.$$arity = -4);
        Opal.defs(self2, '$coerce_to?', $Opal_coerce_to$ques$3 = function(object, type45, method, $a) {
            var $post_args, args11, self = this, coerced = nil;
            $post_args = Opal.slice.call(arguments, 3, arguments.length);
            args11 = $post_args;
            if ($truthy(object['$respond_to?'](method))) {} else {
                return nil;
            }
            coerced = $coerce_to(object, type45, method, args11);
            if ($truthy(coerced['$nil?']())) {
                return nil;
            }
            if ($truthy(type45['$==='](coerced))) {} else {
                self.$raise($type_error(object, type45, method, coerced));
            }
            return coerced;
        }, $Opal_coerce_to$ques$3.$$arity = -4);
        Opal.defs(self2, '$try_convert', $Opal_try_convert$4 = function $$try_convert(object, type46, method) {
            if ($truthy(type46['$==='](object))) {
                return object;
            }
            if ($truthy(object['$respond_to?'](method))) {
                return object.$__send__(method);
            } else {
                return nil;
            }
        }, $Opal_try_convert$4.$$arity = 3);
        Opal.defs(self2, '$compare', $Opal_compare$5 = function $$compare(a, b) {
            var self = this, compare = nil;
            compare = a['$<=>'](b);
            if ($truthy(compare === nil)) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + a.$class() + " with " + b.$class() + " failed");
            }
            return compare;
        }, $Opal_compare$5.$$arity = 2);
        Opal.defs(self2, '$destructure', $Opal_destructure$6 = function $$destructure(args12) {
            if (args12.length == 1) {
                return args12[0];
            } else if (args12.$$is_array) {
                return args12;
            } else {
                var args_ary = new Array(args12.length);
                for(var i152 = 0, l = args_ary.length; i152 < l; i152++){
                    args_ary[i152] = args12[i152];
                }
                return args_ary;
            }
        }, $Opal_destructure$6.$$arity = 1);
        Opal.defs(self2, '$respond_to?', $Opal_respond_to$ques$7 = function(obj, method, include_all) {
            if (include_all == null) {
                include_all = false;
            }
            if (obj == null || !obj.$$class) {
                return false;
            }
            return obj['$respond_to?'](method, include_all);
        }, $Opal_respond_to$ques$7.$$arity = -3);
        Opal.defs(self2, '$instance_variable_name!', $Opal_instance_variable_name$excl$8 = function(name81) {
            var self = this;
            name81 = $$($nesting, 'Opal')['$coerce_to!'](name81, $$($nesting, 'String'), "to_str");
            if ($truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name81))) {} else {
                self.$raise($$($nesting, 'NameError').$new("" + "'" + name81 + "' is not allowed as an instance variable name", name81));
            }
            return name81;
        }, $Opal_instance_variable_name$excl$8.$$arity = 1);
        Opal.defs(self2, '$class_variable_name!', $Opal_class_variable_name$excl$9 = function(name82) {
            var self = this;
            name82 = $$($nesting, 'Opal')['$coerce_to!'](name82, $$($nesting, 'String'), "to_str");
            if ($truthy(name82.length < 3 || name82.slice(0, 2) !== '@@')) {
                self.$raise($$($nesting, 'NameError').$new("" + "`" + name82 + "' is not allowed as a class variable name", name82));
            }
            return name82;
        }, $Opal_class_variable_name$excl$9.$$arity = 1);
        Opal.defs(self2, '$const_name!', $Opal_const_name$excl$10 = function(const_name) {
            var self = this;
            const_name = $$($nesting, 'Opal')['$coerce_to!'](const_name, $$($nesting, 'String'), "to_str");
            if ($truthy(const_name['$[]'](0)['$!='](const_name['$[]'](0).$upcase()))) {
                self.$raise($$($nesting, 'NameError'), "" + "wrong constant name " + const_name);
            }
            return const_name;
        }, $Opal_const_name$excl$10.$$arity = 1);
        return (Opal.defs(self2, '$pristine', $Opal_pristine$11 = function $$pristine(owner_class, $a) {
            var $post_args, method_names;
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            method_names = $post_args;
            var method_name, method;
            for(var i153 = method_names.length - 1; i153 >= 0; i153--){
                method_name = method_names[i153];
                method = owner_class.$$prototype['$' + method_name];
                if (method && !method.$$stub) {
                    method.$$pristine = true;
                }
            }
            return nil;
        }, $Opal_pristine$11.$$arity = -2), nil) && 'pristine';
    }($nesting1[0], $nesting1);
};
Opal.modules["corelib/module"] = function(Opal) {
    function $rb_lt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs < rhs : lhs['$<'](rhs);
    }
    function $rb_gt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs > rhs : lhs['$>'](rhs);
    }
    var self3 = Opal.top, $nesting2 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $lambda = Opal.lambda, $range = Opal.range, $send2 = Opal.send2;
    Opal.add_stubs([
        '$module_eval',
        '$to_proc',
        '$===',
        '$raise',
        '$equal?',
        '$<',
        '$>',
        '$nil?',
        '$attr_reader',
        '$attr_writer',
        '$warn',
        '$attr_accessor',
        '$class_variable_name!',
        '$const_name!',
        '$=~',
        '$new',
        '$inject',
        '$split',
        '$const_get',
        '$==',
        '$!~',
        '$start_with?',
        '$bind',
        '$call',
        '$class',
        '$append_features',
        '$included',
        '$name',
        '$cover?',
        '$size',
        '$merge',
        '$compile',
        '$proc',
        '$any?',
        '$prepend_features',
        '$prepended',
        '$to_s',
        '$__id__',
        '$constants',
        '$include?',
        '$copy_class_variables',
        '$copy_constants'
    ]);
    return function($base, $super, $parent_nesting) {
        var self4 = $klass($base, $super, 'Module');
        var $nesting = [
            self4
        ].concat($parent_nesting), $Module_allocate$1, $Module_initialize$2, $Module_$eq_eq_eq$3, $Module_$lt$4, $Module_$lt_eq$5, $Module_$gt$6, $Module_$gt_eq$7, $Module_$lt_eq_gt$8, $Module_alias_method$9, $Module_alias_native$10, $Module_ancestors$11, $Module_append_features$12, $Module_attr_accessor$13, $Module_attr$14, $Module_attr_reader$15, $Module_attr_writer$16, $Module_autoload$17, $Module_class_variables$18, $Module_class_variable_get$19, $Module_class_variable_set$20, $Module_class_variable_defined$ques$21, $Module_remove_class_variable$22, $Module_constants$23, $Module_constants$24, $Module_nesting$25, $Module_const_defined$ques$26, $Module_const_get$27, $Module_const_missing$29, $Module_const_set$30, $Module_public_constant$31, $Module_define_method$32, $Module_remove_method$34, $Module_singleton_class$ques$35, $Module_include$36, $Module_included_modules$37, $Module_include$ques$38, $Module_instance_method$39, $Module_instance_methods$40, $Module_included$41, $Module_extended$42, $Module_extend_object$43, $Module_method_added$44, $Module_method_removed$45, $Module_method_undefined$46, $Module_module_eval$47, $Module_module_exec$49, $Module_method_defined$ques$50, $Module_module_function$51, $Module_name$52, $Module_prepend$53, $Module_prepend_features$54, $Module_prepended$55, $Module_remove_const$56, $Module_to_s$57, $Module_undef_method$58, $Module_instance_variables$59, $Module_dup$60, $Module_copy_class_variables$61, $Module_copy_constants$62;
        Opal.defs(self4, '$allocate', $Module_allocate$1 = function $$allocate() {
            var self = this;
            var module = Opal.allocate_module(nil, function() {});
            if (self !== Opal.Module) Object.setPrototypeOf(module, self.$$prototype);
            return module;
        }, $Module_allocate$1.$$arity = 0);
        Opal.def(self4, '$initialize', $Module_initialize$2 = function $$initialize() {
            var $iter = $Module_initialize$2.$$p, block = $iter || nil, self = this;
            if ($iter) $Module_initialize$2.$$p = null;
            if ($iter) $Module_initialize$2.$$p = null;
            if (block !== nil) {
                return $send(self, 'module_eval', [], block.$to_proc());
            } else {
                return nil;
            }
        }, $Module_initialize$2.$$arity = 0);
        Opal.def(self4, '$===', $Module_$eq_eq_eq$3 = function(object) {
            var self = this;
            if ($truthy(object == null)) {
                return false;
            }
            return Opal.is_a(object, self);
        }, $Module_$eq_eq_eq$3.$$arity = 1);
        Opal.def(self4, '$<', $Module_$lt$4 = function(other) {
            var self = this;
            if ($truthy($$($nesting, 'Module')['$==='](other))) {} else {
                self.$raise($$($nesting, 'TypeError'), "compared with non class/module");
            }
            var working = self, ancestors, i154, length;
            if (working === other) {
                return false;
            }
            for(i154 = 0, ancestors = Opal.ancestors(self), length = ancestors.length; i154 < length; i154++){
                if (ancestors[i154] === other) {
                    return true;
                }
            }
            for(i154 = 0, ancestors = Opal.ancestors(other), length = ancestors.length; i154 < length; i154++){
                if (ancestors[i154] === self) {
                    return false;
                }
            }
            return nil;
        }, $Module_$lt$4.$$arity = 1);
        Opal.def(self4, '$<=', $Module_$lt_eq$5 = function(other) {
            var self = this, $ret_or_1 = nil;
            if ($truthy($ret_or_1 = self['$equal?'](other))) {
                return $ret_or_1;
            } else {
                return $rb_lt(self, other);
            }
        }, $Module_$lt_eq$5.$$arity = 1);
        Opal.def(self4, '$>', $Module_$gt$6 = function(other) {
            var self = this;
            if ($truthy($$($nesting, 'Module')['$==='](other))) {} else {
                self.$raise($$($nesting, 'TypeError'), "compared with non class/module");
            }
            return $rb_lt(other, self);
        }, $Module_$gt$6.$$arity = 1);
        Opal.def(self4, '$>=', $Module_$gt_eq$7 = function(other) {
            var self = this, $ret_or_2 = nil;
            if ($truthy($ret_or_2 = self['$equal?'](other))) {
                return $ret_or_2;
            } else {
                return $rb_gt(self, other);
            }
        }, $Module_$gt_eq$7.$$arity = 1);
        Opal.def(self4, '$<=>', $Module_$lt_eq_gt$8 = function(other) {
            var self = this, lt = nil;
            if (self === other) {
                return 0;
            }
            if ($truthy($$($nesting, 'Module')['$==='](other))) {} else {
                return nil;
            }
            lt = $rb_lt(self, other);
            if ($truthy(lt['$nil?']())) {
                return nil;
            }
            if ($truthy(lt)) {
                return -1;
            } else {
                return 1;
            }
        }, $Module_$lt_eq_gt$8.$$arity = 1);
        Opal.def(self4, '$alias_method', $Module_alias_method$9 = function $$alias_method(newname, oldname) {
            var self = this;
            newname = $coerce_to(newname, $$($nesting, 'String'), 'to_str');
            oldname = $coerce_to(oldname, $$($nesting, 'String'), 'to_str');
            Opal.alias(self, newname, oldname);
            return self;
        }, $Module_alias_method$9.$$arity = 2);
        Opal.def(self4, '$alias_native', $Module_alias_native$10 = function $$alias_native(mid, jsid) {
            var self = this;
            if (jsid == null) {
                jsid = mid;
            }
            Opal.alias_native(self, mid, jsid);
            return self;
        }, $Module_alias_native$10.$$arity = -2);
        Opal.def(self4, '$ancestors', $Module_ancestors$11 = function $$ancestors() {
            var self = this;
            return Opal.ancestors(self);
        }, $Module_ancestors$11.$$arity = 0);
        Opal.def(self4, '$append_features', $Module_append_features$12 = function $$append_features(includer) {
            var self = this;
            Opal.append_features(self, includer);
            return self;
        }, $Module_append_features$12.$$arity = 1);
        Opal.def(self4, '$attr_accessor', $Module_attr_accessor$13 = function $$attr_accessor($a) {
            var $post_args, names, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            names = $post_args;
            $send(self, 'attr_reader', Opal.to_a(names));
            return $send(self, 'attr_writer', Opal.to_a(names));
        }, $Module_attr_accessor$13.$$arity = -1);
        Opal.def(self4, '$attr', $Module_attr$14 = function $$attr($a) {
            var $post_args, args13, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args13 = $post_args;
            if (args13.length == 2 && (args13[1] === true || args13[1] === false)) {
                self.$warn("optional boolean argument is obsoleted", $hash2([
                    "uplevel"
                ], {
                    "uplevel": 1
                }));
                args13[1] ? self.$attr_accessor(args13[0]) : self.$attr_reader(args13[0]);
                return nil;
            }
            return $send(self, 'attr_reader', Opal.to_a(args13));
        }, $Module_attr$14.$$arity = -1);
        Opal.def(self4, '$attr_reader', $Module_attr_reader$15 = function $$attr_reader($a) {
            var $post_args, names, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            names = $post_args;
            var proto = self.$$prototype;
            for(var i155 = names.length - 1; i155 >= 0; i155--){
                var name83 = names[i155], id = '$' + name83, ivar1 = Opal.ivar(name83);
                var body = function(ivar) {
                    return function() {
                        if (this[ivar] == null) {
                            return nil;
                        } else {
                            return this[ivar];
                        }
                    };
                }(ivar1);
                Opal.defineProperty(proto, ivar1, nil);
                body.$$parameters = [];
                body.$$arity = 0;
                Opal.defn(self, id, body);
            }
            return nil;
        }, $Module_attr_reader$15.$$arity = -1);
        Opal.def(self4, '$attr_writer', $Module_attr_writer$16 = function $$attr_writer($a) {
            var $post_args, names, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            names = $post_args;
            var proto = self.$$prototype;
            for(var i156 = names.length - 1; i156 >= 0; i156--){
                var name84 = names[i156], id = '$' + name84 + '=', ivar3 = Opal.ivar(name84);
                var body = function(ivar) {
                    return function(value) {
                        return this[ivar] = value;
                    };
                }(ivar3);
                body.$$parameters = [
                    [
                        'req'
                    ]
                ];
                body.$$arity = 1;
                Opal.defineProperty(proto, ivar3, nil);
                Opal.defn(self, id, body);
            }
            return nil;
        }, $Module_attr_writer$16.$$arity = -1);
        Opal.def(self4, '$autoload', $Module_autoload$17 = function $$autoload(const$, path5) {
            var self = this;
            if (self.$$autoload == null) self.$$autoload = {};
            Opal.const_cache_version++;
            self.$$autoload[const$] = path5;
            return nil;
        }, $Module_autoload$17.$$arity = 2);
        Opal.def(self4, '$class_variables', $Module_class_variables$18 = function $$class_variables() {
            var self = this;
            return Object.keys(Opal.class_variables(self));
        }, $Module_class_variables$18.$$arity = 0);
        Opal.def(self4, '$class_variable_get', $Module_class_variable_get$19 = function $$class_variable_get(name85) {
            var self = this;
            name85 = $$($nesting, 'Opal')['$class_variable_name!'](name85);
            return Opal.class_variable_get(self, name85, false);
        }, $Module_class_variable_get$19.$$arity = 1);
        Opal.def(self4, '$class_variable_set', $Module_class_variable_set$20 = function $$class_variable_set(name86, value) {
            var self = this;
            name86 = $$($nesting, 'Opal')['$class_variable_name!'](name86);
            return Opal.class_variable_set(self, name86, value);
        }, $Module_class_variable_set$20.$$arity = 2);
        Opal.def(self4, '$class_variable_defined?', $Module_class_variable_defined$ques$21 = function(name87) {
            var self = this;
            name87 = $$($nesting, 'Opal')['$class_variable_name!'](name87);
            return Opal.class_variables(self).hasOwnProperty(name87);
        }, $Module_class_variable_defined$ques$21.$$arity = 1);
        Opal.def(self4, '$remove_class_variable', $Module_remove_class_variable$22 = function $$remove_class_variable(name88) {
            var self = this;
            name88 = $$($nesting, 'Opal')['$class_variable_name!'](name88);
            if (Opal.hasOwnProperty.call(self.$$cvars, name88)) {
                var value = self.$$cvars[name88];
                delete self.$$cvars[name88];
                return value;
            } else {
                self.$raise($$($nesting, 'NameError'), "" + "cannot remove " + name88 + " for " + self);
            }
        }, $Module_remove_class_variable$22.$$arity = 1);
        Opal.def(self4, '$constants', $Module_constants$23 = function $$constants(inherit) {
            var self = this;
            if (inherit == null) {
                inherit = true;
            }
            return Opal.constants(self, inherit);
        }, $Module_constants$23.$$arity = -1);
        Opal.defs(self4, '$constants', $Module_constants$24 = function $$constants(inherit) {
            var self = this;
            if (inherit == null) {
                var nesting = (self.$$nesting || []).concat(Opal.Object), constant, constants7 = {}, i157, ii;
                for(i157 = 0, ii = nesting.length; i157 < ii; i157++){
                    for(constant in nesting[i157].$$const){
                        constants7[constant] = true;
                    }
                }
                return Object.keys(constants7);
            } else {
                return Opal.constants(self, inherit);
            }
        }, $Module_constants$24.$$arity = -1);
        Opal.defs(self4, '$nesting', $Module_nesting$25 = function $$nesting() {
            var self = this;
            return self.$$nesting || [];
        }, $Module_nesting$25.$$arity = 0);
        Opal.def(self4, '$const_defined?', $Module_const_defined$ques$26 = function(name89, inherit) {
            var self = this;
            if (inherit == null) {
                inherit = true;
            }
            name89 = $$($nesting, 'Opal')['$const_name!'](name89);
            if ($truthy(name89['$=~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {} else {
                self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + name89, name89));
            }
            var module, modules2 = [
                self
            ], i158, ii;
            if (inherit) {
                modules2 = modules2.concat(Opal.ancestors(self));
                if (self.$$is_module) {
                    modules2 = modules2.concat([
                        Opal.Object
                    ]).concat(Opal.ancestors(Opal.Object));
                }
            }
            for(i158 = 0, ii = modules2.length; i158 < ii; i158++){
                module = modules2[i158];
                if (module.$$const[name89] != null) {
                    return true;
                }
            }
            return false;
        }, $Module_const_defined$ques$26.$$arity = -2);
        Opal.def(self4, '$const_get', $Module_const_get$27 = function $$const_get(name90, inherit) {
            var $$28, self = this;
            if (inherit == null) {
                inherit = true;
            }
            name90 = $$($nesting, 'Opal')['$const_name!'](name90);
            if (name90.indexOf('::') === 0 && name90 !== '::') {
                name90 = name90.slice(2);
            }
            if ($truthy(name90.indexOf('::') != -1 && name90 != '::')) {
                return $send(name90.$split("::"), 'inject', [
                    self
                ], ($$28 = function(o, c) {
                    $$28.$$s == null ? this : $$28.$$s;
                    if (o == null) {
                        o = nil;
                    }
                    if (c == null) {
                        c = nil;
                    }
                    return o.$const_get(c);
                }, $$28.$$s = self, $$28.$$arity = 2, $$28));
            }
            if ($truthy(name90['$=~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {} else {
                self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + name90, name90));
            }
            if (inherit) {
                return $$([
                    self
                ], name90);
            } else {
                return Opal.const_get_local(self, name90);
            }
        }, $Module_const_get$27.$$arity = -2);
        Opal.def(self4, '$const_missing', $Module_const_missing$29 = function $$const_missing(name91) {
            var self = this, full_const_name = nil;
            if (self.$$autoload) {
                var file = self.$$autoload[name91];
                if (file) {
                    self.$require(file);
                    return self.$const_get(name91);
                }
            }
            full_const_name = function() {
                if (self['$==']($$($nesting, 'Object'))) {
                    return name91;
                } else {
                    return "" + self + "::" + name91;
                }
                return nil;
            }();
            return self.$raise($$($nesting, 'NameError').$new("" + "uninitialized constant " + full_const_name, name91));
        }, $Module_const_missing$29.$$arity = 1);
        Opal.def(self4, '$const_set', $Module_const_set$30 = function $$const_set(name92, value) {
            var self = this, $ret_or_3 = nil;
            name92 = $$($nesting, 'Opal')['$const_name!'](name92);
            if ($truthy(function() {
                if ($truthy($ret_or_3 = name92['$!~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {
                    return $ret_or_3;
                } else {
                    return name92['$start_with?']("::");
                }
                return nil;
            }())) {
                self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + name92, name92));
            }
            Opal.const_set(self, name92, value);
            return value;
        }, $Module_const_set$30.$$arity = 2);
        Opal.def(self4, '$public_constant', $Module_public_constant$31 = function $$public_constant(const_name) {
            return nil;
        }, $Module_public_constant$31.$$arity = 1);
        Opal.def(self4, '$define_method', $Module_define_method$32 = function $$define_method(name93, method) {
            var $iter = $Module_define_method$32.$$p, block = $iter || nil, $$33, self5 = this, $ret_or_4 = nil, $case = nil;
            if ($iter) $Module_define_method$32.$$p = null;
            if ($iter) $Module_define_method$32.$$p = null;
            if ($truthy(method === undefined && block === nil)) {
                self5.$raise($$($nesting, 'ArgumentError'), "tried to create a Proc object without a block");
            }
            block = function() {
                if ($truthy($ret_or_4 = block)) {
                    return $ret_or_4;
                } else {
                    return function() {
                        $case = method;
                        if ($$($nesting, 'Proc')['$===']($case)) {
                            return method;
                        } else if ($$($nesting, 'Method')['$===']($case)) {
                            return method.$to_proc().$$unbound;
                        } else if ($$($nesting, 'UnboundMethod')['$===']($case)) {
                            return $lambda(($$33 = function($a) {
                                var self = $$33.$$s == null ? this : $$33.$$s, $post_args, args14, bound = nil;
                                $post_args = Opal.slice.call(arguments, 0, arguments.length);
                                args14 = $post_args;
                                bound = method.$bind(self);
                                return $send(bound, 'call', Opal.to_a(args14));
                            }, $$33.$$s = self5, $$33.$$arity = -1, $$33));
                        } else {
                            return self5.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + block.$class() + " (expected Proc/Method)");
                        }
                    }();
                }
                return nil;
            }();
            var id = '$' + name93;
            block.$$jsid = name93;
            block.$$s = null;
            block.$$def = block;
            block.$$define_meth = true;
            Opal.defn(self5, id, block);
            return name93;
        }, $Module_define_method$32.$$arity = -2);
        Opal.def(self4, '$remove_method', $Module_remove_method$34 = function $$remove_method($a) {
            var $post_args, names, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            names = $post_args;
            for(var i159 = 0, length = names.length; i159 < length; i159++){
                Opal.rdef(self, "$" + names[i159]);
            }
            return self;
        }, $Module_remove_method$34.$$arity = -1);
        Opal.def(self4, '$singleton_class?', $Module_singleton_class$ques$35 = function() {
            var self = this;
            return !!self.$$is_singleton;
        }, $Module_singleton_class$ques$35.$$arity = 0);
        Opal.def(self4, '$include', $Module_include$36 = function $$include($a) {
            var $post_args, mods, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            mods = $post_args;
            for(var i160 = mods.length - 1; i160 >= 0; i160--){
                var mod61 = mods[i160];
                if (!mod61.$$is_module) {
                    self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + mod61.$class() + " (expected Module)");
                }
                mod61.$append_features(self);
                mod61.$included(self);
            }
            return self;
        }, $Module_include$36.$$arity = -1);
        Opal.def(self4, '$included_modules', $Module_included_modules$37 = function $$included_modules() {
            var self = this;
            return Opal.included_modules(self);
        }, $Module_included_modules$37.$$arity = 0);
        Opal.def(self4, '$include?', $Module_include$ques$38 = function(mod62) {
            var self = this;
            if (!mod62.$$is_module) {
                self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + mod62.$class() + " (expected Module)");
            }
            var i161, ii, mod210, ancestors = Opal.ancestors(self);
            for(i161 = 0, ii = ancestors.length; i161 < ii; i161++){
                mod210 = ancestors[i161];
                if (mod210 === mod62 && mod210 !== self) {
                    return true;
                }
            }
            return false;
        }, $Module_include$ques$38.$$arity = 1);
        Opal.def(self4, '$instance_method', $Module_instance_method$39 = function $$instance_method(name94) {
            var self = this;
            var meth = self.$$prototype['$' + name94];
            if (!meth || meth.$$stub) {
                self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + name94 + "' for class `" + self.$name() + "'", name94));
            }
            return $$($nesting, 'UnboundMethod').$new(self, meth.$$owner || self, meth, name94);
        }, $Module_instance_method$39.$$arity = 1);
        Opal.def(self4, '$instance_methods', $Module_instance_methods$40 = function $$instance_methods(include_super) {
            var self = this;
            if (include_super == null) {
                include_super = true;
            }
            if ($truthy(include_super)) {
                return Opal.instance_methods(self);
            } else {
                return Opal.own_instance_methods(self);
            }
        }, $Module_instance_methods$40.$$arity = -1);
        Opal.def(self4, '$included', $Module_included$41 = function $$included(mod) {
            return nil;
        }, $Module_included$41.$$arity = 1);
        Opal.def(self4, '$extended', $Module_extended$42 = function $$extended(mod) {
            return nil;
        }, $Module_extended$42.$$arity = 1);
        Opal.def(self4, '$extend_object', $Module_extend_object$43 = function $$extend_object(object) {
            return nil;
        }, $Module_extend_object$43.$$arity = 1);
        Opal.def(self4, '$method_added', $Module_method_added$44 = function $$method_added($a) {
            var $post_args;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return nil;
        }, $Module_method_added$44.$$arity = -1);
        Opal.def(self4, '$method_removed', $Module_method_removed$45 = function $$method_removed($a) {
            var $post_args;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return nil;
        }, $Module_method_removed$45.$$arity = -1);
        Opal.def(self4, '$method_undefined', $Module_method_undefined$46 = function $$method_undefined($a) {
            var $post_args;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return nil;
        }, $Module_method_undefined$46.$$arity = -1);
        Opal.def(self4, '$module_eval', $Module_module_eval$47 = function $$module_eval($a) {
            var $iter = $Module_module_eval$47.$$p, block = $iter || nil, $post_args, args15, $b, $$48, self6 = this, $ret_or_5 = nil, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_6 = nil, compiling_options = nil, compiled = nil;
            if ($iter) $Module_module_eval$47.$$p = null;
            if ($iter) $Module_module_eval$47.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args15 = $post_args;
            if ($truthy(function() {
                if ($truthy($ret_or_5 = block['$nil?']())) {
                    return !!Opal.compile;
                } else {
                    return $ret_or_5;
                }
                return nil;
            }())) {
                if ($truthy($range(1, 3, false)['$cover?'](args15.$size()))) {} else {
                    $$($nesting, 'Kernel').$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1..3)");
                }
                $b = [].concat(Opal.to_a(args15)), string = $b[0] == null ? nil : $b[0], file = $b[1] == null ? nil : $b[1], _lineno = $b[2] == null ? nil : $b[2], $b;
                default_eval_options = $hash2([
                    "file",
                    "eval"
                ], {
                    "file": function() {
                        if ($truthy($ret_or_6 = file)) {
                            return $ret_or_6;
                        } else {
                            return "(eval)";
                        }
                        return nil;
                    }(),
                    "eval": true
                });
                compiling_options = Opal.hash({
                    arity_check: false
                }).$merge(default_eval_options);
                compiled = $$($nesting, 'Opal').$compile(string, compiling_options);
                block = $send($$($nesting, 'Kernel'), 'proc', [], ($$48 = function() {
                    var self = $$48.$$s == null ? this : $$48.$$s;
                    return function(self) {
                        return eval(compiled);
                    }(self);
                }, $$48.$$s = self6, $$48.$$arity = 0, $$48));
            } else if ($truthy(args15['$any?']())) {
                $$($nesting, 'Kernel').$raise($$($nesting, 'ArgumentError'), "" + ("" + "wrong number of arguments (" + args15.$size() + " for 0)") + "\n\n  NOTE:If you want to enable passing a String argument please add \"require 'opal-parser'\" to your script\n");
            }
            var old = block.$$s, result;
            block.$$s = null;
            result = block.apply(self6, [
                self6
            ]);
            block.$$s = old;
            return result;
        }, $Module_module_eval$47.$$arity = -1);
        Opal.alias(self4, "class_eval", "module_eval");
        Opal.def(self4, '$module_exec', $Module_module_exec$49 = function $$module_exec($a) {
            var $iter = $Module_module_exec$49.$$p, block = $iter || nil, $post_args, args16, self = this;
            if ($iter) $Module_module_exec$49.$$p = null;
            if ($iter) $Module_module_exec$49.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args16 = $post_args;
            if (block === nil) {
                self.$raise($$($nesting, 'LocalJumpError'), "no block given");
            }
            var block_self = block.$$s, result;
            block.$$s = null;
            result = block.apply(self, args16);
            block.$$s = block_self;
            return result;
        }, $Module_module_exec$49.$$arity = -1);
        Opal.alias(self4, "class_exec", "module_exec");
        Opal.def(self4, '$method_defined?', $Module_method_defined$ques$50 = function(method) {
            var self = this;
            var body = self.$$prototype['$' + method];
            return !!body && !body.$$stub;
        }, $Module_method_defined$ques$50.$$arity = 1);
        Opal.def(self4, '$module_function', $Module_module_function$51 = function $$module_function($a) {
            var $post_args, methods, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            methods = $post_args;
            if (methods.length === 0) {
                self.$$module_function = true;
            } else {
                for(var i162 = 0, length = methods.length; i162 < length; i162++){
                    var meth = methods[i162], id = '$' + meth, func = self.$$prototype[id];
                    Opal.defs(self, id, func);
                }
            }
            return self;
        }, $Module_module_function$51.$$arity = -1);
        Opal.def(self4, '$name', $Module_name$52 = function $$name() {
            var self = this;
            if (self.$$full_name) {
                return self.$$full_name;
            }
            var result = [], base9 = self;
            while(base9){
                if (base9.$$name === nil || base9.$$name == null) return nil;
                result.unshift(base9.$$name);
                base9 = base9.$$base_module;
                if (base9 === Opal.Object) {
                    break;
                }
            }
            if (result.length === 0) {
                return nil;
            }
            return self.$$full_name = result.join('::');
        }, $Module_name$52.$$arity = 0);
        Opal.def(self4, '$prepend', $Module_prepend$53 = function $$prepend($a) {
            var $post_args, mods, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            mods = $post_args;
            if (mods.length === 0) {
                self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (given 0, expected 1+)");
            }
            for(var i163 = mods.length - 1; i163 >= 0; i163--){
                var mod63 = mods[i163];
                if (!mod63.$$is_module) {
                    self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + mod63.$class() + " (expected Module)");
                }
                mod63.$prepend_features(self);
                mod63.$prepended(self);
            }
            return self;
        }, $Module_prepend$53.$$arity = -1);
        Opal.def(self4, '$prepend_features', $Module_prepend_features$54 = function $$prepend_features(prepender) {
            var self = this;
            if (!self.$$is_module) {
                self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + self.$class() + " (expected Module)");
            }
            Opal.prepend_features(self, prepender);
            return self;
        }, $Module_prepend_features$54.$$arity = 1);
        Opal.def(self4, '$prepended', $Module_prepended$55 = function $$prepended(mod) {
            return nil;
        }, $Module_prepended$55.$$arity = 1);
        Opal.def(self4, '$remove_const', $Module_remove_const$56 = function $$remove_const(name95) {
            var self = this;
            return Opal.const_remove(self, name95);
        }, $Module_remove_const$56.$$arity = 1);
        Opal.def(self4, '$to_s', $Module_to_s$57 = function $$to_s() {
            var self = this, $ret_or_7 = nil;
            if ($truthy($ret_or_7 = Opal.Module.$name.call(self))) {
                return $ret_or_7;
            } else {
                return "" + "#<" + (self.$$is_module ? 'Module' : 'Class') + ":0x" + self.$__id__().$to_s(16) + ">";
            }
        }, $Module_to_s$57.$$arity = 0);
        Opal.def(self4, '$undef_method', $Module_undef_method$58 = function $$undef_method($a) {
            var $post_args, names, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            names = $post_args;
            for(var i164 = 0, length = names.length; i164 < length; i164++){
                Opal.udef(self, "$" + names[i164]);
            }
            return self;
        }, $Module_undef_method$58.$$arity = -1);
        Opal.def(self4, '$instance_variables', $Module_instance_variables$59 = function $$instance_variables() {
            var self = this, consts = nil;
            consts = (Opal.Module.$$nesting = $nesting, self.$constants());
            var result = [];
            for(var name96 in self){
                if (self.hasOwnProperty(name96) && name96.charAt(0) !== '$' && name96 !== 'constructor' && !consts['$include?'](name96)) {
                    result.push('@' + name96);
                }
            }
            return result;
        }, $Module_instance_variables$59.$$arity = 0);
        Opal.def(self4, '$dup', $Module_dup$60 = function $$dup() {
            var $iter = $Module_dup$60.$$p, self = this, copy1 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
            if ($iter) $Module_dup$60.$$p = null;
            for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                $zuper[$zuper_i] = arguments[$zuper_i];
            }
            copy1 = $send2(self, Opal.find_super_dispatcher(self, 'dup', $Module_dup$60, false, true), 'dup', $zuper, $iter);
            copy1.$copy_class_variables(self);
            copy1.$copy_constants(self);
            return copy1;
        }, $Module_dup$60.$$arity = 0);
        Opal.def(self4, '$copy_class_variables', $Module_copy_class_variables$61 = function $$copy_class_variables(other) {
            var self = this;
            for(var name97 in other.$$cvars){
                self.$$cvars[name97] = other.$$cvars[name97];
            }
        }, $Module_copy_class_variables$61.$$arity = 1);
        return (Opal.def(self4, '$copy_constants', $Module_copy_constants$62 = function $$copy_constants(other) {
            var self = this;
            var name98, other_constants = other.$$const;
            for(name98 in other_constants){
                Opal.const_set(self, name98, other_constants[name98]);
            }
        }, $Module_copy_constants$62.$$arity = 1), nil) && 'copy_constants';
    }($nesting2[0], null, $nesting2);
};
Opal.modules["corelib/class"] = function(Opal) {
    var self7 = Opal.top, $nesting3 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, $send2 = Opal.send2;
    Opal.add_stubs([
        '$require',
        '$class_eval',
        '$to_proc',
        '$initialize_copy',
        '$allocate',
        '$name',
        '$to_s'
    ]);
    self7.$require("corelib/module");
    return function($base, $super, $parent_nesting) {
        var self8 = $klass($base, $super, 'Class');
        var $nesting = [
            self8
        ].concat($parent_nesting), $Class_new$1, $Class_allocate$2, $Class_inherited$3, $Class_initialize_dup$4, $Class_new$5, $Class_superclass$6, $Class_to_s$7;
        Opal.defs(self8, '$new', $Class_new$1 = function(superclass) {
            var $iter = $Class_new$1.$$p, block = $iter || nil;
            if ($iter) $Class_new$1.$$p = null;
            if ($iter) $Class_new$1.$$p = null;
            if (superclass == null) {
                superclass = $$($nesting, 'Object');
            }
            if (!superclass.$$is_class) {
                throw Opal.TypeError.$new("superclass must be a Class");
            }
            var klass = Opal.allocate_class(nil, superclass);
            superclass.$inherited(klass);
            (function() {
                if (block !== nil) {
                    return $send(klass, 'class_eval', [], block.$to_proc());
                } else {
                    return nil;
                }
                return nil;
            })();
            return klass;
        }, $Class_new$1.$$arity = -1);
        Opal.def(self8, '$allocate', $Class_allocate$2 = function $$allocate() {
            var self = this;
            var obj = new self.$$constructor();
            obj.$$id = Opal.uid();
            return obj;
        }, $Class_allocate$2.$$arity = 0);
        Opal.def(self8, '$inherited', $Class_inherited$3 = function $$inherited(cls) {
            return nil;
        }, $Class_inherited$3.$$arity = 1);
        Opal.def(self8, '$initialize_dup', $Class_initialize_dup$4 = function $$initialize_dup(original) {
            var self = this;
            self.$initialize_copy(original);
            self.$$name = null;
            self.$$full_name = null;
        }, $Class_initialize_dup$4.$$arity = 1);
        Opal.def(self8, '$new', $Class_new$5 = function($a) {
            var $iter = $Class_new$5.$$p, block = $iter || nil, $post_args, args17, self = this;
            if ($iter) $Class_new$5.$$p = null;
            if ($iter) $Class_new$5.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args17 = $post_args;
            var object = self.$allocate();
            Opal.send(object, object.$initialize, args17, block);
            return object;
        }, $Class_new$5.$$arity = -1);
        Opal.def(self8, '$superclass', $Class_superclass$6 = function $$superclass() {
            var self = this;
            return self.$$super || nil;
        }, $Class_superclass$6.$$arity = 0);
        return (Opal.def(self8, '$to_s', $Class_to_s$7 = function $$to_s() {
            var $iter = $Class_to_s$7.$$p, self = this;
            if ($iter) $Class_to_s$7.$$p = null;
            var singleton_of = self.$$singleton_of;
            if (singleton_of && singleton_of.$$is_a_module) {
                return "" + "#<Class:" + singleton_of.$name() + ">";
            } else if (singleton_of) {
                return "" + "#<Class:#<" + singleton_of.$$class.$name() + ":0x" + Opal.id(singleton_of).$to_s(16) + ">>";
            }
            return $send2(self, Opal.find_super_dispatcher(self, 'to_s', $Class_to_s$7, false, true), 'to_s', [], null);
        }, $Class_to_s$7.$$arity = 0), nil) && 'to_s';
    }($nesting3[0], null, $nesting3);
};
Opal.modules["corelib/basic_object"] = function(Opal) {
    var self9 = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $hash2 = Opal.hash2, $send = Opal.send;
    Opal.add_stubs([
        '$==',
        '$!',
        '$nil?',
        '$cover?',
        '$size',
        '$raise',
        '$merge',
        '$compile',
        '$proc',
        '$any?',
        '$inspect',
        '$new'
    ]);
    return function($base, $super, $parent_nesting) {
        var self10 = $klass($base, $super, 'BasicObject');
        var $nesting = [
            self10
        ].concat($parent_nesting), $BasicObject_initialize$1, $BasicObject_$eq_eq$2, $BasicObject_eql$ques$3, $BasicObject___id__$4, $BasicObject___send__$5, $BasicObject_$excl$6, $BasicObject_$not_eq$7, $BasicObject_instance_eval$8, $BasicObject_instance_exec$10, $BasicObject_singleton_method_added$11, $BasicObject_singleton_method_removed$12, $BasicObject_singleton_method_undefined$13, $BasicObject_method_missing$14, $BasicObject_respond_to_missing$ques$15;
        Opal.def(self10, '$initialize', $BasicObject_initialize$1 = function $$initialize($a) {
            var $post_args;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return nil;
        }, $BasicObject_initialize$1.$$arity = -1);
        Opal.def(self10, '$==', $BasicObject_$eq_eq$2 = function(other) {
            var self = this;
            return self === other;
        }, $BasicObject_$eq_eq$2.$$arity = 1);
        Opal.def(self10, '$eql?', $BasicObject_eql$ques$3 = function(other) {
            var self = this;
            return self['$=='](other);
        }, $BasicObject_eql$ques$3.$$arity = 1);
        Opal.alias(self10, "equal?", "==");
        Opal.def(self10, '$__id__', $BasicObject___id__$4 = function $$__id__() {
            var self = this;
            if (self.$$id != null) {
                return self.$$id;
            }
            Opal.defineProperty(self, '$$id', Opal.uid());
            return self.$$id;
        }, $BasicObject___id__$4.$$arity = 0);
        Opal.def(self10, '$__send__', $BasicObject___send__$5 = function $$__send__(symbol, $a) {
            var $iter = $BasicObject___send__$5.$$p, block = $iter || nil, $post_args, args18, self = this;
            if ($iter) $BasicObject___send__$5.$$p = null;
            if ($iter) $BasicObject___send__$5.$$p = null;
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            args18 = $post_args;
            var func = self['$' + symbol];
            if (func) {
                if (block !== nil) {
                    func.$$p = block;
                }
                return func.apply(self, args18);
            }
            if (block !== nil) {
                self.$method_missing.$$p = block;
            }
            return self.$method_missing.apply(self, [
                symbol
            ].concat(args18));
        }, $BasicObject___send__$5.$$arity = -2);
        Opal.def(self10, '$!', $BasicObject_$excl$6 = function() {
            return false;
        }, $BasicObject_$excl$6.$$arity = 0);
        Opal.def(self10, '$!=', $BasicObject_$not_eq$7 = function(other) {
            var self = this;
            return self['$=='](other)['$!']();
        }, $BasicObject_$not_eq$7.$$arity = 1);
        Opal.def(self10, '$instance_eval', $BasicObject_instance_eval$8 = function $$instance_eval($a) {
            var $iter = $BasicObject_instance_eval$8.$$p, block = $iter || nil, $post_args, args19, $b, $$9, self11 = this, $ret_or_1 = nil, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_2 = nil, compiling_options = nil, compiled = nil;
            if ($iter) $BasicObject_instance_eval$8.$$p = null;
            if ($iter) $BasicObject_instance_eval$8.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args19 = $post_args;
            if ($truthy(function() {
                if ($truthy($ret_or_1 = block['$nil?']())) {
                    return !!Opal.compile;
                } else {
                    return $ret_or_1;
                }
                return nil;
            }())) {
                if ($truthy($range(1, 3, false)['$cover?'](args19.$size()))) {} else {
                    $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "wrong number of arguments (0 for 1..3)");
                }
                $b = [].concat(Opal.to_a(args19)), string = $b[0] == null ? nil : $b[0], file = $b[1] == null ? nil : $b[1], _lineno = $b[2] == null ? nil : $b[2], $b;
                default_eval_options = $hash2([
                    "file",
                    "eval"
                ], {
                    "file": function() {
                        if ($truthy($ret_or_2 = file)) {
                            return $ret_or_2;
                        } else {
                            return "(eval)";
                        }
                        return nil;
                    }(),
                    "eval": true
                });
                compiling_options = Opal.hash({
                    arity_check: false
                }).$merge(default_eval_options);
                compiled = $$$('::', 'Opal').$compile(string, compiling_options);
                block = $send($$$('::', 'Kernel'), 'proc', [], ($$9 = function() {
                    var self = $$9.$$s == null ? this : $$9.$$s;
                    return function(self) {
                        return eval(compiled);
                    }(self);
                }, $$9.$$s = self11, $$9.$$arity = 0, $$9));
            } else if ($truthy(args19['$any?']())) {
                $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "" + "wrong number of arguments (" + args19.$size() + " for 0)");
            }
            var old = block.$$s, result;
            block.$$s = null;
            if (self11.$$is_a_module) {
                self11.$$eval = true;
                try {
                    result = block.call(self11, self11);
                } finally{
                    self11.$$eval = false;
                }
            } else {
                result = block.call(self11, self11);
            }
            block.$$s = old;
            return result;
        }, $BasicObject_instance_eval$8.$$arity = -1);
        Opal.def(self10, '$instance_exec', $BasicObject_instance_exec$10 = function $$instance_exec($a) {
            var $iter = $BasicObject_instance_exec$10.$$p, block = $iter || nil, $post_args, args20, self = this;
            if ($iter) $BasicObject_instance_exec$10.$$p = null;
            if ($iter) $BasicObject_instance_exec$10.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args20 = $post_args;
            if ($truthy(block)) {} else {
                $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "no block given");
            }
            var block_self = block.$$s, result;
            block.$$s = null;
            if (self.$$is_a_module) {
                self.$$eval = true;
                try {
                    result = block.apply(self, args20);
                } finally{
                    self.$$eval = false;
                }
            } else {
                result = block.apply(self, args20);
            }
            block.$$s = block_self;
            return result;
        }, $BasicObject_instance_exec$10.$$arity = -1);
        Opal.def(self10, '$singleton_method_added', $BasicObject_singleton_method_added$11 = function $$singleton_method_added($a) {
            var $post_args;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return nil;
        }, $BasicObject_singleton_method_added$11.$$arity = -1);
        Opal.def(self10, '$singleton_method_removed', $BasicObject_singleton_method_removed$12 = function $$singleton_method_removed($a) {
            var $post_args;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return nil;
        }, $BasicObject_singleton_method_removed$12.$$arity = -1);
        Opal.def(self10, '$singleton_method_undefined', $BasicObject_singleton_method_undefined$13 = function $$singleton_method_undefined($a) {
            var $post_args;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return nil;
        }, $BasicObject_singleton_method_undefined$13.$$arity = -1);
        Opal.def(self10, '$method_missing', $BasicObject_method_missing$14 = function $$method_missing(symbol, $a) {
            var $iter = $BasicObject_method_missing$14.$$p, $post_args, self = this, message = nil;
            if ($iter) $BasicObject_method_missing$14.$$p = null;
            if ($iter) $BasicObject_method_missing$14.$$p = null;
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            message = function() {
                if ($truthy(self.$inspect && !self.$inspect.$$stub)) {
                    return "" + "undefined method `" + symbol + "' for " + self.$inspect() + ":" + self.$$class;
                } else {
                    return "" + "undefined method `" + symbol + "' for " + self.$$class;
                }
                return nil;
            }();
            return $$$('::', 'Kernel').$raise($$$('::', 'NoMethodError').$new(message, symbol));
        }, $BasicObject_method_missing$14.$$arity = -2);
        return (Opal.def(self10, '$respond_to_missing?', $BasicObject_respond_to_missing$ques$15 = function(method_name, include_all) {
            if (include_all == null) {
                include_all = false;
            }
            return false;
        }, $BasicObject_respond_to_missing$ques$15.$$arity = -2), nil) && 'respond_to_missing?';
    }($nesting[0], null, $nesting);
};
Opal.modules["corelib/kernel"] = function(Opal) {
    function $rb_le(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs <= rhs : lhs['$<='](rhs);
    }
    function $rb_lt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs < rhs : lhs['$<'](rhs);
    }
    function $rb_plus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
    }
    var self12 = Opal.top, $nesting4 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $module = Opal.module, $gvars = Opal.gvars, $hash2 = Opal.hash2, $send = Opal.send, $klass = Opal.klass;
    Opal.add_stubs([
        '$raise',
        '$new',
        '$inspect',
        '$!',
        '$=~',
        '$==',
        '$object_id',
        '$class',
        '$coerce_to?',
        '$<<',
        '$allocate',
        '$copy_instance_variables',
        '$copy_singleton_methods',
        '$initialize_clone',
        '$initialize_copy',
        '$define_method',
        '$singleton_class',
        '$to_proc',
        '$initialize_dup',
        '$for',
        '$empty?',
        '$pop',
        '$call',
        '$append_features',
        '$extend_object',
        '$extended',
        '$__id__',
        '$to_s',
        '$instance_variable_name!',
        '$respond_to?',
        '$to_int',
        '$coerce_to!',
        '$Integer',
        '$nil?',
        '$===',
        '$enum_for',
        '$result',
        '$any?',
        '$print',
        '$format',
        '$puts',
        '$each',
        '$<=',
        '$length',
        '$[]',
        '$<',
        '$first',
        '$caller',
        '$+',
        '$map',
        '$exception',
        '$is_a?',
        '$rand',
        '$respond_to_missing?',
        '$pristine',
        '$try_convert!',
        '$expand_path',
        '$join',
        '$start_with?',
        '$new_seed',
        '$srand',
        '$sym',
        '$arg',
        '$open',
        '$include'
    ]);
    (function($base, $parent_nesting) {
        var self13 = $module($base, 'Kernel');
        var $nesting = [
            self13
        ].concat($parent_nesting), $Kernel_method_missing$1, $Kernel_$eq_tilde$2, $Kernel_$excl_tilde$3, $Kernel_$eq_eq_eq$4, $Kernel_$lt_eq_gt$5, $Kernel_method$6, $Kernel_methods$7, $Kernel_public_methods$8, $Kernel_Array$9, $Kernel_at_exit$10, $Kernel_caller$11, $Kernel_class$12, $Kernel_copy_instance_variables$13, $Kernel_copy_singleton_methods$14, $Kernel_clone$15, $Kernel_initialize_clone$16, $Kernel_define_singleton_method$17, $Kernel_dup$18, $Kernel_initialize_dup$19, $Kernel_enum_for$20, $Kernel_equal$ques$21, $Kernel_exit$22, $Kernel_extend$23, $Kernel_hash$24, $Kernel_initialize_copy$25, $Kernel_inspect$26, $Kernel_instance_of$ques$27, $Kernel_instance_variable_defined$ques$28, $Kernel_instance_variable_get$29, $Kernel_instance_variable_set$30, $Kernel_remove_instance_variable$31, $Kernel_instance_variables$32, $Kernel_Integer$33, $Kernel_Float$34, $Kernel_Hash$35, $Kernel_is_a$ques$36, $Kernel_itself$37, $Kernel_lambda$38, $Kernel_load$39, $Kernel_loop$40, $Kernel_nil$ques$42, $Kernel_printf$43, $Kernel_proc$44, $Kernel_puts$45, $Kernel_p$46, $Kernel_print$48, $Kernel_warn$49, $Kernel_raise$51, $Kernel_rand$52, $Kernel_respond_to$ques$53, $Kernel_respond_to_missing$ques$54, $Kernel_require$55, $Kernel_require_relative$56, $Kernel_require_tree$57, $Kernel_singleton_class$58, $Kernel_sleep$59, $Kernel_srand$60, $Kernel_String$61, $Kernel_tap$62, $Kernel_to_proc$63, $Kernel_to_s$64, $Kernel_catch$65, $Kernel_throw$66, $Kernel_open$67, $Kernel_yield_self$68;
        Opal.def(self13, '$method_missing', $Kernel_method_missing$1 = function $$method_missing(symbol, $a) {
            var $iter = $Kernel_method_missing$1.$$p, $post_args, args21, self = this;
            if ($iter) $Kernel_method_missing$1.$$p = null;
            if ($iter) $Kernel_method_missing$1.$$p = null;
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            args21 = $post_args;
            return self.$raise($$($nesting, 'NoMethodError').$new("" + "undefined method `" + symbol + "' for " + self.$inspect(), symbol, args21));
        }, $Kernel_method_missing$1.$$arity = -2);
        Opal.def(self13, '$=~', $Kernel_$eq_tilde$2 = function(obj) {
            return false;
        }, $Kernel_$eq_tilde$2.$$arity = 1);
        Opal.def(self13, '$!~', $Kernel_$excl_tilde$3 = function(obj) {
            var self = this;
            return self['$=~'](obj)['$!']();
        }, $Kernel_$excl_tilde$3.$$arity = 1);
        Opal.def(self13, '$===', $Kernel_$eq_eq_eq$4 = function(other) {
            var self = this, $ret_or_1 = nil;
            if ($truthy($ret_or_1 = self.$object_id()['$=='](other.$object_id()))) {
                return $ret_or_1;
            } else {
                return self['$=='](other);
            }
        }, $Kernel_$eq_eq_eq$4.$$arity = 1);
        Opal.def(self13, '$<=>', $Kernel_$lt_eq_gt$5 = function(other) {
            var self = this;
            self.$$comparable = true;
            var x = self['$=='](other);
            if (x && x !== nil) {
                return 0;
            }
            return nil;
        }, $Kernel_$lt_eq_gt$5.$$arity = 1);
        Opal.def(self13, '$method', $Kernel_method$6 = function $$method(name99) {
            var self = this;
            var meth = self['$' + name99];
            if (!meth || meth.$$stub) {
                self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + name99 + "' for class `" + self.$class() + "'", name99));
            }
            return $$($nesting, 'Method').$new(self, meth.$$owner || self.$class(), meth, name99);
        }, $Kernel_method$6.$$arity = 1);
        Opal.def(self13, '$methods', $Kernel_methods$7 = function $$methods(all) {
            var self = this;
            if (all == null) {
                all = true;
            }
            if ($truthy(all)) {
                return Opal.methods(self);
            } else {
                return Opal.own_methods(self);
            }
        }, $Kernel_methods$7.$$arity = -1);
        Opal.def(self13, '$public_methods', $Kernel_public_methods$8 = function $$public_methods(all) {
            var self = this;
            if (all == null) {
                all = true;
            }
            if ($truthy(all)) {
                return Opal.methods(self);
            } else {
                return Opal.receiver_methods(self);
            }
        }, $Kernel_public_methods$8.$$arity = -1);
        Opal.def(self13, '$Array', $Kernel_Array$9 = function $$Array(object) {
            var coerced;
            if (object === nil) {
                return [];
            }
            if (object.$$is_array) {
                return object;
            }
            coerced = $$($nesting, 'Opal')['$coerce_to?'](object, $$($nesting, 'Array'), "to_ary");
            if (coerced !== nil) {
                return coerced;
            }
            coerced = $$($nesting, 'Opal')['$coerce_to?'](object, $$($nesting, 'Array'), "to_a");
            if (coerced !== nil) {
                return coerced;
            }
            return [
                object
            ];
        }, $Kernel_Array$9.$$arity = 1);
        Opal.def(self13, '$at_exit', $Kernel_at_exit$10 = function $$at_exit() {
            var $iter = $Kernel_at_exit$10.$$p, block = $iter || nil, $ret_or_2 = nil;
            if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;
            if ($iter) $Kernel_at_exit$10.$$p = null;
            if ($iter) $Kernel_at_exit$10.$$p = null;
            $gvars.__at_exit__ = function() {
                if ($truthy($ret_or_2 = $gvars.__at_exit__)) {
                    return $ret_or_2;
                } else {
                    return [];
                }
                return nil;
            }();
            $gvars.__at_exit__['$<<'](block);
            return block;
        }, $Kernel_at_exit$10.$$arity = 0);
        Opal.def(self13, '$caller', $Kernel_caller$11 = function $$caller(start, length) {
            if (start == null) {
                start = 1;
            }
            if (length == null) {
                length = nil;
            }
            var stack, result;
            stack = (new Error().stack || "").split("\n");
            result = [];
            for(var i165 = 3, ii = stack.length; i165 < ii; i165++){
                if (!stack[i165].match("runtime.js")) {
                    result.push(stack[i165].replace(/^ *\w+ +/, ''));
                    if (length && result.length == length) break;
                }
            }
            return result;
        }, $Kernel_caller$11.$$arity = -1);
        Opal.def(self13, '$class', $Kernel_class$12 = function() {
            var self = this;
            return self.$$class;
        }, $Kernel_class$12.$$arity = 0);
        Opal.def(self13, '$copy_instance_variables', $Kernel_copy_instance_variables$13 = function $$copy_instance_variables(other) {
            var self = this;
            var keys = Object.keys(other), i166, ii, name100;
            for(i166 = 0, ii = keys.length; i166 < ii; i166++){
                name100 = keys[i166];
                if (name100.charAt(0) !== '$' && other.hasOwnProperty(name100)) {
                    self[name100] = other[name100];
                }
            }
        }, $Kernel_copy_instance_variables$13.$$arity = 1);
        Opal.def(self13, '$copy_singleton_methods', $Kernel_copy_singleton_methods$14 = function $$copy_singleton_methods(other) {
            var self = this;
            var i167, name101, names, length;
            if (other.hasOwnProperty('$$meta')) {
                var other_singleton_class = Opal.get_singleton_class(other);
                var self_singleton_class = Opal.get_singleton_class(self);
                names = Object.getOwnPropertyNames(other_singleton_class.$$prototype);
                for(i167 = 0, length = names.length; i167 < length; i167++){
                    name101 = names[i167];
                    if (Opal.is_method(name101)) {
                        self_singleton_class.$$prototype[name101] = other_singleton_class.$$prototype[name101];
                    }
                }
                self_singleton_class.$$const = Object.assign({}, other_singleton_class.$$const);
                Object.setPrototypeOf(self_singleton_class.$$prototype, Object.getPrototypeOf(other_singleton_class.$$prototype));
            }
            for(i167 = 0, names = Object.getOwnPropertyNames(other), length = names.length; i167 < length; i167++){
                name101 = names[i167];
                if (name101.charAt(0) === '$' && name101.charAt(1) !== '$' && other.hasOwnProperty(name101)) {
                    self[name101] = other[name101];
                }
            }
        }, $Kernel_copy_singleton_methods$14.$$arity = 1);
        Opal.def(self13, '$clone', $Kernel_clone$15 = function $$clone($kwargs) {
            var freeze, self = this, copy2 = nil;
            if ($kwargs == null) {
                $kwargs = $hash2([], {});
            } else if (!$kwargs.$$is_hash) {
                throw Opal.ArgumentError.$new('expected kwargs');
            }
            freeze = $kwargs.$$smap["freeze"];
            if (freeze == null) {
                freeze = true;
            }
            copy2 = self.$class().$allocate();
            copy2.$copy_instance_variables(self);
            copy2.$copy_singleton_methods(self);
            copy2.$initialize_clone(self);
            return copy2;
        }, $Kernel_clone$15.$$arity = -1);
        Opal.def(self13, '$initialize_clone', $Kernel_initialize_clone$16 = function $$initialize_clone(other) {
            var self = this;
            return self.$initialize_copy(other);
        }, $Kernel_initialize_clone$16.$$arity = 1);
        Opal.def(self13, '$define_singleton_method', $Kernel_define_singleton_method$17 = function $$define_singleton_method(name102, method) {
            var $iter = $Kernel_define_singleton_method$17.$$p, block = $iter || nil, self = this;
            if ($iter) $Kernel_define_singleton_method$17.$$p = null;
            if ($iter) $Kernel_define_singleton_method$17.$$p = null;
            return $send(self.$singleton_class(), 'define_method', [
                name102,
                method
            ], block.$to_proc());
        }, $Kernel_define_singleton_method$17.$$arity = -2);
        Opal.def(self13, '$dup', $Kernel_dup$18 = function $$dup() {
            var self = this, copy3 = nil;
            copy3 = self.$class().$allocate();
            copy3.$copy_instance_variables(self);
            copy3.$initialize_dup(self);
            return copy3;
        }, $Kernel_dup$18.$$arity = 0);
        Opal.def(self13, '$initialize_dup', $Kernel_initialize_dup$19 = function $$initialize_dup(other) {
            var self = this;
            return self.$initialize_copy(other);
        }, $Kernel_initialize_dup$19.$$arity = 1);
        Opal.def(self13, '$enum_for', $Kernel_enum_for$20 = function $$enum_for($a, $b) {
            var $iter = $Kernel_enum_for$20.$$p, block = $iter || nil, $post_args, method, args22, self = this;
            if ($iter) $Kernel_enum_for$20.$$p = null;
            if ($iter) $Kernel_enum_for$20.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            if ($post_args.length > 0) {
                method = $post_args[0];
                $post_args.splice(0, 1);
            }
            if (method == null) {
                method = "each";
            }
            args22 = $post_args;
            return $send($$($nesting, 'Enumerator'), 'for', [
                self,
                method
            ].concat(Opal.to_a(args22)), block.$to_proc());
        }, $Kernel_enum_for$20.$$arity = -1);
        Opal.alias(self13, "to_enum", "enum_for");
        Opal.def(self13, '$equal?', $Kernel_equal$ques$21 = function(other) {
            var self = this;
            return self === other;
        }, $Kernel_equal$ques$21.$$arity = 1);
        Opal.def(self13, '$exit', $Kernel_exit$22 = function $$exit(status) {
            var $ret_or_3 = nil, block = nil;
            if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;
            if (status == null) {
                status = true;
            }
            $gvars.__at_exit__ = function() {
                if ($truthy($ret_or_3 = $gvars.__at_exit__)) {
                    return $ret_or_3;
                } else {
                    return [];
                }
                return nil;
            }();
            while(!$truthy($gvars.__at_exit__['$empty?']())){
                block = $gvars.__at_exit__.$pop();
                block.$call();
            }
            if (status.$$is_boolean) {
                status = status ? 0 : 1;
            } else {
                status = $coerce_to(status, $$($nesting, 'Integer'), 'to_int');
            }
            Opal.exit(status);
            return nil;
        }, $Kernel_exit$22.$$arity = -1);
        Opal.def(self13, '$extend', $Kernel_extend$23 = function $$extend($a) {
            var $post_args, mods, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            mods = $post_args;
            var singleton = self.$singleton_class();
            for(var i168 = mods.length - 1; i168 >= 0; i168--){
                var mod64 = mods[i168];
                if (!mod64.$$is_module) {
                    self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + mod64.$class() + " (expected Module)");
                }
                mod64.$append_features(singleton);
                mod64.$extend_object(self);
                mod64.$extended(self);
            }
            return self;
        }, $Kernel_extend$23.$$arity = -1);
        Opal.def(self13, '$hash', $Kernel_hash$24 = function $$hash() {
            var self = this;
            return self.$__id__();
        }, $Kernel_hash$24.$$arity = 0);
        Opal.def(self13, '$initialize_copy', $Kernel_initialize_copy$25 = function $$initialize_copy(other) {
            return nil;
        }, $Kernel_initialize_copy$25.$$arity = 1);
        Opal.def(self13, '$inspect', $Kernel_inspect$26 = function $$inspect() {
            var self = this;
            return self.$to_s();
        }, $Kernel_inspect$26.$$arity = 0);
        Opal.def(self13, '$instance_of?', $Kernel_instance_of$ques$27 = function(klass) {
            var self = this;
            if (!klass.$$is_class && !klass.$$is_module) {
                self.$raise($$($nesting, 'TypeError'), "class or module required");
            }
            return self.$$class === klass;
        }, $Kernel_instance_of$ques$27.$$arity = 1);
        Opal.def(self13, '$instance_variable_defined?', $Kernel_instance_variable_defined$ques$28 = function(name103) {
            var self = this;
            name103 = $$($nesting, 'Opal')['$instance_variable_name!'](name103);
            return Opal.hasOwnProperty.call(self, name103.substr(1));
        }, $Kernel_instance_variable_defined$ques$28.$$arity = 1);
        Opal.def(self13, '$instance_variable_get', $Kernel_instance_variable_get$29 = function $$instance_variable_get(name104) {
            var self = this;
            name104 = $$($nesting, 'Opal')['$instance_variable_name!'](name104);
            var ivar = self[Opal.ivar(name104.substr(1))];
            return ivar == null ? nil : ivar;
        }, $Kernel_instance_variable_get$29.$$arity = 1);
        Opal.def(self13, '$instance_variable_set', $Kernel_instance_variable_set$30 = function $$instance_variable_set(name105, value) {
            var self = this;
            name105 = $$($nesting, 'Opal')['$instance_variable_name!'](name105);
            return self[Opal.ivar(name105.substr(1))] = value;
        }, $Kernel_instance_variable_set$30.$$arity = 2);
        Opal.def(self13, '$remove_instance_variable', $Kernel_remove_instance_variable$31 = function $$remove_instance_variable(name106) {
            var self = this;
            name106 = $$($nesting, 'Opal')['$instance_variable_name!'](name106);
            var key = Opal.ivar(name106.substr(1)), val;
            if (self.hasOwnProperty(key)) {
                val = self[key];
                delete self[key];
                return val;
            }
            return self.$raise($$($nesting, 'NameError'), "" + "instance variable " + name106 + " not defined");
        }, $Kernel_remove_instance_variable$31.$$arity = 1);
        Opal.def(self13, '$instance_variables', $Kernel_instance_variables$32 = function $$instance_variables() {
            var self = this;
            var result = [], ivar;
            for(var name107 in self){
                if (self.hasOwnProperty(name107) && name107.charAt(0) !== '$') {
                    if (name107.substr(-1) === '$') {
                        ivar = name107.slice(0, name107.length - 1);
                    } else {
                        ivar = name107;
                    }
                    result.push('@' + ivar);
                }
            }
            return result;
        }, $Kernel_instance_variables$32.$$arity = 0);
        Opal.def(self13, '$Integer', $Kernel_Integer$33 = function $$Integer(value, base10) {
            var self = this;
            var i169, str, base_digits;
            if (!value.$$is_string) {
                if (base10 !== undefined) {
                    self.$raise($$($nesting, 'ArgumentError'), "base specified for non string value");
                }
                if (value === nil) {
                    self.$raise($$($nesting, 'TypeError'), "can't convert nil into Integer");
                }
                if (value.$$is_number) {
                    if (value === Infinity || value === -Infinity || isNaN(value)) {
                        self.$raise($$($nesting, 'FloatDomainError'), value);
                    }
                    return Math.floor(value);
                }
                if (value['$respond_to?']("to_int")) {
                    i169 = value.$to_int();
                    if (i169 !== nil) {
                        return i169;
                    }
                }
                return $$($nesting, 'Opal')['$coerce_to!'](value, $$($nesting, 'Integer'), "to_i");
            }
            if (value === "0") {
                return 0;
            }
            if (base10 === undefined) {
                base10 = 0;
            } else {
                base10 = $coerce_to(base10, $$($nesting, 'Integer'), 'to_int');
                if (base10 === 1 || base10 < 0 || base10 > 36) {
                    self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + base10);
                }
            }
            str = value.toLowerCase();
            str = str.replace(/(\d)_(?=\d)/g, '$1');
            str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function(_, head, flag) {
                switch(flag){
                    case '0b':
                        if (base10 === 0 || base10 === 2) {
                            base10 = 2;
                            return head;
                        }
                    case '0':
                    case '0o':
                        if (base10 === 0 || base10 === 8) {
                            base10 = 8;
                            return head;
                        }
                    case '0d':
                        if (base10 === 0 || base10 === 10) {
                            base10 = 10;
                            return head;
                        }
                    case '0x':
                        if (base10 === 0 || base10 === 16) {
                            base10 = 16;
                            return head;
                        }
                }
                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + value + "\"");
            });
            base10 = base10 === 0 ? 10 : base10;
            base_digits = '0-' + (base10 <= 10 ? base10 - 1 : '9a-' + String.fromCharCode(97 + (base10 - 11)));
            if (!new RegExp('^\\s*[+-]?[' + base_digits + ']+\\s*$').test(str)) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + value + "\"");
            }
            i169 = parseInt(str, base10);
            if (isNaN(i169)) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + value + "\"");
            }
            return i169;
        }, $Kernel_Integer$33.$$arity = -2);
        Opal.def(self13, '$Float', $Kernel_Float$34 = function $$Float(value) {
            var self = this;
            var str;
            if (value === nil) {
                self.$raise($$($nesting, 'TypeError'), "can't convert nil into Float");
            }
            if (value.$$is_string) {
                str = value.toString();
                str = str.replace(/(\d)_(?=\d)/g, '$1');
                if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
                    return self.$Integer(str);
                }
                if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
                    self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Float(): \"" + value + "\"");
                }
                return parseFloat(str);
            }
            return $$($nesting, 'Opal')['$coerce_to!'](value, $$($nesting, 'Float'), "to_f");
        }, $Kernel_Float$34.$$arity = 1);
        Opal.def(self13, '$Hash', $Kernel_Hash$35 = function $$Hash(arg) {
            var $ret_or_4 = nil;
            if ($truthy(function() {
                if ($truthy($ret_or_4 = arg['$nil?']())) {
                    return $ret_or_4;
                } else {
                    return arg['$==']([]);
                }
                return nil;
            }())) {
                return $hash2([], {});
            }
            if ($truthy($$($nesting, 'Hash')['$==='](arg))) {
                return arg;
            }
            return $$($nesting, 'Opal')['$coerce_to!'](arg, $$($nesting, 'Hash'), "to_hash");
        }, $Kernel_Hash$35.$$arity = 1);
        Opal.def(self13, '$is_a?', $Kernel_is_a$ques$36 = function(klass) {
            var self = this;
            if (!klass.$$is_class && !klass.$$is_module) {
                self.$raise($$($nesting, 'TypeError'), "class or module required");
            }
            return Opal.is_a(self, klass);
        }, $Kernel_is_a$ques$36.$$arity = 1);
        Opal.def(self13, '$itself', $Kernel_itself$37 = function $$itself() {
            var self = this;
            return self;
        }, $Kernel_itself$37.$$arity = 0);
        Opal.alias(self13, "kind_of?", "is_a?");
        Opal.def(self13, '$lambda', $Kernel_lambda$38 = function $$lambda() {
            var $iter = $Kernel_lambda$38.$$p, block = $iter || nil;
            if ($iter) $Kernel_lambda$38.$$p = null;
            if ($iter) $Kernel_lambda$38.$$p = null;
            return Opal.lambda(block);
        }, $Kernel_lambda$38.$$arity = 0);
        Opal.def(self13, '$load', $Kernel_load$39 = function $$load(file) {
            file = $$($nesting, 'Opal')['$coerce_to!'](file, $$($nesting, 'String'), "to_str");
            return Opal.load(file);
        }, $Kernel_load$39.$$arity = 1);
        Opal.def(self13, '$loop', $Kernel_loop$40 = function $$loop() {
            var $$41, $iter = $Kernel_loop$40.$$p, $yield = $iter || nil, self = this, e = nil;
            if ($iter) $Kernel_loop$40.$$p = null;
            if ($yield !== nil) {} else {
                return $send(self, 'enum_for', [
                    "loop"
                ], ($$41 = function() {
                    $$41.$$s == null ? this : $$41.$$s;
                    return $$$($$($nesting, 'Float'), 'INFINITY');
                }, $$41.$$s = self, $$41.$$arity = 0, $$41));
            }
            while($truthy(true)){
                try {
                    Opal.yieldX($yield, []);
                } catch ($err) {
                    if (Opal.rescue($err, [
                        $$($nesting, 'StopIteration')
                    ])) {
                        e = $err;
                        try {
                            return e.$result();
                        } finally{
                            Opal.pop_exception();
                        }
                    } else {
                        throw $err;
                    }
                }
            }
            return self;
        }, $Kernel_loop$40.$$arity = 0);
        Opal.def(self13, '$nil?', $Kernel_nil$ques$42 = function() {
            return false;
        }, $Kernel_nil$ques$42.$$arity = 0);
        Opal.alias(self13, "object_id", "__id__");
        Opal.def(self13, '$printf', $Kernel_printf$43 = function $$printf($a) {
            var $post_args, args23, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args23 = $post_args;
            if ($truthy(args23['$any?']())) {
                self.$print($send(self, 'format', Opal.to_a(args23)));
            }
            return nil;
        }, $Kernel_printf$43.$$arity = -1);
        Opal.def(self13, '$proc', $Kernel_proc$44 = function $$proc() {
            var $iter = $Kernel_proc$44.$$p, block = $iter || nil, self = this;
            if ($iter) $Kernel_proc$44.$$p = null;
            if ($iter) $Kernel_proc$44.$$p = null;
            if ($truthy(block)) {} else {
                self.$raise($$($nesting, 'ArgumentError'), "tried to create Proc object without a block");
            }
            block.$$is_lambda = false;
            return block;
        }, $Kernel_proc$44.$$arity = 0);
        Opal.def(self13, '$puts', $Kernel_puts$45 = function $$puts($a) {
            var $post_args, strs;
            if ($gvars.stdout == null) $gvars.stdout = nil;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            strs = $post_args;
            return $send($gvars.stdout, 'puts', Opal.to_a(strs));
        }, $Kernel_puts$45.$$arity = -1);
        Opal.def(self13, '$p', $Kernel_p$46 = function $$p($a) {
            var $post_args, args24, $$47, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args24 = $post_args;
            $send(args24, 'each', [], ($$47 = function(obj) {
                $$47.$$s == null ? this : $$47.$$s;
                if ($gvars.stdout == null) $gvars.stdout = nil;
                if (obj == null) {
                    obj = nil;
                }
                return $gvars.stdout.$puts(obj.$inspect());
            }, $$47.$$s = self, $$47.$$arity = 1, $$47));
            if ($truthy($rb_le(args24.$length(), 1))) {
                return args24['$[]'](0);
            } else {
                return args24;
            }
        }, $Kernel_p$46.$$arity = -1);
        Opal.def(self13, '$print', $Kernel_print$48 = function $$print($a) {
            var $post_args, strs;
            if ($gvars.stdout == null) $gvars.stdout = nil;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            strs = $post_args;
            return $send($gvars.stdout, 'print', Opal.to_a(strs));
        }, $Kernel_print$48.$$arity = -1);
        Opal.def(self13, '$warn', $Kernel_warn$49 = function $$warn($a, $b) {
            var $post_args, $kwargs, strs, uplevel, $$50, self = this, location = nil, $ret_or_5 = nil;
            if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;
            if ($gvars.stderr == null) $gvars.stderr = nil;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            $kwargs = Opal.extract_kwargs($post_args);
            if ($kwargs == null) {
                $kwargs = $hash2([], {});
            } else if (!$kwargs.$$is_hash) {
                throw Opal.ArgumentError.$new('expected kwargs');
            }
            strs = $post_args;
            uplevel = $kwargs.$$smap["uplevel"];
            if (uplevel == null) {
                uplevel = nil;
            }
            if ($truthy(uplevel)) {
                uplevel = $$($nesting, 'Opal')['$coerce_to!'](uplevel, $$($nesting, 'Integer'), "to_str");
                if ($truthy($rb_lt(uplevel, 0))) {
                    self.$raise($$($nesting, 'ArgumentError'), "" + "negative level (" + uplevel + ")");
                }
                location = self.$caller($rb_plus(uplevel, 2), 1).$first();
                if ($truthy(location)) {
                    location = "" + location + ": ";
                }
                strs = $send(strs, 'map', [], ($$50 = function(s) {
                    $$50.$$s == null ? this : $$50.$$s;
                    if (s == null) {
                        s = nil;
                    }
                    return "" + location + "warning: " + s;
                }, $$50.$$s = self, $$50.$$arity = 1, $$50));
            }
            if ($truthy(function() {
                if ($truthy($ret_or_5 = $gvars.VERBOSE['$nil?']())) {
                    return $ret_or_5;
                } else {
                    return strs['$empty?']();
                }
                return nil;
            }())) {
                return nil;
            } else {
                return $send($gvars.stderr, 'puts', Opal.to_a(strs));
            }
        }, $Kernel_warn$49.$$arity = -1);
        Opal.def(self13, '$raise', $Kernel_raise$51 = function $$raise(exception, string, _backtrace) {
            if ($gvars["!"] == null) $gvars["!"] = nil;
            if (string == null) {
                string = nil;
            }
            if (_backtrace == null) {
                _backtrace = nil;
            }
            if (exception == null && $gvars["!"] !== nil) {
                throw $gvars["!"];
            }
            if (exception == null) {
                exception = $$($nesting, 'RuntimeError').$new();
            } else if (exception.$$is_string) {
                exception = $$($nesting, 'RuntimeError').$new(exception);
            } else if (exception.$$is_class && exception['$respond_to?']("exception")) {
                exception = exception.$exception(string);
            } else if (exception['$is_a?']($$($nesting, 'Exception'))) {} else {
                exception = $$($nesting, 'TypeError').$new("exception class/object expected");
            }
            if ($gvars["!"] !== nil) {
                Opal.exceptions.push($gvars["!"]);
            }
            $gvars["!"] = exception;
            throw exception;
        }, $Kernel_raise$51.$$arity = -1);
        Opal.alias(self13, "fail", "raise");
        Opal.def(self13, '$rand', $Kernel_rand$52 = function $$rand(max) {
            if (max === undefined) {
                return $$$($$($nesting, 'Random'), 'DEFAULT').$rand();
            }
            if (max.$$is_number) {
                if (max < 0) {
                    max = Math.abs(max);
                }
                if (max % 1 !== 0) {
                    max = max.$to_i();
                }
                if (max === 0) {
                    max = undefined;
                }
            }
            return $$$($$($nesting, 'Random'), 'DEFAULT').$rand(max);
        }, $Kernel_rand$52.$$arity = -1);
        Opal.def(self13, '$respond_to?', $Kernel_respond_to$ques$53 = function(name108, include_all) {
            var self = this;
            if (include_all == null) {
                include_all = false;
            }
            var body = self['$' + name108];
            if (typeof body === "function" && !body.$$stub) {
                return true;
            }
            if (self['$respond_to_missing?'].$$pristine === true) {
                return false;
            } else {
                return self['$respond_to_missing?'](name108, include_all);
            }
        }, $Kernel_respond_to$ques$53.$$arity = -2);
        Opal.def(self13, '$respond_to_missing?', $Kernel_respond_to_missing$ques$54 = function(method_name, include_all) {
            if (include_all == null) {
                include_all = false;
            }
            return false;
        }, $Kernel_respond_to_missing$ques$54.$$arity = -2);
        $$($nesting, 'Opal').$pristine(self13, "respond_to?", "respond_to_missing?");
        Opal.def(self13, '$require', $Kernel_require$55 = function $$require(file) {
            file = $$($nesting, 'Opal')['$coerce_to!'](file, $$($nesting, 'String'), "to_str");
            return Opal.require(file);
        }, $Kernel_require$55.$$arity = 1);
        Opal.def(self13, '$require_relative', $Kernel_require_relative$56 = function $$require_relative(file) {
            $$($nesting, 'Opal')['$try_convert!'](file, $$($nesting, 'String'), "to_str");
            file = $$($nesting, 'File').$expand_path($$($nesting, 'File').$join(Opal.current_file, "..", file));
            return Opal.require(file);
        }, $Kernel_require_relative$56.$$arity = 1);
        Opal.def(self13, '$require_tree', $Kernel_require_tree$57 = function $$require_tree(path6) {
            var result = [];
            path6 = $$($nesting, 'File').$expand_path(path6);
            path6 = Opal.normalize(path6);
            if (path6 === '.') path6 = '';
            for(var name109 in Opal.modules){
                if (name109['$start_with?'](path6)) {
                    result.push([
                        name109,
                        Opal.require(name109)
                    ]);
                }
            }
            return result;
        }, $Kernel_require_tree$57.$$arity = 1);
        Opal.alias(self13, "send", "__send__");
        Opal.alias(self13, "public_send", "__send__");
        Opal.def(self13, '$singleton_class', $Kernel_singleton_class$58 = function $$singleton_class() {
            var self = this;
            return Opal.get_singleton_class(self);
        }, $Kernel_singleton_class$58.$$arity = 0);
        Opal.def(self13, '$sleep', $Kernel_sleep$59 = function $$sleep(seconds) {
            var self = this;
            if (seconds == null) {
                seconds = nil;
            }
            if (seconds === nil) {
                self.$raise($$($nesting, 'TypeError'), "can't convert NilClass into time interval");
            }
            if (!seconds.$$is_number) {
                self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + seconds.$class() + " into time interval");
            }
            if (seconds < 0) {
                self.$raise($$($nesting, 'ArgumentError'), "time interval must be positive");
            }
            var get_time = Opal.global.performance ? function() {
                return performance.now();
            } : function() {
                return new Date();
            };
            var t = get_time();
            while(get_time() - t <= seconds * 1000);
            return Math.round(seconds);
        }, $Kernel_sleep$59.$$arity = -1);
        Opal.def(self13, '$srand', $Kernel_srand$60 = function $$srand(seed) {
            if (seed == null) {
                seed = $$($nesting, 'Random').$new_seed();
            }
            return $$($nesting, 'Random').$srand(seed);
        }, $Kernel_srand$60.$$arity = -1);
        Opal.def(self13, '$String', $Kernel_String$61 = function $$String(str) {
            var $ret_or_6 = nil;
            if ($truthy($ret_or_6 = $$($nesting, 'Opal')['$coerce_to?'](str, $$($nesting, 'String'), "to_str"))) {
                return $ret_or_6;
            } else {
                return $$($nesting, 'Opal')['$coerce_to!'](str, $$($nesting, 'String'), "to_s");
            }
        }, $Kernel_String$61.$$arity = 1);
        Opal.def(self13, '$tap', $Kernel_tap$62 = function $$tap() {
            var $iter = $Kernel_tap$62.$$p, block = $iter || nil, self = this;
            if ($iter) $Kernel_tap$62.$$p = null;
            if ($iter) $Kernel_tap$62.$$p = null;
            Opal.yield1(block, self);
            return self;
        }, $Kernel_tap$62.$$arity = 0);
        Opal.def(self13, '$to_proc', $Kernel_to_proc$63 = function $$to_proc() {
            var self = this;
            return self;
        }, $Kernel_to_proc$63.$$arity = 0);
        Opal.def(self13, '$to_s', $Kernel_to_s$64 = function $$to_s() {
            var self = this;
            return "" + "#<" + self.$class() + ":0x" + self.$__id__().$to_s(16) + ">";
        }, $Kernel_to_s$64.$$arity = 0);
        Opal.def(self13, '$catch', $Kernel_catch$65 = function(sym) {
            var $iter = $Kernel_catch$65.$$p, $yield = $iter || nil, self = this, e = nil;
            if ($iter) $Kernel_catch$65.$$p = null;
            try {
                return Opal.yieldX($yield, []);
            } catch ($err) {
                if (Opal.rescue($err, [
                    $$($nesting, 'UncaughtThrowError')
                ])) {
                    e = $err;
                    try {
                        if (e.$sym()['$=='](sym)) {
                            return e.$arg();
                        }
                        return self.$raise();
                    } finally{
                        Opal.pop_exception();
                    }
                } else {
                    throw $err;
                }
            }
        }, $Kernel_catch$65.$$arity = 1);
        Opal.def(self13, '$throw', $Kernel_throw$66 = function($a) {
            var $post_args, args25, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args25 = $post_args;
            return self.$raise($$($nesting, 'UncaughtThrowError'), args25);
        }, $Kernel_throw$66.$$arity = -1);
        Opal.def(self13, '$open', $Kernel_open$67 = function $$open($a) {
            var $iter = $Kernel_open$67.$$p, block = $iter || nil, $post_args, args26;
            if ($iter) $Kernel_open$67.$$p = null;
            if ($iter) $Kernel_open$67.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args26 = $post_args;
            return $send($$($nesting, 'File'), 'open', Opal.to_a(args26), block.$to_proc());
        }, $Kernel_open$67.$$arity = -1);
        Opal.def(self13, '$yield_self', $Kernel_yield_self$68 = function $$yield_self() {
            var $$69, $iter = $Kernel_yield_self$68.$$p, $yield = $iter || nil, self = this;
            if ($iter) $Kernel_yield_self$68.$$p = null;
            if ($yield !== nil) {} else {
                return $send(self, 'enum_for', [
                    "yield_self"
                ], ($$69 = function() {
                    $$69.$$s == null ? this : $$69.$$s;
                    return 1;
                }, $$69.$$s = self, $$69.$$arity = 0, $$69));
            }
            return Opal.yield1($yield, self);
        }, $Kernel_yield_self$68.$$arity = 0);
        Opal.alias(self13, "then", "yield_self");
        return $$($nesting, 'Opal').$pristine(self13, "method_missing");
    })($nesting4[0], $nesting4);
    return function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Object');
        var $nesting = [
            self
        ].concat($parent_nesting);
        return self.$include($$($nesting, 'Kernel'));
    }($nesting4[0], null, $nesting4);
};
Opal.modules["corelib/error"] = function(Opal) {
    function $rb_plus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
    }
    function $rb_gt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs > rhs : lhs['$>'](rhs);
    }
    var self14 = Opal.top, $nesting5 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $module = Opal.module, $send2 = Opal.send2, $hash2 = Opal.hash2;
    Opal.add_stubs([
        '$new',
        '$clone',
        '$to_s',
        '$empty?',
        '$class',
        '$raise',
        '$+',
        '$attr_reader',
        '$[]',
        '$>',
        '$length',
        '$inspect'
    ]);
    (function($base, $super, $parent_nesting) {
        var self15 = $klass($base, $super, 'Exception');
        var $nesting = [
            self15
        ].concat($parent_nesting), $Exception_new$1, $Exception_exception$2, $Exception_initialize$3, $Exception_backtrace$4, $Exception_exception$5, $Exception_message$6, $Exception_inspect$7, $Exception_set_backtrace$8, $Exception_to_s$9;
        self15.$$prototype.message = nil;
        var stack_trace_limit;
        Opal.defs(self15, '$new', $Exception_new$1 = function($a) {
            var $post_args, args27, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args27 = $post_args;
            var message = args27.length > 0 ? args27[0] : nil;
            var error22 = new self.$$constructor(message);
            error22.name = self.$$name;
            error22.message = message;
            Opal.send(error22, error22.$initialize, args27);
            if (Opal.config.enable_stack_trace && Error.captureStackTrace) {
                Error.captureStackTrace(error22, stack_trace_limit);
            }
            return error22;
        }, $Exception_new$1.$$arity = -1);
        stack_trace_limit = self15.$new;
        Opal.defs(self15, '$exception', $Exception_exception$2 = function $$exception($a) {
            var $post_args, args28, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args28 = $post_args;
            return $send(self, 'new', Opal.to_a(args28));
        }, $Exception_exception$2.$$arity = -1);
        Opal.def(self15, '$initialize', $Exception_initialize$3 = function $$initialize($a) {
            var $post_args, args29, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args29 = $post_args;
            return self.message = args29.length > 0 ? args29[0] : nil;
        }, $Exception_initialize$3.$$arity = -1);
        Opal.def(self15, '$backtrace', $Exception_backtrace$4 = function $$backtrace() {
            var self = this;
            if (self.backtrace) {
                return self.backtrace;
            }
            var backtrace = self.stack;
            if (typeof backtrace === 'string') {
                return backtrace.split("\n").slice(0, 15);
            } else if (backtrace) {
                return backtrace.slice(0, 15);
            }
            return [];
        }, $Exception_backtrace$4.$$arity = 0);
        Opal.def(self15, '$exception', $Exception_exception$5 = function $$exception(str) {
            var self = this;
            if (str == null) {
                str = nil;
            }
            if (str === nil || self === str) {
                return self;
            }
            var cloned = self.$clone();
            cloned.message = str;
            cloned.stack = self.stack;
            return cloned;
        }, $Exception_exception$5.$$arity = -1);
        Opal.def(self15, '$message', $Exception_message$6 = function $$message() {
            var self = this;
            return self.$to_s();
        }, $Exception_message$6.$$arity = 0);
        Opal.def(self15, '$inspect', $Exception_inspect$7 = function $$inspect() {
            var self = this, as_str = nil;
            as_str = self.$to_s();
            if ($truthy(as_str['$empty?']())) {
                return self.$class().$to_s();
            } else {
                return "" + "#<" + self.$class().$to_s() + ": " + self.$to_s() + ">";
            }
        }, $Exception_inspect$7.$$arity = 0);
        Opal.def(self15, '$set_backtrace', $Exception_set_backtrace$8 = function $$set_backtrace(backtrace) {
            var self = this;
            var valid = true, i170, ii;
            if (backtrace === nil) {
                self.backtrace = nil;
                self.stack = '';
            } else if (backtrace.$$is_string) {
                self.backtrace = [
                    backtrace
                ];
                self.stack = backtrace;
            } else {
                if (backtrace.$$is_array) {
                    for(i170 = 0, ii = backtrace.length; i170 < ii; i170++){
                        if (!backtrace[i170].$$is_string) {
                            valid = false;
                            break;
                        }
                    }
                } else {
                    valid = false;
                }
                if (valid === false) {
                    self.$raise($$($nesting, 'TypeError'), "backtrace must be Array of String");
                }
                self.backtrace = backtrace;
                self.stack = backtrace.join('\n');
            }
            return backtrace;
        }, $Exception_set_backtrace$8.$$arity = 1);
        return (Opal.def(self15, '$to_s', $Exception_to_s$9 = function $$to_s() {
            var self = this, $ret_or_1 = nil, $ret_or_2 = nil;
            if ($truthy($ret_or_1 = function() {
                if ($truthy($ret_or_2 = self.message)) {
                    return self.message.$to_s();
                } else {
                    return $ret_or_2;
                }
                return nil;
            }())) {
                return $ret_or_1;
            } else {
                return self.$class().$to_s();
            }
        }, $Exception_to_s$9.$$arity = 0), nil) && 'to_s';
    })($nesting5[0], Error, $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'ScriptError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'Exception'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'SyntaxError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'ScriptError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'LoadError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'ScriptError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'NotImplementedError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'ScriptError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'SystemExit');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'Exception'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'NoMemoryError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'Exception'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'SignalException');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'Exception'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Interrupt');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'Exception'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'SecurityError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'Exception'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'StandardError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'Exception'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'EncodingError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'StandardError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'ZeroDivisionError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'StandardError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'NameError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'StandardError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'NoMethodError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'NameError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'RuntimeError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'StandardError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'FrozenError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'RuntimeError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'LocalJumpError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'StandardError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'TypeError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'StandardError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'ArgumentError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'StandardError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'IndexError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'StandardError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'StopIteration');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'IndexError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'KeyError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'IndexError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'RangeError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'StandardError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'FloatDomainError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'RangeError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'IOError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'StandardError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'SystemCallError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting5[0], $$($nesting5, 'StandardError'), $nesting5);
    (function($base1, $parent_nesting1) {
        var self16 = $module($base1, 'Errno');
        var $nesting = [
            self16
        ].concat($parent_nesting1);
        return function($base, $super, $parent_nesting) {
            var self17 = $klass($base, $super, 'EINVAL');
            var $nesting = [
                self17
            ].concat($parent_nesting), $EINVAL_new$10;
            return (Opal.defs(self17, '$new', $EINVAL_new$10 = function(name110) {
                var $iter = $EINVAL_new$10.$$p, self = this, message = nil;
                if ($iter) $EINVAL_new$10.$$p = null;
                if (name110 == null) {
                    name110 = nil;
                }
                message = "Invalid argument";
                if ($truthy(name110)) {
                    message = $rb_plus(message, "" + " - " + name110);
                }
                return $send2(self, Opal.find_super_dispatcher(self, 'new', $EINVAL_new$10, false, true), 'new', [
                    message
                ], null);
            }, $EINVAL_new$10.$$arity = -1), nil) && 'new';
        }($nesting[0], $$($nesting, 'SystemCallError'), $nesting);
    })($nesting5[0], $nesting5);
    (function($base, $super, $parent_nesting) {
        var self18 = $klass($base, $super, 'UncaughtThrowError');
        var $nesting = [
            self18
        ].concat($parent_nesting), $UncaughtThrowError_initialize$11;
        self18.$$prototype.sym = nil;
        self18.$attr_reader("sym", "arg");
        return (Opal.def(self18, '$initialize', $UncaughtThrowError_initialize$11 = function $$initialize(args30) {
            var $iter = $UncaughtThrowError_initialize$11.$$p, self = this;
            if ($iter) $UncaughtThrowError_initialize$11.$$p = null;
            self.sym = args30['$[]'](0);
            if ($truthy($rb_gt(args30.$length(), 1))) {
                self.arg = args30['$[]'](1);
            }
            return $send2(self, Opal.find_super_dispatcher(self, 'initialize', $UncaughtThrowError_initialize$11, false, true), 'initialize', [
                "" + "uncaught throw " + self.sym.$inspect()
            ], null);
        }, $UncaughtThrowError_initialize$11.$$arity = 1), nil) && 'initialize';
    })($nesting5[0], $$($nesting5, 'ArgumentError'), $nesting5);
    (function($base, $super, $parent_nesting) {
        var self19 = $klass($base, $super, 'NameError');
        var $nesting = [
            self19
        ].concat($parent_nesting), $NameError_initialize$12;
        self19.$attr_reader("name");
        return (Opal.def(self19, '$initialize', $NameError_initialize$12 = function $$initialize(message, name111) {
            var $iter = $NameError_initialize$12.$$p, self = this;
            if ($iter) $NameError_initialize$12.$$p = null;
            if (name111 == null) {
                name111 = nil;
            }
            $send2(self, Opal.find_super_dispatcher(self, 'initialize', $NameError_initialize$12, false, true), 'initialize', [
                message
            ], null);
            return self.name = name111;
        }, $NameError_initialize$12.$$arity = -2), nil) && 'initialize';
    })($nesting5[0], null, $nesting5);
    (function($base, $super, $parent_nesting) {
        var self20 = $klass($base, $super, 'NoMethodError');
        var $nesting = [
            self20
        ].concat($parent_nesting), $NoMethodError_initialize$13;
        self20.$attr_reader("args");
        return (Opal.def(self20, '$initialize', $NoMethodError_initialize$13 = function $$initialize(message, name112, args31) {
            var $iter = $NoMethodError_initialize$13.$$p, self = this;
            if ($iter) $NoMethodError_initialize$13.$$p = null;
            if (name112 == null) {
                name112 = nil;
            }
            if (args31 == null) {
                args31 = [];
            }
            $send2(self, Opal.find_super_dispatcher(self, 'initialize', $NoMethodError_initialize$13, false, true), 'initialize', [
                message,
                name112
            ], null);
            return self.args = args31;
        }, $NoMethodError_initialize$13.$$arity = -2), nil) && 'initialize';
    })($nesting5[0], null, $nesting5);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'StopIteration');
        [
            self
        ].concat($parent_nesting);
        return self.$attr_reader("result");
    })($nesting5[0], null, $nesting5);
    (function($base, $super, $parent_nesting) {
        var self21 = $klass($base, $super, 'KeyError');
        var $nesting = [
            self21
        ].concat($parent_nesting), $KeyError_initialize$14, $KeyError_receiver$15, $KeyError_key$16;
        self21.$$prototype.receiver = self21.$$prototype.key = nil;
        Opal.def(self21, '$initialize', $KeyError_initialize$14 = function $$initialize(message, $kwargs) {
            var receiver, key, $iter = $KeyError_initialize$14.$$p, self = this;
            if ($iter) $KeyError_initialize$14.$$p = null;
            if ($kwargs == null) {
                $kwargs = $hash2([], {});
            } else if (!$kwargs.$$is_hash) {
                throw Opal.ArgumentError.$new('expected kwargs');
            }
            receiver = $kwargs.$$smap["receiver"];
            if (receiver == null) {
                receiver = nil;
            }
            key = $kwargs.$$smap["key"];
            if (key == null) {
                key = nil;
            }
            $send2(self, Opal.find_super_dispatcher(self, 'initialize', $KeyError_initialize$14, false, true), 'initialize', [
                message
            ], null);
            self.receiver = receiver;
            return self.key = key;
        }, $KeyError_initialize$14.$$arity = -2);
        Opal.def(self21, '$receiver', $KeyError_receiver$15 = function $$receiver() {
            var self = this, $ret_or_3 = nil;
            if ($truthy($ret_or_3 = self.receiver)) {
                return $ret_or_3;
            } else {
                return self.$raise($$($nesting, 'ArgumentError'), "no receiver is available");
            }
        }, $KeyError_receiver$15.$$arity = 0);
        return (Opal.def(self21, '$key', $KeyError_key$16 = function $$key() {
            var self = this, $ret_or_4 = nil;
            if ($truthy($ret_or_4 = self.key)) {
                return $ret_or_4;
            } else {
                return self.$raise($$($nesting, 'ArgumentError'), "no key is available");
            }
        }, $KeyError_key$16.$$arity = 0), nil) && 'key';
    })($nesting5[0], null, $nesting5);
    return function($base2, $parent_nesting2) {
        var self22 = $module($base2, 'JS');
        var $nesting = [
            self22
        ].concat($parent_nesting2);
        return function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Error');
            [
                self
            ].concat($parent_nesting);
            return nil;
        }($nesting[0], null, $nesting);
    }($nesting5[0], $nesting5);
};
Opal.modules["corelib/constants"] = function(Opal) {
    var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;
    Opal.const_set($nesting[0], 'RUBY_PLATFORM', "opal");
    Opal.const_set($nesting[0], 'RUBY_ENGINE', "opal");
    Opal.const_set($nesting[0], 'RUBY_VERSION', "3.0.2");
    Opal.const_set($nesting[0], 'RUBY_ENGINE_VERSION', "1.2.0");
    Opal.const_set($nesting[0], 'RUBY_RELEASE_DATE', "2021-07-28");
    Opal.const_set($nesting[0], 'RUBY_PATCHLEVEL', 0);
    Opal.const_set($nesting[0], 'RUBY_REVISION', "0");
    Opal.const_set($nesting[0], 'RUBY_COPYRIGHT', "opal - Copyright (C) 2013-2021 Adam Beynon and the Opal contributors");
    return Opal.const_set($nesting[0], 'RUBY_DESCRIPTION', "" + "opal " + $$($nesting, 'RUBY_ENGINE_VERSION') + " (" + $$($nesting, 'RUBY_RELEASE_DATE') + " revision " + $$($nesting, 'RUBY_REVISION') + ")");
};
Opal.modules["opal/base"] = function(Opal) {
    var self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;
    Opal.add_stubs([
        '$require'
    ]);
    self.$require("corelib/runtime");
    self.$require("corelib/helpers");
    self.$require("corelib/module");
    self.$require("corelib/class");
    self.$require("corelib/basic_object");
    self.$require("corelib/kernel");
    self.$require("corelib/error");
    return self.$require("corelib/constants");
};
Opal.modules["corelib/nil"] = function(Opal) {
    function $rb_gt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs > rhs : lhs['$>'](rhs);
    }
    var self23 = Opal.top, $nesting6 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy;
    Opal.add_stubs([
        '$raise',
        '$name',
        '$new',
        '$>',
        '$length',
        '$Rational'
    ]);
    (function($base, $super, $parent_nesting3) {
        var self24 = $klass($base, $super, 'NilClass');
        var $nesting7 = [
            self24
        ].concat($parent_nesting3), $NilClass_$excl$2, $NilClass_$$3, $NilClass_$$4, $NilClass_$$5, $NilClass_$eq_eq$6, $NilClass_dup$7, $NilClass_clone$8, $NilClass_inspect$9, $NilClass_nil$ques$10, $NilClass_singleton_class$11, $NilClass_to_a$12, $NilClass_to_h$13, $NilClass_to_i$14, $NilClass_to_s$15, $NilClass_to_c$16, $NilClass_rationalize$17, $NilClass_to_r$18, $NilClass_instance_variables$19;
        self24.$$prototype.$$meta = self24;
        (function(self25, $parent_nesting) {
            var $nesting = [
                self25
            ].concat($parent_nesting), $allocate$1;
            Opal.def(self25, '$allocate', $allocate$1 = function $$allocate() {
                var self = this;
                return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + self.$name());
            }, $allocate$1.$$arity = 0);
            Opal.udef(self25, '$' + "new");
            return nil;
        })(Opal.get_singleton_class(self24), $nesting7);
        Opal.def(self24, '$!', $NilClass_$excl$2 = function() {
            return true;
        }, $NilClass_$excl$2.$$arity = 0);
        Opal.def(self24, '$&', $NilClass_$$3 = function(other) {
            return false;
        }, $NilClass_$$3.$$arity = 1);
        Opal.def(self24, '$|', $NilClass_$$4 = function(other) {
            return other !== false && other !== nil;
        }, $NilClass_$$4.$$arity = 1);
        Opal.def(self24, '$^', $NilClass_$$5 = function(other) {
            return other !== false && other !== nil;
        }, $NilClass_$$5.$$arity = 1);
        Opal.def(self24, '$==', $NilClass_$eq_eq$6 = function(other) {
            return other === nil;
        }, $NilClass_$eq_eq$6.$$arity = 1);
        Opal.def(self24, '$dup', $NilClass_dup$7 = function $$dup() {
            return nil;
        }, $NilClass_dup$7.$$arity = 0);
        Opal.def(self24, '$clone', $NilClass_clone$8 = function $$clone($kwargs) {
            var freeze;
            if ($kwargs == null) {
                $kwargs = $hash2([], {});
            } else if (!$kwargs.$$is_hash) {
                throw Opal.ArgumentError.$new('expected kwargs');
            }
            freeze = $kwargs.$$smap["freeze"];
            if (freeze == null) {
                freeze = true;
            }
            return nil;
        }, $NilClass_clone$8.$$arity = -1);
        Opal.def(self24, '$inspect', $NilClass_inspect$9 = function $$inspect() {
            return "nil";
        }, $NilClass_inspect$9.$$arity = 0);
        Opal.def(self24, '$nil?', $NilClass_nil$ques$10 = function() {
            return true;
        }, $NilClass_nil$ques$10.$$arity = 0);
        Opal.def(self24, '$singleton_class', $NilClass_singleton_class$11 = function $$singleton_class() {
            return $$($nesting7, 'NilClass');
        }, $NilClass_singleton_class$11.$$arity = 0);
        Opal.def(self24, '$to_a', $NilClass_to_a$12 = function $$to_a() {
            return [];
        }, $NilClass_to_a$12.$$arity = 0);
        Opal.def(self24, '$to_h', $NilClass_to_h$13 = function $$to_h() {
            return Opal.hash();
        }, $NilClass_to_h$13.$$arity = 0);
        Opal.def(self24, '$to_i', $NilClass_to_i$14 = function $$to_i() {
            return 0;
        }, $NilClass_to_i$14.$$arity = 0);
        Opal.alias(self24, "to_f", "to_i");
        Opal.def(self24, '$to_s', $NilClass_to_s$15 = function $$to_s() {
            return "";
        }, $NilClass_to_s$15.$$arity = 0);
        Opal.def(self24, '$to_c', $NilClass_to_c$16 = function $$to_c() {
            return $$($nesting7, 'Complex').$new(0, 0);
        }, $NilClass_to_c$16.$$arity = 0);
        Opal.def(self24, '$rationalize', $NilClass_rationalize$17 = function $$rationalize($a) {
            var $post_args, args32, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args32 = $post_args;
            if ($truthy($rb_gt(args32.$length(), 1))) {
                self.$raise($$($nesting7, 'ArgumentError'));
            }
            return self.$Rational(0, 1);
        }, $NilClass_rationalize$17.$$arity = -1);
        Opal.def(self24, '$to_r', $NilClass_to_r$18 = function $$to_r() {
            var self = this;
            return self.$Rational(0, 1);
        }, $NilClass_to_r$18.$$arity = 0);
        return (Opal.def(self24, '$instance_variables', $NilClass_instance_variables$19 = function $$instance_variables() {
            return [];
        }, $NilClass_instance_variables$19.$$arity = 0), nil) && 'instance_variables';
    })($nesting6[0], null, $nesting6);
    return Opal.const_set($nesting6[0], 'NIL', nil);
};
Opal.modules["corelib/boolean"] = function(Opal) {
    var self26 = Opal.top, $nesting8 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2;
    Opal.add_stubs([
        '$raise',
        '$name'
    ]);
    (function($base, $super, $parent_nesting4) {
        var self27 = $klass($base, $super, 'Boolean');
        var $nesting9 = [
            self27
        ].concat($parent_nesting4), $Boolean___id__$2, $Boolean_$excl$3, $Boolean_$$4, $Boolean_$$5, $Boolean_$$6, $Boolean_$eq_eq$7, $Boolean_singleton_class$8, $Boolean_to_s$9, $Boolean_dup$10, $Boolean_clone$11;
        Opal.defineProperty(self27.$$prototype, '$$is_boolean', true);
        Opal.defineProperty(self27.$$prototype, '$$meta', self27);
        (function(self28, $parent_nesting) {
            var $nesting = [
                self28
            ].concat($parent_nesting), $allocate$1;
            Opal.def(self28, '$allocate', $allocate$1 = function $$allocate() {
                var self = this;
                return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + self.$name());
            }, $allocate$1.$$arity = 0);
            Opal.udef(self28, '$' + "new");
            return nil;
        })(Opal.get_singleton_class(self27), $nesting9);
        Opal.def(self27, '$__id__', $Boolean___id__$2 = function $$__id__() {
            var self = this;
            return self.valueOf() ? 2 : 0;
        }, $Boolean___id__$2.$$arity = 0);
        Opal.alias(self27, "object_id", "__id__");
        Opal.def(self27, '$!', $Boolean_$excl$3 = function() {
            var self = this;
            return self != true;
        }, $Boolean_$excl$3.$$arity = 0);
        Opal.def(self27, '$&', $Boolean_$$4 = function(other) {
            var self = this;
            return self == true ? other !== false && other !== nil : false;
        }, $Boolean_$$4.$$arity = 1);
        Opal.def(self27, '$|', $Boolean_$$5 = function(other) {
            var self = this;
            return self == true ? true : other !== false && other !== nil;
        }, $Boolean_$$5.$$arity = 1);
        Opal.def(self27, '$^', $Boolean_$$6 = function(other) {
            var self = this;
            return self == true ? other === false || other === nil : other !== false && other !== nil;
        }, $Boolean_$$6.$$arity = 1);
        Opal.def(self27, '$==', $Boolean_$eq_eq$7 = function(other) {
            var self = this;
            return self == true === other.valueOf();
        }, $Boolean_$eq_eq$7.$$arity = 1);
        Opal.alias(self27, "equal?", "==");
        Opal.alias(self27, "eql?", "==");
        Opal.def(self27, '$singleton_class', $Boolean_singleton_class$8 = function $$singleton_class() {
            return $$($nesting9, 'Boolean');
        }, $Boolean_singleton_class$8.$$arity = 0);
        Opal.def(self27, '$to_s', $Boolean_to_s$9 = function $$to_s() {
            var self = this;
            return self == true ? 'true' : 'false';
        }, $Boolean_to_s$9.$$arity = 0);
        Opal.def(self27, '$dup', $Boolean_dup$10 = function $$dup() {
            var self = this;
            return self;
        }, $Boolean_dup$10.$$arity = 0);
        return (Opal.def(self27, '$clone', $Boolean_clone$11 = function $$clone($kwargs) {
            var freeze, self = this;
            if ($kwargs == null) {
                $kwargs = $hash2([], {});
            } else if (!$kwargs.$$is_hash) {
                throw Opal.ArgumentError.$new('expected kwargs');
            }
            freeze = $kwargs.$$smap["freeze"];
            if (freeze == null) {
                freeze = true;
            }
            return self;
        }, $Boolean_clone$11.$$arity = -1), nil) && 'clone';
    })($nesting8[0], Boolean, $nesting8);
    Opal.const_set($nesting8[0], 'TrueClass', $$($nesting8, 'Boolean'));
    Opal.const_set($nesting8[0], 'FalseClass', $$($nesting8, 'Boolean'));
    Opal.const_set($nesting8[0], 'TRUE', true);
    return Opal.const_set($nesting8[0], 'FALSE', false);
};
Opal.modules["corelib/comparable"] = function(Opal) {
    function $rb_gt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs > rhs : lhs['$>'](rhs);
    }
    function $rb_lt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs < rhs : lhs['$<'](rhs);
    }
    var self29 = Opal.top, $nesting10 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $falsy = Opal.falsy, $module = Opal.module, $truthy = Opal.truthy;
    Opal.add_stubs([
        '$>',
        '$<',
        '$===',
        '$raise',
        '$class',
        '$<=>',
        '$equal?'
    ]);
    return function($base, $parent_nesting) {
        var self30 = $module($base, 'Comparable');
        var $nesting = [
            self30
        ].concat($parent_nesting), $Comparable_$eq_eq$1, $Comparable_$gt$2, $Comparable_$gt_eq$3, $Comparable_$lt$4, $Comparable_$lt_eq$5, $Comparable_between$ques$6, $Comparable_clamp$7, $case = nil;
        function normalize8(what) {
            if (Opal.is_a(what, Opal.Integer)) {
                return what;
            }
            if ($rb_gt(what, 0)) {
                return 1;
            }
            if ($rb_lt(what, 0)) {
                return -1;
            }
            return 0;
        }
        function fail_comparison(lhs, rhs) {
            var class_name;
            (function() {
                $case = rhs;
                if (nil['$===']($case) || true['$===']($case) || false['$===']($case) || $$($nesting, 'Integer')['$===']($case) || $$($nesting, 'Float')['$===']($case)) {
                    return class_name = rhs.$inspect();
                } else {
                    return class_name = rhs.$$class;
                }
            })();
            self30.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + lhs.$class() + " with " + class_name + " failed");
        }
        function cmp_or_fail(lhs, rhs) {
            var cmp = lhs['$<=>'](rhs);
            if ($falsy(cmp)) fail_comparison(lhs, rhs);
            return normalize8(cmp);
        }
        Opal.def(self30, '$==', $Comparable_$eq_eq$1 = function(other) {
            var self = this, cmp = nil;
            if ($truthy(self['$equal?'](other))) {
                return true;
            }
            if (self["$<=>"] == Opal.Kernel["$<=>"]) {
                return false;
            }
            if (self.$$comparable) {
                delete self.$$comparable;
                return false;
            }
            if ($truthy(cmp = self['$<=>'](other))) {} else {
                return false;
            }
            return normalize8(cmp) == 0;
        }, $Comparable_$eq_eq$1.$$arity = 1);
        Opal.def(self30, '$>', $Comparable_$gt$2 = function(other) {
            var self = this;
            return cmp_or_fail(self, other) > 0;
        }, $Comparable_$gt$2.$$arity = 1);
        Opal.def(self30, '$>=', $Comparable_$gt_eq$3 = function(other) {
            var self = this;
            return cmp_or_fail(self, other) >= 0;
        }, $Comparable_$gt_eq$3.$$arity = 1);
        Opal.def(self30, '$<', $Comparable_$lt$4 = function(other) {
            var self = this;
            return cmp_or_fail(self, other) < 0;
        }, $Comparable_$lt$4.$$arity = 1);
        Opal.def(self30, '$<=', $Comparable_$lt_eq$5 = function(other) {
            var self = this;
            return cmp_or_fail(self, other) <= 0;
        }, $Comparable_$lt_eq$5.$$arity = 1);
        Opal.def(self30, '$between?', $Comparable_between$ques$6 = function(min23, max) {
            var self = this;
            if ($rb_lt(self, min23)) {
                return false;
            }
            if ($rb_gt(self, max)) {
                return false;
            }
            return true;
        }, $Comparable_between$ques$6.$$arity = 2);
        return (Opal.def(self30, '$clamp', $Comparable_clamp$7 = function $$clamp(min24, max) {
            var self = this;
            if (max == null) {
                max = nil;
            }
            var c, excl;
            if (max === nil) {
                if (!Opal.is_a(min24, Opal.Range)) {
                    self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + min24.$class() + " (expected Range)");
                }
                excl = min24.excl;
                max = min24.end;
                min24 = min24.begin;
                if (max !== nil && excl) {
                    self.$raise($$($nesting, 'ArgumentError'), "cannot clamp with an exclusive range");
                }
            }
            if (min24 !== nil && max !== nil && cmp_or_fail(min24, max) > 0) {
                self.$raise($$($nesting, 'ArgumentError'), "min argument must be smaller than max argument");
            }
            if (min24 !== nil) {
                c = cmp_or_fail(self, min24);
                if (c == 0) return self;
                if (c < 0) return min24;
            }
            if (max !== nil) {
                c = cmp_or_fail(self, max);
                if (c > 0) return max;
            }
            return self;
        }, $Comparable_clamp$7.$$arity = -2), nil) && 'clamp';
    }($nesting10[0], $nesting10);
};
Opal.modules["corelib/regexp"] = function(Opal) {
    var self31 = Opal.top, $nesting11 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $send2 = Opal.send2, $truthy = Opal.truthy, $gvars = Opal.gvars, $send = Opal.send;
    Opal.add_stubs([
        '$nil?',
        '$[]',
        '$raise',
        '$escape',
        '$options',
        '$to_str',
        '$new',
        '$join',
        '$coerce_to!',
        '$!',
        '$match',
        '$coerce_to?',
        '$begin',
        '$=~',
        '$attr_reader',
        '$===',
        '$inspect',
        '$to_a'
    ]);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'RegexpError');
        [
            self
        ].concat($parent_nesting);
        return nil;
    })($nesting11[0], $$($nesting11, 'StandardError'), $nesting11);
    (function($base, $super, $parent_nesting5) {
        var self32 = $klass($base, $super, 'Regexp');
        var $nesting12 = [
            self32
        ].concat($parent_nesting5), $Regexp_$eq_eq$6, $Regexp_$eq_eq_eq$7, $Regexp_$eq_tilde$8, $Regexp_inspect$9, $Regexp_match$10, $Regexp_match$ques$11, $Regexp_$$12, $Regexp_source$13, $Regexp_options$14, $Regexp_casefold$ques$15;
        Opal.const_set($nesting12[0], 'IGNORECASE', 1);
        Opal.const_set($nesting12[0], 'EXTENDED', 2);
        Opal.const_set($nesting12[0], 'MULTILINE', 4);
        Opal.defineProperty(self32.$$prototype, '$$is_regexp', true);
        (function(self33, $parent_nesting) {
            var $nesting = [
                self33
            ].concat($parent_nesting), $allocate$1, $escape$2, $last_match$3, $union$4, $new$5;
            Opal.def(self33, '$allocate', $allocate$1 = function $$allocate() {
                var $iter = $allocate$1.$$p, self = this, allocated = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
                if ($iter) $allocate$1.$$p = null;
                for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                    $zuper[$zuper_i] = arguments[$zuper_i];
                }
                allocated = $send2(self, Opal.find_super_dispatcher(self, 'allocate', $allocate$1, false, true), 'allocate', $zuper, $iter);
                allocated.uninitialized = true;
                return allocated;
            }, $allocate$1.$$arity = 0);
            Opal.def(self33, '$escape', $escape$2 = function $$escape(string) {
                return Opal.escape_regexp(string);
            }, $escape$2.$$arity = 1);
            Opal.def(self33, '$last_match', $last_match$3 = function $$last_match(n) {
                if ($gvars["~"] == null) $gvars["~"] = nil;
                if (n == null) {
                    n = nil;
                }
                if ($truthy(n['$nil?']())) {
                    return $gvars["~"];
                } else {
                    return $gvars["~"]['$[]'](n);
                }
            }, $last_match$3.$$arity = -1);
            Opal.alias(self33, "quote", "escape");
            Opal.def(self33, '$union', $union$4 = function $$union($a) {
                var $post_args, parts, self = this;
                $post_args = Opal.slice.call(arguments, 0, arguments.length);
                parts = $post_args;
                var is_first_part_array, quoted_validated, part, options, each_part_options;
                if (parts.length == 0) {
                    return /(?!)/;
                }
                if (parts.length == 1 && parts[0].$$is_regexp) {
                    return parts[0];
                }
                is_first_part_array = parts[0].$$is_array;
                if (parts.length > 1 && is_first_part_array) {
                    self.$raise($$($nesting, 'TypeError'), "no implicit conversion of Array into String");
                }
                if (is_first_part_array) {
                    parts = parts[0];
                }
                options = undefined;
                quoted_validated = [];
                for(var i171 = 0; i171 < parts.length; i171++){
                    part = parts[i171];
                    if (part.$$is_string) {
                        quoted_validated.push(self.$escape(part));
                    } else if (part.$$is_regexp) {
                        each_part_options = part.$options();
                        if (options != undefined && options != each_part_options) {
                            self.$raise($$($nesting, 'TypeError'), "All expressions must use the same options");
                        }
                        options = each_part_options;
                        quoted_validated.push('(' + part.source + ')');
                    } else {
                        quoted_validated.push(self.$escape(part.$to_str()));
                    }
                }
                return self.$new(quoted_validated.$join("|"), options);
            }, $union$4.$$arity = -1);
            Opal.def(self33, '$new', $new$5 = function(regexp, options) {
                var self = this;
                if (regexp.$$is_regexp) {
                    return new RegExp(regexp);
                }
                regexp = $$($nesting, 'Opal')['$coerce_to!'](regexp, $$($nesting, 'String'), "to_str");
                if (regexp.charAt(regexp.length - 1) === '\\' && regexp.charAt(regexp.length - 2) !== '\\') {
                    self.$raise($$($nesting, 'RegexpError'), "" + "too short escape sequence: /" + regexp + "/");
                }
                if (options === undefined || options['$!']()) {
                    return new RegExp(regexp);
                }
                if (options.$$is_number) {
                    var temp = '';
                    if ($$($nesting, 'IGNORECASE') & options) {
                        temp += 'i';
                    }
                    if ($$($nesting, 'MULTILINE') & options) {
                        temp += 'm';
                    }
                    options = temp;
                } else {
                    options = 'i';
                }
                return new RegExp(regexp, options);
            }, $new$5.$$arity = -2);
            return Opal.alias(self33, "compile", "new");
        })(Opal.get_singleton_class(self32), $nesting12);
        Opal.def(self32, '$==', $Regexp_$eq_eq$6 = function(other) {
            var self = this;
            return other instanceof RegExp && self.toString() === other.toString();
        }, $Regexp_$eq_eq$6.$$arity = 1);
        Opal.def(self32, '$===', $Regexp_$eq_eq_eq$7 = function(string) {
            var self = this;
            return self.$match($$($nesting12, 'Opal')['$coerce_to?'](string, $$($nesting12, 'String'), "to_str")) !== nil;
        }, $Regexp_$eq_eq_eq$7.$$arity = 1);
        Opal.def(self32, '$=~', $Regexp_$eq_tilde$8 = function(string) {
            var self = this, $ret_or_1 = nil;
            if ($gvars["~"] == null) $gvars["~"] = nil;
            if ($truthy($ret_or_1 = self.$match(string))) {
                return $gvars["~"].$begin(0);
            } else {
                return $ret_or_1;
            }
        }, $Regexp_$eq_tilde$8.$$arity = 1);
        Opal.alias(self32, "eql?", "==");
        Opal.def(self32, '$inspect', $Regexp_inspect$9 = function $$inspect() {
            var self = this;
            var regexp_format = /^\/(.*)\/([^\/]*)$/;
            var value = self.toString();
            var matches = regexp_format.exec(value);
            if (matches) {
                var regexp_pattern = matches[1];
                var regexp_flags = matches[2];
                var chars = regexp_pattern.split('');
                var chars_length = chars.length;
                var char_escaped = false;
                var regexp_pattern_escaped = '';
                for(var i172 = 0; i172 < chars_length; i172++){
                    var current_char = chars[i172];
                    if (!char_escaped && current_char == '/') {
                        regexp_pattern_escaped = regexp_pattern_escaped.concat('\\');
                    }
                    regexp_pattern_escaped = regexp_pattern_escaped.concat(current_char);
                    if (current_char == '\\') {
                        if (char_escaped) {
                            char_escaped = false;
                        } else {
                            char_escaped = true;
                        }
                    } else {
                        char_escaped = false;
                    }
                }
                return '/' + regexp_pattern_escaped + '/' + regexp_flags;
            } else {
                return value;
            }
        }, $Regexp_inspect$9.$$arity = 0);
        Opal.def(self32, '$match', $Regexp_match$10 = function $$match(string, pos) {
            var $iter = $Regexp_match$10.$$p, block = $iter || nil, self = this;
            if ($gvars["~"] == null) $gvars["~"] = nil;
            if ($iter) $Regexp_match$10.$$p = null;
            if ($iter) $Regexp_match$10.$$p = null;
            if (self.uninitialized) {
                self.$raise($$($nesting12, 'TypeError'), "uninitialized Regexp");
            }
            if (pos === undefined) {
                if (string === nil) return $gvars["~"] = nil;
                var m = self.exec($coerce_to(string, $$($nesting12, 'String'), 'to_str'));
                if (m) {
                    $gvars["~"] = $$($nesting12, 'MatchData').$new(self, m);
                    return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
                } else {
                    return $gvars["~"] = nil;
                }
            }
            pos = $coerce_to(pos, $$($nesting12, 'Integer'), 'to_int');
            if (string === nil) {
                return $gvars["~"] = nil;
            }
            string = $coerce_to(string, $$($nesting12, 'String'), 'to_str');
            if (pos < 0) {
                pos += string.length;
                if (pos < 0) {
                    return $gvars["~"] = nil;
                }
            }
            var md, re = Opal.global_regexp(self);
            while(true){
                md = re.exec(string);
                if (md === null) {
                    return $gvars["~"] = nil;
                }
                if (md.index >= pos) {
                    $gvars["~"] = $$($nesting12, 'MatchData').$new(re, md);
                    return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
                }
                re.lastIndex = md.index + 1;
            }
        }, $Regexp_match$10.$$arity = -2);
        Opal.def(self32, '$match?', $Regexp_match$ques$11 = function(string, pos) {
            var self = this;
            if (self.uninitialized) {
                self.$raise($$($nesting12, 'TypeError'), "uninitialized Regexp");
            }
            if (pos === undefined) {
                return string === nil ? false : self.test($coerce_to(string, $$($nesting12, 'String'), 'to_str'));
            }
            pos = $coerce_to(pos, $$($nesting12, 'Integer'), 'to_int');
            if (string === nil) {
                return false;
            }
            string = $coerce_to(string, $$($nesting12, 'String'), 'to_str');
            if (pos < 0) {
                pos += string.length;
                if (pos < 0) {
                    return false;
                }
            }
            var md, re = Opal.global_regexp(self);
            md = re.exec(string);
            if (md === null || md.index < pos) {
                return false;
            } else {
                return true;
            }
        }, $Regexp_match$ques$11.$$arity = -2);
        Opal.def(self32, '$~', $Regexp_$$12 = function() {
            var self = this;
            if ($gvars._ == null) $gvars._ = nil;
            return self['$=~']($gvars._);
        }, $Regexp_$$12.$$arity = 0);
        Opal.def(self32, '$source', $Regexp_source$13 = function $$source() {
            var self = this;
            return self.source;
        }, $Regexp_source$13.$$arity = 0);
        Opal.def(self32, '$options', $Regexp_options$14 = function $$options() {
            var self = this;
            if (self.uninitialized) {
                self.$raise($$($nesting12, 'TypeError'), "uninitialized Regexp");
            }
            var result = 0;
            if (self.multiline) {
                result |= $$($nesting12, 'MULTILINE');
            }
            if (self.ignoreCase) {
                result |= $$($nesting12, 'IGNORECASE');
            }
            return result;
        }, $Regexp_options$14.$$arity = 0);
        Opal.def(self32, '$casefold?', $Regexp_casefold$ques$15 = function() {
            var self = this;
            return self.ignoreCase;
        }, $Regexp_casefold$ques$15.$$arity = 0);
        return Opal.alias(self32, "to_s", "source");
    })($nesting11[0], RegExp, $nesting11);
    return function($base, $super, $parent_nesting) {
        var self34 = $klass($base, $super, 'MatchData');
        var $nesting = [
            self34
        ].concat($parent_nesting), $MatchData_initialize$16, $MatchData_$$$17, $MatchData_offset$18, $MatchData_$eq_eq$19, $MatchData_begin$20, $MatchData_end$21, $MatchData_captures$22, $MatchData_inspect$23, $MatchData_length$24, $MatchData_to_a$25, $MatchData_to_s$26, $MatchData_values_at$27;
        self34.$$prototype.matches = nil;
        self34.$attr_reader("post_match", "pre_match", "regexp", "string");
        Opal.def(self34, '$initialize', $MatchData_initialize$16 = function $$initialize(regexp, match_groups) {
            var self = this;
            $gvars["~"] = self;
            self.regexp = regexp;
            self.begin = match_groups.index;
            self.string = match_groups.input;
            self.pre_match = match_groups.input.slice(0, match_groups.index);
            self.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);
            self.matches = [];
            for(var i173 = 0, length = match_groups.length; i173 < length; i173++){
                var group = match_groups[i173];
                if (group == null) {
                    self.matches.push(nil);
                } else {
                    self.matches.push(group);
                }
            }
        }, $MatchData_initialize$16.$$arity = 2);
        Opal.def(self34, '$[]', $MatchData_$$$17 = function($a) {
            var $post_args, args33, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args33 = $post_args;
            return $send(self.matches, '[]', Opal.to_a(args33));
        }, $MatchData_$$$17.$$arity = -1);
        Opal.def(self34, '$offset', $MatchData_offset$18 = function $$offset(n) {
            var self = this;
            if (n !== 0) {
                self.$raise($$($nesting, 'ArgumentError'), "MatchData#offset only supports 0th element");
            }
            return [
                self.begin,
                self.begin + self.matches[n].length
            ];
        }, $MatchData_offset$18.$$arity = 1);
        Opal.def(self34, '$==', $MatchData_$eq_eq$19 = function(other) {
            var self = this, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil, $ret_or_5 = nil;
            if ($truthy($$($nesting, 'MatchData')['$==='](other))) {} else {
                return false;
            }
            if ($truthy($ret_or_2 = function() {
                if ($truthy($ret_or_3 = function() {
                    if ($truthy($ret_or_4 = function() {
                        if ($truthy($ret_or_5 = self.string == other.string)) {
                            return self.regexp.toString() == other.regexp.toString();
                        } else {
                            return $ret_or_5;
                        }
                        return nil;
                    }())) {
                        return self.pre_match == other.pre_match;
                    } else {
                        return $ret_or_4;
                    }
                    return nil;
                }())) {
                    return self.post_match == other.post_match;
                } else {
                    return $ret_or_3;
                }
                return nil;
            }())) {
                return self.begin == other.begin;
            } else {
                return $ret_or_2;
            }
        }, $MatchData_$eq_eq$19.$$arity = 1);
        Opal.alias(self34, "eql?", "==");
        Opal.def(self34, '$begin', $MatchData_begin$20 = function $$begin(n) {
            var self = this;
            if (n !== 0) {
                self.$raise($$($nesting, 'ArgumentError'), "MatchData#begin only supports 0th element");
            }
            return self.begin;
        }, $MatchData_begin$20.$$arity = 1);
        Opal.def(self34, '$end', $MatchData_end$21 = function $$end(n) {
            var self = this;
            if (n !== 0) {
                self.$raise($$($nesting, 'ArgumentError'), "MatchData#end only supports 0th element");
            }
            return self.begin + self.matches[n].length;
        }, $MatchData_end$21.$$arity = 1);
        Opal.def(self34, '$captures', $MatchData_captures$22 = function $$captures() {
            var self = this;
            return self.matches.slice(1);
        }, $MatchData_captures$22.$$arity = 0);
        Opal.def(self34, '$inspect', $MatchData_inspect$23 = function $$inspect() {
            var self = this;
            var str = "#<MatchData " + self.matches[0].$inspect();
            for(var i174 = 1, length = self.matches.length; i174 < length; i174++){
                str += " " + i174 + ":" + self.matches[i174].$inspect();
            }
            return str + ">";
        }, $MatchData_inspect$23.$$arity = 0);
        Opal.def(self34, '$length', $MatchData_length$24 = function $$length() {
            var self = this;
            return self.matches.length;
        }, $MatchData_length$24.$$arity = 0);
        Opal.alias(self34, "size", "length");
        Opal.def(self34, '$to_a', $MatchData_to_a$25 = function $$to_a() {
            var self = this;
            return self.matches;
        }, $MatchData_to_a$25.$$arity = 0);
        Opal.def(self34, '$to_s', $MatchData_to_s$26 = function $$to_s() {
            var self = this;
            return self.matches[0];
        }, $MatchData_to_s$26.$$arity = 0);
        return (Opal.def(self34, '$values_at', $MatchData_values_at$27 = function $$values_at($a) {
            var $post_args, args34, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args34 = $post_args;
            var i175, a, index, values = [];
            for(i175 = 0; i175 < args34.length; i175++){
                if (args34[i175].$$is_range) {
                    a = args34[i175].$to_a();
                    a.unshift(i175, 1);
                    Array.prototype.splice.apply(args34, a);
                }
                index = $$($nesting, 'Opal')['$coerce_to!'](args34[i175], $$($nesting, 'Integer'), "to_int");
                if (index < 0) {
                    index += self.matches.length;
                    if (index < 0) {
                        values.push(nil);
                        continue;
                    }
                }
                values.push(self.matches[index]);
            }
            return values;
        }, $MatchData_values_at$27.$$arity = -1), nil) && 'values_at';
    }($nesting11[0], null, $nesting11);
};
Opal.modules["corelib/string"] = function(Opal) {
    function $rb_divide(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs / rhs : lhs['$/'](rhs);
    }
    function $rb_plus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
    }
    var self35 = Opal.top, $nesting13 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy, $gvars = Opal.gvars;
    Opal.add_stubs([
        '$require',
        '$include',
        '$coerce_to?',
        '$initialize',
        '$===',
        '$format',
        '$raise',
        '$respond_to?',
        '$to_s',
        '$to_str',
        '$<=>',
        '$==',
        '$=~',
        '$new',
        '$force_encoding',
        '$casecmp',
        '$empty?',
        '$ljust',
        '$ceil',
        '$/',
        '$+',
        '$rjust',
        '$floor',
        '$coerce_to!',
        '$copy_singleton_methods',
        '$initialize_clone',
        '$initialize_dup',
        '$enum_for',
        '$chomp',
        '$[]',
        '$to_i',
        '$each_line',
        '$to_proc',
        '$to_a',
        '$class',
        '$match',
        '$match?',
        '$captures',
        '$proc',
        '$succ',
        '$escape',
        '$include?',
        '$upcase',
        '$unicode_normalize',
        '$pristine'
    ]);
    self35.$require("corelib/comparable");
    self35.$require("corelib/regexp");
    (function($base, $super, $parent_nesting) {
        var self36 = $klass($base, $super, 'String');
        var $nesting = [
            self36
        ].concat($parent_nesting), $String___id__$1, $String_try_convert$2, $String_new$3, $String_initialize$4, $String_$percent$5, $String_$$6, $String_$plus$7, $String_$lt_eq_gt$8, $String_$eq_eq$9, $String_$eq_tilde$10, $String_$$$11, $String_b$12, $String_capitalize$13, $String_casecmp$14, $String_casecmp$ques$15, $String_center$16, $String_chomp$17, $String_chop$18, $String_chr$19, $String_clone$20, $String_dup$21, $String_count$22, $String_delete$23, $String_delete_prefix$24, $String_delete_suffix$25, $String_downcase$26, $String_each_line$27, $String_empty$ques$28, $String_end_with$ques$29, $String_gsub$30, $String_hash$31, $String_hex$32, $String_include$ques$33, $String_index$34, $String_inspect$35, $String_intern$36, $String_lines$37, $String_ljust$38, $String_lstrip$39, $String_ascii_only$ques$40, $String_match$41, $String_match$ques$42, $String_next$43, $String_oct$44, $String_ord$45, $String_partition$46, $String_reverse$47, $String_rindex$48, $String_rjust$49, $String_rpartition$50, $String_rstrip$51, $String_scan$52, $String_split$53, $String_squeeze$54, $String_start_with$ques$55, $String_strip$56, $String_sub$57, $String_sum$58, $String_swapcase$59, $String_to_f$60, $String_to_i$61, $String_to_proc$62, $String_to_s$64, $String_tr$65, $String_tr_s$66, $String_upcase$67, $String_upto$68, $String_instance_variables$69, $String__load$70, $String_unicode_normalize$71, $String_unicode_normalized$ques$72, $String_unpack$73, $String_unpack1$74, $String_freeze$75, $String_$minus$$76, $String_frozen$ques$77;
        self36.$include($$($nesting, 'Comparable'));
        Opal.defineProperty(self36.$$prototype, '$$is_string', true);
        Opal.defineProperty(self36.$$prototype, '$$cast', function(string) {
            var klass = this.$$class;
            if (klass.$$constructor === String) {
                return string;
            } else {
                return new klass.$$constructor(string);
            }
        });
        Opal.def(self36, '$__id__', $String___id__$1 = function $$__id__() {
            var self = this;
            return self.toString();
        }, $String___id__$1.$$arity = 0);
        Opal.alias(self36, "object_id", "__id__");
        Opal.defs(self36, '$try_convert', $String_try_convert$2 = function $$try_convert(what) {
            return $$($nesting, 'Opal')['$coerce_to?'](what, $$($nesting, 'String'), "to_str");
        }, $String_try_convert$2.$$arity = 1);
        Opal.defs(self36, '$new', $String_new$3 = function($a) {
            var $post_args, args35, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args35 = $post_args;
            var str = args35[0] || "";
            var opts = args35[args35.length - 1];
            str = $coerce_to(str, $$($nesting, 'String'), 'to_str');
            if (opts && opts.$$is_hash) {
                if (opts.$$smap.encoding) str = str.$force_encoding(opts.$$smap.encoding);
            }
            str = new self.$$constructor(str);
            if (!str.$initialize.$$pristine) $send(str, 'initialize', Opal.to_a(args35));
            return str;
        }, $String_new$3.$$arity = -1);
        Opal.def(self36, '$initialize', $String_initialize$4 = function $$initialize($a, $b) {
            var $post_args, $kwargs, str, encoding, capacity;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            $kwargs = Opal.extract_kwargs($post_args);
            if ($kwargs == null) {
                $kwargs = $hash2([], {});
            } else if (!$kwargs.$$is_hash) {
                throw Opal.ArgumentError.$new('expected kwargs');
            }
            if ($post_args.length > 0) {
                str = $post_args[0];
                $post_args.splice(0, 1);
            }
            encoding = $kwargs.$$smap["encoding"];
            if (encoding == null) {
                encoding = nil;
            }
            capacity = $kwargs.$$smap["capacity"];
            if (capacity == null) {
                capacity = nil;
            }
            return nil;
        }, $String_initialize$4.$$arity = -1);
        Opal.def(self36, '$%', $String_$percent$5 = function(data11) {
            var self = this;
            if ($truthy($$($nesting, 'Array')['$==='](data11))) {
                return $send(self, 'format', [
                    self
                ].concat(Opal.to_a(data11)));
            } else {
                return self.$format(self, data11);
            }
        }, $String_$percent$5.$$arity = 1);
        Opal.def(self36, '$*', $String_$$6 = function(count) {
            var self = this;
            count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');
            if (count < 0) {
                self.$raise($$($nesting, 'ArgumentError'), "negative argument");
            }
            if (count === 0) {
                return self.$$cast('');
            }
            var result = '', string = self.toString();
            if (string.length * count >= 1 << 28) {
                self.$raise($$($nesting, 'RangeError'), "multiply count must not overflow maximum string size");
            }
            for(;;){
                if ((count & 1) === 1) {
                    result += string;
                }
                count >>>= 1;
                if (count === 0) {
                    break;
                }
                string += string;
            }
            return self.$$cast(result);
        }, $String_$$6.$$arity = 1);
        Opal.def(self36, '$+', $String_$plus$7 = function(other) {
            var self = this;
            other = $coerce_to(other, $$($nesting, 'String'), 'to_str');
            if (other == "" && self.$$class === Opal.String) return self;
            if (self == "" && other.$$class === Opal.String) return other;
            var out = self + other;
            if (self.encoding === out.encoding && other.encoding === out.encoding) return out;
            if (self.encoding.name === "UTF-8" || other.encoding.name === "UTF-8") return out;
            return Opal.enc(out, self.encoding);
        }, $String_$plus$7.$$arity = 1);
        Opal.def(self36, '$<=>', $String_$lt_eq_gt$8 = function(other) {
            var self = this;
            if ($truthy(other['$respond_to?']("to_str"))) {
                other = other.$to_str().$to_s();
                return self > other ? 1 : self < other ? -1 : 0;
            } else {
                var cmp = other['$<=>'](self);
                if (cmp === nil) {
                    return nil;
                } else {
                    return cmp > 0 ? -1 : cmp < 0 ? 1 : 0;
                }
            }
        }, $String_$lt_eq_gt$8.$$arity = 1);
        Opal.def(self36, '$==', $String_$eq_eq$9 = function(other) {
            var self = this;
            if (other.$$is_string) {
                return self.toString() === other.toString();
            }
            if ($respond_to(other, '$to_str')) {
                return other['$=='](self);
            }
            return false;
        }, $String_$eq_eq$9.$$arity = 1);
        Opal.alias(self36, "eql?", "==");
        Opal.alias(self36, "===", "==");
        Opal.def(self36, '$=~', $String_$eq_tilde$10 = function(other) {
            var self = this;
            if (other.$$is_string) {
                self.$raise($$($nesting, 'TypeError'), "type mismatch: String given");
            }
            return other['$=~'](self);
        }, $String_$eq_tilde$10.$$arity = 1);
        Opal.def(self36, '$[]', $String_$$$11 = function(index, length) {
            var self = this;
            var size = self.length, exclude;
            if (index.$$is_range) {
                exclude = index.excl;
                length = $coerce_to(index.end, $$($nesting, 'Integer'), 'to_int');
                index = $coerce_to(index.begin, $$($nesting, 'Integer'), 'to_int');
                if (Math.abs(index) > size) {
                    return nil;
                }
                if (index < 0) {
                    index += size;
                }
                if (length < 0) {
                    length += size;
                }
                if (!exclude) {
                    length += 1;
                }
                length = length - index;
                if (length < 0) {
                    length = 0;
                }
                return self.$$cast(self.substr(index, length));
            }
            if (index.$$is_string) {
                if (length != null) {
                    self.$raise($$($nesting, 'TypeError'));
                }
                return self.indexOf(index) !== -1 ? self.$$cast(index) : nil;
            }
            if (index.$$is_regexp) {
                var match = self.match(index);
                if (match === null) {
                    $gvars["~"] = nil;
                    return nil;
                }
                $gvars["~"] = $$($nesting, 'MatchData').$new(index, match);
                if (length == null) {
                    return self.$$cast(match[0]);
                }
                length = $coerce_to(length, $$($nesting, 'Integer'), 'to_int');
                if (length < 0 && -length < match.length) {
                    return self.$$cast(match[length += match.length]);
                }
                if (length >= 0 && length < match.length) {
                    return self.$$cast(match[length]);
                }
                return nil;
            }
            index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');
            if (index < 0) {
                index += size;
            }
            if (length == null) {
                if (index >= size || index < 0) {
                    return nil;
                }
                return self.$$cast(self.substr(index, 1));
            }
            length = $coerce_to(length, $$($nesting, 'Integer'), 'to_int');
            if (length < 0) {
                return nil;
            }
            if (index > size || index < 0) {
                return nil;
            }
            return self.$$cast(self.substr(index, length));
        }, $String_$$$11.$$arity = -2);
        Opal.alias(self36, "byteslice", "[]");
        Opal.def(self36, '$b', $String_b$12 = function $$b() {
            var self = this;
            return new String(self).$force_encoding("binary");
        }, $String_b$12.$$arity = 0);
        Opal.def(self36, '$capitalize', $String_capitalize$13 = function $$capitalize() {
            var self = this;
            return self.$$cast(self.charAt(0).toUpperCase() + self.substr(1).toLowerCase());
        }, $String_capitalize$13.$$arity = 0);
        Opal.def(self36, '$casecmp', $String_casecmp$14 = function $$casecmp(other) {
            var self = this;
            if ($truthy(other['$respond_to?']("to_str"))) {} else {
                return nil;
            }
            other = $coerce_to(other, $$($nesting, 'String'), 'to_str').$to_s();
            var ascii_only = /^[\x00-\x7F]*$/;
            if (ascii_only.test(self) && ascii_only.test(other)) {
                self = self.toLowerCase();
                other = other.toLowerCase();
            }
            return self['$<=>'](other);
        }, $String_casecmp$14.$$arity = 1);
        Opal.def(self36, '$casecmp?', $String_casecmp$ques$15 = function(other) {
            var self = this;
            var cmp = self.$casecmp(other);
            if (cmp === nil) {
                return nil;
            } else {
                return cmp === 0;
            }
        }, $String_casecmp$ques$15.$$arity = 1);
        Opal.def(self36, '$center', $String_center$16 = function $$center(width, padstr) {
            var self = this;
            if (padstr == null) {
                padstr = " ";
            }
            width = $coerce_to(width, $$($nesting, 'Integer'), 'to_int');
            padstr = $coerce_to(padstr, $$($nesting, 'String'), 'to_str').$to_s();
            if ($truthy(padstr['$empty?']())) {
                self.$raise($$($nesting, 'ArgumentError'), "zero width padding");
            }
            if ($truthy(width <= self.length)) {
                return self;
            }
            var ljustified = self.$ljust($rb_divide($rb_plus(width, self.length), 2).$ceil(), padstr), rjustified = self.$rjust($rb_divide($rb_plus(width, self.length), 2).$floor(), padstr);
            return self.$$cast(rjustified + ljustified.slice(self.length));
        }, $String_center$16.$$arity = -2);
        Opal.def(self36, '$chomp', $String_chomp$17 = function $$chomp(separator) {
            var self = this;
            if ($gvars["/"] == null) $gvars["/"] = nil;
            if (separator == null) {
                separator = $gvars["/"];
            }
            if ($truthy(separator === nil || self.length === 0)) {
                return self;
            }
            separator = $$($nesting, 'Opal')['$coerce_to!'](separator, $$($nesting, 'String'), "to_str").$to_s();
            var result;
            if (separator === "\n") {
                result = self.replace(/\r?\n?$/, '');
            } else if (separator === "") {
                result = self.replace(/(\r?\n)+$/, '');
            } else if (self.length >= separator.length) {
                var tail = self.substr(self.length - separator.length, separator.length);
                if (tail === separator) {
                    result = self.substr(0, self.length - separator.length);
                }
            }
            if (result != null) {
                return self.$$cast(result);
            }
            return self;
        }, $String_chomp$17.$$arity = -1);
        Opal.def(self36, '$chop', $String_chop$18 = function $$chop() {
            var self = this;
            var length = self.length, result;
            if (length <= 1) {
                result = "";
            } else if (self.charAt(length - 1) === "\n" && self.charAt(length - 2) === "\r") {
                result = self.substr(0, length - 2);
            } else {
                result = self.substr(0, length - 1);
            }
            return self.$$cast(result);
        }, $String_chop$18.$$arity = 0);
        Opal.def(self36, '$chr', $String_chr$19 = function $$chr() {
            var self = this;
            return self.charAt(0);
        }, $String_chr$19.$$arity = 0);
        Opal.def(self36, '$clone', $String_clone$20 = function $$clone() {
            var self = this, copy4 = nil;
            copy4 = new String(self);
            copy4.$copy_singleton_methods(self);
            copy4.$initialize_clone(self);
            return copy4;
        }, $String_clone$20.$$arity = 0);
        Opal.def(self36, '$dup', $String_dup$21 = function $$dup() {
            var self = this, copy5 = nil;
            copy5 = new String(self);
            copy5.$initialize_dup(self);
            return copy5;
        }, $String_dup$21.$$arity = 0);
        Opal.def(self36, '$count', $String_count$22 = function $$count($a) {
            var $post_args, sets, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            sets = $post_args;
            if (sets.length === 0) {
                self.$raise($$($nesting, 'ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)");
            }
            var char_class = char_class_from_char_sets(sets);
            if (char_class === null) {
                return 0;
            }
            return self.length - self.replace(new RegExp(char_class, 'g'), '').length;
        }, $String_count$22.$$arity = -1);
        Opal.def(self36, '$delete', $String_delete$23 = function($a) {
            var $post_args, sets, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            sets = $post_args;
            if (sets.length === 0) {
                self.$raise($$($nesting, 'ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)");
            }
            var char_class = char_class_from_char_sets(sets);
            if (char_class === null) {
                return self;
            }
            return self.$$cast(self.replace(new RegExp(char_class, 'g'), ''));
        }, $String_delete$23.$$arity = -1);
        Opal.def(self36, '$delete_prefix', $String_delete_prefix$24 = function $$delete_prefix(prefix) {
            var self = this;
            if (!prefix.$$is_string) {
                prefix = $coerce_to(prefix, $$($nesting, 'String'), 'to_str');
            }
            if (self.slice(0, prefix.length) === prefix) {
                return self.$$cast(self.slice(prefix.length));
            } else {
                return self;
            }
        }, $String_delete_prefix$24.$$arity = 1);
        Opal.def(self36, '$delete_suffix', $String_delete_suffix$25 = function $$delete_suffix(suffix) {
            var self = this;
            if (!suffix.$$is_string) {
                suffix = $coerce_to(suffix, $$($nesting, 'String'), 'to_str');
            }
            if (self.slice(self.length - suffix.length) === suffix) {
                return self.$$cast(self.slice(0, self.length - suffix.length));
            } else {
                return self;
            }
        }, $String_delete_suffix$25.$$arity = 1);
        Opal.def(self36, '$downcase', $String_downcase$26 = function $$downcase() {
            var self = this;
            return self.$$cast(self.toLowerCase());
        }, $String_downcase$26.$$arity = 0);
        Opal.def(self36, '$each_line', $String_each_line$27 = function $$each_line(separator) {
            var $iter = $String_each_line$27.$$p, block = $iter || nil, self = this;
            if ($gvars["/"] == null) $gvars["/"] = nil;
            if ($iter) $String_each_line$27.$$p = null;
            if ($iter) $String_each_line$27.$$p = null;
            if (separator == null) {
                separator = $gvars["/"];
            }
            if (block !== nil) {} else {
                return self.$enum_for("each_line", separator);
            }
            if (separator === nil) {
                Opal.yield1(block, self);
                return self;
            }
            separator = $coerce_to(separator, $$($nesting, 'String'), 'to_str');
            var a, i176, n, length, chomped, trailing, splitted;
            if (separator.length === 0) {
                for(a = self.split(/(\n{2,})/), i176 = 0, n = a.length; i176 < n; i176 += 2){
                    if (a[i176] || a[i176 + 1]) {
                        var value = (a[i176] || "") + (a[i176 + 1] || "");
                        Opal.yield1(block, self.$$cast(value));
                    }
                }
                return self;
            }
            chomped = self.$chomp(separator);
            trailing = self.length != chomped.length;
            splitted = chomped.split(separator);
            for(i176 = 0, length = splitted.length; i176 < length; i176++){
                if (i176 < length - 1 || trailing) {
                    Opal.yield1(block, self.$$cast(splitted[i176] + separator));
                } else {
                    Opal.yield1(block, self.$$cast(splitted[i176]));
                }
            }
            return self;
        }, $String_each_line$27.$$arity = -1);
        Opal.def(self36, '$empty?', $String_empty$ques$28 = function() {
            var self = this;
            return self.length === 0;
        }, $String_empty$ques$28.$$arity = 0);
        Opal.def(self36, '$end_with?', $String_end_with$ques$29 = function($a) {
            var $post_args, suffixes, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            suffixes = $post_args;
            for(var i177 = 0, length = suffixes.length; i177 < length; i177++){
                var suffix = $coerce_to(suffixes[i177], $$($nesting, 'String'), 'to_str').$to_s();
                if (self.length >= suffix.length && self.substr(self.length - suffix.length, suffix.length) == suffix) {
                    return true;
                }
            }
            return false;
        }, $String_end_with$ques$29.$$arity = -1);
        Opal.alias(self36, "equal?", "===");
        Opal.def(self36, '$gsub', $String_gsub$30 = function $$gsub(pattern, replacement) {
            var $iter = $String_gsub$30.$$p, block = $iter || nil, self = this;
            if ($iter) $String_gsub$30.$$p = null;
            if ($iter) $String_gsub$30.$$p = null;
            if (replacement === undefined && block === nil) {
                return self.$enum_for("gsub", pattern);
            }
            var result = '', match_data = nil, index = 0, match, _replacement;
            if (pattern.$$is_regexp) {
                pattern = Opal.global_multiline_regexp(pattern);
            } else {
                pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str');
                pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
            }
            var lastIndex;
            while(true){
                match = pattern.exec(self);
                if (match === null) {
                    $gvars["~"] = nil;
                    result += self.slice(index);
                    break;
                }
                match_data = $$($nesting, 'MatchData').$new(pattern, match);
                if (replacement === undefined) {
                    lastIndex = pattern.lastIndex;
                    _replacement = block(match[0]);
                    pattern.lastIndex = lastIndex;
                } else if (replacement.$$is_hash) {
                    _replacement = replacement['$[]'](match[0]).$to_s();
                } else {
                    if (!replacement.$$is_string) {
                        replacement = $coerce_to(replacement, $$($nesting, 'String'), 'to_str');
                    }
                    _replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function(original, slashes, command) {
                        if (slashes.length % 2 === 0) {
                            return original;
                        }
                        switch(command){
                            case "+":
                                for(var i178 = match.length - 1; i178 > 0; i178--){
                                    if (match[i178] !== undefined) {
                                        return slashes.slice(1) + match[i178];
                                    }
                                }
                                return '';
                            case "&":
                                return slashes.slice(1) + match[0];
                            case "`":
                                return slashes.slice(1) + self.slice(0, match.index);
                            case "'":
                                return slashes.slice(1) + self.slice(match.index + match[0].length);
                            default:
                                return slashes.slice(1) + (match[command] || '');
                        }
                    }).replace(/\\\\/g, '\\');
                }
                if (pattern.lastIndex === match.index) {
                    result += self.slice(index, match.index) + _replacement + (self[match.index] || "");
                    pattern.lastIndex += 1;
                } else {
                    result += self.slice(index, match.index) + _replacement;
                }
                index = pattern.lastIndex;
            }
            $gvars["~"] = match_data;
            return self.$$cast(result);
        }, $String_gsub$30.$$arity = -2);
        Opal.def(self36, '$hash', $String_hash$31 = function $$hash() {
            var self = this;
            return self.toString();
        }, $String_hash$31.$$arity = 0);
        Opal.def(self36, '$hex', $String_hex$32 = function $$hex() {
            var self = this;
            return self.$to_i(16);
        }, $String_hex$32.$$arity = 0);
        Opal.def(self36, '$include?', $String_include$ques$33 = function(other) {
            var self = this;
            if (!other.$$is_string) {
                other = $coerce_to(other, $$($nesting, 'String'), 'to_str');
            }
            return self.indexOf(other) !== -1;
        }, $String_include$ques$33.$$arity = 1);
        Opal.def(self36, '$index', $String_index$34 = function $$index(search, offset) {
            var self = this;
            var index, match, regex;
            if (offset === undefined) {
                offset = 0;
            } else {
                offset = $coerce_to(offset, $$($nesting, 'Integer'), 'to_int');
                if (offset < 0) {
                    offset += self.length;
                    if (offset < 0) {
                        return nil;
                    }
                }
            }
            if (search.$$is_regexp) {
                regex = Opal.global_multiline_regexp(search);
                while(true){
                    match = regex.exec(self);
                    if (match === null) {
                        $gvars["~"] = nil;
                        index = -1;
                        break;
                    }
                    if (match.index >= offset) {
                        $gvars["~"] = $$($nesting, 'MatchData').$new(regex, match);
                        index = match.index;
                        break;
                    }
                    regex.lastIndex = match.index + 1;
                }
            } else {
                search = $coerce_to(search, $$($nesting, 'String'), 'to_str');
                if (search.length === 0 && offset > self.length) {
                    index = -1;
                } else {
                    index = self.indexOf(search, offset);
                }
            }
            return index === -1 ? nil : index;
        }, $String_index$34.$$arity = -2);
        Opal.def(self36, '$inspect', $String_inspect$35 = function $$inspect() {
            var self = this;
            var escapable = /[\\\"\x00-\x1f\u007F-\u009F\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, meta3 = {
                '\u0007': '\\a',
                '\u001b': '\\e',
                '\b': '\\b',
                '\t': '\\t',
                '\n': '\\n',
                '\f': '\\f',
                '\r': '\\r',
                '\v': '\\v',
                '"': '\\"',
                '\\': '\\\\'
            }, escaped = self.replace(escapable, function(chr) {
                if (meta3[chr]) return meta3[chr];
                chr = chr.charCodeAt(0);
                if (chr <= 0xff && (self.encoding["$binary?"]() || self.internal_encoding["$binary?"]())) {
                    return '\\x' + ('00' + chr.toString(16).toUpperCase()).slice(-2);
                } else {
                    return '\\u' + ('0000' + chr.toString(16).toUpperCase()).slice(-4);
                }
            });
            return '"' + escaped.replace(/\#[\$\@\{]/g, '\\$&') + '"';
        }, $String_inspect$35.$$arity = 0);
        Opal.def(self36, '$intern', $String_intern$36 = function $$intern() {
            var self = this;
            return self.toString();
        }, $String_intern$36.$$arity = 0);
        Opal.def(self36, '$lines', $String_lines$37 = function $$lines(separator) {
            var $iter = $String_lines$37.$$p, block = $iter || nil, self = this, e = nil;
            if ($gvars["/"] == null) $gvars["/"] = nil;
            if ($iter) $String_lines$37.$$p = null;
            if ($iter) $String_lines$37.$$p = null;
            if (separator == null) {
                separator = $gvars["/"];
            }
            e = $send(self, 'each_line', [
                separator
            ], block.$to_proc());
            if ($truthy(block)) {
                return self;
            } else {
                return e.$to_a();
            }
        }, $String_lines$37.$$arity = -1);
        Opal.def(self36, '$ljust', $String_ljust$38 = function $$ljust(width, padstr) {
            var self = this;
            if (padstr == null) {
                padstr = " ";
            }
            width = $coerce_to(width, $$($nesting, 'Integer'), 'to_int');
            padstr = $coerce_to(padstr, $$($nesting, 'String'), 'to_str').$to_s();
            if ($truthy(padstr['$empty?']())) {
                self.$raise($$($nesting, 'ArgumentError'), "zero width padding");
            }
            if ($truthy(width <= self.length)) {
                return self;
            }
            var index = -1, result = "";
            width -= self.length;
            while(++index < width){
                result += padstr;
            }
            return self.$$cast(self + result.slice(0, width));
        }, $String_ljust$38.$$arity = -2);
        Opal.def(self36, '$lstrip', $String_lstrip$39 = function $$lstrip() {
            var self = this;
            return self.replace(/^\s*/, '');
        }, $String_lstrip$39.$$arity = 0);
        Opal.def(self36, '$ascii_only?', $String_ascii_only$ques$40 = function() {
            var self = this;
            if (!self.encoding.ascii) return false;
            return /^[\x00-\x7F]*$/.test(self);
        }, $String_ascii_only$ques$40.$$arity = 0);
        Opal.def(self36, '$match', $String_match$41 = function $$match(pattern, pos) {
            var $iter = $String_match$41.$$p, block = $iter || nil, self = this, $ret_or_1 = nil;
            if ($iter) $String_match$41.$$p = null;
            if ($iter) $String_match$41.$$p = null;
            if ($truthy(function() {
                if ($truthy($ret_or_1 = $$($nesting, 'String')['$==='](pattern))) {
                    return $ret_or_1;
                } else {
                    return pattern['$respond_to?']("to_str");
                }
                return nil;
            }())) {
                pattern = $$($nesting, 'Regexp').$new(pattern.$to_str());
            }
            if ($truthy($$($nesting, 'Regexp')['$==='](pattern))) {} else {
                self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + pattern.$class() + " (expected Regexp)");
            }
            return $send(pattern, 'match', [
                self,
                pos
            ], block.$to_proc());
        }, $String_match$41.$$arity = -2);
        Opal.def(self36, '$match?', $String_match$ques$42 = function(pattern, pos) {
            var self = this, $ret_or_2 = nil;
            if ($truthy(function() {
                if ($truthy($ret_or_2 = $$($nesting, 'String')['$==='](pattern))) {
                    return $ret_or_2;
                } else {
                    return pattern['$respond_to?']("to_str");
                }
                return nil;
            }())) {
                pattern = $$($nesting, 'Regexp').$new(pattern.$to_str());
            }
            if ($truthy($$($nesting, 'Regexp')['$==='](pattern))) {} else {
                self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + pattern.$class() + " (expected Regexp)");
            }
            return pattern['$match?'](self, pos);
        }, $String_match$ques$42.$$arity = -2);
        Opal.def(self36, '$next', $String_next$43 = function $$next() {
            var self = this;
            var i179 = self.length;
            if (i179 === 0) {
                return self.$$cast('');
            }
            var result = self;
            var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);
            var carry = false;
            var code;
            while(i179--){
                code = self.charCodeAt(i179);
                if (code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122) {
                    switch(code){
                        case 57:
                            carry = true;
                            code = 48;
                            break;
                        case 90:
                            carry = true;
                            code = 65;
                            break;
                        case 122:
                            carry = true;
                            code = 97;
                            break;
                        default:
                            carry = false;
                            code += 1;
                    }
                } else {
                    if (first_alphanum_char_index === -1) {
                        if (code === 255) {
                            carry = true;
                            code = 0;
                        } else {
                            carry = false;
                            code += 1;
                        }
                    } else {
                        carry = true;
                    }
                }
                result = result.slice(0, i179) + String.fromCharCode(code) + result.slice(i179 + 1);
                if (carry && (i179 === 0 || i179 === first_alphanum_char_index)) {
                    switch(code){
                        case 65:
                            break;
                        case 97:
                            break;
                        default:
                            code += 1;
                    }
                    if (i179 === 0) {
                        result = String.fromCharCode(code) + result;
                    } else {
                        result = result.slice(0, i179) + String.fromCharCode(code) + result.slice(i179);
                    }
                    carry = false;
                }
                if (!carry) {
                    break;
                }
            }
            return self.$$cast(result);
        }, $String_next$43.$$arity = 0);
        Opal.def(self36, '$oct', $String_oct$44 = function $$oct() {
            var self = this;
            var result, string = self, radix = 8;
            if (/^\s*_/.test(string)) {
                return 0;
            }
            string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/i, function(original, head, flag, tail) {
                switch(tail.charAt(0)){
                    case '+':
                    case '-':
                        return original;
                    case '0':
                        if (tail.charAt(1) === 'x' && flag === '0x') {
                            return original;
                        }
                }
                switch(flag){
                    case '0b':
                        radix = 2;
                        break;
                    case '0':
                    case '0o':
                        radix = 8;
                        break;
                    case '0d':
                        radix = 10;
                        break;
                    case '0x':
                        radix = 16;
                        break;
                }
                return head + tail;
            });
            result = parseInt(string.replace(/_(?!_)/g, ''), radix);
            return isNaN(result) ? 0 : result;
        }, $String_oct$44.$$arity = 0);
        Opal.def(self36, '$ord', $String_ord$45 = function $$ord() {
            var self = this;
            if (typeof self.codePointAt === "function") {
                return self.codePointAt(0);
            } else {
                return self.charCodeAt(0);
            }
        }, $String_ord$45.$$arity = 0);
        Opal.def(self36, '$partition', $String_partition$46 = function $$partition(sep13) {
            var self = this;
            var i180, m;
            if (sep13.$$is_regexp) {
                m = sep13.exec(self);
                if (m === null) {
                    i180 = -1;
                } else {
                    $$($nesting, 'MatchData').$new(sep13, m);
                    sep13 = m[0];
                    i180 = m.index;
                }
            } else {
                sep13 = $coerce_to(sep13, $$($nesting, 'String'), 'to_str');
                i180 = self.indexOf(sep13);
            }
            if (i180 === -1) {
                return [
                    self,
                    '',
                    ''
                ];
            }
            return [
                self.slice(0, i180),
                self.slice(i180, i180 + sep13.length),
                self.slice(i180 + sep13.length)
            ];
        }, $String_partition$46.$$arity = 1);
        Opal.def(self36, '$reverse', $String_reverse$47 = function $$reverse() {
            var self = this;
            return self.split('').reverse().join('');
        }, $String_reverse$47.$$arity = 0);
        Opal.def(self36, '$rindex', $String_rindex$48 = function $$rindex(search, offset) {
            var self = this;
            var i181, m, r, _m;
            if (offset === undefined) {
                offset = self.length;
            } else {
                offset = $coerce_to(offset, $$($nesting, 'Integer'), 'to_int');
                if (offset < 0) {
                    offset += self.length;
                    if (offset < 0) {
                        return nil;
                    }
                }
            }
            if (search.$$is_regexp) {
                m = null;
                r = Opal.global_multiline_regexp(search);
                while(true){
                    _m = r.exec(self);
                    if (_m === null || _m.index > offset) {
                        break;
                    }
                    m = _m;
                    r.lastIndex = m.index + 1;
                }
                if (m === null) {
                    $gvars["~"] = nil;
                    i181 = -1;
                } else {
                    $$($nesting, 'MatchData').$new(r, m);
                    i181 = m.index;
                }
            } else {
                search = $coerce_to(search, $$($nesting, 'String'), 'to_str');
                i181 = self.lastIndexOf(search, offset);
            }
            return i181 === -1 ? nil : i181;
        }, $String_rindex$48.$$arity = -2);
        Opal.def(self36, '$rjust', $String_rjust$49 = function $$rjust(width, padstr) {
            var self = this;
            if (padstr == null) {
                padstr = " ";
            }
            width = $coerce_to(width, $$($nesting, 'Integer'), 'to_int');
            padstr = $coerce_to(padstr, $$($nesting, 'String'), 'to_str').$to_s();
            if ($truthy(padstr['$empty?']())) {
                self.$raise($$($nesting, 'ArgumentError'), "zero width padding");
            }
            if ($truthy(width <= self.length)) {
                return self;
            }
            var chars = Math.floor(width - self.length), patterns = Math.floor(chars / padstr.length), result = Array(patterns + 1).join(padstr), remaining = chars - result.length;
            return self.$$cast(result + padstr.slice(0, remaining) + self);
        }, $String_rjust$49.$$arity = -2);
        Opal.def(self36, '$rpartition', $String_rpartition$50 = function $$rpartition(sep14) {
            var self = this;
            var i182, m, r, _m;
            if (sep14.$$is_regexp) {
                m = null;
                r = Opal.global_multiline_regexp(sep14);
                while(true){
                    _m = r.exec(self);
                    if (_m === null) {
                        break;
                    }
                    m = _m;
                    r.lastIndex = m.index + 1;
                }
                if (m === null) {
                    i182 = -1;
                } else {
                    $$($nesting, 'MatchData').$new(r, m);
                    sep14 = m[0];
                    i182 = m.index;
                }
            } else {
                sep14 = $coerce_to(sep14, $$($nesting, 'String'), 'to_str');
                i182 = self.lastIndexOf(sep14);
            }
            if (i182 === -1) {
                return [
                    '',
                    '',
                    self
                ];
            }
            return [
                self.slice(0, i182),
                self.slice(i182, i182 + sep14.length),
                self.slice(i182 + sep14.length)
            ];
        }, $String_rpartition$50.$$arity = 1);
        Opal.def(self36, '$rstrip', $String_rstrip$51 = function $$rstrip() {
            var self = this;
            return self.replace(/[\s\u0000]*$/, '');
        }, $String_rstrip$51.$$arity = 0);
        Opal.def(self36, '$scan', $String_scan$52 = function $$scan(pattern) {
            var $iter = $String_scan$52.$$p, block = $iter || nil, self = this;
            if ($iter) $String_scan$52.$$p = null;
            if ($iter) $String_scan$52.$$p = null;
            var result = [], match_data = nil, match;
            if (pattern.$$is_regexp) {
                pattern = Opal.global_multiline_regexp(pattern);
            } else {
                pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str');
                pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
            }
            while((match = pattern.exec(self)) != null){
                match_data = $$($nesting, 'MatchData').$new(pattern, match);
                if (block === nil) {
                    match.length == 1 ? result.push(match[0]) : result.push(match_data.$captures());
                } else {
                    match.length == 1 ? block(match[0]) : block.call(self, match_data.$captures());
                }
                if (pattern.lastIndex === match.index) {
                    pattern.lastIndex += 1;
                }
            }
            $gvars["~"] = match_data;
            return block !== nil ? self : result;
        }, $String_scan$52.$$arity = 1);
        Opal.alias(self36, "slice", "[]");
        Opal.def(self36, '$split', $String_split$53 = function $$split(pattern, limit) {
            var self = this, $ret_or_3 = nil;
            if ($gvars[";"] == null) $gvars[";"] = nil;
            if (self.length === 0) {
                return [];
            }
            if (limit === undefined) {
                limit = 0;
            } else {
                limit = $$($nesting, 'Opal')['$coerce_to!'](limit, $$($nesting, 'Integer'), "to_int");
                if (limit === 1) {
                    return [
                        self
                    ];
                }
            }
            if (pattern === undefined || pattern === nil) {
                pattern = function() {
                    if ($truthy($ret_or_3 = $gvars[";"])) {
                        return $ret_or_3;
                    } else {
                        return " ";
                    }
                    return nil;
                }();
            }
            var result = [], string = self.toString(), index = 0, match, i183, ii;
            if (pattern.$$is_regexp) {
                pattern = Opal.global_multiline_regexp(pattern);
            } else {
                pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str').$to_s();
                if (pattern === ' ') {
                    pattern = /\s+/gm;
                    string = string.replace(/^\s+/, '');
                } else {
                    pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
                }
            }
            result = string.split(pattern);
            if (result.length === 1 && result[0] === string) {
                return [
                    self.$$cast(result[0])
                ];
            }
            while((i183 = result.indexOf(undefined)) !== -1){
                result.splice(i183, 1);
            }
            function castResult() {
                for(i183 = 0; i183 < result.length; i183++){
                    result[i183] = self.$$cast(result[i183]);
                }
            }
            if (limit === 0) {
                while(result[result.length - 1] === ''){
                    result.length -= 1;
                }
                castResult();
                return result;
            }
            match = pattern.exec(string);
            if (limit < 0) {
                if (match !== null && match[0] === '' && pattern.source.indexOf('(?=') === -1) {
                    for(i183 = 0, ii = match.length; i183 < ii; i183++){
                        result.push('');
                    }
                }
                castResult();
                return result;
            }
            if (match !== null && match[0] === '') {
                result.splice(limit - 1, result.length - 1, result.slice(limit - 1).join(''));
                castResult();
                return result;
            }
            if (limit >= result.length) {
                castResult();
                return result;
            }
            i183 = 0;
            while(match !== null){
                i183++;
                index = pattern.lastIndex;
                if (i183 + 1 === limit) {
                    break;
                }
                match = pattern.exec(string);
            }
            result.splice(limit - 1, result.length - 1, string.slice(index));
            castResult();
            return result;
        }, $String_split$53.$$arity = -1);
        Opal.def(self36, '$squeeze', $String_squeeze$54 = function $$squeeze($a) {
            var $post_args, sets, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            sets = $post_args;
            if (sets.length === 0) {
                return self.$$cast(self.replace(/(.)\1+/g, '$1'));
            }
            var char_class = char_class_from_char_sets(sets);
            if (char_class === null) {
                return self;
            }
            return self.$$cast(self.replace(new RegExp('(' + char_class + ')\\1+', 'g'), '$1'));
        }, $String_squeeze$54.$$arity = -1);
        Opal.def(self36, '$start_with?', $String_start_with$ques$55 = function($a) {
            var $post_args, prefixes, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            prefixes = $post_args;
            for(var i184 = 0, length = prefixes.length; i184 < length; i184++){
                if (prefixes[i184].$$is_regexp) {
                    var regexp = prefixes[i184];
                    var match = regexp.exec(self);
                    if (match != null && match.index === 0) {
                        $gvars["~"] = $$($nesting, 'MatchData').$new(regexp, match);
                        return true;
                    } else {
                        $gvars["~"] = nil;
                    }
                } else {
                    var prefix = $coerce_to(prefixes[i184], $$($nesting, 'String'), 'to_str').$to_s();
                    if (self.indexOf(prefix) === 0) {
                        return true;
                    }
                }
            }
            return false;
        }, $String_start_with$ques$55.$$arity = -1);
        Opal.def(self36, '$strip', $String_strip$56 = function $$strip() {
            var self = this;
            return self.replace(/^\s*/, '').replace(/[\s\u0000]*$/, '');
        }, $String_strip$56.$$arity = 0);
        Opal.def(self36, '$sub', $String_sub$57 = function $$sub(pattern, replacement) {
            var $iter = $String_sub$57.$$p, block = $iter || nil, self = this;
            if ($iter) $String_sub$57.$$p = null;
            if ($iter) $String_sub$57.$$p = null;
            if (!pattern.$$is_regexp) {
                pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str');
                pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
            }
            var result, match = pattern.exec(self);
            if (match === null) {
                $gvars["~"] = nil;
                result = self.toString();
            } else {
                $$($nesting, 'MatchData').$new(pattern, match);
                if (replacement === undefined) {
                    if (block === nil) {
                        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (1 for 2)");
                    }
                    result = self.slice(0, match.index) + block(match[0]) + self.slice(match.index + match[0].length);
                } else if (replacement.$$is_hash) {
                    result = self.slice(0, match.index) + replacement['$[]'](match[0]).$to_s() + self.slice(match.index + match[0].length);
                } else {
                    replacement = $coerce_to(replacement, $$($nesting, 'String'), 'to_str');
                    replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function(original, slashes, command) {
                        if (slashes.length % 2 === 0) {
                            return original;
                        }
                        switch(command){
                            case "+":
                                for(var i185 = match.length - 1; i185 > 0; i185--){
                                    if (match[i185] !== undefined) {
                                        return slashes.slice(1) + match[i185];
                                    }
                                }
                                return '';
                            case "&":
                                return slashes.slice(1) + match[0];
                            case "`":
                                return slashes.slice(1) + self.slice(0, match.index);
                            case "'":
                                return slashes.slice(1) + self.slice(match.index + match[0].length);
                            default:
                                return slashes.slice(1) + (match[command] || '');
                        }
                    }).replace(/\\\\/g, '\\');
                    result = self.slice(0, match.index) + replacement + self.slice(match.index + match[0].length);
                }
            }
            return self.$$cast(result);
        }, $String_sub$57.$$arity = -2);
        Opal.alias(self36, "succ", "next");
        Opal.def(self36, '$sum', $String_sum$58 = function $$sum(n) {
            var self = this;
            if (n == null) {
                n = 16;
            }
            n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
            var result = 0, length = self.length, i186 = 0;
            for(; i186 < length; i186++){
                result += self.charCodeAt(i186);
            }
            if (n <= 0) {
                return result;
            }
            return result & Math.pow(2, n) - 1;
        }, $String_sum$58.$$arity = -1);
        Opal.def(self36, '$swapcase', $String_swapcase$59 = function $$swapcase() {
            var self = this;
            var str = self.replace(/([a-z]+)|([A-Z]+)/g, function($0, $1, $2) {
                return $1 ? $0.toUpperCase() : $0.toLowerCase();
            });
            if (self.constructor === String) {
                return str;
            }
            return self.$class().$new(str);
        }, $String_swapcase$59.$$arity = 0);
        Opal.def(self36, '$to_f', $String_to_f$60 = function $$to_f() {
            var self = this;
            if (self.charAt(0) === '_') {
                return 0;
            }
            var result = parseFloat(self.replace(/_/g, ''));
            if (isNaN(result) || result == Infinity || result == -Infinity) {
                return 0;
            } else {
                return result;
            }
        }, $String_to_f$60.$$arity = 0);
        Opal.def(self36, '$to_i', $String_to_i$61 = function $$to_i(base11) {
            var self = this;
            if (base11 == null) {
                base11 = 10;
            }
            var result, string = self.toLowerCase(), radix = $coerce_to(base11, $$($nesting, 'Integer'), 'to_int');
            if (radix === 1 || radix < 0 || radix > 36) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + radix);
            }
            if (/^\s*_/.test(string)) {
                return 0;
            }
            string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/, function(original, head, flag, tail) {
                switch(tail.charAt(0)){
                    case '+':
                    case '-':
                        return original;
                    case '0':
                        if (tail.charAt(1) === 'x' && flag === '0x' && (radix === 0 || radix === 16)) {
                            return original;
                        }
                }
                switch(flag){
                    case '0b':
                        if (radix === 0 || radix === 2) {
                            radix = 2;
                            return head + tail;
                        }
                        break;
                    case '0':
                    case '0o':
                        if (radix === 0 || radix === 8) {
                            radix = 8;
                            return head + tail;
                        }
                        break;
                    case '0d':
                        if (radix === 0 || radix === 10) {
                            radix = 10;
                            return head + tail;
                        }
                        break;
                    case '0x':
                        if (radix === 0 || radix === 16) {
                            radix = 16;
                            return head + tail;
                        }
                        break;
                }
                return original;
            });
            result = parseInt(string.replace(/_(?!_)/g, ''), radix);
            return isNaN(result) ? 0 : result;
        }, $String_to_i$61.$$arity = -1);
        Opal.def(self36, '$to_proc', $String_to_proc$62 = function $$to_proc() {
            var $$63, $iter1 = $String_to_proc$62.$$p, self37 = this, method_name = nil;
            if ($iter1) $String_to_proc$62.$$p = null;
            method_name = $rb_plus("$", self37.valueOf());
            return $send(self37, 'proc', [], ($$63 = function($a) {
                var self = $$63.$$s == null ? this : $$63.$$s, $iter = $$63.$$p, block = $iter || nil, $post_args, args36;
                if ($iter) $$63.$$p = null;
                $post_args = Opal.slice.call(arguments, 0, arguments.length);
                args36 = $post_args;
                if (args36.length === 0) {
                    self.$raise($$($nesting, 'ArgumentError'), "no receiver given");
                }
                var recv = args36[0];
                if (recv == null) recv = nil;
                var body = recv[method_name];
                if (!body) {
                    return recv.$method_missing.apply(recv, args36);
                }
                if (typeof block === 'function') {
                    body.$$p = block;
                }
                if (args36.length === 1) {
                    return body.call(recv);
                } else {
                    return body.apply(recv, args36.slice(1));
                }
            }, $$63.$$s = self37, $$63.$$arity = -1, $$63));
        }, $String_to_proc$62.$$arity = 0);
        Opal.def(self36, '$to_s', $String_to_s$64 = function $$to_s() {
            var self = this;
            return self.toString();
        }, $String_to_s$64.$$arity = 0);
        Opal.alias(self36, "to_str", "to_s");
        Opal.alias(self36, "to_sym", "intern");
        Opal.def(self36, '$tr', $String_tr$65 = function $$tr(from, to) {
            var self = this;
            from = $coerce_to(from, $$($nesting, 'String'), 'to_str').$to_s();
            to = $coerce_to(to, $$($nesting, 'String'), 'to_str').$to_s();
            if (from.length == 0 || from === to) {
                return self;
            }
            var i187, in_range, c, ch, start, end, length;
            var subs = {};
            var from_chars = from.split('');
            var from_length = from_chars.length;
            var to_chars = to.split('');
            var to_length = to_chars.length;
            var inverse = false;
            var global_sub = null;
            if (from_chars[0] === '^' && from_chars.length > 1) {
                inverse = true;
                from_chars.shift();
                global_sub = to_chars[to_length - 1];
                from_length -= 1;
            }
            var from_chars_expanded = [];
            var last_from = null;
            in_range = false;
            for(i187 = 0; i187 < from_length; i187++){
                ch = from_chars[i187];
                if (last_from == null) {
                    last_from = ch;
                    from_chars_expanded.push(ch);
                } else if (ch === '-') {
                    if (last_from === '-') {
                        from_chars_expanded.push('-');
                        from_chars_expanded.push('-');
                    } else if (i187 == from_length - 1) {
                        from_chars_expanded.push('-');
                    } else {
                        in_range = true;
                    }
                } else if (in_range) {
                    start = last_from.charCodeAt(0);
                    end = ch.charCodeAt(0);
                    if (start > end) {
                        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + String.fromCharCode(start) + "-" + String.fromCharCode(end) + "\" in string transliteration");
                    }
                    for(c = start + 1; c < end; c++){
                        from_chars_expanded.push(String.fromCharCode(c));
                    }
                    from_chars_expanded.push(ch);
                    in_range = null;
                    last_from = null;
                } else {
                    from_chars_expanded.push(ch);
                }
            }
            from_chars = from_chars_expanded;
            from_length = from_chars.length;
            if (inverse) {
                for(i187 = 0; i187 < from_length; i187++){
                    subs[from_chars[i187]] = true;
                }
            } else {
                if (to_length > 0) {
                    var to_chars_expanded = [];
                    var last_to = null;
                    in_range = false;
                    for(i187 = 0; i187 < to_length; i187++){
                        ch = to_chars[i187];
                        if (last_to == null) {
                            last_to = ch;
                            to_chars_expanded.push(ch);
                        } else if (ch === '-') {
                            if (last_to === '-') {
                                to_chars_expanded.push('-');
                                to_chars_expanded.push('-');
                            } else if (i187 == to_length - 1) {
                                to_chars_expanded.push('-');
                            } else {
                                in_range = true;
                            }
                        } else if (in_range) {
                            start = last_to.charCodeAt(0);
                            end = ch.charCodeAt(0);
                            if (start > end) {
                                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + String.fromCharCode(start) + "-" + String.fromCharCode(end) + "\" in string transliteration");
                            }
                            for(c = start + 1; c < end; c++){
                                to_chars_expanded.push(String.fromCharCode(c));
                            }
                            to_chars_expanded.push(ch);
                            in_range = null;
                            last_to = null;
                        } else {
                            to_chars_expanded.push(ch);
                        }
                    }
                    to_chars = to_chars_expanded;
                    to_length = to_chars.length;
                }
                var length_diff = from_length - to_length;
                if (length_diff > 0) {
                    var pad_char = to_length > 0 ? to_chars[to_length - 1] : '';
                    for(i187 = 0; i187 < length_diff; i187++){
                        to_chars.push(pad_char);
                    }
                }
                for(i187 = 0; i187 < from_length; i187++){
                    subs[from_chars[i187]] = to_chars[i187];
                }
            }
            var new_str = '';
            for(i187 = 0, length = self.length; i187 < length; i187++){
                ch = self.charAt(i187);
                var sub = subs[ch];
                if (inverse) {
                    new_str += sub == null ? global_sub : ch;
                } else {
                    new_str += sub != null ? sub : ch;
                }
            }
            return self.$$cast(new_str);
        }, $String_tr$65.$$arity = 2);
        Opal.def(self36, '$tr_s', $String_tr_s$66 = function $$tr_s(from, to) {
            var self = this;
            from = $coerce_to(from, $$($nesting, 'String'), 'to_str').$to_s();
            to = $coerce_to(to, $$($nesting, 'String'), 'to_str').$to_s();
            if (from.length == 0) {
                return self;
            }
            var i188, in_range, c, ch, start, end, length;
            var subs = {};
            var from_chars = from.split('');
            var from_length = from_chars.length;
            var to_chars = to.split('');
            var to_length = to_chars.length;
            var inverse = false;
            var global_sub = null;
            if (from_chars[0] === '^' && from_chars.length > 1) {
                inverse = true;
                from_chars.shift();
                global_sub = to_chars[to_length - 1];
                from_length -= 1;
            }
            var from_chars_expanded = [];
            var last_from = null;
            in_range = false;
            for(i188 = 0; i188 < from_length; i188++){
                ch = from_chars[i188];
                if (last_from == null) {
                    last_from = ch;
                    from_chars_expanded.push(ch);
                } else if (ch === '-') {
                    if (last_from === '-') {
                        from_chars_expanded.push('-');
                        from_chars_expanded.push('-');
                    } else if (i188 == from_length - 1) {
                        from_chars_expanded.push('-');
                    } else {
                        in_range = true;
                    }
                } else if (in_range) {
                    start = last_from.charCodeAt(0);
                    end = ch.charCodeAt(0);
                    if (start > end) {
                        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + String.fromCharCode(start) + "-" + String.fromCharCode(end) + "\" in string transliteration");
                    }
                    for(c = start + 1; c < end; c++){
                        from_chars_expanded.push(String.fromCharCode(c));
                    }
                    from_chars_expanded.push(ch);
                    in_range = null;
                    last_from = null;
                } else {
                    from_chars_expanded.push(ch);
                }
            }
            from_chars = from_chars_expanded;
            from_length = from_chars.length;
            if (inverse) {
                for(i188 = 0; i188 < from_length; i188++){
                    subs[from_chars[i188]] = true;
                }
            } else {
                if (to_length > 0) {
                    var to_chars_expanded = [];
                    var last_to = null;
                    in_range = false;
                    for(i188 = 0; i188 < to_length; i188++){
                        ch = to_chars[i188];
                        if (last_from == null) {
                            last_from = ch;
                            to_chars_expanded.push(ch);
                        } else if (ch === '-') {
                            if (last_to === '-') {
                                to_chars_expanded.push('-');
                                to_chars_expanded.push('-');
                            } else if (i188 == to_length - 1) {
                                to_chars_expanded.push('-');
                            } else {
                                in_range = true;
                            }
                        } else if (in_range) {
                            start = last_from.charCodeAt(0);
                            end = ch.charCodeAt(0);
                            if (start > end) {
                                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + String.fromCharCode(start) + "-" + String.fromCharCode(end) + "\" in string transliteration");
                            }
                            for(c = start + 1; c < end; c++){
                                to_chars_expanded.push(String.fromCharCode(c));
                            }
                            to_chars_expanded.push(ch);
                            in_range = null;
                            last_from = null;
                        } else {
                            to_chars_expanded.push(ch);
                        }
                    }
                    to_chars = to_chars_expanded;
                    to_length = to_chars.length;
                }
                var length_diff = from_length - to_length;
                if (length_diff > 0) {
                    var pad_char = to_length > 0 ? to_chars[to_length - 1] : '';
                    for(i188 = 0; i188 < length_diff; i188++){
                        to_chars.push(pad_char);
                    }
                }
                for(i188 = 0; i188 < from_length; i188++){
                    subs[from_chars[i188]] = to_chars[i188];
                }
            }
            var new_str = '';
            var last_substitute = null;
            for(i188 = 0, length = self.length; i188 < length; i188++){
                ch = self.charAt(i188);
                var sub = subs[ch];
                if (inverse) {
                    if (sub == null) {
                        if (last_substitute == null) {
                            new_str += global_sub;
                            last_substitute = true;
                        }
                    } else {
                        new_str += ch;
                        last_substitute = null;
                    }
                } else {
                    if (sub != null) {
                        if (last_substitute == null || last_substitute !== sub) {
                            new_str += sub;
                            last_substitute = sub;
                        }
                    } else {
                        new_str += ch;
                        last_substitute = null;
                    }
                }
            }
            return self.$$cast(new_str);
        }, $String_tr_s$66.$$arity = 2);
        Opal.def(self36, '$upcase', $String_upcase$67 = function $$upcase() {
            var self = this;
            return self.$$cast(self.toUpperCase());
        }, $String_upcase$67.$$arity = 0);
        Opal.def(self36, '$upto', $String_upto$68 = function $$upto(stop, excl) {
            var $iter = $String_upto$68.$$p, block = $iter || nil, self = this;
            if ($iter) $String_upto$68.$$p = null;
            if ($iter) $String_upto$68.$$p = null;
            if (excl == null) {
                excl = false;
            }
            if (block !== nil) {} else {
                return self.$enum_for("upto", stop, excl);
            }
            var a, b, s = self.toString();
            stop = $coerce_to(stop, $$($nesting, 'String'), 'to_str');
            if (s.length === 1 && stop.length === 1) {
                a = s.charCodeAt(0);
                b = stop.charCodeAt(0);
                while(a <= b){
                    if (excl && a === b) {
                        break;
                    }
                    block(String.fromCharCode(a));
                    a += 1;
                }
            } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {
                a = parseInt(s, 10);
                b = parseInt(stop, 10);
                while(a <= b){
                    if (excl && a === b) {
                        break;
                    }
                    block(a.toString());
                    a += 1;
                }
            } else {
                while(s.length <= stop.length && s <= stop){
                    if (excl && s === stop) {
                        break;
                    }
                    block(s);
                    s = s.$succ();
                }
            }
            return self;
        }, $String_upto$68.$$arity = -2);
        function char_class_from_char_sets(sets) {
            function explode_sequences_in_character_set(set) {
                var result = '', i189, len = set.length, curr_char, skip_next_dash, char_code_from, char_code_upto, char_code;
                for(i189 = 0; i189 < len; i189++){
                    curr_char = set.charAt(i189);
                    if (curr_char === '-' && i189 > 0 && i189 < len - 1 && !skip_next_dash) {
                        char_code_from = set.charCodeAt(i189 - 1);
                        char_code_upto = set.charCodeAt(i189 + 1);
                        if (char_code_from > char_code_upto) {
                            self36.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + char_code_from + "-" + char_code_upto + "\" in string transliteration");
                        }
                        for(char_code = char_code_from + 1; char_code < char_code_upto + 1; char_code++){
                            result += String.fromCharCode(char_code);
                        }
                        skip_next_dash = true;
                        i189++;
                    } else {
                        skip_next_dash = curr_char === '\\';
                        result += curr_char;
                    }
                }
                return result;
            }
            function intersection(setA, setB) {
                if (setA.length === 0) {
                    return setB;
                }
                var result = '', i190, len = setA.length, chr;
                for(i190 = 0; i190 < len; i190++){
                    chr = setA.charAt(i190);
                    if (setB.indexOf(chr) !== -1) {
                        result += chr;
                    }
                }
                return result;
            }
            var i191, len1, set1, neg, chr1, tmp, pos_intersection = '', neg_intersection = '';
            for(i191 = 0, len1 = sets.length; i191 < len1; i191++){
                set1 = $coerce_to(sets[i191], $$($nesting, 'String'), 'to_str');
                neg = set1.charAt(0) === '^' && set1.length > 1;
                set1 = explode_sequences_in_character_set(neg ? set1.slice(1) : set1);
                if (neg) {
                    neg_intersection = intersection(neg_intersection, set1);
                } else {
                    pos_intersection = intersection(pos_intersection, set1);
                }
            }
            if (pos_intersection.length > 0 && neg_intersection.length > 0) {
                tmp = '';
                for(i191 = 0, len1 = pos_intersection.length; i191 < len1; i191++){
                    chr1 = pos_intersection.charAt(i191);
                    if (neg_intersection.indexOf(chr1) === -1) {
                        tmp += chr1;
                    }
                }
                pos_intersection = tmp;
                neg_intersection = '';
            }
            if (pos_intersection.length > 0) {
                return '[' + $$($nesting, 'Regexp').$escape(pos_intersection) + ']';
            }
            if (neg_intersection.length > 0) {
                return '[^' + $$($nesting, 'Regexp').$escape(neg_intersection) + ']';
            }
            return null;
        }
        Opal.def(self36, '$instance_variables', $String_instance_variables$69 = function $$instance_variables() {
            return [];
        }, $String_instance_variables$69.$$arity = 0);
        Opal.defs(self36, '$_load', $String__load$70 = function $$_load($a) {
            var $post_args, args37, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args37 = $post_args;
            return $send(self, 'new', Opal.to_a(args37));
        }, $String__load$70.$$arity = -1);
        Opal.def(self36, '$unicode_normalize', $String_unicode_normalize$71 = function $$unicode_normalize(form) {
            var self = this;
            if (form == null) {
                form = "nfc";
            }
            if ($truthy([
                "nfc",
                "nfd",
                "nfkc",
                "nfkd"
            ]['$include?'](form))) {} else {
                self.$raise($$($nesting, 'ArgumentError'), "" + "Invalid normalization form " + form);
            }
            return self.normalize(form.$upcase());
        }, $String_unicode_normalize$71.$$arity = -1);
        Opal.def(self36, '$unicode_normalized?', $String_unicode_normalized$ques$72 = function(form) {
            var self = this;
            if (form == null) {
                form = "nfc";
            }
            return self.$unicode_normalize(form)['$=='](self);
        }, $String_unicode_normalized$ques$72.$$arity = -1);
        Opal.def(self36, '$unpack', $String_unpack$73 = function $$unpack(format) {
            var self = this;
            return self.$raise("To use String#unpack, you must first require 'corelib/string/unpack'.");
        }, $String_unpack$73.$$arity = 1);
        Opal.def(self36, '$unpack1', $String_unpack1$74 = function $$unpack1(format) {
            var self = this;
            return self.$raise("To use String#unpack1, you must first require 'corelib/string/unpack'.");
        }, $String_unpack1$74.$$arity = 1);
        Opal.def(self36, '$freeze', $String_freeze$75 = function $$freeze() {
            var self = this;
            if (typeof self === 'string') return self;
            self.$$frozen = true;
            return self;
        }, $String_freeze$75.$$arity = 0);
        Opal.alias(self36, "+@", "dup");
        Opal.def(self36, '$-@', $String_$minus$$76 = function() {
            var self = this;
            if (typeof self === 'string') return self;
            if (self.$$frozen === true) return self;
            if (self.encoding.name == 'UTF-8' && self.internal_encoding.name == 'UTF-8') return self.toString();
            return self.$dup().$freeze();
        }, $String_$minus$$76.$$arity = 0);
        Opal.def(self36, '$frozen?', $String_frozen$ques$77 = function() {
            var self = this;
            return typeof self === 'string' || self.$$frozen === true;
        }, $String_frozen$ques$77.$$arity = 0);
        return $$($nesting, 'Opal').$pristine(self36, "initialize");
    })($nesting13[0], String, $nesting13);
    return Opal.const_set($nesting13[0], 'Symbol', $$($nesting13, 'String'));
};
Opal.modules["corelib/enumerable"] = function(Opal) {
    function $rb_gt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs > rhs : lhs['$>'](rhs);
    }
    function $rb_times(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs * rhs : lhs['$*'](rhs);
    }
    function $rb_lt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs < rhs : lhs['$<'](rhs);
    }
    function $rb_plus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
    }
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    function $rb_divide(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs / rhs : lhs['$/'](rhs);
    }
    function $rb_le(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs <= rhs : lhs['$<='](rhs);
    }
    var self38 = Opal.top, $nesting14 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $falsy = Opal.falsy, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $module = Opal.module, $send = Opal.send, $hash2 = Opal.hash2, $lambda = Opal.lambda;
    Opal.add_stubs([
        '$each',
        '$public_send',
        '$destructure',
        '$to_enum',
        '$enumerator_size',
        '$new',
        '$yield',
        '$raise',
        '$slice_when',
        '$!',
        '$enum_for',
        '$flatten',
        '$map',
        '$warn',
        '$proc',
        '$==',
        '$nil?',
        '$respond_to?',
        '$coerce_to!',
        '$>',
        '$*',
        '$try_convert',
        '$<',
        '$+',
        '$-',
        '$ceil',
        '$/',
        '$size',
        '$select',
        '$to_proc',
        '$__send__',
        '$length',
        '$<=',
        '$[]',
        '$push',
        '$<<',
        '$[]=',
        '$===',
        '$inspect',
        '$<=>',
        '$first',
        '$reverse',
        '$sort',
        '$take',
        '$sort_by',
        '$compare',
        '$call',
        '$dup',
        '$to_a',
        '$sort!',
        '$map!',
        '$key?',
        '$values',
        '$transform_values',
        '$group_by',
        '$to_h',
        '$coerce_to?',
        '$class',
        '$zip'
    ]);
    return function($base, $parent_nesting) {
        var self39 = $module($base, 'Enumerable');
        var $nesting = [
            self39
        ].concat($parent_nesting), $Enumerable_all$ques$1, $Enumerable_any$ques$5, $Enumerable_chunk$9, $Enumerable_chunk_while$12, $Enumerable_collect$14, $Enumerable_collect_concat$16, $Enumerable_count$19, $Enumerable_cycle$23, $Enumerable_detect$25, $Enumerable_drop$27, $Enumerable_drop_while$28, $Enumerable_each_cons$29, $Enumerable_each_entry$31, $Enumerable_each_slice$33, $Enumerable_each_with_index$35, $Enumerable_each_with_object$37, $Enumerable_entries$39, $Enumerable_filter_map$40, $Enumerable_find_all$42, $Enumerable_find_index$44, $Enumerable_first$47, $Enumerable_grep$50, $Enumerable_grep_v$52, $Enumerable_group_by$54, $Enumerable_include$ques$56, $Enumerable_inject$58, $Enumerable_lazy$59, $Enumerable_enumerator_size$61, $Enumerable_max$62, $Enumerable_max_by$63, $Enumerable_min$65, $Enumerable_min_by$67, $Enumerable_minmax$69, $Enumerable_minmax_by$71, $Enumerable_none$ques$73, $Enumerable_one$ques$77, $Enumerable_partition$81, $Enumerable_reject$83, $Enumerable_reverse_each$85, $Enumerable_slice_before$87, $Enumerable_slice_after$89, $Enumerable_slice_when$92, $Enumerable_sort$94, $Enumerable_sort_by$96, $Enumerable_sum$101, $Enumerable_take$103, $Enumerable_take_while$104, $Enumerable_uniq$106, $Enumerable_tally$108, $Enumerable_to_h$109, $Enumerable_zip$110;
        function comparableForPattern(value) {
            if (value.length === 0) {
                value = [
                    nil
                ];
            }
            if (value.length > 1) {
                value = [
                    value
                ];
            }
            return value;
        }
        Opal.def(self39, '$all?', $Enumerable_all$ques$1 = function(pattern) {
            try {
                var $iter = $Enumerable_all$ques$1.$$p, block = $iter || nil, $$2, $$3, $$4, self = this;
                if ($iter) $Enumerable_all$ques$1.$$p = null;
                if ($iter) $Enumerable_all$ques$1.$$p = null;
                if ($truthy(pattern !== undefined)) {
                    $send(self, 'each', [], ($$2 = function($a) {
                        var self = $$2.$$s == null ? this : $$2.$$s, $post_args, value, comparable = nil;
                        $post_args = Opal.slice.call(arguments, 0, arguments.length);
                        value = $post_args;
                        comparable = comparableForPattern(value);
                        if ($truthy($send(pattern, 'public_send', [
                            "==="
                        ].concat(Opal.to_a(comparable))))) {
                            return nil;
                        } else {
                            Opal.ret(false);
                        }
                    }, $$2.$$s = self, $$2.$$arity = -1, $$2));
                } else if (block !== nil) {
                    $send(self, 'each', [], ($$3 = function($a) {
                        var self = $$3.$$s == null ? this : $$3.$$s, $post_args, value;
                        $post_args = Opal.slice.call(arguments, 0, arguments.length);
                        value = $post_args;
                        if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
                            return nil;
                        } else {
                            Opal.ret(false);
                        }
                    }, $$3.$$s = self, $$3.$$arity = -1, $$3));
                } else {
                    $send(self, 'each', [], ($$4 = function($a) {
                        var self = $$4.$$s == null ? this : $$4.$$s, $post_args, value;
                        $post_args = Opal.slice.call(arguments, 0, arguments.length);
                        value = $post_args;
                        if ($truthy($$($nesting, 'Opal').$destructure(value))) {
                            return nil;
                        } else {
                            Opal.ret(false);
                        }
                    }, $$4.$$s = self, $$4.$$arity = -1, $$4));
                }
                return true;
            } catch ($returner) {
                if ($returner === Opal.returner) {
                    return $returner.$v;
                }
                throw $returner;
            }
        }, $Enumerable_all$ques$1.$$arity = -1);
        Opal.def(self39, '$any?', $Enumerable_any$ques$5 = function(pattern) {
            try {
                var $iter = $Enumerable_any$ques$5.$$p, block = $iter || nil, $$6, $$7, $$8, self = this;
                if ($iter) $Enumerable_any$ques$5.$$p = null;
                if ($iter) $Enumerable_any$ques$5.$$p = null;
                if ($truthy(pattern !== undefined)) {
                    $send(self, 'each', [], ($$6 = function($a) {
                        var self = $$6.$$s == null ? this : $$6.$$s, $post_args, value, comparable = nil;
                        $post_args = Opal.slice.call(arguments, 0, arguments.length);
                        value = $post_args;
                        comparable = comparableForPattern(value);
                        if ($truthy($send(pattern, 'public_send', [
                            "==="
                        ].concat(Opal.to_a(comparable))))) {
                            Opal.ret(true);
                        } else {
                            return nil;
                        }
                    }, $$6.$$s = self, $$6.$$arity = -1, $$6));
                } else if (block !== nil) {
                    $send(self, 'each', [], ($$7 = function($a) {
                        var self = $$7.$$s == null ? this : $$7.$$s, $post_args, value;
                        $post_args = Opal.slice.call(arguments, 0, arguments.length);
                        value = $post_args;
                        if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
                            Opal.ret(true);
                        } else {
                            return nil;
                        }
                    }, $$7.$$s = self, $$7.$$arity = -1, $$7));
                } else {
                    $send(self, 'each', [], ($$8 = function($a) {
                        var self = $$8.$$s == null ? this : $$8.$$s, $post_args, value;
                        $post_args = Opal.slice.call(arguments, 0, arguments.length);
                        value = $post_args;
                        if ($truthy($$($nesting, 'Opal').$destructure(value))) {
                            Opal.ret(true);
                        } else {
                            return nil;
                        }
                    }, $$8.$$s = self, $$8.$$arity = -1, $$8));
                }
                return false;
            } catch ($returner) {
                if ($returner === Opal.returner) {
                    return $returner.$v;
                }
                throw $returner;
            }
        }, $Enumerable_any$ques$5.$$arity = -1);
        Opal.def(self39, '$chunk', $Enumerable_chunk$9 = function $$chunk() {
            var $iter = $Enumerable_chunk$9.$$p, block = $iter || nil, $$10, $$11, self40 = this;
            if ($iter) $Enumerable_chunk$9.$$p = null;
            if ($iter) $Enumerable_chunk$9.$$p = null;
            if (block !== nil) {} else {
                return $send(self40, 'to_enum', [
                    "chunk"
                ], ($$10 = function() {
                    var self = $$10.$$s == null ? this : $$10.$$s;
                    return self.$enumerator_size();
                }, $$10.$$s = self40, $$10.$$arity = 0, $$10));
            }
            return $send($$$('::', 'Enumerator'), 'new', [], ($$11 = function(yielder) {
                var self = $$11.$$s == null ? this : $$11.$$s;
                if (yielder == null) {
                    yielder = nil;
                }
                var previous = nil, accumulate = [];
                function releaseAccumulate() {
                    if (accumulate.length > 0) {
                        yielder.$yield(previous, accumulate);
                    }
                }
                self.$each.$$p = function(value) {
                    var key = Opal.yield1(block, value);
                    if (key === nil) {
                        releaseAccumulate();
                        accumulate = [];
                        previous = nil;
                    } else {
                        if (previous === nil || previous === key) {
                            accumulate.push(value);
                        } else {
                            releaseAccumulate();
                            accumulate = [
                                value
                            ];
                        }
                        previous = key;
                    }
                };
                self.$each();
                releaseAccumulate();
            }, $$11.$$s = self40, $$11.$$arity = 1, $$11));
        }, $Enumerable_chunk$9.$$arity = 0);
        Opal.def(self39, '$chunk_while', $Enumerable_chunk_while$12 = function $$chunk_while() {
            var $iter = $Enumerable_chunk_while$12.$$p, block = $iter || nil, $$13, self = this;
            if ($iter) $Enumerable_chunk_while$12.$$p = null;
            if ($iter) $Enumerable_chunk_while$12.$$p = null;
            if (block !== nil) {} else {
                self.$raise($$($nesting, 'ArgumentError'), "no block given");
            }
            return $send(self, 'slice_when', [], ($$13 = function(before, after) {
                $$13.$$s == null ? this : $$13.$$s;
                if (before == null) {
                    before = nil;
                }
                if (after == null) {
                    after = nil;
                }
                return Opal.yieldX(block, [
                    before,
                    after
                ])['$!']();
            }, $$13.$$s = self, $$13.$$arity = 2, $$13));
        }, $Enumerable_chunk_while$12.$$arity = 0);
        Opal.def(self39, '$collect', $Enumerable_collect$14 = function $$collect() {
            var $iter = $Enumerable_collect$14.$$p, block = $iter || nil, $$15, self41 = this;
            if ($iter) $Enumerable_collect$14.$$p = null;
            if ($iter) $Enumerable_collect$14.$$p = null;
            if (block !== nil) {} else {
                return $send(self41, 'enum_for', [
                    "collect"
                ], ($$15 = function() {
                    var self = $$15.$$s == null ? this : $$15.$$s;
                    return self.$enumerator_size();
                }, $$15.$$s = self41, $$15.$$arity = 0, $$15));
            }
            var result = [];
            self41.$each.$$p = function() {
                var value = Opal.yieldX(block, arguments);
                result.push(value);
            };
            self41.$each();
            return result;
        }, $Enumerable_collect$14.$$arity = 0);
        Opal.def(self39, '$collect_concat', $Enumerable_collect_concat$16 = function $$collect_concat() {
            var $iter = $Enumerable_collect_concat$16.$$p, block = $iter || nil, $$17, $$18, self42 = this;
            if ($iter) $Enumerable_collect_concat$16.$$p = null;
            if ($iter) $Enumerable_collect_concat$16.$$p = null;
            if (block !== nil) {} else {
                return $send(self42, 'enum_for', [
                    "collect_concat"
                ], ($$17 = function() {
                    var self = $$17.$$s == null ? this : $$17.$$s;
                    return self.$enumerator_size();
                }, $$17.$$s = self42, $$17.$$arity = 0, $$17));
            }
            return $send(self42, 'map', [], ($$18 = function(item) {
                $$18.$$s == null ? this : $$18.$$s;
                if (item == null) {
                    item = nil;
                }
                return Opal.yield1(block, item);
            }, $$18.$$s = self42, $$18.$$arity = 1, $$18)).$flatten(1);
        }, $Enumerable_collect_concat$16.$$arity = 0);
        Opal.def(self39, '$count', $Enumerable_count$19 = function $$count(object) {
            var $iter = $Enumerable_count$19.$$p, block = $iter || nil, $$20, $$21, $$22, self = this, result = nil;
            if ($iter) $Enumerable_count$19.$$p = null;
            if ($iter) $Enumerable_count$19.$$p = null;
            result = 0;
            if (object != null && block !== nil) {
                self.$warn("warning: given block not used");
            }
            if ($truthy(object != null)) {
                block = $send(self, 'proc', [], ($$20 = function($a) {
                    var self = $$20.$$s == null ? this : $$20.$$s, $post_args, args38;
                    $post_args = Opal.slice.call(arguments, 0, arguments.length);
                    args38 = $post_args;
                    return $$($nesting, 'Opal').$destructure(args38)['$=='](object);
                }, $$20.$$s = self, $$20.$$arity = -1, $$20));
            } else if ($truthy(block['$nil?']())) {
                block = $send(self, 'proc', [], ($$21 = function() {
                    $$21.$$s == null ? this : $$21.$$s;
                    return true;
                }, $$21.$$s = self, $$21.$$arity = 0, $$21));
            }
            $send(self, 'each', [], ($$22 = function($a) {
                var self = $$22.$$s == null ? this : $$22.$$s, $post_args, args39;
                $post_args = Opal.slice.call(arguments, 0, arguments.length);
                args39 = $post_args;
                if ($truthy(Opal.yieldX(block, args39))) {
                    return result++;
                } else {
                    return nil;
                }
            }, $$22.$$s = self, $$22.$$arity = -1, $$22));
            return result;
        }, $Enumerable_count$19.$$arity = -1);
        Opal.def(self39, '$cycle', $Enumerable_cycle$23 = function $$cycle(n) {
            var $iter = $Enumerable_cycle$23.$$p, block = $iter || nil, $$24, self43 = this;
            if ($iter) $Enumerable_cycle$23.$$p = null;
            if ($iter) $Enumerable_cycle$23.$$p = null;
            if (n == null) {
                n = nil;
            }
            if (block !== nil) {} else {
                return $send(self43, 'enum_for', [
                    "cycle",
                    n
                ], ($$24 = function() {
                    var self = $$24.$$s == null ? this : $$24.$$s;
                    if ($truthy(n['$nil?']())) {
                        if ($truthy(self['$respond_to?']("size"))) {
                            return $$$($$($nesting, 'Float'), 'INFINITY');
                        } else {
                            return nil;
                        }
                    } else {
                        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
                        if ($truthy($rb_gt(n, 0))) {
                            return $rb_times(self.$enumerator_size(), n);
                        } else {
                            return 0;
                        }
                    }
                }, $$24.$$s = self43, $$24.$$arity = 0, $$24));
            }
            if ($truthy(n['$nil?']())) {} else {
                n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
                if ($truthy(n <= 0)) {
                    return nil;
                }
            }
            var all = [], i192, length, value;
            self43.$each.$$p = function() {
                var param = $$($nesting, 'Opal').$destructure(arguments), value = Opal.yield1(block, param);
                all.push(param);
            };
            self43.$each();
            if (all.length === 0) {
                return nil;
            }
            if (n === nil) {
                while(true){
                    for(i192 = 0, length = all.length; i192 < length; i192++){
                        value = Opal.yield1(block, all[i192]);
                    }
                }
            } else {
                while(n > 1){
                    for(i192 = 0, length = all.length; i192 < length; i192++){
                        value = Opal.yield1(block, all[i192]);
                    }
                    n--;
                }
            }
        }, $Enumerable_cycle$23.$$arity = -1);
        Opal.def(self39, '$detect', $Enumerable_detect$25 = function $$detect(ifnone) {
            try {
                var $iter = $Enumerable_detect$25.$$p, block = $iter || nil, $$26, self = this;
                if ($iter) $Enumerable_detect$25.$$p = null;
                if ($iter) $Enumerable_detect$25.$$p = null;
                if (block !== nil) {} else {
                    return self.$enum_for("detect", ifnone);
                }
                $send(self, 'each', [], ($$26 = function($a) {
                    var self = $$26.$$s == null ? this : $$26.$$s, $post_args, args40, value = nil;
                    $post_args = Opal.slice.call(arguments, 0, arguments.length);
                    args40 = $post_args;
                    value = $$($nesting, 'Opal').$destructure(args40);
                    if ($truthy(Opal.yield1(block, value))) {
                        Opal.ret(value);
                    } else {
                        return nil;
                    }
                }, $$26.$$s = self, $$26.$$arity = -1, $$26));
                if (ifnone !== undefined) {
                    if (typeof ifnone === 'function') {
                        return ifnone();
                    } else {
                        return ifnone;
                    }
                }
                return nil;
            } catch ($returner) {
                if ($returner === Opal.returner) {
                    return $returner.$v;
                }
                throw $returner;
            }
        }, $Enumerable_detect$25.$$arity = -1);
        Opal.def(self39, '$drop', $Enumerable_drop$27 = function $$drop(number) {
            var self = this;
            number = $coerce_to(number, $$($nesting, 'Integer'), 'to_int');
            if ($truthy(number < 0)) {
                self.$raise($$($nesting, 'ArgumentError'), "attempt to drop negative size");
            }
            var result = [], current = 0;
            self.$each.$$p = function() {
                if (number <= current) {
                    result.push($$($nesting, 'Opal').$destructure(arguments));
                }
                current++;
            };
            self.$each();
            return result;
        }, $Enumerable_drop$27.$$arity = 1);
        Opal.def(self39, '$drop_while', $Enumerable_drop_while$28 = function $$drop_while() {
            var $iter = $Enumerable_drop_while$28.$$p, block = $iter || nil, self = this;
            if ($iter) $Enumerable_drop_while$28.$$p = null;
            if ($iter) $Enumerable_drop_while$28.$$p = null;
            if (block !== nil) {} else {
                return self.$enum_for("drop_while");
            }
            var result = [], dropping = true;
            self.$each.$$p = function() {
                var param = $$($nesting, 'Opal').$destructure(arguments);
                if (dropping) {
                    var value = Opal.yield1(block, param);
                    if ($falsy(value)) {
                        dropping = false;
                        result.push(param);
                    }
                } else {
                    result.push(param);
                }
            };
            self.$each();
            return result;
        }, $Enumerable_drop_while$28.$$arity = 0);
        Opal.def(self39, '$each_cons', $Enumerable_each_cons$29 = function $$each_cons(n) {
            var $iter = $Enumerable_each_cons$29.$$p, block = $iter || nil, $$30, self44 = this;
            if ($iter) $Enumerable_each_cons$29.$$p = null;
            if ($iter) $Enumerable_each_cons$29.$$p = null;
            if ($truthy(arguments.length != 1)) {
                self44.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + arguments.length + " for 1)");
            }
            n = $$($nesting, 'Opal').$try_convert(n, $$($nesting, 'Integer'), "to_int");
            if ($truthy(n <= 0)) {
                self44.$raise($$($nesting, 'ArgumentError'), "invalid size");
            }
            if (block !== nil) {} else {
                return $send(self44, 'enum_for', [
                    "each_cons",
                    n
                ], ($$30 = function() {
                    var self = $$30.$$s == null ? this : $$30.$$s, enum_size = nil, $ret_or_1 = nil;
                    enum_size = self.$enumerator_size();
                    if ($truthy(enum_size['$nil?']())) {
                        return nil;
                    } else if ($truthy(function() {
                        if ($truthy($ret_or_1 = enum_size['$=='](0))) {
                            return $ret_or_1;
                        } else {
                            return $rb_lt(enum_size, n);
                        }
                        return nil;
                    }())) {
                        return 0;
                    } else {
                        return $rb_plus($rb_minus(enum_size, n), 1);
                    }
                }, $$30.$$s = self44, $$30.$$arity = 0, $$30));
            }
            var buffer = [];
            self44.$each.$$p = function() {
                var element = $$($nesting, 'Opal').$destructure(arguments);
                buffer.push(element);
                if (buffer.length > n) {
                    buffer.shift();
                }
                if (buffer.length == n) {
                    Opal.yield1(block, buffer.slice(0, n));
                }
            };
            self44.$each();
            return nil;
        }, $Enumerable_each_cons$29.$$arity = 1);
        Opal.def(self39, '$each_entry', $Enumerable_each_entry$31 = function $$each_entry($a) {
            var $iter = $Enumerable_each_entry$31.$$p, block = $iter || nil, $post_args, data12, $$32, self45 = this;
            if ($iter) $Enumerable_each_entry$31.$$p = null;
            if ($iter) $Enumerable_each_entry$31.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            data12 = $post_args;
            if (block !== nil) {} else {
                return $send(self45, 'to_enum', [
                    "each_entry"
                ].concat(Opal.to_a(data12)), ($$32 = function() {
                    var self = $$32.$$s == null ? this : $$32.$$s;
                    return self.$enumerator_size();
                }, $$32.$$s = self45, $$32.$$arity = 0, $$32));
            }
            self45.$each.$$p = function() {
                var item = $$($nesting, 'Opal').$destructure(arguments);
                Opal.yield1(block, item);
            };
            self45.$each.apply(self45, data12);
            return self45;
        }, $Enumerable_each_entry$31.$$arity = -1);
        Opal.def(self39, '$each_slice', $Enumerable_each_slice$33 = function $$each_slice(n) {
            var $iter = $Enumerable_each_slice$33.$$p, block = $iter || nil, $$34, self46 = this;
            if ($iter) $Enumerable_each_slice$33.$$p = null;
            if ($iter) $Enumerable_each_slice$33.$$p = null;
            n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
            if ($truthy(n <= 0)) {
                self46.$raise($$($nesting, 'ArgumentError'), "invalid slice size");
            }
            if (block !== nil) {} else {
                return $send(self46, 'enum_for', [
                    "each_slice",
                    n
                ], ($$34 = function() {
                    var self = $$34.$$s == null ? this : $$34.$$s;
                    if ($truthy(self['$respond_to?']("size"))) {
                        return $rb_divide(self.$size(), n).$ceil();
                    } else {
                        return nil;
                    }
                }, $$34.$$s = self46, $$34.$$arity = 0, $$34));
            }
            var slice = [];
            self46.$each.$$p = function() {
                var param = $$($nesting, 'Opal').$destructure(arguments);
                slice.push(param);
                if (slice.length === n) {
                    Opal.yield1(block, slice);
                    slice = [];
                }
            };
            self46.$each();
            if (slice.length > 0) {
                Opal.yield1(block, slice);
            }
            return nil;
        }, $Enumerable_each_slice$33.$$arity = 1);
        Opal.def(self39, '$each_with_index', $Enumerable_each_with_index$35 = function $$each_with_index($a) {
            var $iter = $Enumerable_each_with_index$35.$$p, block = $iter || nil, $post_args, args41, $$36, self47 = this;
            if ($iter) $Enumerable_each_with_index$35.$$p = null;
            if ($iter) $Enumerable_each_with_index$35.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args41 = $post_args;
            if (block !== nil) {} else {
                return $send(self47, 'enum_for', [
                    "each_with_index"
                ].concat(Opal.to_a(args41)), ($$36 = function() {
                    var self = $$36.$$s == null ? this : $$36.$$s;
                    return self.$enumerator_size();
                }, $$36.$$s = self47, $$36.$$arity = 0, $$36));
            }
            var index = 0;
            self47.$each.$$p = function() {
                var param = $$($nesting, 'Opal').$destructure(arguments);
                block(param, index);
                index++;
            };
            self47.$each.apply(self47, args41);
            return self47;
        }, $Enumerable_each_with_index$35.$$arity = -1);
        Opal.def(self39, '$each_with_object', $Enumerable_each_with_object$37 = function $$each_with_object(object) {
            var $iter = $Enumerable_each_with_object$37.$$p, block = $iter || nil, $$38, self48 = this;
            if ($iter) $Enumerable_each_with_object$37.$$p = null;
            if ($iter) $Enumerable_each_with_object$37.$$p = null;
            if (block !== nil) {} else {
                return $send(self48, 'enum_for', [
                    "each_with_object",
                    object
                ], ($$38 = function() {
                    var self = $$38.$$s == null ? this : $$38.$$s;
                    return self.$enumerator_size();
                }, $$38.$$s = self48, $$38.$$arity = 0, $$38));
            }
            self48.$each.$$p = function() {
                var param = $$($nesting, 'Opal').$destructure(arguments);
                block(param, object);
            };
            self48.$each();
            return object;
        }, $Enumerable_each_with_object$37.$$arity = 1);
        Opal.def(self39, '$entries', $Enumerable_entries$39 = function $$entries($a) {
            var $post_args, args42, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args42 = $post_args;
            var result = [];
            self.$each.$$p = function() {
                result.push($$($nesting, 'Opal').$destructure(arguments));
            };
            self.$each.apply(self, args42);
            return result;
        }, $Enumerable_entries$39.$$arity = -1);
        Opal.def(self39, '$filter_map', $Enumerable_filter_map$40 = function $$filter_map() {
            var $iter = $Enumerable_filter_map$40.$$p, block = $iter || nil, $$41, self49 = this;
            if ($iter) $Enumerable_filter_map$40.$$p = null;
            if ($iter) $Enumerable_filter_map$40.$$p = null;
            if (block !== nil) {} else {
                return $send(self49, 'enum_for', [
                    "filter_map"
                ], ($$41 = function() {
                    var self = $$41.$$s == null ? this : $$41.$$s;
                    return self.$enumerator_size();
                }, $$41.$$s = self49, $$41.$$arity = 0, $$41));
            }
            return $send($send(self49, 'map', [], block.$to_proc()), 'select', [], "itself".$to_proc());
        }, $Enumerable_filter_map$40.$$arity = 0);
        Opal.alias(self39, "find", "detect");
        Opal.def(self39, '$find_all', $Enumerable_find_all$42 = function $$find_all() {
            var $iter = $Enumerable_find_all$42.$$p, block = $iter || nil, $$43, self50 = this;
            if ($iter) $Enumerable_find_all$42.$$p = null;
            if ($iter) $Enumerable_find_all$42.$$p = null;
            if (block !== nil) {} else {
                return $send(self50, 'enum_for', [
                    "find_all"
                ], ($$43 = function() {
                    var self = $$43.$$s == null ? this : $$43.$$s;
                    return self.$enumerator_size();
                }, $$43.$$s = self50, $$43.$$arity = 0, $$43));
            }
            var result = [];
            self50.$each.$$p = function() {
                var param = $$($nesting, 'Opal').$destructure(arguments), value = Opal.yield1(block, param);
                if ($truthy(value)) {
                    result.push(param);
                }
            };
            self50.$each();
            return result;
        }, $Enumerable_find_all$42.$$arity = 0);
        Opal.alias(self39, "filter", "find_all");
        Opal.def(self39, '$find_index', $Enumerable_find_index$44 = function $$find_index(object) {
            try {
                var $iter = $Enumerable_find_index$44.$$p, block = $iter || nil, $$45, $$46, self = this, index = nil;
                if ($iter) $Enumerable_find_index$44.$$p = null;
                if ($iter) $Enumerable_find_index$44.$$p = null;
                if ($truthy(object === undefined && block === nil)) {
                    return self.$enum_for("find_index");
                }
                if (object != null && block !== nil) {
                    self.$warn("warning: given block not used");
                }
                index = 0;
                if ($truthy(object != null)) {
                    $send(self, 'each', [], ($$45 = function($a) {
                        var self = $$45.$$s == null ? this : $$45.$$s, $post_args, value;
                        $post_args = Opal.slice.call(arguments, 0, arguments.length);
                        value = $post_args;
                        if ($$($nesting, 'Opal').$destructure(value)['$=='](object)) {
                            Opal.ret(index);
                        }
                        return index += 1;
                    }, $$45.$$s = self, $$45.$$arity = -1, $$45));
                } else {
                    $send(self, 'each', [], ($$46 = function($a) {
                        var self = $$46.$$s == null ? this : $$46.$$s, $post_args, value;
                        $post_args = Opal.slice.call(arguments, 0, arguments.length);
                        value = $post_args;
                        if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
                            Opal.ret(index);
                        }
                        return index += 1;
                    }, $$46.$$s = self, $$46.$$arity = -1, $$46));
                }
                return nil;
            } catch ($returner) {
                if ($returner === Opal.returner) {
                    return $returner.$v;
                }
                throw $returner;
            }
        }, $Enumerable_find_index$44.$$arity = -1);
        Opal.def(self39, '$first', $Enumerable_first$47 = function $$first(number) {
            try {
                var $$48, $$49, self = this, result = nil, current = nil;
                if ($truthy(number === undefined)) {
                    return $send(self, 'each', [], ($$48 = function(value) {
                        $$48.$$s == null ? this : $$48.$$s;
                        if (value == null) {
                            value = nil;
                        }
                        Opal.ret(value);
                    }, $$48.$$s = self, $$48.$$arity = 1, $$48));
                } else {
                    result = [];
                    number = $coerce_to(number, $$($nesting, 'Integer'), 'to_int');
                    if ($truthy(number < 0)) {
                        self.$raise($$($nesting, 'ArgumentError'), "attempt to take negative size");
                    }
                    if ($truthy(number == 0)) {
                        return [];
                    }
                    current = 0;
                    $send(self, 'each', [], ($$49 = function($a) {
                        var self = $$49.$$s == null ? this : $$49.$$s, $post_args, args43;
                        $post_args = Opal.slice.call(arguments, 0, arguments.length);
                        args43 = $post_args;
                        result.push($$($nesting, 'Opal').$destructure(args43));
                        if ($truthy(number <= ++current)) {
                            Opal.ret(result);
                        } else {
                            return nil;
                        }
                    }, $$49.$$s = self, $$49.$$arity = -1, $$49));
                    return result;
                }
            } catch ($returner) {
                if ($returner === Opal.returner) {
                    return $returner.$v;
                }
                throw $returner;
            }
        }, $Enumerable_first$47.$$arity = -1);
        Opal.alias(self39, "flat_map", "collect_concat");
        Opal.def(self39, '$grep', $Enumerable_grep$50 = function $$grep(pattern) {
            var $iter = $Enumerable_grep$50.$$p, block = $iter || nil, $$51, self = this, result = nil;
            if ($iter) $Enumerable_grep$50.$$p = null;
            if ($iter) $Enumerable_grep$50.$$p = null;
            result = [];
            $send(self, 'each', [], ($$51 = function($a) {
                var self = $$51.$$s == null ? this : $$51.$$s, $post_args, value, cmp = nil;
                $post_args = Opal.slice.call(arguments, 0, arguments.length);
                value = $post_args;
                cmp = comparableForPattern(value);
                if ($truthy($send(pattern, '__send__', [
                    "==="
                ].concat(Opal.to_a(cmp))))) {} else {
                    return nil;
                }
                if (block !== nil) {
                    if ($truthy($rb_gt(value.$length(), 1))) {
                        value = [
                            value
                        ];
                    }
                    value = Opal.yieldX(block, Opal.to_a(value));
                } else if ($truthy($rb_le(value.$length(), 1))) {
                    value = value['$[]'](0);
                }
                return result.$push(value);
            }, $$51.$$s = self, $$51.$$arity = -1, $$51));
            return result;
        }, $Enumerable_grep$50.$$arity = 1);
        Opal.def(self39, '$grep_v', $Enumerable_grep_v$52 = function $$grep_v(pattern) {
            var $iter = $Enumerable_grep_v$52.$$p, block = $iter || nil, $$53, self = this, result = nil;
            if ($iter) $Enumerable_grep_v$52.$$p = null;
            if ($iter) $Enumerable_grep_v$52.$$p = null;
            result = [];
            $send(self, 'each', [], ($$53 = function($a) {
                var self = $$53.$$s == null ? this : $$53.$$s, $post_args, value, cmp = nil;
                $post_args = Opal.slice.call(arguments, 0, arguments.length);
                value = $post_args;
                cmp = comparableForPattern(value);
                if ($truthy($send(pattern, '__send__', [
                    "==="
                ].concat(Opal.to_a(cmp))))) {
                    return nil;
                }
                if (block !== nil) {
                    if ($truthy($rb_gt(value.$length(), 1))) {
                        value = [
                            value
                        ];
                    }
                    value = Opal.yieldX(block, Opal.to_a(value));
                } else if ($truthy($rb_le(value.$length(), 1))) {
                    value = value['$[]'](0);
                }
                return result.$push(value);
            }, $$53.$$s = self, $$53.$$arity = -1, $$53));
            return result;
        }, $Enumerable_grep_v$52.$$arity = 1);
        Opal.def(self39, '$group_by', $Enumerable_group_by$54 = function $$group_by() {
            var $iter = $Enumerable_group_by$54.$$p, block = $iter || nil, $$55, self51 = this, hash = nil, $ret_or_2 = nil, $writer = nil;
            if ($iter) $Enumerable_group_by$54.$$p = null;
            if ($iter) $Enumerable_group_by$54.$$p = null;
            if (block !== nil) {} else {
                return $send(self51, 'enum_for', [
                    "group_by"
                ], ($$55 = function() {
                    var self = $$55.$$s == null ? this : $$55.$$s;
                    return self.$enumerator_size();
                }, $$55.$$s = self51, $$55.$$arity = 0, $$55));
            }
            hash = $hash2([], {});
            var result;
            self51.$each.$$p = function() {
                var param = $$($nesting, 'Opal').$destructure(arguments), value = Opal.yield1(block, param);
                (function() {
                    if ($truthy($ret_or_2 = hash['$[]'](value))) {
                        return $ret_or_2;
                    } else {
                        $writer = [
                            value,
                            []
                        ];
                        $send(hash, '[]=', Opal.to_a($writer));
                        return $writer[$rb_minus($writer["length"], 1)];
                    }
                    return nil;
                })()['$<<'](param);
            };
            self51.$each();
            if (result !== undefined) {
                return result;
            }
            return hash;
        }, $Enumerable_group_by$54.$$arity = 0);
        Opal.def(self39, '$include?', $Enumerable_include$ques$56 = function(obj) {
            try {
                var $$57, self = this;
                $send(self, 'each', [], ($$57 = function($a) {
                    var self = $$57.$$s == null ? this : $$57.$$s, $post_args, args44;
                    $post_args = Opal.slice.call(arguments, 0, arguments.length);
                    args44 = $post_args;
                    if ($$($nesting, 'Opal').$destructure(args44)['$=='](obj)) {
                        Opal.ret(true);
                    } else {
                        return nil;
                    }
                }, $$57.$$s = self, $$57.$$arity = -1, $$57));
                return false;
            } catch ($returner) {
                if ($returner === Opal.returner) {
                    return $returner.$v;
                }
                throw $returner;
            }
        }, $Enumerable_include$ques$56.$$arity = 1);
        Opal.def(self39, '$inject', $Enumerable_inject$58 = function $$inject(object, sym) {
            var $iter = $Enumerable_inject$58.$$p, block = $iter || nil, self = this;
            if ($iter) $Enumerable_inject$58.$$p = null;
            if ($iter) $Enumerable_inject$58.$$p = null;
            var result = object;
            if (block !== nil && sym === undefined) {
                self.$each.$$p = function() {
                    var value = $$($nesting, 'Opal').$destructure(arguments);
                    if (result === undefined) {
                        result = value;
                        return;
                    }
                    value = Opal.yieldX(block, [
                        result,
                        value
                    ]);
                    result = value;
                };
            } else {
                if (sym === undefined) {
                    if (!$$($nesting, 'Symbol')['$==='](object)) {
                        self.$raise($$($nesting, 'TypeError'), "" + object.$inspect() + " is not a Symbol");
                    }
                    sym = object;
                    result = undefined;
                }
                self.$each.$$p = function() {
                    var value = $$($nesting, 'Opal').$destructure(arguments);
                    if (result === undefined) {
                        result = value;
                        return;
                    }
                    result = result.$__send__(sym, value);
                };
            }
            self.$each();
            return result == undefined ? nil : result;
        }, $Enumerable_inject$58.$$arity = -1);
        Opal.def(self39, '$lazy', $Enumerable_lazy$59 = function $$lazy() {
            var $$60, self = this;
            return $send($$$($$($nesting, 'Enumerator'), 'Lazy'), 'new', [
                self,
                self.$enumerator_size()
            ], ($$60 = function(enum$, $a) {
                var self = $$60.$$s == null ? this : $$60.$$s, $post_args, args45;
                if (enum$ == null) {
                    enum$ = nil;
                }
                $post_args = Opal.slice.call(arguments, 1, arguments.length);
                args45 = $post_args;
                return $send(enum$, 'yield', Opal.to_a(args45));
            }, $$60.$$s = self, $$60.$$arity = -2, $$60));
        }, $Enumerable_lazy$59.$$arity = 0);
        Opal.def(self39, '$enumerator_size', $Enumerable_enumerator_size$61 = function $$enumerator_size() {
            var self = this;
            if ($truthy(self['$respond_to?']("size"))) {
                return self.$size();
            } else {
                return nil;
            }
        }, $Enumerable_enumerator_size$61.$$arity = 0);
        Opal.alias(self39, "map", "collect");
        Opal.def(self39, '$max', $Enumerable_max$62 = function $$max(n) {
            var $iter = $Enumerable_max$62.$$p, block = $iter || nil, self = this;
            if ($iter) $Enumerable_max$62.$$p = null;
            if ($iter) $Enumerable_max$62.$$p = null;
            if (n === undefined || n === nil) {
                var result, value;
                self.$each.$$p = function() {
                    var item = $$($nesting, 'Opal').$destructure(arguments);
                    if (result === undefined) {
                        result = item;
                        return;
                    }
                    if (block !== nil) {
                        value = Opal.yieldX(block, [
                            item,
                            result
                        ]);
                    } else {
                        value = item['$<=>'](result);
                    }
                    if (value === nil) {
                        self.$raise($$($nesting, 'ArgumentError'), "comparison failed");
                    }
                    if (value > 0) {
                        result = item;
                    }
                };
                self.$each();
                if (result === undefined) {
                    return nil;
                } else {
                    return result;
                }
            }
            n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
            return $send(self, 'sort', [], block.$to_proc()).$reverse().$first(n);
        }, $Enumerable_max$62.$$arity = -1);
        Opal.def(self39, '$max_by', $Enumerable_max_by$63 = function $$max_by(n) {
            var $iter = $Enumerable_max_by$63.$$p, block = $iter || nil, $$64, self52 = this;
            if ($iter) $Enumerable_max_by$63.$$p = null;
            if ($iter) $Enumerable_max_by$63.$$p = null;
            if (n == null) {
                n = nil;
            }
            if ($truthy(block)) {} else {
                return $send(self52, 'enum_for', [
                    "max_by",
                    n
                ], ($$64 = function() {
                    var self = $$64.$$s == null ? this : $$64.$$s;
                    return self.$enumerator_size();
                }, $$64.$$s = self52, $$64.$$arity = 0, $$64));
            }
            if ($truthy(n['$nil?']())) {} else {
                return $send(self52, 'sort_by', [], block.$to_proc()).$reverse().$take(n);
            }
            var result, by;
            self52.$each.$$p = function() {
                var param = $$($nesting, 'Opal').$destructure(arguments), value = Opal.yield1(block, param);
                if (result === undefined) {
                    result = param;
                    by = value;
                    return;
                }
                if (value['$<=>'](by) > 0) {
                    result = param;
                    by = value;
                }
            };
            self52.$each();
            return result === undefined ? nil : result;
        }, $Enumerable_max_by$63.$$arity = -1);
        Opal.alias(self39, "member?", "include?");
        Opal.def(self39, '$min', $Enumerable_min$65 = function $$min(n) {
            var $iter = $Enumerable_min$65.$$p, block = $iter || nil, $$66, self = this;
            if ($iter) $Enumerable_min$65.$$p = null;
            if ($iter) $Enumerable_min$65.$$p = null;
            if (n == null) {
                n = nil;
            }
            if ($truthy(n['$nil?']())) {} else if (block !== nil) {
                return $send(self, 'sort', [], ($$66 = function(a, b) {
                    $$66.$$s == null ? this : $$66.$$s;
                    if (a == null) {
                        a = nil;
                    }
                    if (b == null) {
                        b = nil;
                    }
                    return Opal.yieldX(block, [
                        a,
                        b
                    ]);
                }, $$66.$$s = self, $$66.$$arity = 2, $$66)).$take(n);
            } else {
                return self.$sort().$take(n);
            }
            var result;
            if (block !== nil) {
                self.$each.$$p = function() {
                    var param = $$($nesting, 'Opal').$destructure(arguments);
                    if (result === undefined) {
                        result = param;
                        return;
                    }
                    var value = block(param, result);
                    if (value === nil) {
                        self.$raise($$($nesting, 'ArgumentError'), "comparison failed");
                    }
                    if (value < 0) {
                        result = param;
                    }
                };
            } else {
                self.$each.$$p = function() {
                    var param = $$($nesting, 'Opal').$destructure(arguments);
                    if (result === undefined) {
                        result = param;
                        return;
                    }
                    if ($$($nesting, 'Opal').$compare(param, result) < 0) {
                        result = param;
                    }
                };
            }
            self.$each();
            return result === undefined ? nil : result;
        }, $Enumerable_min$65.$$arity = -1);
        Opal.def(self39, '$min_by', $Enumerable_min_by$67 = function $$min_by(n) {
            var $iter = $Enumerable_min_by$67.$$p, block = $iter || nil, $$68, self53 = this;
            if ($iter) $Enumerable_min_by$67.$$p = null;
            if ($iter) $Enumerable_min_by$67.$$p = null;
            if (n == null) {
                n = nil;
            }
            if ($truthy(block)) {} else {
                return $send(self53, 'enum_for', [
                    "min_by",
                    n
                ], ($$68 = function() {
                    var self = $$68.$$s == null ? this : $$68.$$s;
                    return self.$enumerator_size();
                }, $$68.$$s = self53, $$68.$$arity = 0, $$68));
            }
            if ($truthy(n['$nil?']())) {} else {
                return $send(self53, 'sort_by', [], block.$to_proc()).$take(n);
            }
            var result, by;
            self53.$each.$$p = function() {
                var param = $$($nesting, 'Opal').$destructure(arguments), value = Opal.yield1(block, param);
                if (result === undefined) {
                    result = param;
                    by = value;
                    return;
                }
                if (value['$<=>'](by) < 0) {
                    result = param;
                    by = value;
                }
            };
            self53.$each();
            return result === undefined ? nil : result;
        }, $Enumerable_min_by$67.$$arity = -1);
        Opal.def(self39, '$minmax', $Enumerable_minmax$69 = function $$minmax() {
            var $iter = $Enumerable_minmax$69.$$p, block = $iter || nil, $$70, self = this, $ret_or_3 = nil;
            if ($iter) $Enumerable_minmax$69.$$p = null;
            if ($iter) $Enumerable_minmax$69.$$p = null;
            block = function() {
                if ($truthy($ret_or_3 = block)) {
                    return $ret_or_3;
                } else {
                    return $send(self, 'proc', [], ($$70 = function(a, b) {
                        $$70.$$s == null ? this : $$70.$$s;
                        if (a == null) {
                            a = nil;
                        }
                        if (b == null) {
                            b = nil;
                        }
                        return a['$<=>'](b);
                    }, $$70.$$s = self, $$70.$$arity = 2, $$70));
                }
                return nil;
            }();
            var min25 = nil, max = nil, first_time = true;
            self.$each.$$p = function() {
                var element = $$($nesting, 'Opal').$destructure(arguments);
                if (first_time) {
                    min25 = max = element;
                    first_time = false;
                } else {
                    var min_cmp = block.$call(min25, element);
                    if (min_cmp === nil) {
                        self.$raise($$($nesting, 'ArgumentError'), "comparison failed");
                    } else if (min_cmp > 0) {
                        min25 = element;
                    }
                    var max_cmp = block.$call(max, element);
                    if (max_cmp === nil) {
                        self.$raise($$($nesting, 'ArgumentError'), "comparison failed");
                    } else if (max_cmp < 0) {
                        max = element;
                    }
                }
            };
            self.$each();
            return [
                min25,
                max
            ];
        }, $Enumerable_minmax$69.$$arity = 0);
        Opal.def(self39, '$minmax_by', $Enumerable_minmax_by$71 = function $$minmax_by() {
            var $iter = $Enumerable_minmax_by$71.$$p, block = $iter || nil, $$72, self54 = this;
            if ($iter) $Enumerable_minmax_by$71.$$p = null;
            if ($iter) $Enumerable_minmax_by$71.$$p = null;
            if ($truthy(block)) {} else {
                return $send(self54, 'enum_for', [
                    "minmax_by"
                ], ($$72 = function() {
                    var self = $$72.$$s == null ? this : $$72.$$s;
                    return self.$enumerator_size();
                }, $$72.$$s = self54, $$72.$$arity = 0, $$72));
            }
            var min_result = nil, max_result = nil, min_by, max_by;
            self54.$each.$$p = function() {
                var param = $$($nesting, 'Opal').$destructure(arguments), value = Opal.yield1(block, param);
                if (min_by === undefined || value['$<=>'](min_by) < 0) {
                    min_result = param;
                    min_by = value;
                }
                if (max_by === undefined || value['$<=>'](max_by) > 0) {
                    max_result = param;
                    max_by = value;
                }
            };
            self54.$each();
            return [
                min_result,
                max_result
            ];
        }, $Enumerable_minmax_by$71.$$arity = 0);
        Opal.def(self39, '$none?', $Enumerable_none$ques$73 = function(pattern) {
            try {
                var $iter = $Enumerable_none$ques$73.$$p, block = $iter || nil, $$74, $$75, $$76, self = this;
                if ($iter) $Enumerable_none$ques$73.$$p = null;
                if ($iter) $Enumerable_none$ques$73.$$p = null;
                if ($truthy(pattern !== undefined)) {
                    $send(self, 'each', [], ($$74 = function($a) {
                        var self = $$74.$$s == null ? this : $$74.$$s, $post_args, value, comparable = nil;
                        $post_args = Opal.slice.call(arguments, 0, arguments.length);
                        value = $post_args;
                        comparable = comparableForPattern(value);
                        if ($truthy($send(pattern, 'public_send', [
                            "==="
                        ].concat(Opal.to_a(comparable))))) {
                            Opal.ret(false);
                        } else {
                            return nil;
                        }
                    }, $$74.$$s = self, $$74.$$arity = -1, $$74));
                } else if (block !== nil) {
                    $send(self, 'each', [], ($$75 = function($a) {
                        var self = $$75.$$s == null ? this : $$75.$$s, $post_args, value;
                        $post_args = Opal.slice.call(arguments, 0, arguments.length);
                        value = $post_args;
                        if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
                            Opal.ret(false);
                        } else {
                            return nil;
                        }
                    }, $$75.$$s = self, $$75.$$arity = -1, $$75));
                } else {
                    $send(self, 'each', [], ($$76 = function($a) {
                        var self = $$76.$$s == null ? this : $$76.$$s, $post_args, value, item = nil;
                        $post_args = Opal.slice.call(arguments, 0, arguments.length);
                        value = $post_args;
                        item = $$($nesting, 'Opal').$destructure(value);
                        if ($truthy(item)) {
                            Opal.ret(false);
                        } else {
                            return nil;
                        }
                    }, $$76.$$s = self, $$76.$$arity = -1, $$76));
                }
                return true;
            } catch ($returner) {
                if ($returner === Opal.returner) {
                    return $returner.$v;
                }
                throw $returner;
            }
        }, $Enumerable_none$ques$73.$$arity = -1);
        Opal.def(self39, '$one?', $Enumerable_one$ques$77 = function(pattern) {
            try {
                var $iter = $Enumerable_one$ques$77.$$p, block = $iter || nil, $$78, $$79, $$80, self = this, count = nil;
                if ($iter) $Enumerable_one$ques$77.$$p = null;
                if ($iter) $Enumerable_one$ques$77.$$p = null;
                count = 0;
                if ($truthy(pattern !== undefined)) {
                    $send(self, 'each', [], ($$78 = function($a) {
                        var self = $$78.$$s == null ? this : $$78.$$s, $post_args, value, comparable = nil;
                        $post_args = Opal.slice.call(arguments, 0, arguments.length);
                        value = $post_args;
                        comparable = comparableForPattern(value);
                        if ($truthy($send(pattern, 'public_send', [
                            "==="
                        ].concat(Opal.to_a(comparable))))) {
                            count = $rb_plus(count, 1);
                            if ($truthy($rb_gt(count, 1))) {
                                Opal.ret(false);
                            } else {
                                return nil;
                            }
                        } else {
                            return nil;
                        }
                    }, $$78.$$s = self, $$78.$$arity = -1, $$78));
                } else if (block !== nil) {
                    $send(self, 'each', [], ($$79 = function($a) {
                        var self = $$79.$$s == null ? this : $$79.$$s, $post_args, value;
                        $post_args = Opal.slice.call(arguments, 0, arguments.length);
                        value = $post_args;
                        if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {} else {
                            return nil;
                        }
                        count = $rb_plus(count, 1);
                        if ($truthy($rb_gt(count, 1))) {
                            Opal.ret(false);
                        } else {
                            return nil;
                        }
                    }, $$79.$$s = self, $$79.$$arity = -1, $$79));
                } else {
                    $send(self, 'each', [], ($$80 = function($a) {
                        var self = $$80.$$s == null ? this : $$80.$$s, $post_args, value;
                        $post_args = Opal.slice.call(arguments, 0, arguments.length);
                        value = $post_args;
                        if ($truthy($$($nesting, 'Opal').$destructure(value))) {} else {
                            return nil;
                        }
                        count = $rb_plus(count, 1);
                        if ($truthy($rb_gt(count, 1))) {
                            Opal.ret(false);
                        } else {
                            return nil;
                        }
                    }, $$80.$$s = self, $$80.$$arity = -1, $$80));
                }
                return count['$=='](1);
            } catch ($returner) {
                if ($returner === Opal.returner) {
                    return $returner.$v;
                }
                throw $returner;
            }
        }, $Enumerable_one$ques$77.$$arity = -1);
        Opal.def(self39, '$partition', $Enumerable_partition$81 = function $$partition() {
            var $iter = $Enumerable_partition$81.$$p, block = $iter || nil, $$82, self55 = this;
            if ($iter) $Enumerable_partition$81.$$p = null;
            if ($iter) $Enumerable_partition$81.$$p = null;
            if (block !== nil) {} else {
                return $send(self55, 'enum_for', [
                    "partition"
                ], ($$82 = function() {
                    var self = $$82.$$s == null ? this : $$82.$$s;
                    return self.$enumerator_size();
                }, $$82.$$s = self55, $$82.$$arity = 0, $$82));
            }
            var truthy = [], falsy = [];
            self55.$each.$$p = function() {
                var param = $$($nesting, 'Opal').$destructure(arguments), value = Opal.yield1(block, param);
                if ($truthy(value)) {
                    truthy.push(param);
                } else {
                    falsy.push(param);
                }
            };
            self55.$each();
            return [
                truthy,
                falsy
            ];
        }, $Enumerable_partition$81.$$arity = 0);
        Opal.alias(self39, "reduce", "inject");
        Opal.def(self39, '$reject', $Enumerable_reject$83 = function $$reject() {
            var $iter = $Enumerable_reject$83.$$p, block = $iter || nil, $$84, self56 = this;
            if ($iter) $Enumerable_reject$83.$$p = null;
            if ($iter) $Enumerable_reject$83.$$p = null;
            if (block !== nil) {} else {
                return $send(self56, 'enum_for', [
                    "reject"
                ], ($$84 = function() {
                    var self = $$84.$$s == null ? this : $$84.$$s;
                    return self.$enumerator_size();
                }, $$84.$$s = self56, $$84.$$arity = 0, $$84));
            }
            var result = [];
            self56.$each.$$p = function() {
                var param = $$($nesting, 'Opal').$destructure(arguments), value = Opal.yield1(block, param);
                if ($falsy(value)) {
                    result.push(param);
                }
            };
            self56.$each();
            return result;
        }, $Enumerable_reject$83.$$arity = 0);
        Opal.def(self39, '$reverse_each', $Enumerable_reverse_each$85 = function $$reverse_each() {
            var $iter = $Enumerable_reverse_each$85.$$p, block = $iter || nil, $$86, self57 = this;
            if ($iter) $Enumerable_reverse_each$85.$$p = null;
            if ($iter) $Enumerable_reverse_each$85.$$p = null;
            if (block !== nil) {} else {
                return $send(self57, 'enum_for', [
                    "reverse_each"
                ], ($$86 = function() {
                    var self = $$86.$$s == null ? this : $$86.$$s;
                    return self.$enumerator_size();
                }, $$86.$$s = self57, $$86.$$arity = 0, $$86));
            }
            var result = [];
            self57.$each.$$p = function() {
                result.push(arguments);
            };
            self57.$each();
            for(var i193 = result.length - 1; i193 >= 0; i193--){
                Opal.yieldX(block, result[i193]);
            }
            return result;
        }, $Enumerable_reverse_each$85.$$arity = 0);
        Opal.alias(self39, "select", "find_all");
        Opal.def(self39, '$slice_before', $Enumerable_slice_before$87 = function $$slice_before(pattern) {
            var $iter = $Enumerable_slice_before$87.$$p, block = $iter || nil, $$88, self58 = this;
            if ($iter) $Enumerable_slice_before$87.$$p = null;
            if ($iter) $Enumerable_slice_before$87.$$p = null;
            if ($truthy(pattern === undefined && block === nil)) {
                self58.$raise($$($nesting, 'ArgumentError'), "both pattern and block are given");
            }
            if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
                self58.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + arguments.length + " expected 1)");
            }
            return $send($$($nesting, 'Enumerator'), 'new', [], ($$88 = function(e) {
                var self = $$88.$$s == null ? this : $$88.$$s;
                if (e == null) {
                    e = nil;
                }
                var slice = [];
                if (block !== nil) {
                    if (pattern === undefined) {
                        self.$each.$$p = function() {
                            var param = $$($nesting, 'Opal').$destructure(arguments), value = Opal.yield1(block, param);
                            if ($truthy(value) && slice.length > 0) {
                                e['$<<'](slice);
                                slice = [];
                            }
                            slice.push(param);
                        };
                    } else {
                        self.$each.$$p = function() {
                            var param = $$($nesting, 'Opal').$destructure(arguments), value = block(param, pattern.$dup());
                            if ($truthy(value) && slice.length > 0) {
                                e['$<<'](slice);
                                slice = [];
                            }
                            slice.push(param);
                        };
                    }
                } else {
                    self.$each.$$p = function() {
                        var param = $$($nesting, 'Opal').$destructure(arguments), value = pattern['$==='](param);
                        if ($truthy(value) && slice.length > 0) {
                            e['$<<'](slice);
                            slice = [];
                        }
                        slice.push(param);
                    };
                }
                self.$each();
                if (slice.length > 0) {
                    e['$<<'](slice);
                }
            }, $$88.$$s = self58, $$88.$$arity = 1, $$88));
        }, $Enumerable_slice_before$87.$$arity = -1);
        Opal.def(self39, '$slice_after', $Enumerable_slice_after$89 = function $$slice_after(pattern) {
            var $iter = $Enumerable_slice_after$89.$$p, block = $iter || nil, $$90, $$91, self59 = this;
            if ($iter) $Enumerable_slice_after$89.$$p = null;
            if ($iter) $Enumerable_slice_after$89.$$p = null;
            if ($truthy(pattern === undefined && block === nil)) {
                self59.$raise($$($nesting, 'ArgumentError'), "both pattern and block are given");
            }
            if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
                self59.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + arguments.length + " expected 1)");
            }
            if ($truthy(pattern !== undefined)) {
                block = $send(self59, 'proc', [], ($$90 = function(e) {
                    $$90.$$s == null ? this : $$90.$$s;
                    if (e == null) {
                        e = nil;
                    }
                    return pattern['$==='](e);
                }, $$90.$$s = self59, $$90.$$arity = 1, $$90));
            }
            return $send($$($nesting, 'Enumerator'), 'new', [], ($$91 = function(yielder) {
                var self = $$91.$$s == null ? this : $$91.$$s;
                if (yielder == null) {
                    yielder = nil;
                }
                var accumulate;
                self.$each.$$p = function() {
                    var element = $$($nesting, 'Opal').$destructure(arguments), end_chunk = Opal.yield1(block, element);
                    if (accumulate == null) {
                        accumulate = [];
                    }
                    if ($truthy(end_chunk)) {
                        accumulate.push(element);
                        yielder.$yield(accumulate);
                        accumulate = null;
                    } else {
                        accumulate.push(element);
                    }
                };
                self.$each();
                if (accumulate != null) {
                    yielder.$yield(accumulate);
                }
            }, $$91.$$s = self59, $$91.$$arity = 1, $$91));
        }, $Enumerable_slice_after$89.$$arity = -1);
        Opal.def(self39, '$slice_when', $Enumerable_slice_when$92 = function $$slice_when() {
            var $iter = $Enumerable_slice_when$92.$$p, block = $iter || nil, $$93, self60 = this;
            if ($iter) $Enumerable_slice_when$92.$$p = null;
            if ($iter) $Enumerable_slice_when$92.$$p = null;
            if (block !== nil) {} else {
                self60.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1)");
            }
            return $send($$($nesting, 'Enumerator'), 'new', [], ($$93 = function(yielder) {
                var self = $$93.$$s == null ? this : $$93.$$s;
                if (yielder == null) {
                    yielder = nil;
                }
                var slice = nil, last_after = nil;
                self.$each_cons.$$p = function() {
                    var params = $$($nesting, 'Opal').$destructure(arguments), before = params[0], after = params[1], match = Opal.yieldX(block, [
                        before,
                        after
                    ]);
                    last_after = after;
                    if (slice === nil) {
                        slice = [];
                    }
                    if ($truthy(match)) {
                        slice.push(before);
                        yielder.$yield(slice);
                        slice = [];
                    } else {
                        slice.push(before);
                    }
                };
                self.$each_cons(2);
                if (slice !== nil) {
                    slice.push(last_after);
                    yielder.$yield(slice);
                }
            }, $$93.$$s = self60, $$93.$$arity = 1, $$93));
        }, $Enumerable_slice_when$92.$$arity = 0);
        Opal.def(self39, '$sort', $Enumerable_sort$94 = function $$sort() {
            var $iter = $Enumerable_sort$94.$$p, block = $iter || nil, $$95, self = this, ary = nil;
            if ($iter) $Enumerable_sort$94.$$p = null;
            if ($iter) $Enumerable_sort$94.$$p = null;
            ary = self.$to_a();
            if (block !== nil) {} else {
                block = $lambda(($$95 = function(a, b) {
                    $$95.$$s == null ? this : $$95.$$s;
                    if (a == null) {
                        a = nil;
                    }
                    if (b == null) {
                        b = nil;
                    }
                    return a['$<=>'](b);
                }, $$95.$$s = self, $$95.$$arity = 2, $$95));
            }
            return $send(ary, 'sort', [], block.$to_proc());
        }, $Enumerable_sort$94.$$arity = 0);
        Opal.def(self39, '$sort_by', $Enumerable_sort_by$96 = function $$sort_by() {
            var $iter = $Enumerable_sort_by$96.$$p, block = $iter || nil, $$97, $$98, $$99, $$100, self61 = this, dup = nil;
            if ($iter) $Enumerable_sort_by$96.$$p = null;
            if ($iter) $Enumerable_sort_by$96.$$p = null;
            if (block !== nil) {} else {
                return $send(self61, 'enum_for', [
                    "sort_by"
                ], ($$97 = function() {
                    var self = $$97.$$s == null ? this : $$97.$$s;
                    return self.$enumerator_size();
                }, $$97.$$s = self61, $$97.$$arity = 0, $$97));
            }
            dup = $send(self61, 'map', [], ($$98 = function() {
                var self = $$98.$$s == null ? this : $$98.$$s, arg = nil;
                arg = $$($nesting, 'Opal').$destructure(arguments);
                return [
                    Opal.yield1(block, arg),
                    arg
                ];
            }, $$98.$$s = self61, $$98.$$arity = 0, $$98));
            $send(dup, 'sort!', [], ($$99 = function(a, b) {
                $$99.$$s == null ? this : $$99.$$s;
                if (a == null) {
                    a = nil;
                }
                if (b == null) {
                    b = nil;
                }
                return a[0]['$<=>'](b[0]);
            }, $$99.$$s = self61, $$99.$$arity = 2, $$99));
            return $send(dup, 'map!', [], ($$100 = function(i194) {
                $$100.$$s == null ? this : $$100.$$s;
                if (i194 == null) {
                    i194 = nil;
                }
                return i194[1];
            }, $$100.$$s = self61, $$100.$$arity = 1, $$100));
        }, $Enumerable_sort_by$96.$$arity = 0);
        Opal.def(self39, '$sum', $Enumerable_sum$101 = function $$sum(initial) {
            var $$102, $iter = $Enumerable_sum$101.$$p, $yield = $iter || nil, self = this, result = nil;
            if ($iter) $Enumerable_sum$101.$$p = null;
            if (initial == null) {
                initial = 0;
            }
            result = initial;
            $send(self, 'each', [], ($$102 = function($a) {
                var self = $$102.$$s == null ? this : $$102.$$s, $post_args, args46, item = nil;
                $post_args = Opal.slice.call(arguments, 0, arguments.length);
                args46 = $post_args;
                item = function() {
                    if ($yield !== nil) {
                        return Opal.yieldX($yield, Opal.to_a(args46));
                    } else {
                        return $$($nesting, 'Opal').$destructure(args46);
                    }
                    return nil;
                }();
                return result = $rb_plus(result, item);
            }, $$102.$$s = self, $$102.$$arity = -1, $$102));
            return result;
        }, $Enumerable_sum$101.$$arity = -1);
        Opal.def(self39, '$take', $Enumerable_take$103 = function $$take(num) {
            var self = this;
            return self.$first(num);
        }, $Enumerable_take$103.$$arity = 1);
        Opal.def(self39, '$take_while', $Enumerable_take_while$104 = function $$take_while() {
            try {
                var $iter = $Enumerable_take_while$104.$$p, block = $iter || nil, $$105, self = this, result = nil;
                if ($iter) $Enumerable_take_while$104.$$p = null;
                if ($iter) $Enumerable_take_while$104.$$p = null;
                if ($truthy(block)) {} else {
                    return self.$enum_for("take_while");
                }
                result = [];
                return $send(self, 'each', [], ($$105 = function($a) {
                    var self = $$105.$$s == null ? this : $$105.$$s, $post_args, args47, value = nil;
                    $post_args = Opal.slice.call(arguments, 0, arguments.length);
                    args47 = $post_args;
                    value = $$($nesting, 'Opal').$destructure(args47);
                    if ($truthy(Opal.yield1(block, value))) {} else {
                        Opal.ret(result);
                    }
                    return result.push(value);
                }, $$105.$$s = self, $$105.$$arity = -1, $$105));
            } catch ($returner) {
                if ($returner === Opal.returner) {
                    return $returner.$v;
                }
                throw $returner;
            }
        }, $Enumerable_take_while$104.$$arity = 0);
        Opal.def(self39, '$uniq', $Enumerable_uniq$106 = function $$uniq() {
            var $iter = $Enumerable_uniq$106.$$p, block = $iter || nil, $$107, self = this, hash = nil;
            if ($iter) $Enumerable_uniq$106.$$p = null;
            if ($iter) $Enumerable_uniq$106.$$p = null;
            hash = $hash2([], {});
            $send(self, 'each', [], ($$107 = function($a) {
                var self = $$107.$$s == null ? this : $$107.$$s, $post_args, args48, value = nil, produced = nil, $writer = nil;
                $post_args = Opal.slice.call(arguments, 0, arguments.length);
                args48 = $post_args;
                value = $$($nesting, 'Opal').$destructure(args48);
                produced = function() {
                    if (block !== nil) {
                        return Opal.yield1(block, value);
                    } else {
                        return value;
                    }
                    return nil;
                }();
                if ($truthy(hash['$key?'](produced))) {
                    return nil;
                } else {
                    $writer = [
                        produced,
                        value
                    ];
                    $send(hash, '[]=', Opal.to_a($writer));
                    return $writer[$rb_minus($writer["length"], 1)];
                }
            }, $$107.$$s = self, $$107.$$arity = -1, $$107));
            return hash.$values();
        }, $Enumerable_uniq$106.$$arity = 0);
        Opal.def(self39, '$tally', $Enumerable_tally$108 = function $$tally() {
            var self = this;
            return $send($send(self, 'group_by', [], "itself".$to_proc()), 'transform_values', [], "count".$to_proc());
        }, $Enumerable_tally$108.$$arity = 0);
        Opal.alias(self39, "to_a", "entries");
        Opal.def(self39, '$to_h', $Enumerable_to_h$109 = function $$to_h($a) {
            var $iter = $Enumerable_to_h$109.$$p, block = $iter || nil, $post_args, args49, self = this;
            if ($iter) $Enumerable_to_h$109.$$p = null;
            if ($iter) $Enumerable_to_h$109.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args49 = $post_args;
            if (block !== nil) {
                return $send($send(self, 'map', [], block.$to_proc()), 'to_h', Opal.to_a(args49));
            }
            var hash = $hash2([], {});
            self.$each.$$p = function() {
                var param = $$($nesting, 'Opal').$destructure(arguments);
                var ary = $$($nesting, 'Opal')['$coerce_to?'](param, $$($nesting, 'Array'), "to_ary"), key, val;
                if (!ary.$$is_array) {
                    self.$raise($$($nesting, 'TypeError'), "" + "wrong element type " + ary.$class() + " (expected array)");
                }
                if (ary.length !== 2) {
                    self.$raise($$($nesting, 'ArgumentError'), "" + "wrong array length (expected 2, was " + ary.$length() + ")");
                }
                key = ary[0];
                val = ary[1];
                Opal.hash_put(hash, key, val);
            };
            self.$each.apply(self, args49);
            return hash;
        }, $Enumerable_to_h$109.$$arity = -1);
        return (Opal.def(self39, '$zip', $Enumerable_zip$110 = function $$zip($a) {
            var $iter = $Enumerable_zip$110.$$p, $post_args, others, self = this;
            if ($iter) $Enumerable_zip$110.$$p = null;
            if ($iter) $Enumerable_zip$110.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            others = $post_args;
            return $send(self.$to_a(), 'zip', Opal.to_a(others));
        }, $Enumerable_zip$110.$$arity = -1), nil) && 'zip';
    }($nesting14[0], $nesting14);
};
Opal.modules["corelib/enumerator"] = function(Opal) {
    function $rb_plus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
    }
    function $rb_lt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs < rhs : lhs['$<'](rhs);
    }
    var self62 = Opal.top, $nesting15 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $breaker = Opal.breaker, $slice = Opal.slice, $falsy = Opal.falsy, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $send = Opal.send, $send2 = Opal.send2;
    Opal.add_stubs([
        '$require',
        '$include',
        '$allocate',
        '$new',
        '$to_proc',
        '$!',
        '$respond_to?',
        '$nil?',
        '$empty?',
        '$+',
        '$class',
        '$__send__',
        '$call',
        '$enum_for',
        '$size',
        '$destructure',
        '$inspect',
        '$any?',
        '$[]',
        '$raise',
        '$yield',
        '$each',
        '$enumerator_size',
        '$try_convert',
        '$<',
        '$===',
        '$for'
    ]);
    self62.$require("corelib/enumerable");
    return function($base3, $super1, $parent_nesting6) {
        var self63 = $klass($base3, $super1, 'Enumerator');
        var $nesting16 = [
            self63
        ].concat($parent_nesting6), $Enumerator_for$1, $Enumerator_initialize$2, $Enumerator_each$3, $Enumerator_size$4, $Enumerator_with_index$5, $Enumerator_each_with_index$7, $Enumerator_inspect$9;
        self63.$$prototype.size = self63.$$prototype.args = self63.$$prototype.object = self63.$$prototype.method = nil;
        self63.$include($$($nesting16, 'Enumerable'));
        self63.$$prototype.$$is_enumerator = true;
        Opal.defs(self63, '$for', $Enumerator_for$1 = function(object, $a, $b) {
            var $iter = $Enumerator_for$1.$$p, block = $iter || nil, $post_args, method, args50, self = this;
            if ($iter) $Enumerator_for$1.$$p = null;
            if ($iter) $Enumerator_for$1.$$p = null;
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            if ($post_args.length > 0) {
                method = $post_args[0];
                $post_args.splice(0, 1);
            }
            if (method == null) {
                method = "each";
            }
            args50 = $post_args;
            var obj = self.$allocate();
            obj.object = object;
            obj.size = block;
            obj.method = method;
            obj.args = args50;
            return obj;
        }, $Enumerator_for$1.$$arity = -2);
        Opal.def(self63, '$initialize', $Enumerator_initialize$2 = function $$initialize($a) {
            var $iter = $Enumerator_initialize$2.$$p, block = $iter || nil, $post_args, self = this, $ret_or_1 = nil;
            if ($iter) $Enumerator_initialize$2.$$p = null;
            if ($iter) $Enumerator_initialize$2.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            if ($truthy(block)) {
                self.object = $send($$($nesting16, 'Generator'), 'new', [], block.$to_proc());
                self.method = "each";
                self.args = [];
                self.size = arguments[0] || nil;
                if ($truthy(function() {
                    if ($truthy($ret_or_1 = self.size)) {
                        return self.size['$respond_to?']("call")['$!']();
                    } else {
                        return $ret_or_1;
                    }
                    return nil;
                }())) {
                    return self.size = $coerce_to(self.size, $$($nesting16, 'Integer'), 'to_int');
                } else {
                    return nil;
                }
            } else {
                self.object = arguments[0];
                self.method = arguments[1] || "each";
                self.args = $slice.call(arguments, 2);
                return self.size = nil;
            }
        }, $Enumerator_initialize$2.$$arity = -1);
        Opal.def(self63, '$each', $Enumerator_each$3 = function $$each($a) {
            var $iter = $Enumerator_each$3.$$p, block = $iter || nil, $post_args, args51, self = this, $ret_or_2 = nil;
            if ($iter) $Enumerator_each$3.$$p = null;
            if ($iter) $Enumerator_each$3.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args51 = $post_args;
            if ($truthy(function() {
                if ($truthy($ret_or_2 = block['$nil?']())) {
                    return args51['$empty?']();
                } else {
                    return $ret_or_2;
                }
                return nil;
            }())) {
                return self;
            }
            args51 = $rb_plus(self.args, args51);
            if ($truthy(block['$nil?']())) {
                return $send(self.$class(), 'new', [
                    self.object,
                    self.method
                ].concat(Opal.to_a(args51)));
            }
            return $send(self.object, '__send__', [
                self.method
            ].concat(Opal.to_a(args51)), block.$to_proc());
        }, $Enumerator_each$3.$$arity = -1);
        Opal.def(self63, '$size', $Enumerator_size$4 = function $$size() {
            var self = this;
            if ($truthy(self.size['$respond_to?']("call"))) {
                return $send(self.size, 'call', Opal.to_a(self.args));
            } else {
                return self.size;
            }
        }, $Enumerator_size$4.$$arity = 0);
        Opal.def(self63, '$with_index', $Enumerator_with_index$5 = function $$with_index(offset) {
            var $iter = $Enumerator_with_index$5.$$p, block = $iter || nil, $$6, self64 = this;
            if ($iter) $Enumerator_with_index$5.$$p = null;
            if ($iter) $Enumerator_with_index$5.$$p = null;
            if (offset == null) {
                offset = 0;
            }
            offset = function() {
                if ($truthy(offset)) {
                    return $coerce_to(offset, $$($nesting16, 'Integer'), 'to_int');
                } else {
                    return 0;
                }
                return nil;
            }();
            if ($truthy(block)) {} else {
                return $send(self64, 'enum_for', [
                    "with_index",
                    offset
                ], ($$6 = function() {
                    var self = $$6.$$s == null ? this : $$6.$$s;
                    return self.$size();
                }, $$6.$$s = self64, $$6.$$arity = 0, $$6));
            }
            var index = offset;
            self64.$each.$$p = function() {
                var param = $$($nesting16, 'Opal').$destructure(arguments), value = block(param, index);
                index++;
                return value;
            };
            return self64.$each();
        }, $Enumerator_with_index$5.$$arity = -1);
        Opal.alias(self63, "with_object", "each_with_object");
        Opal.def(self63, '$each_with_index', $Enumerator_each_with_index$7 = function $$each_with_index() {
            var $iter = $Enumerator_each_with_index$7.$$p, block = $iter || nil, $$8, self65 = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
            if ($iter) $Enumerator_each_with_index$7.$$p = null;
            for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                $zuper[$zuper_i] = arguments[$zuper_i];
            }
            if ($iter) $Enumerator_each_with_index$7.$$p = null;
            if (block !== nil) {} else {
                return $send(self65, 'enum_for', [
                    "each_with_index"
                ], ($$8 = function() {
                    var self = $$8.$$s == null ? this : $$8.$$s;
                    return self.$size();
                }, $$8.$$s = self65, $$8.$$arity = 0, $$8));
            }
            $send2(self65, Opal.find_super_dispatcher(self65, 'each_with_index', $Enumerator_each_with_index$7, false, true), 'each_with_index', $zuper, $iter);
            return self65.object;
        }, $Enumerator_each_with_index$7.$$arity = 0);
        Opal.def(self63, '$inspect', $Enumerator_inspect$9 = function $$inspect() {
            var self = this, result = nil;
            result = "" + "#<" + self.$class() + ": " + self.object.$inspect() + ":" + self.method;
            if ($truthy(self.args['$any?']())) {
                result = $rb_plus(result, "" + "(" + self.args.$inspect()['$[]']($$($nesting16, 'Range').$new(1, -2)) + ")");
            }
            return $rb_plus(result, ">");
        }, $Enumerator_inspect$9.$$arity = 0);
        (function($base, $super, $parent_nesting) {
            var self66 = $klass($base, $super, 'Generator');
            var $nesting = [
                self66
            ].concat($parent_nesting), $Generator_initialize$10, $Generator_each$11;
            self66.$$prototype.block = nil;
            self66.$include($$($nesting, 'Enumerable'));
            Opal.def(self66, '$initialize', $Generator_initialize$10 = function $$initialize() {
                var $iter = $Generator_initialize$10.$$p, block = $iter || nil, self = this;
                if ($iter) $Generator_initialize$10.$$p = null;
                if ($iter) $Generator_initialize$10.$$p = null;
                if ($truthy(block)) {} else {
                    self.$raise($$($nesting, 'LocalJumpError'), "no block given");
                }
                return self.block = block;
            }, $Generator_initialize$10.$$arity = 0);
            return (Opal.def(self66, '$each', $Generator_each$11 = function $$each($a) {
                var $iter = $Generator_each$11.$$p, block = $iter || nil, $post_args, args52, self = this, yielder = nil;
                if ($iter) $Generator_each$11.$$p = null;
                if ($iter) $Generator_each$11.$$p = null;
                $post_args = Opal.slice.call(arguments, 0, arguments.length);
                args52 = $post_args;
                yielder = $send($$($nesting, 'Yielder'), 'new', [], block.$to_proc());
                try {
                    args52.unshift(yielder);
                    Opal.yieldX(self.block, args52);
                } catch (e) {
                    if (e === $breaker) {
                        return $breaker.$v;
                    } else {
                        throw e;
                    }
                }
                return self;
            }, $Generator_each$11.$$arity = -1), nil) && 'each';
        })($nesting16[0], null, $nesting16);
        (function($base, $super, $parent_nesting) {
            var self67 = $klass($base, $super, 'Yielder');
            var $nesting = [
                self67
            ].concat($parent_nesting), $Yielder_initialize$12, $Yielder_yield$13, $Yielder_$lt$lt$14;
            self67.$$prototype.block = nil;
            Opal.def(self67, '$initialize', $Yielder_initialize$12 = function $$initialize() {
                var $iter = $Yielder_initialize$12.$$p, block = $iter || nil, self = this;
                if ($iter) $Yielder_initialize$12.$$p = null;
                if ($iter) $Yielder_initialize$12.$$p = null;
                return self.block = block;
            }, $Yielder_initialize$12.$$arity = 0);
            Opal.def(self67, '$yield', $Yielder_yield$13 = function($a) {
                var $post_args, values, self = this;
                $post_args = Opal.slice.call(arguments, 0, arguments.length);
                values = $post_args;
                var value = Opal.yieldX(self.block, values);
                if (value === $breaker) {
                    throw $breaker;
                }
                return value;
            }, $Yielder_yield$13.$$arity = -1);
            return (Opal.def(self67, '$<<', $Yielder_$lt$lt$14 = function($a) {
                var $post_args, values, self = this;
                $post_args = Opal.slice.call(arguments, 0, arguments.length);
                values = $post_args;
                $send(self, 'yield', Opal.to_a(values));
                return self;
            }, $Yielder_$lt$lt$14.$$arity = -1), nil) && '<<';
        })($nesting16[0], null, $nesting16);
        (function($base4, $super2, $parent_nesting7) {
            var self68 = $klass($base4, $super2, 'Lazy');
            var $nesting = [
                self68
            ].concat($parent_nesting7), $Lazy_initialize$15, $Lazy_lazy$18, $Lazy_collect$19, $Lazy_collect_concat$21, $Lazy_drop$25, $Lazy_drop_while$27, $Lazy_enum_for$29, $Lazy_find_all$30, $Lazy_grep$32, $Lazy_reject$35, $Lazy_take$37, $Lazy_take_while$39, $Lazy_inspect$41;
            self68.$$prototype.enumerator = nil;
            (function($base, $super, $parent_nesting) {
                var self = $klass($base, $super, 'StopLazyError');
                [
                    self
                ].concat($parent_nesting);
                return nil;
            })($nesting[0], $$($nesting, 'Exception'), $nesting);
            Opal.def(self68, '$initialize', $Lazy_initialize$15 = function $$initialize(object, size) {
                var $iter = $Lazy_initialize$15.$$p, block = $iter || nil, $$16, self69 = this;
                if ($iter) $Lazy_initialize$15.$$p = null;
                if ($iter) $Lazy_initialize$15.$$p = null;
                if (size == null) {
                    size = nil;
                }
                if (block !== nil) {} else {
                    self69.$raise($$($nesting, 'ArgumentError'), "tried to call lazy new without a block");
                }
                self69.enumerator = object;
                return $send2(self69, Opal.find_super_dispatcher(self69, 'initialize', $Lazy_initialize$15, false, true), 'initialize', [
                    size
                ], ($$16 = function(yielder, $a) {
                    var self = $$16.$$s == null ? this : $$16.$$s, $post_args1, each_args, $$17;
                    if (yielder == null) {
                        yielder = nil;
                    }
                    $post_args1 = Opal.slice.call(arguments, 1, arguments.length);
                    each_args = $post_args1;
                    try {
                        return $send(object, 'each', Opal.to_a(each_args), ($$17 = function($b) {
                            var self = $$17.$$s == null ? this : $$17.$$s, $post_args, args53;
                            $post_args = Opal.slice.call(arguments, 0, arguments.length);
                            args53 = $post_args;
                            args53.unshift(yielder);
                            Opal.yieldX(block, args53);
                        }, $$17.$$s = self, $$17.$$arity = -1, $$17));
                    } catch ($err) {
                        if (Opal.rescue($err, [
                            $$($nesting, 'Exception')
                        ])) {
                            try {
                                return nil;
                            } finally{
                                Opal.pop_exception();
                            }
                        } else {
                            throw $err;
                        }
                    }
                }, $$16.$$s = self69, $$16.$$arity = -2, $$16));
            }, $Lazy_initialize$15.$$arity = -2);
            Opal.alias(self68, "force", "to_a");
            Opal.def(self68, '$lazy', $Lazy_lazy$18 = function $$lazy() {
                var self = this;
                return self;
            }, $Lazy_lazy$18.$$arity = 0);
            Opal.def(self68, '$collect', $Lazy_collect$19 = function $$collect() {
                var $iter = $Lazy_collect$19.$$p, block = $iter || nil, $$20, self = this;
                if ($iter) $Lazy_collect$19.$$p = null;
                if ($iter) $Lazy_collect$19.$$p = null;
                if ($truthy(block)) {} else {
                    self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy map without a block");
                }
                return $send($$($nesting, 'Lazy'), 'new', [
                    self,
                    self.$enumerator_size()
                ], ($$20 = function(enum$, $a) {
                    var self = $$20.$$s == null ? this : $$20.$$s, $post_args, args54;
                    if (enum$ == null) {
                        enum$ = nil;
                    }
                    $post_args = Opal.slice.call(arguments, 1, arguments.length);
                    args54 = $post_args;
                    var value = Opal.yieldX(block, args54);
                    enum$.$yield(value);
                }, $$20.$$s = self, $$20.$$arity = -2, $$20));
            }, $Lazy_collect$19.$$arity = 0);
            Opal.def(self68, '$collect_concat', $Lazy_collect_concat$21 = function $$collect_concat() {
                var $iter = $Lazy_collect_concat$21.$$p, block = $iter || nil, $$22, self70 = this;
                if ($iter) $Lazy_collect_concat$21.$$p = null;
                if ($iter) $Lazy_collect_concat$21.$$p = null;
                if ($truthy(block)) {} else {
                    self70.$raise($$($nesting, 'ArgumentError'), "tried to call lazy map without a block");
                }
                return $send($$($nesting, 'Lazy'), 'new', [
                    self70,
                    nil
                ], ($$22 = function(enum$, $a) {
                    var self = $$22.$$s == null ? this : $$22.$$s, $post_args, args55, $$23, $$24;
                    if (enum$ == null) {
                        enum$ = nil;
                    }
                    $post_args = Opal.slice.call(arguments, 1, arguments.length);
                    args55 = $post_args;
                    var value = Opal.yieldX(block, args55);
                    if (value['$respond_to?']("force") && value['$respond_to?']("each")) {
                        $send(value, 'each', [], ($$23 = function(v) {
                            $$23.$$s == null ? this : $$23.$$s;
                            if (v == null) {
                                v = nil;
                            }
                            return enum$.$yield(v);
                        }, $$23.$$s = self, $$23.$$arity = 1, $$23));
                    } else {
                        var array = $$($nesting, 'Opal').$try_convert(value, $$($nesting, 'Array'), "to_ary");
                        if (array === nil) {
                            enum$.$yield(value);
                        } else {
                            $send(value, 'each', [], ($$24 = function(v) {
                                $$24.$$s == null ? this : $$24.$$s;
                                if (v == null) {
                                    v = nil;
                                }
                                return enum$.$yield(v);
                            }, $$24.$$s = self, $$24.$$arity = 1, $$24));
                        }
                    }
                }, $$22.$$s = self70, $$22.$$arity = -2, $$22));
            }, $Lazy_collect_concat$21.$$arity = 0);
            Opal.def(self68, '$drop', $Lazy_drop$25 = function $$drop(n) {
                var $$26, self = this, current_size = nil, set_size = nil, dropped = nil;
                n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
                if ($truthy($rb_lt(n, 0))) {
                    self.$raise($$($nesting, 'ArgumentError'), "attempt to drop negative size");
                }
                current_size = self.$enumerator_size();
                set_size = function() {
                    if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {
                        if ($truthy($rb_lt(n, current_size))) {
                            return n;
                        } else {
                            return current_size;
                        }
                    } else {
                        return current_size;
                    }
                    return nil;
                }();
                dropped = 0;
                return $send($$($nesting, 'Lazy'), 'new', [
                    self,
                    set_size
                ], ($$26 = function(enum$, $a) {
                    var self = $$26.$$s == null ? this : $$26.$$s, $post_args, args56;
                    if (enum$ == null) {
                        enum$ = nil;
                    }
                    $post_args = Opal.slice.call(arguments, 1, arguments.length);
                    args56 = $post_args;
                    if ($truthy($rb_lt(dropped, n))) {
                        return dropped = $rb_plus(dropped, 1);
                    } else {
                        return $send(enum$, 'yield', Opal.to_a(args56));
                    }
                }, $$26.$$s = self, $$26.$$arity = -2, $$26));
            }, $Lazy_drop$25.$$arity = 1);
            Opal.def(self68, '$drop_while', $Lazy_drop_while$27 = function $$drop_while() {
                var $iter = $Lazy_drop_while$27.$$p, block = $iter || nil, $$28, self = this, succeeding = nil;
                if ($iter) $Lazy_drop_while$27.$$p = null;
                if ($iter) $Lazy_drop_while$27.$$p = null;
                if ($truthy(block)) {} else {
                    self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy drop_while without a block");
                }
                succeeding = true;
                return $send($$($nesting, 'Lazy'), 'new', [
                    self,
                    nil
                ], ($$28 = function(enum$, $a) {
                    var self = $$28.$$s == null ? this : $$28.$$s, $post_args, args57;
                    if (enum$ == null) {
                        enum$ = nil;
                    }
                    $post_args = Opal.slice.call(arguments, 1, arguments.length);
                    args57 = $post_args;
                    if ($truthy(succeeding)) {
                        var value = Opal.yieldX(block, args57);
                        if ($falsy(value)) {
                            succeeding = false;
                            $send(enum$, 'yield', Opal.to_a(args57));
                        }
                    } else {
                        return $send(enum$, 'yield', Opal.to_a(args57));
                    }
                }, $$28.$$s = self, $$28.$$arity = -2, $$28));
            }, $Lazy_drop_while$27.$$arity = 0);
            Opal.def(self68, '$enum_for', $Lazy_enum_for$29 = function $$enum_for($a, $b) {
                var $iter = $Lazy_enum_for$29.$$p, block = $iter || nil, $post_args, method, args58, self = this;
                if ($iter) $Lazy_enum_for$29.$$p = null;
                if ($iter) $Lazy_enum_for$29.$$p = null;
                $post_args = Opal.slice.call(arguments, 0, arguments.length);
                if ($post_args.length > 0) {
                    method = $post_args[0];
                    $post_args.splice(0, 1);
                }
                if (method == null) {
                    method = "each";
                }
                args58 = $post_args;
                return $send(self.$class(), 'for', [
                    self,
                    method
                ].concat(Opal.to_a(args58)), block.$to_proc());
            }, $Lazy_enum_for$29.$$arity = -1);
            Opal.alias(self68, "filter", "find_all");
            Opal.def(self68, '$find_all', $Lazy_find_all$30 = function $$find_all() {
                var $iter = $Lazy_find_all$30.$$p, block = $iter || nil, $$31, self = this;
                if ($iter) $Lazy_find_all$30.$$p = null;
                if ($iter) $Lazy_find_all$30.$$p = null;
                if ($truthy(block)) {} else {
                    self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy select without a block");
                }
                return $send($$($nesting, 'Lazy'), 'new', [
                    self,
                    nil
                ], ($$31 = function(enum$, $a) {
                    var self = $$31.$$s == null ? this : $$31.$$s, $post_args, args59;
                    if (enum$ == null) {
                        enum$ = nil;
                    }
                    $post_args = Opal.slice.call(arguments, 1, arguments.length);
                    args59 = $post_args;
                    var value = Opal.yieldX(block, args59);
                    if ($truthy(value)) {
                        $send(enum$, 'yield', Opal.to_a(args59));
                    }
                }, $$31.$$s = self, $$31.$$arity = -2, $$31));
            }, $Lazy_find_all$30.$$arity = 0);
            Opal.alias(self68, "flat_map", "collect_concat");
            Opal.def(self68, '$grep', $Lazy_grep$32 = function $$grep(pattern) {
                var $iter = $Lazy_grep$32.$$p, block = $iter || nil, $$33, $$34, self = this;
                if ($iter) $Lazy_grep$32.$$p = null;
                if ($iter) $Lazy_grep$32.$$p = null;
                if ($truthy(block)) {
                    return $send($$($nesting, 'Lazy'), 'new', [
                        self,
                        nil
                    ], ($$33 = function(enum$, $a) {
                        var self = $$33.$$s == null ? this : $$33.$$s, $post_args, args60;
                        if (enum$ == null) {
                            enum$ = nil;
                        }
                        $post_args = Opal.slice.call(arguments, 1, arguments.length);
                        args60 = $post_args;
                        var param = $$($nesting, 'Opal').$destructure(args60), value = pattern['$==='](param);
                        if ($truthy(value)) {
                            value = Opal.yield1(block, param);
                            enum$.$yield(Opal.yield1(block, param));
                        }
                    }, $$33.$$s = self, $$33.$$arity = -2, $$33));
                } else {
                    return $send($$($nesting, 'Lazy'), 'new', [
                        self,
                        nil
                    ], ($$34 = function(enum$, $a) {
                        var self = $$34.$$s == null ? this : $$34.$$s, $post_args, args61;
                        if (enum$ == null) {
                            enum$ = nil;
                        }
                        $post_args = Opal.slice.call(arguments, 1, arguments.length);
                        args61 = $post_args;
                        var param = $$($nesting, 'Opal').$destructure(args61), value = pattern['$==='](param);
                        if ($truthy(value)) {
                            enum$.$yield(param);
                        }
                    }, $$34.$$s = self, $$34.$$arity = -2, $$34));
                }
            }, $Lazy_grep$32.$$arity = 1);
            Opal.alias(self68, "map", "collect");
            Opal.alias(self68, "select", "find_all");
            Opal.def(self68, '$reject', $Lazy_reject$35 = function $$reject() {
                var $iter = $Lazy_reject$35.$$p, block = $iter || nil, $$36, self = this;
                if ($iter) $Lazy_reject$35.$$p = null;
                if ($iter) $Lazy_reject$35.$$p = null;
                if ($truthy(block)) {} else {
                    self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy reject without a block");
                }
                return $send($$($nesting, 'Lazy'), 'new', [
                    self,
                    nil
                ], ($$36 = function(enum$, $a) {
                    var self = $$36.$$s == null ? this : $$36.$$s, $post_args, args62;
                    if (enum$ == null) {
                        enum$ = nil;
                    }
                    $post_args = Opal.slice.call(arguments, 1, arguments.length);
                    args62 = $post_args;
                    var value = Opal.yieldX(block, args62);
                    if ($falsy(value)) {
                        $send(enum$, 'yield', Opal.to_a(args62));
                    }
                }, $$36.$$s = self, $$36.$$arity = -2, $$36));
            }, $Lazy_reject$35.$$arity = 0);
            Opal.def(self68, '$take', $Lazy_take$37 = function $$take(n) {
                var $$38, self71 = this, current_size = nil, set_size = nil, taken = nil;
                n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
                if ($truthy($rb_lt(n, 0))) {
                    self71.$raise($$($nesting, 'ArgumentError'), "attempt to take negative size");
                }
                current_size = self71.$enumerator_size();
                set_size = function() {
                    if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {
                        if ($truthy($rb_lt(n, current_size))) {
                            return n;
                        } else {
                            return current_size;
                        }
                    } else {
                        return current_size;
                    }
                    return nil;
                }();
                taken = 0;
                return $send($$($nesting, 'Lazy'), 'new', [
                    self71,
                    set_size
                ], ($$38 = function(enum$, $a) {
                    var self = $$38.$$s == null ? this : $$38.$$s, $post_args, args63;
                    if (enum$ == null) {
                        enum$ = nil;
                    }
                    $post_args = Opal.slice.call(arguments, 1, arguments.length);
                    args63 = $post_args;
                    if ($truthy($rb_lt(taken, n))) {
                        $send(enum$, 'yield', Opal.to_a(args63));
                        return taken = $rb_plus(taken, 1);
                    } else {
                        return self.$raise($$($nesting, 'StopLazyError'));
                    }
                }, $$38.$$s = self71, $$38.$$arity = -2, $$38));
            }, $Lazy_take$37.$$arity = 1);
            Opal.def(self68, '$take_while', $Lazy_take_while$39 = function $$take_while() {
                var $iter = $Lazy_take_while$39.$$p, block = $iter || nil, $$40, self72 = this;
                if ($iter) $Lazy_take_while$39.$$p = null;
                if ($iter) $Lazy_take_while$39.$$p = null;
                if ($truthy(block)) {} else {
                    self72.$raise($$($nesting, 'ArgumentError'), "tried to call lazy take_while without a block");
                }
                return $send($$($nesting, 'Lazy'), 'new', [
                    self72,
                    nil
                ], ($$40 = function(enum$, $a) {
                    var self = $$40.$$s == null ? this : $$40.$$s, $post_args, args64;
                    if (enum$ == null) {
                        enum$ = nil;
                    }
                    $post_args = Opal.slice.call(arguments, 1, arguments.length);
                    args64 = $post_args;
                    var value = Opal.yieldX(block, args64);
                    if ($truthy(value)) {
                        $send(enum$, 'yield', Opal.to_a(args64));
                    } else {
                        self.$raise($$($nesting, 'StopLazyError'));
                    }
                }, $$40.$$s = self72, $$40.$$arity = -2, $$40));
            }, $Lazy_take_while$39.$$arity = 0);
            Opal.alias(self68, "to_enum", "enum_for");
            return (Opal.def(self68, '$inspect', $Lazy_inspect$41 = function $$inspect() {
                var self = this;
                return "" + "#<" + self.$class() + ": " + self.enumerator.$inspect() + ">";
            }, $Lazy_inspect$41.$$arity = 0), nil) && 'inspect';
        })($nesting16[0], self63, $nesting16);
        return function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'ArithmeticSequence');
            [
                self
            ].concat($parent_nesting);
            return nil;
        }($nesting16[0], self63, $nesting16);
    }($nesting15[0], null, $nesting15);
};
Opal.modules["corelib/numeric"] = function(Opal) {
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    function $rb_times(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs * rhs : lhs['$*'](rhs);
    }
    function $rb_lt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs < rhs : lhs['$<'](rhs);
    }
    function $rb_divide(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs / rhs : lhs['$/'](rhs);
    }
    function $rb_ge(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs >= rhs : lhs['$>='](rhs);
    }
    function $rb_le(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs <= rhs : lhs['$<='](rhs);
    }
    function $rb_plus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
    }
    function $rb_gt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs > rhs : lhs['$>'](rhs);
    }
    var self73 = Opal.top, $nesting17 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;
    Opal.add_stubs([
        '$require',
        '$include',
        '$instance_of?',
        '$class',
        '$Float',
        '$respond_to?',
        '$coerce',
        '$__send__',
        '$===',
        '$raise',
        '$equal?',
        '$-',
        '$*',
        '$div',
        '$<',
        '$-@',
        '$ceil',
        '$to_f',
        '$denominator',
        '$to_r',
        '$==',
        '$floor',
        '$/',
        '$%',
        '$Complex',
        '$zero?',
        '$numerator',
        '$abs',
        '$arg',
        '$coerce_to!',
        '$round',
        '$<=>',
        '$compare',
        '$enum_for',
        '$to_proc',
        '$negative?',
        '$>=',
        '$<=',
        '$+',
        '$to_i',
        '$truncate',
        '$>'
    ]);
    self73.$require("corelib/comparable");
    return function($base, $super, $parent_nesting) {
        var self74 = $klass($base, $super, 'Numeric');
        var $nesting = [
            self74
        ].concat($parent_nesting), $Numeric_coerce$1, $Numeric___coerced__$2, $Numeric_$lt_eq_gt$3, $Numeric_$plus$$4, $Numeric_$minus$$5, $Numeric_$percent$6, $Numeric_abs$7, $Numeric_abs2$8, $Numeric_angle$9, $Numeric_ceil$10, $Numeric_conj$11, $Numeric_denominator$12, $Numeric_div$13, $Numeric_divmod$14, $Numeric_fdiv$15, $Numeric_floor$16, $Numeric_i$17, $Numeric_imag$18, $Numeric_integer$ques$19, $Numeric_nonzero$ques$20, $Numeric_numerator$21, $Numeric_polar$22, $Numeric_quo$23, $Numeric_real$24, $Numeric_real$ques$25, $Numeric_rect$26, $Numeric_round$27, $Numeric_step$28, $Numeric_to_c$29, $Numeric_to_int$30, $Numeric_truncate$31, $Numeric_zero$ques$32, $Numeric_positive$ques$33, $Numeric_negative$ques$34, $Numeric_dup$35, $Numeric_clone$36, $Numeric_finite$ques$37, $Numeric_infinite$ques$38;
        self74.$include($$($nesting, 'Comparable'));
        Opal.def(self74, '$coerce', $Numeric_coerce$1 = function $$coerce(other) {
            var self = this;
            if ($truthy(other['$instance_of?'](self.$class()))) {
                return [
                    other,
                    self
                ];
            }
            return [
                self.$Float(other),
                self.$Float(self)
            ];
        }, $Numeric_coerce$1.$$arity = 1);
        Opal.def(self74, '$__coerced__', $Numeric___coerced__$2 = function $$__coerced__(method, other) {
            var $a, $b, self = this, a = nil, b = nil, $case = nil;
            if ($truthy(other['$respond_to?']("coerce"))) {
                $b = other.$coerce(self), $a = Opal.to_ary($b), a = $a[0] == null ? nil : $a[0], b = $a[1] == null ? nil : $a[1], $b;
                return a.$__send__(method, b);
            } else {
                return function() {
                    $case = method;
                    if ("+"['$===']($case) || "-"['$===']($case) || "*"['$===']($case) || "/"['$===']($case) || "%"['$===']($case) || "&"['$===']($case) || "|"['$===']($case) || "^"['$===']($case) || "**"['$===']($case)) {
                        return self.$raise($$($nesting, 'TypeError'), "" + other.$class() + " can't be coerced into Numeric");
                    } else if (">"['$===']($case) || ">="['$===']($case) || "<"['$===']($case) || "<="['$===']($case) || "<=>"['$===']($case)) {
                        return self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + self.$class() + " with " + other.$class() + " failed");
                    } else {
                        return nil;
                    }
                }();
            }
        }, $Numeric___coerced__$2.$$arity = 2);
        Opal.def(self74, '$<=>', $Numeric_$lt_eq_gt$3 = function(other) {
            var self = this;
            if ($truthy(self['$equal?'](other))) {
                return 0;
            }
            return nil;
        }, $Numeric_$lt_eq_gt$3.$$arity = 1);
        Opal.def(self74, '$+@', $Numeric_$plus$$4 = function() {
            var self = this;
            return self;
        }, $Numeric_$plus$$4.$$arity = 0);
        Opal.def(self74, '$-@', $Numeric_$minus$$5 = function() {
            var self = this;
            return $rb_minus(0, self);
        }, $Numeric_$minus$$5.$$arity = 0);
        Opal.def(self74, '$%', $Numeric_$percent$6 = function(other) {
            var self = this;
            return $rb_minus(self, $rb_times(other, self.$div(other)));
        }, $Numeric_$percent$6.$$arity = 1);
        Opal.def(self74, '$abs', $Numeric_abs$7 = function $$abs() {
            var self = this;
            if ($rb_lt(self, 0)) {
                return self['$-@']();
            } else {
                return self;
            }
        }, $Numeric_abs$7.$$arity = 0);
        Opal.def(self74, '$abs2', $Numeric_abs2$8 = function $$abs2() {
            var self = this;
            return $rb_times(self, self);
        }, $Numeric_abs2$8.$$arity = 0);
        Opal.def(self74, '$angle', $Numeric_angle$9 = function $$angle() {
            var self = this;
            if ($rb_lt(self, 0)) {
                return $$$($$($nesting, 'Math'), 'PI');
            } else {
                return 0;
            }
        }, $Numeric_angle$9.$$arity = 0);
        Opal.alias(self74, "arg", "angle");
        Opal.def(self74, '$ceil', $Numeric_ceil$10 = function $$ceil(ndigits) {
            var self = this;
            if (ndigits == null) {
                ndigits = 0;
            }
            return self.$to_f().$ceil(ndigits);
        }, $Numeric_ceil$10.$$arity = -1);
        Opal.def(self74, '$conj', $Numeric_conj$11 = function $$conj() {
            var self = this;
            return self;
        }, $Numeric_conj$11.$$arity = 0);
        Opal.alias(self74, "conjugate", "conj");
        Opal.def(self74, '$denominator', $Numeric_denominator$12 = function $$denominator() {
            var self = this;
            return self.$to_r().$denominator();
        }, $Numeric_denominator$12.$$arity = 0);
        Opal.def(self74, '$div', $Numeric_div$13 = function $$div(other) {
            var self = this;
            if (other['$=='](0)) {
                self.$raise($$($nesting, 'ZeroDivisionError'), "divided by o");
            }
            return $rb_divide(self, other).$floor();
        }, $Numeric_div$13.$$arity = 1);
        Opal.def(self74, '$divmod', $Numeric_divmod$14 = function $$divmod(other) {
            var self = this;
            return [
                self.$div(other),
                self['$%'](other)
            ];
        }, $Numeric_divmod$14.$$arity = 1);
        Opal.def(self74, '$fdiv', $Numeric_fdiv$15 = function $$fdiv(other) {
            var self = this;
            return $rb_divide(self.$to_f(), other);
        }, $Numeric_fdiv$15.$$arity = 1);
        Opal.def(self74, '$floor', $Numeric_floor$16 = function $$floor(ndigits) {
            var self = this;
            if (ndigits == null) {
                ndigits = 0;
            }
            return self.$to_f().$floor(ndigits);
        }, $Numeric_floor$16.$$arity = -1);
        Opal.def(self74, '$i', $Numeric_i$17 = function $$i() {
            var self = this;
            return self.$Complex(0, self);
        }, $Numeric_i$17.$$arity = 0);
        Opal.def(self74, '$imag', $Numeric_imag$18 = function $$imag() {
            return 0;
        }, $Numeric_imag$18.$$arity = 0);
        Opal.alias(self74, "imaginary", "imag");
        Opal.def(self74, '$integer?', $Numeric_integer$ques$19 = function() {
            return false;
        }, $Numeric_integer$ques$19.$$arity = 0);
        Opal.alias(self74, "magnitude", "abs");
        Opal.alias(self74, "modulo", "%");
        Opal.def(self74, '$nonzero?', $Numeric_nonzero$ques$20 = function() {
            var self = this;
            if ($truthy(self['$zero?']())) {
                return nil;
            } else {
                return self;
            }
        }, $Numeric_nonzero$ques$20.$$arity = 0);
        Opal.def(self74, '$numerator', $Numeric_numerator$21 = function $$numerator() {
            var self = this;
            return self.$to_r().$numerator();
        }, $Numeric_numerator$21.$$arity = 0);
        Opal.alias(self74, "phase", "arg");
        Opal.def(self74, '$polar', $Numeric_polar$22 = function $$polar() {
            var self = this;
            return [
                self.$abs(),
                self.$arg()
            ];
        }, $Numeric_polar$22.$$arity = 0);
        Opal.def(self74, '$quo', $Numeric_quo$23 = function $$quo(other) {
            var self = this;
            return $rb_divide($$($nesting, 'Opal')['$coerce_to!'](self, $$($nesting, 'Rational'), "to_r"), other);
        }, $Numeric_quo$23.$$arity = 1);
        Opal.def(self74, '$real', $Numeric_real$24 = function $$real() {
            var self = this;
            return self;
        }, $Numeric_real$24.$$arity = 0);
        Opal.def(self74, '$real?', $Numeric_real$ques$25 = function() {
            return true;
        }, $Numeric_real$ques$25.$$arity = 0);
        Opal.def(self74, '$rect', $Numeric_rect$26 = function $$rect() {
            var self = this;
            return [
                self,
                0
            ];
        }, $Numeric_rect$26.$$arity = 0);
        Opal.alias(self74, "rectangular", "rect");
        Opal.def(self74, '$round', $Numeric_round$27 = function $$round(digits) {
            var self = this;
            return self.$to_f().$round(digits);
        }, $Numeric_round$27.$$arity = -1);
        Opal.def(self74, '$step', $Numeric_step$28 = function $$step($a, $b, $c) {
            var $iter = $Numeric_step$28.$$p, block = $iter || nil, $post_args, $kwargs, limit, step, to, by, self = this, counter = nil;
            if ($iter) $Numeric_step$28.$$p = null;
            if ($iter) $Numeric_step$28.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            $kwargs = Opal.extract_kwargs($post_args);
            if ($kwargs == null) {
                $kwargs = $hash2([], {});
            } else if (!$kwargs.$$is_hash) {
                throw Opal.ArgumentError.$new('expected kwargs');
            }
            if ($post_args.length > 0) {
                limit = $post_args[0];
                $post_args.splice(0, 1);
            }
            if ($post_args.length > 0) {
                step = $post_args[0];
                $post_args.splice(0, 1);
            }
            to = $kwargs.$$smap["to"];
            by = $kwargs.$$smap["by"];
            if (limit !== undefined && to !== undefined) {
                self.$raise($$($nesting, 'ArgumentError'), "to is given twice");
            }
            if (step !== undefined && by !== undefined) {
                self.$raise($$($nesting, 'ArgumentError'), "step is given twice");
            }
            if (to !== undefined) {
                limit = to;
            }
            if (by !== undefined) {
                step = by;
            }
            if (limit === undefined) {
                limit = nil;
            }
            function validateParameters() {
                if (step === nil) {
                    self.$raise($$($nesting, 'TypeError'), "step must be numeric");
                }
                if (step != null && step['$=='](0)) {
                    self.$raise($$($nesting, 'ArgumentError'), "step can't be 0");
                }
                if (step === nil || step == null) {
                    step = 1;
                }
                var sign = step['$<=>'](0);
                if (sign === nil) {
                    self.$raise($$($nesting, 'ArgumentError'), "" + "0 can't be coerced into " + step.$class());
                }
                if (limit === nil || limit == null) {
                    limit = sign > 0 ? $$$($$($nesting, 'Float'), 'INFINITY') : $$$($$($nesting, 'Float'), 'INFINITY')['$-@']();
                }
                $$($nesting, 'Opal').$compare(self, limit);
            }
            function stepFloatSize() {
                if (step > 0 && self > limit || step < 0 && self < limit) {
                    return 0;
                } else if (step === Infinity || step === -Infinity) {
                    return 1;
                } else {
                    var abs = Math.abs, floor = Math.floor, err = (abs(self) + abs(limit) + abs(limit - self)) / abs(step) * $$$($$($nesting, 'Float'), 'EPSILON');
                    if (err === Infinity || err === -Infinity) {
                        return 0;
                    } else {
                        if (err > 0.5) {
                            err = 0.5;
                        }
                        return floor((limit - self) / step + err) + 1;
                    }
                }
            }
            function stepSize() {
                validateParameters();
                if (step === 0) {
                    return Infinity;
                }
                if (step % 1 !== 0) {
                    return stepFloatSize();
                } else if (step > 0 && self > limit || step < 0 && self < limit) {
                    return 0;
                } else {
                    var ceil = Math.ceil, abs = Math.abs, lhs = abs(self - limit) + 1, rhs = abs(step);
                    return ceil(lhs / rhs);
                }
            }
            if (block !== nil) {} else {
                return $send(self, 'enum_for', [
                    "step",
                    limit,
                    step
                ], stepSize.$to_proc());
            }
            validateParameters();
            var isDesc = step['$negative?'](), isInf = step['$=='](0) || limit === Infinity && !isDesc || limit === -Infinity && isDesc;
            if (self.$$is_number && step.$$is_number && limit.$$is_number) {
                if (self % 1 === 0 && (isInf || limit % 1 === 0) && step % 1 === 0) {
                    var value = self;
                    if (isInf) {
                        for(;; value += step){
                            block(value);
                        }
                    } else if (isDesc) {
                        for(; value >= limit; value += step){
                            block(value);
                        }
                    } else {
                        for(; value <= limit; value += step){
                            block(value);
                        }
                    }
                    return self;
                } else {
                    var begin = self.$to_f().valueOf();
                    step = step.$to_f().valueOf();
                    limit = limit.$to_f().valueOf();
                    var n = stepFloatSize();
                    if (!isFinite(step)) {
                        if (n !== 0) block(begin);
                    } else if (step === 0) {
                        while(true){
                            block(begin);
                        }
                    } else {
                        for(var i195 = 0; i195 < n; i195++){
                            var d = i195 * step + self;
                            if (step >= 0 ? limit < d : limit > d) {
                                d = limit;
                            }
                            block(d);
                        }
                    }
                    return self;
                }
            }
            counter = self;
            while($truthy(isDesc ? $rb_ge(counter, limit) : $rb_le(counter, limit))){
                Opal.yield1(block, counter);
                counter = $rb_plus(counter, step);
            }
        }, $Numeric_step$28.$$arity = -1);
        Opal.def(self74, '$to_c', $Numeric_to_c$29 = function $$to_c() {
            var self = this;
            return self.$Complex(self, 0);
        }, $Numeric_to_c$29.$$arity = 0);
        Opal.def(self74, '$to_int', $Numeric_to_int$30 = function $$to_int() {
            var self = this;
            return self.$to_i();
        }, $Numeric_to_int$30.$$arity = 0);
        Opal.def(self74, '$truncate', $Numeric_truncate$31 = function $$truncate(ndigits) {
            var self = this;
            if (ndigits == null) {
                ndigits = 0;
            }
            return self.$to_f().$truncate(ndigits);
        }, $Numeric_truncate$31.$$arity = -1);
        Opal.def(self74, '$zero?', $Numeric_zero$ques$32 = function() {
            var self = this;
            return self['$=='](0);
        }, $Numeric_zero$ques$32.$$arity = 0);
        Opal.def(self74, '$positive?', $Numeric_positive$ques$33 = function() {
            var self = this;
            return $rb_gt(self, 0);
        }, $Numeric_positive$ques$33.$$arity = 0);
        Opal.def(self74, '$negative?', $Numeric_negative$ques$34 = function() {
            var self = this;
            return $rb_lt(self, 0);
        }, $Numeric_negative$ques$34.$$arity = 0);
        Opal.def(self74, '$dup', $Numeric_dup$35 = function $$dup() {
            var self = this;
            return self;
        }, $Numeric_dup$35.$$arity = 0);
        Opal.def(self74, '$clone', $Numeric_clone$36 = function $$clone($kwargs) {
            var freeze, self = this;
            if ($kwargs == null) {
                $kwargs = $hash2([], {});
            } else if (!$kwargs.$$is_hash) {
                throw Opal.ArgumentError.$new('expected kwargs');
            }
            freeze = $kwargs.$$smap["freeze"];
            if (freeze == null) {
                freeze = true;
            }
            return self;
        }, $Numeric_clone$36.$$arity = -1);
        Opal.def(self74, '$finite?', $Numeric_finite$ques$37 = function() {
            return true;
        }, $Numeric_finite$ques$37.$$arity = 0);
        return (Opal.def(self74, '$infinite?', $Numeric_infinite$ques$38 = function() {
            return nil;
        }, $Numeric_infinite$ques$38.$$arity = 0), nil) && 'infinite?';
    }($nesting17[0], null, $nesting17);
};
Opal.modules["corelib/array"] = function(Opal) {
    function $rb_gt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs > rhs : lhs['$>'](rhs);
    }
    function $rb_times(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs * rhs : lhs['$*'](rhs);
    }
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    function $rb_ge(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs >= rhs : lhs['$>='](rhs);
    }
    function $rb_lt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs < rhs : lhs['$<'](rhs);
    }
    var self75 = Opal.top, $nesting18 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $falsy = Opal.falsy, $hash_ids = Opal.hash_ids, $yield1 = Opal.yield1, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $hash_delete = Opal.hash_delete, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $klass = Opal.klass, $hash2 = Opal.hash2, $send2 = Opal.send2, $send = Opal.send, $gvars = Opal.gvars;
    Opal.add_stubs([
        '$require',
        '$include',
        '$to_a',
        '$warn',
        '$raise',
        '$replace',
        '$respond_to?',
        '$to_ary',
        '$coerce_to?',
        '$===',
        '$join',
        '$to_str',
        '$hash',
        '$<=>',
        '$==',
        '$object_id',
        '$inspect',
        '$enum_for',
        '$class',
        '$bsearch_index',
        '$to_proc',
        '$nil?',
        '$coerce_to!',
        '$>',
        '$*',
        '$enumerator_size',
        '$empty?',
        '$size',
        '$map',
        '$equal?',
        '$dup',
        '$each',
        '$reduce',
        '$-',
        '$[]',
        '$dig',
        '$eql?',
        '$length',
        '$exclude_end?',
        '$flatten',
        '$__id__',
        '$&',
        '$to_s',
        '$new',
        '$max',
        '$min',
        '$!',
        '$>=',
        '$**',
        '$delete_if',
        '$reverse',
        '$rotate',
        '$rand',
        '$at',
        '$keep_if',
        '$shuffle!',
        '$<',
        '$sort',
        '$sort_by',
        '$!=',
        '$times',
        '$[]=',
        '$<<',
        '$uniq',
        '$|',
        '$values',
        '$is_a?',
        '$last',
        '$first',
        '$upto',
        '$reject',
        '$pristine',
        '$singleton_class'
    ]);
    self75.$require("corelib/enumerable");
    self75.$require("corelib/numeric");
    return function($base5, $super3, $parent_nesting8) {
        var self76 = $klass($base5, $super3, 'Array');
        var $nesting19 = [
            self76
        ].concat($parent_nesting8), $Array_$$$1, $Array_initialize$2, $Array_try_convert$3, $Array_$$4, $Array_$$5, $Array_$$6, $Array_$plus$7, $Array_$minus$8, $Array_$lt$lt$9, $Array_$lt_eq_gt$10, $Array_$eq_eq$11, $Array_$$$12, $Array_$$$eq$13, $Array_any$ques$14, $Array_assoc$15, $Array_at$16, $Array_bsearch_index$17, $Array_bsearch$18, $Array_cycle$19, $Array_clear$21, $Array_count$22, $Array_initialize_copy$23, $Array_collect$24, $Array_collect$excl$26, $Array_combination$28, $Array_repeated_combination$30, $Array_compact$32, $Array_compact$excl$33, $Array_concat$34, $Array_delete$37, $Array_delete_at$38, $Array_delete_if$39, $Array_difference$41, $Array_dig$43, $Array_drop$44, $Array_dup$45, $Array_each$46, $Array_each_index$48, $Array_empty$ques$50, $Array_eql$ques$51, $Array_fetch$52, $Array_fill$53, $Array_first$54, $Array_flatten$55, $Array_flatten$excl$56, $Array_hash$57, $Array_include$ques$58, $Array_index$59, $Array_insert$60, $Array_inspect$61, $Array_intersection$62, $Array_join$64, $Array_keep_if$65, $Array_last$67, $Array_length$68, $Array_max$69, $Array_min$70, $Array_permutation$71, $Array_repeated_permutation$73, $Array_pop$75, $Array_product$76, $Array_push$77, $Array_rassoc$78, $Array_reject$79, $Array_reject$excl$81, $Array_replace$83, $Array_reverse$84, $Array_reverse$excl$85, $Array_reverse_each$86, $Array_rindex$88, $Array_rotate$89, $Array_rotate$excl$90, $Array_sample$93, $Array_select$94, $Array_select$excl$96, $Array_shift$98, $Array_shuffle$99, $Array_shuffle$excl$100, $Array_slice$excl$101, $Array_sort$102, $Array_sort$excl$103, $Array_sort_by$excl$104, $Array_take$106, $Array_take_while$107, $Array_to_a$108, $Array_to_ary$109, $Array_to_h$110, $Array_transpose$111, $Array_union$114, $Array_uniq$116, $Array_uniq$excl$117, $Array_unshift$118, $Array_values_at$119, $Array_zip$122, $Array_inherited$123, $Array_instance_variables$124, $Array_pack$126;
        self76.$include($$($nesting19, 'Enumerable'));
        Opal.defineProperty(self76.$$prototype, '$$is_array', true);
        function shiftNoArg(list) {
            var r = list[0];
            var index = 1;
            var length = list.length;
            for(; index < length; index++){
                list[index - 1] = list[index];
            }
            list.pop();
            return r;
        }
        function toArraySubclass(obj, klass) {
            if (klass.$$name === Opal.Array) {
                return obj;
            } else {
                return klass.$allocate().$replace(obj.$to_a());
            }
        }
        function filterIf(self, filter, block) {
            var value, raised = null, updated = new Array(self.length);
            for(var i196 = 0, i2 = 0, length = self.length; i196 < length; i196++){
                if (!raised) {
                    try {
                        value = $yield1(block, self[i196]);
                    } catch (error23) {
                        raised = error23;
                    }
                }
                if (raised || filter(value)) {
                    updated[i2] = self[i196];
                    i2 += 1;
                }
            }
            if (i2 !== i196) {
                self.splice.apply(self, [
                    0,
                    updated.length
                ].concat(updated));
                self.splice(i2, updated.length);
            }
            if (raised) throw raised;
        }
        Opal.defs(self76, '$[]', $Array_$$$1 = function($a) {
            var $post_args, objects, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            objects = $post_args;
            return toArraySubclass(objects, self);
        }, $Array_$$$1.$$arity = -1);
        Opal.def(self76, '$initialize', $Array_initialize$2 = function $$initialize(size, obj) {
            var $iter = $Array_initialize$2.$$p, block = $iter || nil, self = this;
            if ($iter) $Array_initialize$2.$$p = null;
            if ($iter) $Array_initialize$2.$$p = null;
            if (size == null) {
                size = nil;
            }
            if (obj == null) {
                obj = nil;
            }
            if (obj !== nil && block !== nil) {
                self.$warn("warning: block supersedes default value argument");
            }
            if (size > $$$($$($nesting19, 'Integer'), 'MAX')) {
                self.$raise($$($nesting19, 'ArgumentError'), "array size too big");
            }
            if (arguments.length > 2) {
                self.$raise($$($nesting19, 'ArgumentError'), "" + "wrong number of arguments (" + arguments.length + " for 0..2)");
            }
            if (arguments.length === 0) {
                self.splice(0, self.length);
                return self;
            }
            if (arguments.length === 1) {
                if (size.$$is_array) {
                    self.$replace(size.$to_a());
                    return self;
                } else if (size['$respond_to?']("to_ary")) {
                    self.$replace(size.$to_ary());
                    return self;
                }
            }
            size = $coerce_to(size, $$($nesting19, 'Integer'), 'to_int');
            if (size < 0) {
                self.$raise($$($nesting19, 'ArgumentError'), "negative array size");
            }
            self.splice(0, self.length);
            var i197, value;
            if (block === nil) {
                for(i197 = 0; i197 < size; i197++){
                    self.push(obj);
                }
            } else {
                for(i197 = 0, value; i197 < size; i197++){
                    value = block(i197);
                    self[i197] = value;
                }
            }
            return self;
        }, $Array_initialize$2.$$arity = -1);
        Opal.defs(self76, '$try_convert', $Array_try_convert$3 = function $$try_convert(obj) {
            return $$($nesting19, 'Opal')['$coerce_to?'](obj, $$($nesting19, 'Array'), "to_ary");
        }, $Array_try_convert$3.$$arity = 1);
        Opal.def(self76, '$&', $Array_$$4 = function(other) {
            var self = this;
            other = function() {
                if ($truthy($$($nesting19, 'Array')['$==='](other))) {
                    return other.$to_a();
                } else {
                    return $coerce_to(other, $$($nesting19, 'Array'), 'to_ary').$to_a();
                }
                return nil;
            }();
            var result = [], hash = $hash2([], {}), i198, length, item;
            for(i198 = 0, length = other.length; i198 < length; i198++){
                $hash_put(hash, other[i198], true);
            }
            for(i198 = 0, length = self.length; i198 < length; i198++){
                item = self[i198];
                if ($hash_delete(hash, item) !== undefined) {
                    result.push(item);
                }
            }
            return result;
        }, $Array_$$4.$$arity = 1);
        Opal.def(self76, '$|', $Array_$$5 = function(other) {
            var self = this;
            other = function() {
                if ($truthy($$($nesting19, 'Array')['$==='](other))) {
                    return other.$to_a();
                } else {
                    return $coerce_to(other, $$($nesting19, 'Array'), 'to_ary').$to_a();
                }
                return nil;
            }();
            var hash = $hash2([], {}), i199, length;
            for(i199 = 0, length = self.length; i199 < length; i199++){
                $hash_put(hash, self[i199], true);
            }
            for(i199 = 0, length = other.length; i199 < length; i199++){
                $hash_put(hash, other[i199], true);
            }
            return hash.$keys();
        }, $Array_$$5.$$arity = 1);
        Opal.def(self76, '$*', $Array_$$6 = function(other) {
            var self = this;
            if ($truthy(other['$respond_to?']("to_str"))) {
                return self.$join(other.$to_str());
            }
            other = $coerce_to(other, $$($nesting19, 'Integer'), 'to_int');
            if ($truthy(other < 0)) {
                self.$raise($$($nesting19, 'ArgumentError'), "negative argument");
            }
            var result = [], converted = self.$to_a();
            for(var i200 = 0; i200 < other; i200++){
                result = result.concat(converted);
            }
            return result;
        }, $Array_$$6.$$arity = 1);
        Opal.def(self76, '$+', $Array_$plus$7 = function(other) {
            var self = this;
            other = function() {
                if ($truthy($$($nesting19, 'Array')['$==='](other))) {
                    return other.$to_a();
                } else {
                    return $coerce_to(other, $$($nesting19, 'Array'), 'to_ary').$to_a();
                }
                return nil;
            }();
            return self.concat(other);
        }, $Array_$plus$7.$$arity = 1);
        Opal.def(self76, '$-', $Array_$minus$8 = function(other) {
            var self = this;
            other = function() {
                if ($truthy($$($nesting19, 'Array')['$==='](other))) {
                    return other.$to_a();
                } else {
                    return $coerce_to(other, $$($nesting19, 'Array'), 'to_ary').$to_a();
                }
                return nil;
            }();
            if ($truthy(self.length === 0)) {
                return [];
            }
            if ($truthy(other.length === 0)) {
                return self.slice();
            }
            var result = [], hash = $hash2([], {}), i201, length, item;
            for(i201 = 0, length = other.length; i201 < length; i201++){
                $hash_put(hash, other[i201], true);
            }
            for(i201 = 0, length = self.length; i201 < length; i201++){
                item = self[i201];
                if ($hash_get(hash, item) === undefined) {
                    result.push(item);
                }
            }
            return result;
        }, $Array_$minus$8.$$arity = 1);
        Opal.def(self76, '$<<', $Array_$lt$lt$9 = function(object) {
            var self = this;
            self.push(object);
            return self;
        }, $Array_$lt$lt$9.$$arity = 1);
        Opal.def(self76, '$<=>', $Array_$lt_eq_gt$10 = function(other) {
            var self = this;
            if ($truthy($$($nesting19, 'Array')['$==='](other))) {
                other = other.$to_a();
            } else if ($truthy(other['$respond_to?']("to_ary"))) {
                other = other.$to_ary().$to_a();
            } else {
                return nil;
            }
            if (self.$hash() === other.$hash()) {
                return 0;
            }
            var count = Math.min(self.length, other.length);
            for(var i202 = 0; i202 < count; i202++){
                var tmp = self[i202]['$<=>'](other[i202]);
                if (tmp !== 0) {
                    return tmp;
                }
            }
            return self.length['$<=>'](other.length);
        }, $Array_$lt_eq_gt$10.$$arity = 1);
        Opal.def(self76, '$==', $Array_$eq_eq$11 = function(other1) {
            var self = this;
            var recursed = {};
            function _eqeq(array, other) {
                var i203, length, a, b;
                if (array === other) return true;
                if (!other.$$is_array) {
                    if ($respond_to(other, '$to_ary')) {
                        return other['$=='](array);
                    } else {
                        return false;
                    }
                }
                if (array.$$constructor !== Array) array = array.$to_a();
                if (other.$$constructor !== Array) other = other.$to_a();
                if (array.length !== other.length) {
                    return false;
                }
                recursed[array.$object_id()] = true;
                for(i203 = 0, length = array.length; i203 < length; i203++){
                    a = array[i203];
                    b = other[i203];
                    if (a.$$is_array) {
                        if (b.$$is_array && b.length !== a.length) {
                            return false;
                        }
                        if (!recursed.hasOwnProperty(a.$object_id())) {
                            if (!_eqeq(a, b)) {
                                return false;
                            }
                        }
                    } else {
                        if (!a['$=='](b)) {
                            return false;
                        }
                    }
                }
                return true;
            }
            return _eqeq(self, other1);
        }, $Array_$eq_eq$11.$$arity = 1);
        function $array_slice_range(self, index) {
            var size = self.length, exclude, from, to, result;
            exclude = index.excl;
            from = $coerce_to(index.begin, Opal.Integer, 'to_int');
            to = $coerce_to(index.end, Opal.Integer, 'to_int');
            if (from < 0) {
                from += size;
                if (from < 0) {
                    return nil;
                }
            }
            if (from > size) {
                return nil;
            }
            if (to < 0) {
                to += size;
                if (to < 0) {
                    return [];
                }
            }
            if (!exclude) {
                to += 1;
            }
            result = self.slice(from, to);
            return result;
        }
        function $array_slice_index_length(self, index, length) {
            var size = self.length, result;
            index = $coerce_to(index, Opal.Integer, 'to_int');
            if (index < 0) {
                index += size;
                if (index < 0) {
                    return nil;
                }
            }
            if (length === undefined) {
                if (index >= size || index < 0) {
                    return nil;
                }
                return self[index];
            } else {
                length = $coerce_to(length, Opal.Integer, 'to_int');
                if (length < 0 || index > size || index < 0) {
                    return nil;
                }
                result = self.slice(index, index + length);
            }
            return result;
        }
        Opal.def(self76, '$[]', $Array_$$$12 = function(index, length) {
            var self = this;
            if (index.$$is_range) {
                return $array_slice_range(self, index);
            } else {
                return $array_slice_index_length(self, index, length);
            }
        }, $Array_$$$12.$$arity = -2);
        Opal.def(self76, '$[]=', $Array_$$$eq$13 = function(index, value, extra) {
            var self = this, data13 = nil, length = nil;
            var i204, size = self.length;
            if ($truthy($$($nesting19, 'Range')['$==='](index))) {
                data13 = function() {
                    if ($truthy($$($nesting19, 'Array')['$==='](value))) {
                        return value.$to_a();
                    } else if ($truthy(value['$respond_to?']("to_ary"))) {
                        return value.$to_ary().$to_a();
                    } else {
                        return [
                            value
                        ];
                    }
                    return nil;
                }();
                var exclude = index.excl, from = $coerce_to(index.begin, $$($nesting19, 'Integer'), 'to_int'), to = $coerce_to(index.end, $$($nesting19, 'Integer'), 'to_int');
                if (from < 0) {
                    from += size;
                    if (from < 0) {
                        self.$raise($$($nesting19, 'RangeError'), "" + index.$inspect() + " out of range");
                    }
                }
                if (to < 0) {
                    to += size;
                }
                if (!exclude) {
                    to += 1;
                }
                if (from > size) {
                    for(i204 = size; i204 < from; i204++){
                        self[i204] = nil;
                    }
                }
                if (to < 0) {
                    self.splice.apply(self, [
                        from,
                        0
                    ].concat(data13));
                } else {
                    self.splice.apply(self, [
                        from,
                        to - from
                    ].concat(data13));
                }
                return value;
            } else {
                if ($truthy(extra === undefined)) {
                    length = 1;
                } else {
                    length = value;
                    value = extra;
                    data13 = function() {
                        if ($truthy($$($nesting19, 'Array')['$==='](value))) {
                            return value.$to_a();
                        } else if ($truthy(value['$respond_to?']("to_ary"))) {
                            return value.$to_ary().$to_a();
                        } else {
                            return [
                                value
                            ];
                        }
                        return nil;
                    }();
                }
                var old;
                index = $coerce_to(index, $$($nesting19, 'Integer'), 'to_int');
                length = $coerce_to(length, $$($nesting19, 'Integer'), 'to_int');
                if (index < 0) {
                    old = index;
                    index += size;
                    if (index < 0) {
                        self.$raise($$($nesting19, 'IndexError'), "" + "index " + old + " too small for array; minimum " + -self.length);
                    }
                }
                if (length < 0) {
                    self.$raise($$($nesting19, 'IndexError'), "" + "negative length (" + length + ")");
                }
                if (index > size) {
                    for(i204 = size; i204 < index; i204++){
                        self[i204] = nil;
                    }
                }
                if (extra === undefined) {
                    self[index] = value;
                } else {
                    self.splice.apply(self, [
                        index,
                        length
                    ].concat(data13));
                }
                return value;
            }
        }, $Array_$$$eq$13.$$arity = -3);
        Opal.def(self76, '$any?', $Array_any$ques$14 = function(pattern) {
            var $iter = $Array_any$ques$14.$$p, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
            if ($iter) $Array_any$ques$14.$$p = null;
            for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                $zuper[$zuper_i] = arguments[$zuper_i];
            }
            if ($iter) $Array_any$ques$14.$$p = null;
            if (self.length === 0) return false;
            return $send2(self, Opal.find_super_dispatcher(self, 'any?', $Array_any$ques$14, false, true), 'any?', $zuper, $iter);
        }, $Array_any$ques$14.$$arity = -1);
        Opal.def(self76, '$assoc', $Array_assoc$15 = function $$assoc(object) {
            var self = this;
            for(var i205 = 0, length = self.length, item; i205 < length; i205++){
                if (item = self[i205], item.length && item[0]['$=='](object)) {
                    return item;
                }
            }
            return nil;
        }, $Array_assoc$15.$$arity = 1);
        Opal.def(self76, '$at', $Array_at$16 = function $$at(index) {
            var self = this;
            index = $coerce_to(index, $$($nesting19, 'Integer'), 'to_int');
            if (index < 0) {
                index += self.length;
            }
            if (index < 0 || index >= self.length) {
                return nil;
            }
            return self[index];
        }, $Array_at$16.$$arity = 1);
        Opal.def(self76, '$bsearch_index', $Array_bsearch_index$17 = function $$bsearch_index() {
            var $iter = $Array_bsearch_index$17.$$p, block = $iter || nil, self = this;
            if ($iter) $Array_bsearch_index$17.$$p = null;
            if ($iter) $Array_bsearch_index$17.$$p = null;
            if (block !== nil) {} else {
                return self.$enum_for("bsearch_index");
            }
            var min26 = 0, max = self.length, mid, val, ret, smaller = false, satisfied = nil;
            while(min26 < max){
                mid = min26 + Math.floor((max - min26) / 2);
                val = self[mid];
                ret = $yield1(block, val);
                if (ret === true) {
                    satisfied = mid;
                    smaller = true;
                } else if (ret === false || ret === nil) {
                    smaller = false;
                } else if (ret.$$is_number) {
                    if (ret === 0) {
                        return mid;
                    }
                    smaller = ret < 0;
                } else {
                    self.$raise($$($nesting19, 'TypeError'), "" + "wrong argument type " + ret.$class() + " (must be numeric, true, false or nil)");
                }
                if (smaller) {
                    max = mid;
                } else {
                    min26 = mid + 1;
                }
            }
            return satisfied;
        }, $Array_bsearch_index$17.$$arity = 0);
        Opal.def(self76, '$bsearch', $Array_bsearch$18 = function $$bsearch() {
            var $iter = $Array_bsearch$18.$$p, block = $iter || nil, self = this, index = nil;
            if ($iter) $Array_bsearch$18.$$p = null;
            if ($iter) $Array_bsearch$18.$$p = null;
            if (block !== nil) {} else {
                return self.$enum_for("bsearch");
            }
            index = $send(self, 'bsearch_index', [], block.$to_proc());
            if (index != null && index.$$is_number) {
                return self[index];
            } else {
                return index;
            }
        }, $Array_bsearch$18.$$arity = 0);
        Opal.def(self76, '$cycle', $Array_cycle$19 = function $$cycle(n) {
            var $iter = $Array_cycle$19.$$p, block = $iter || nil, $$20, self77 = this, $ret_or_1 = nil;
            if ($iter) $Array_cycle$19.$$p = null;
            if ($iter) $Array_cycle$19.$$p = null;
            if (n == null) {
                n = nil;
            }
            if (block !== nil) {} else {
                return $send(self77, 'enum_for', [
                    "cycle",
                    n
                ], ($$20 = function() {
                    var self = $$20.$$s == null ? this : $$20.$$s;
                    if ($truthy(n['$nil?']())) {
                        return $$$($$($nesting19, 'Float'), 'INFINITY');
                    } else {
                        n = $$($nesting19, 'Opal')['$coerce_to!'](n, $$($nesting19, 'Integer'), "to_int");
                        if ($truthy($rb_gt(n, 0))) {
                            return $rb_times(self.$enumerator_size(), n);
                        } else {
                            return 0;
                        }
                    }
                }, $$20.$$s = self77, $$20.$$arity = 0, $$20));
            }
            if ($truthy(function() {
                if ($truthy($ret_or_1 = self77['$empty?']())) {
                    return $ret_or_1;
                } else {
                    return n['$=='](0);
                }
                return nil;
            }())) {
                return nil;
            }
            var i206, length, value;
            if (n === nil) {
                while(true){
                    for(i206 = 0, length = self77.length; i206 < length; i206++){
                        value = $yield1(block, self77[i206]);
                    }
                }
            } else {
                n = $$($nesting19, 'Opal')['$coerce_to!'](n, $$($nesting19, 'Integer'), "to_int");
                if (n <= 0) {
                    return self77;
                }
                while(n > 0){
                    for(i206 = 0, length = self77.length; i206 < length; i206++){
                        value = $yield1(block, self77[i206]);
                    }
                    n--;
                }
            }
            return self77;
        }, $Array_cycle$19.$$arity = -1);
        Opal.def(self76, '$clear', $Array_clear$21 = function $$clear() {
            var self = this;
            self.splice(0, self.length);
            return self;
        }, $Array_clear$21.$$arity = 0);
        Opal.def(self76, '$count', $Array_count$22 = function $$count(object) {
            var $iter = $Array_count$22.$$p, block = $iter || nil, self = this, $ret_or_2 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
            if ($iter) $Array_count$22.$$p = null;
            for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                $zuper[$zuper_i] = arguments[$zuper_i];
            }
            if ($iter) $Array_count$22.$$p = null;
            if (object == null) {
                object = nil;
            }
            if ($truthy(function() {
                if ($truthy($ret_or_2 = object)) {
                    return $ret_or_2;
                } else {
                    return block;
                }
                return nil;
            }())) {
                return $send2(self, Opal.find_super_dispatcher(self, 'count', $Array_count$22, false, true), 'count', $zuper, $iter);
            } else {
                return self.$size();
            }
        }, $Array_count$22.$$arity = -1);
        Opal.def(self76, '$initialize_copy', $Array_initialize_copy$23 = function $$initialize_copy(other) {
            var self = this;
            return self.$replace(other);
        }, $Array_initialize_copy$23.$$arity = 1);
        Opal.def(self76, '$collect', $Array_collect$24 = function $$collect() {
            var $iter = $Array_collect$24.$$p, block = $iter || nil, $$25, self78 = this;
            if ($iter) $Array_collect$24.$$p = null;
            if ($iter) $Array_collect$24.$$p = null;
            if (block !== nil) {} else {
                return $send(self78, 'enum_for', [
                    "collect"
                ], ($$25 = function() {
                    var self = $$25.$$s == null ? this : $$25.$$s;
                    return self.$size();
                }, $$25.$$s = self78, $$25.$$arity = 0, $$25));
            }
            var result = [];
            for(var i207 = 0, length = self78.length; i207 < length; i207++){
                var value = $yield1(block, self78[i207]);
                result.push(value);
            }
            return result;
        }, $Array_collect$24.$$arity = 0);
        Opal.def(self76, '$collect!', $Array_collect$excl$26 = function() {
            var $iter = $Array_collect$excl$26.$$p, block = $iter || nil, $$27, self79 = this;
            if ($iter) $Array_collect$excl$26.$$p = null;
            if ($iter) $Array_collect$excl$26.$$p = null;
            if (block !== nil) {} else {
                return $send(self79, 'enum_for', [
                    "collect!"
                ], ($$27 = function() {
                    var self = $$27.$$s == null ? this : $$27.$$s;
                    return self.$size();
                }, $$27.$$s = self79, $$27.$$arity = 0, $$27));
            }
            for(var i208 = 0, length = self79.length; i208 < length; i208++){
                var value = $yield1(block, self79[i208]);
                self79[i208] = value;
            }
            return self79;
        }, $Array_collect$excl$26.$$arity = 0);
        function binomial_coefficient(n, k) {
            if (n === k || k === 0) {
                return 1;
            }
            if (k > 0 && n > k) {
                return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);
            }
            return 0;
        }
        Opal.def(self76, '$combination', $Array_combination$28 = function $$combination(n) {
            var $$29, $iter = $Array_combination$28.$$p, $yield = $iter || nil, self80 = this, num = nil;
            if ($iter) $Array_combination$28.$$p = null;
            num = $$($nesting19, 'Opal')['$coerce_to!'](n, $$($nesting19, 'Integer'), "to_int");
            if ($yield !== nil) {} else {
                return $send(self80, 'enum_for', [
                    "combination",
                    num
                ], ($$29 = function() {
                    var self = $$29.$$s == null ? this : $$29.$$s;
                    return binomial_coefficient(self.length, num);
                }, $$29.$$s = self80, $$29.$$arity = 0, $$29));
            }
            var i209, length, stack, chosen, lev, done, next;
            if (num === 0) {
                Opal.yield1($yield, []);
            } else if (num === 1) {
                for(i209 = 0, length = self80.length; i209 < length; i209++){
                    Opal.yield1($yield, [
                        self80[i209]
                    ]);
                }
            } else if (num === self80.length) {
                Opal.yield1($yield, self80.slice());
            } else if (num >= 0 && num < self80.length) {
                stack = [];
                for(i209 = 0; i209 <= num + 1; i209++){
                    stack.push(0);
                }
                chosen = [];
                lev = 0;
                done = false;
                stack[0] = -1;
                while(!done){
                    chosen[lev] = self80[stack[lev + 1]];
                    while(lev < num - 1){
                        lev++;
                        next = stack[lev + 1] = stack[lev] + 1;
                        chosen[lev] = self80[next];
                    }
                    Opal.yield1($yield, chosen.slice());
                    lev++;
                    do {
                        done = lev === 0;
                        stack[lev]++;
                        lev--;
                    }while (stack[lev + 1] + num === self80.length + lev + 1)
                }
            }
            return self80;
        }, $Array_combination$28.$$arity = 1);
        Opal.def(self76, '$repeated_combination', $Array_repeated_combination$30 = function $$repeated_combination(n) {
            var $$31, $iter = $Array_repeated_combination$30.$$p, $yield = $iter || nil, self81 = this, num = nil;
            if ($iter) $Array_repeated_combination$30.$$p = null;
            num = $$($nesting19, 'Opal')['$coerce_to!'](n, $$($nesting19, 'Integer'), "to_int");
            if ($yield !== nil) {} else {
                return $send(self81, 'enum_for', [
                    "repeated_combination",
                    num
                ], ($$31 = function() {
                    var self = $$31.$$s == null ? this : $$31.$$s;
                    return binomial_coefficient(self.length + num - 1, num);
                }, $$31.$$s = self81, $$31.$$arity = 0, $$31));
            }
            function iterate(max, from, buffer, self) {
                if (buffer.length == max) {
                    var copy6 = buffer.slice();
                    Opal.yield1($yield, copy6);
                    return;
                }
                for(var i210 = from; i210 < self.length; i210++){
                    buffer.push(self[i210]);
                    iterate(max, i210, buffer, self);
                    buffer.pop();
                }
            }
            if (num >= 0) {
                iterate(num, 0, [], self81);
            }
            return self81;
        }, $Array_repeated_combination$30.$$arity = 1);
        Opal.def(self76, '$compact', $Array_compact$32 = function $$compact() {
            var self = this;
            var result = [];
            for(var i211 = 0, length = self.length, item; i211 < length; i211++){
                if ((item = self[i211]) !== nil) {
                    result.push(item);
                }
            }
            return result;
        }, $Array_compact$32.$$arity = 0);
        Opal.def(self76, '$compact!', $Array_compact$excl$33 = function() {
            var self = this;
            var original = self.length;
            for(var i212 = 0, length = self.length; i212 < length; i212++){
                if (self[i212] === nil) {
                    self.splice(i212, 1);
                    length--;
                    i212--;
                }
            }
            return self.length === original ? nil : self;
        }, $Array_compact$excl$33.$$arity = 0);
        Opal.def(self76, '$concat', $Array_concat$34 = function $$concat($a) {
            var $post_args, others, $$35, $$36, self82 = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            others = $post_args;
            others = $send(others, 'map', [], ($$35 = function(other) {
                var self = $$35.$$s == null ? this : $$35.$$s;
                if (other == null) {
                    other = nil;
                }
                other = function() {
                    if ($truthy($$($nesting19, 'Array')['$==='](other))) {
                        return other.$to_a();
                    } else {
                        return $coerce_to(other, $$($nesting19, 'Array'), 'to_ary').$to_a();
                    }
                    return nil;
                }();
                if ($truthy(other['$equal?'](self))) {
                    other = other.$dup();
                }
                return other;
            }, $$35.$$s = self82, $$35.$$arity = 1, $$35));
            $send(others, 'each', [], ($$36 = function(other) {
                var self = $$36.$$s == null ? this : $$36.$$s;
                if (other == null) {
                    other = nil;
                }
                for(var i213 = 0, length = other.length; i213 < length; i213++){
                    self.push(other[i213]);
                }
            }, $$36.$$s = self82, $$36.$$arity = 1, $$36));
            return self82;
        }, $Array_concat$34.$$arity = -1);
        Opal.def(self76, '$delete', $Array_delete$37 = function(object) {
            var $iter = $Array_delete$37.$$p, $yield = $iter || nil, self = this;
            if ($iter) $Array_delete$37.$$p = null;
            var original = self.length;
            for(var i214 = 0, length = original; i214 < length; i214++){
                if (self[i214]['$=='](object)) {
                    self.splice(i214, 1);
                    length--;
                    i214--;
                }
            }
            if (self.length === original) {
                if ($yield !== nil) {
                    return Opal.yieldX($yield, []);
                }
                return nil;
            }
            return object;
        }, $Array_delete$37.$$arity = 1);
        Opal.def(self76, '$delete_at', $Array_delete_at$38 = function $$delete_at(index) {
            var self = this;
            index = $coerce_to(index, $$($nesting19, 'Integer'), 'to_int');
            if (index < 0) {
                index += self.length;
            }
            if (index < 0 || index >= self.length) {
                return nil;
            }
            var result = self[index];
            self.splice(index, 1);
            return result;
        }, $Array_delete_at$38.$$arity = 1);
        Opal.def(self76, '$delete_if', $Array_delete_if$39 = function $$delete_if() {
            var $iter = $Array_delete_if$39.$$p, block = $iter || nil, $$40, self83 = this;
            if ($iter) $Array_delete_if$39.$$p = null;
            if ($iter) $Array_delete_if$39.$$p = null;
            if (block !== nil) {} else {
                return $send(self83, 'enum_for', [
                    "delete_if"
                ], ($$40 = function() {
                    var self = $$40.$$s == null ? this : $$40.$$s;
                    return self.$size();
                }, $$40.$$s = self83, $$40.$$arity = 0, $$40));
            }
            filterIf(self83, $falsy, block);
            return self83;
        }, $Array_delete_if$39.$$arity = 0);
        Opal.def(self76, '$difference', $Array_difference$41 = function $$difference($a) {
            var $post_args, arrays, $$42, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            arrays = $post_args;
            return $send(arrays, 'reduce', [
                self.$to_a().$dup()
            ], ($$42 = function(a, b) {
                $$42.$$s == null ? this : $$42.$$s;
                if (a == null) {
                    a = nil;
                }
                if (b == null) {
                    b = nil;
                }
                return $rb_minus(a, b);
            }, $$42.$$s = self, $$42.$$arity = 2, $$42));
        }, $Array_difference$41.$$arity = -1);
        Opal.def(self76, '$dig', $Array_dig$43 = function $$dig(idx, $a) {
            var $post_args, idxs, self = this, item = nil;
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            idxs = $post_args;
            item = self['$[]'](idx);
            if (item === nil || idxs.length === 0) {
                return item;
            }
            if ($truthy(item['$respond_to?']("dig"))) {} else {
                self.$raise($$($nesting19, 'TypeError'), "" + item.$class() + " does not have #dig method");
            }
            return $send(item, 'dig', Opal.to_a(idxs));
        }, $Array_dig$43.$$arity = -2);
        Opal.def(self76, '$drop', $Array_drop$44 = function $$drop(number) {
            var self = this;
            if (number < 0) {
                self.$raise($$($nesting19, 'ArgumentError'));
            }
            return self.slice(number);
        }, $Array_drop$44.$$arity = 1);
        Opal.def(self76, '$dup', $Array_dup$45 = function $$dup() {
            var $iter = $Array_dup$45.$$p, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
            if ($iter) $Array_dup$45.$$p = null;
            for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                $zuper[$zuper_i] = arguments[$zuper_i];
            }
            if (self.$$class === Opal.Array && self.$$class.$allocate.$$pristine && self.$copy_instance_variables.$$pristine && self.$initialize_dup.$$pristine) {
                return self.slice(0);
            }
            return $send2(self, Opal.find_super_dispatcher(self, 'dup', $Array_dup$45, false, true), 'dup', $zuper, $iter);
        }, $Array_dup$45.$$arity = 0);
        Opal.def(self76, '$each', $Array_each$46 = function $$each() {
            var $iter = $Array_each$46.$$p, block = $iter || nil, $$47, self84 = this;
            if ($iter) $Array_each$46.$$p = null;
            if ($iter) $Array_each$46.$$p = null;
            if (block !== nil) {} else {
                return $send(self84, 'enum_for', [
                    "each"
                ], ($$47 = function() {
                    var self = $$47.$$s == null ? this : $$47.$$s;
                    return self.$size();
                }, $$47.$$s = self84, $$47.$$arity = 0, $$47));
            }
            for(var i215 = 0, length = self84.length; i215 < length; i215++){
                $yield1(block, self84[i215]);
            }
            return self84;
        }, $Array_each$46.$$arity = 0);
        Opal.def(self76, '$each_index', $Array_each_index$48 = function $$each_index() {
            var $iter = $Array_each_index$48.$$p, block = $iter || nil, $$49, self85 = this;
            if ($iter) $Array_each_index$48.$$p = null;
            if ($iter) $Array_each_index$48.$$p = null;
            if (block !== nil) {} else {
                return $send(self85, 'enum_for', [
                    "each_index"
                ], ($$49 = function() {
                    var self = $$49.$$s == null ? this : $$49.$$s;
                    return self.$size();
                }, $$49.$$s = self85, $$49.$$arity = 0, $$49));
            }
            for(var i216 = 0, length = self85.length; i216 < length; i216++){
                $yield1(block, i216);
            }
            return self85;
        }, $Array_each_index$48.$$arity = 0);
        Opal.def(self76, '$empty?', $Array_empty$ques$50 = function() {
            var self = this;
            return self.length === 0;
        }, $Array_empty$ques$50.$$arity = 0);
        Opal.def(self76, '$eql?', $Array_eql$ques$51 = function(other2) {
            var self = this;
            var recursed = {};
            function _eql(array, other) {
                var i217, length, a, b;
                if (!other.$$is_array) {
                    return false;
                }
                other = other.$to_a();
                if (array.length !== other.length) {
                    return false;
                }
                recursed[array.$object_id()] = true;
                for(i217 = 0, length = array.length; i217 < length; i217++){
                    a = array[i217];
                    b = other[i217];
                    if (a.$$is_array) {
                        if (b.$$is_array && b.length !== a.length) {
                            return false;
                        }
                        if (!recursed.hasOwnProperty(a.$object_id())) {
                            if (!_eql(a, b)) {
                                return false;
                            }
                        }
                    } else {
                        if (!a['$eql?'](b)) {
                            return false;
                        }
                    }
                }
                return true;
            }
            return _eql(self, other2);
        }, $Array_eql$ques$51.$$arity = 1);
        Opal.def(self76, '$fetch', $Array_fetch$52 = function $$fetch(index, defaults) {
            var $iter = $Array_fetch$52.$$p, block = $iter || nil, self = this;
            if ($iter) $Array_fetch$52.$$p = null;
            if ($iter) $Array_fetch$52.$$p = null;
            var original = index;
            index = $coerce_to(index, $$($nesting19, 'Integer'), 'to_int');
            if (index < 0) {
                index += self.length;
            }
            if (index >= 0 && index < self.length) {
                return self[index];
            }
            if (block !== nil && defaults != null) {
                self.$warn("warning: block supersedes default value argument");
            }
            if (block !== nil) {
                return block(original);
            }
            if (defaults != null) {
                return defaults;
            }
            if (self.length === 0) {
                self.$raise($$($nesting19, 'IndexError'), "" + "index " + original + " outside of array bounds: 0...0");
            } else {
                self.$raise($$($nesting19, 'IndexError'), "" + "index " + original + " outside of array bounds: -" + self.length + "..." + self.length);
            }
        }, $Array_fetch$52.$$arity = -2);
        Opal.def(self76, '$fill', $Array_fill$53 = function $$fill($a) {
            var $iter = $Array_fill$53.$$p, block = $iter || nil, $post_args, args65, $b, $c, self = this, one = nil, two = nil, obj = nil, left = nil, right = nil;
            if ($iter) $Array_fill$53.$$p = null;
            if ($iter) $Array_fill$53.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args65 = $post_args;
            var i218, length, value;
            if ($truthy(block)) {
                if ($truthy(args65.length > 2)) {
                    self.$raise($$($nesting19, 'ArgumentError'), "" + "wrong number of arguments (" + args65.$length() + " for 0..2)");
                }
                $c = args65, $b = Opal.to_ary($c), one = $b[0] == null ? nil : $b[0], two = $b[1] == null ? nil : $b[1], $c;
            } else {
                if ($truthy(args65.length == 0)) {
                    self.$raise($$($nesting19, 'ArgumentError'), "wrong number of arguments (0 for 1..3)");
                } else if ($truthy(args65.length > 3)) {
                    self.$raise($$($nesting19, 'ArgumentError'), "" + "wrong number of arguments (" + args65.$length() + " for 1..3)");
                }
                $c = args65, $b = Opal.to_ary($c), obj = $b[0] == null ? nil : $b[0], one = $b[1] == null ? nil : $b[1], two = $b[2] == null ? nil : $b[2], $c;
            }
            if ($truthy($$($nesting19, 'Range')['$==='](one))) {
                if ($truthy(two)) {
                    self.$raise($$($nesting19, 'TypeError'), "length invalid with range");
                }
                left = $coerce_to(one.begin, $$($nesting19, 'Integer'), 'to_int');
                if ($truthy(left < 0)) {
                    left += this.length;
                }
                if ($truthy(left < 0)) {
                    self.$raise($$($nesting19, 'RangeError'), "" + one.$inspect() + " out of range");
                }
                right = $coerce_to(one.end, $$($nesting19, 'Integer'), 'to_int');
                if ($truthy(right < 0)) {
                    right += this.length;
                }
                if ($truthy(one['$exclude_end?']())) {} else {
                    right += 1;
                }
                if ($truthy(right <= left)) {
                    return self;
                }
            } else if ($truthy(one)) {
                left = $coerce_to(one, $$($nesting19, 'Integer'), 'to_int');
                if ($truthy(left < 0)) {
                    left += this.length;
                }
                if ($truthy(left < 0)) {
                    left = 0;
                }
                if ($truthy(two)) {
                    right = $coerce_to(two, $$($nesting19, 'Integer'), 'to_int');
                    if ($truthy(right == 0)) {
                        return self;
                    }
                    right += left;
                } else {
                    right = this.length;
                }
            } else {
                left = 0;
                right = this.length;
            }
            if ($truthy(left > this.length)) {
                for(i218 = this.length; i218 < right; i218++){
                    self[i218] = nil;
                }
            }
            if ($truthy(right > this.length)) {
                this.length = right;
            }
            if ($truthy(block)) {
                for(length = this.length; left < right; left++){
                    value = block(left);
                    self[left] = value;
                }
            } else {
                for(length = this.length; left < right; left++){
                    self[left] = obj;
                }
            }
            return self;
        }, $Array_fill$53.$$arity = -1);
        Opal.def(self76, '$first', $Array_first$54 = function $$first(count) {
            var self = this;
            if (count == null) {
                return self.length === 0 ? nil : self[0];
            }
            count = $coerce_to(count, $$($nesting19, 'Integer'), 'to_int');
            if (count < 0) {
                self.$raise($$($nesting19, 'ArgumentError'), "negative array size");
            }
            return self.slice(0, count);
        }, $Array_first$54.$$arity = -1);
        Opal.def(self76, '$flatten', $Array_flatten$55 = function $$flatten(level1) {
            var self = this;
            function _flatten(array, level) {
                var result = [], i219, length, item, ary;
                array = array.$to_a();
                for(i219 = 0, length = array.length; i219 < length; i219++){
                    item = array[i219];
                    if (!$respond_to(item, '$to_ary', true)) {
                        result.push(item);
                        continue;
                    }
                    ary = item.$to_ary();
                    if (ary === nil) {
                        result.push(item);
                        continue;
                    }
                    if (!ary.$$is_array) {
                        self.$raise($$($nesting19, 'TypeError'));
                    }
                    if (ary === self) {
                        self.$raise($$($nesting19, 'ArgumentError'));
                    }
                    switch(level){
                        case undefined:
                            result = result.concat(_flatten(ary));
                            break;
                        case 0:
                            result.push(ary);
                            break;
                        default:
                            result.push.apply(result, _flatten(ary, level - 1));
                    }
                }
                return result;
            }
            if (level1 !== undefined) {
                level1 = $coerce_to(level1, $$($nesting19, 'Integer'), 'to_int');
            }
            return _flatten(self, level1);
        }, $Array_flatten$55.$$arity = -1);
        Opal.def(self76, '$flatten!', $Array_flatten$excl$56 = function(level) {
            var self = this;
            var flattened = self.$flatten(level);
            if (self.length == flattened.length) {
                for(var i220 = 0, length = self.length; i220 < length; i220++){
                    if (self[i220] !== flattened[i220]) {
                        break;
                    }
                }
                if (i220 == length) {
                    return nil;
                }
            }
            self.$replace(flattened);
            return self;
        }, $Array_flatten$excl$56.$$arity = -1);
        Opal.def(self76, '$hash', $Array_hash$57 = function $$hash() {
            var self = this;
            var top = $hash_ids === undefined, result = [
                'A'
            ], hash_id = self.$object_id(), item, i221, key;
            try {
                if (top) {
                    $hash_ids = Object.create(null);
                }
                if ($hash_ids[hash_id]) {
                    return 'self';
                }
                for(key in $hash_ids){
                    item = $hash_ids[key];
                    if (self['$eql?'](item)) {
                        return 'self';
                    }
                }
                $hash_ids[hash_id] = self;
                for(i221 = 0; i221 < self.length; i221++){
                    item = self[i221];
                    result.push(item.$hash());
                }
                return result.join(',');
            } finally{
                if (top) {
                    $hash_ids = undefined;
                }
            }
        }, $Array_hash$57.$$arity = 0);
        Opal.def(self76, '$include?', $Array_include$ques$58 = function(member) {
            var self = this;
            for(var i222 = 0, length = self.length; i222 < length; i222++){
                if (self[i222]['$=='](member)) {
                    return true;
                }
            }
            return false;
        }, $Array_include$ques$58.$$arity = 1);
        Opal.def(self76, '$index', $Array_index$59 = function $$index(object) {
            var $iter = $Array_index$59.$$p, block = $iter || nil, self = this;
            if ($iter) $Array_index$59.$$p = null;
            if ($iter) $Array_index$59.$$p = null;
            var i223, length, value;
            if (object != null && block !== nil) {
                self.$warn("warning: given block not used");
            }
            if (object != null) {
                for(i223 = 0, length = self.length; i223 < length; i223++){
                    if (self[i223]['$=='](object)) {
                        return i223;
                    }
                }
            } else if (block !== nil) {
                for(i223 = 0, length = self.length; i223 < length; i223++){
                    value = block(self[i223]);
                    if (value !== false && value !== nil) {
                        return i223;
                    }
                }
            } else {
                return self.$enum_for("index");
            }
            return nil;
        }, $Array_index$59.$$arity = -1);
        Opal.def(self76, '$insert', $Array_insert$60 = function $$insert(index, $a) {
            var $post_args, objects, self = this;
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            objects = $post_args;
            index = $coerce_to(index, $$($nesting19, 'Integer'), 'to_int');
            if (objects.length > 0) {
                if (index < 0) {
                    index += self.length + 1;
                    if (index < 0) {
                        self.$raise($$($nesting19, 'IndexError'), "" + index + " is out of bounds");
                    }
                }
                if (index > self.length) {
                    for(var i224 = self.length; i224 < index; i224++){
                        self.push(nil);
                    }
                }
                self.splice.apply(self, [
                    index,
                    0
                ].concat(objects));
            }
            return self;
        }, $Array_insert$60.$$arity = -2);
        Opal.def(self76, '$inspect', $Array_inspect$61 = function $$inspect() {
            var self = this;
            var result = [], id = self.$__id__();
            for(var i225 = 0, length = self.length; i225 < length; i225++){
                var item = self['$[]'](i225);
                if (item.$__id__() === id) {
                    result.push('[...]');
                } else {
                    result.push(item.$inspect());
                }
            }
            return '[' + result.join(', ') + ']';
        }, $Array_inspect$61.$$arity = 0);
        Opal.def(self76, '$intersection', $Array_intersection$62 = function $$intersection($a) {
            var $post_args, arrays, $$63, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            arrays = $post_args;
            return $send(arrays, 'reduce', [
                self.$to_a().$dup()
            ], ($$63 = function(a, b) {
                $$63.$$s == null ? this : $$63.$$s;
                if (a == null) {
                    a = nil;
                }
                if (b == null) {
                    b = nil;
                }
                return a['$&'](b);
            }, $$63.$$s = self, $$63.$$arity = 2, $$63));
        }, $Array_intersection$62.$$arity = -1);
        Opal.def(self76, '$join', $Array_join$64 = function $$join(sep15) {
            var self = this;
            if ($gvars[","] == null) $gvars[","] = nil;
            if (sep15 == null) {
                sep15 = nil;
            }
            if ($truthy(self.length === 0)) {
                return "";
            }
            if ($truthy(sep15 === nil)) {
                sep15 = $gvars[","];
            }
            var result = [];
            var i226, length, item, tmp;
            for(i226 = 0, length = self.length; i226 < length; i226++){
                item = self[i226];
                if ($respond_to(item, '$to_str')) {
                    tmp = item.$to_str();
                    if (tmp !== nil) {
                        result.push(tmp.$to_s());
                        continue;
                    }
                }
                if ($respond_to(item, '$to_ary')) {
                    tmp = item.$to_ary();
                    if (tmp === self) {
                        self.$raise($$($nesting19, 'ArgumentError'));
                    }
                    if (tmp !== nil) {
                        result.push(tmp.$join(sep15));
                        continue;
                    }
                }
                if ($respond_to(item, '$to_s')) {
                    tmp = item.$to_s();
                    if (tmp !== nil) {
                        result.push(tmp);
                        continue;
                    }
                }
                self.$raise($$($nesting19, 'NoMethodError').$new("" + Opal.inspect(item) + " doesn't respond to #to_str, #to_ary or #to_s", "to_str"));
            }
            if (sep15 === nil) {
                return result.join('');
            } else {
                return result.join($$($nesting19, 'Opal')['$coerce_to!'](sep15, $$($nesting19, 'String'), "to_str").$to_s());
            }
        }, $Array_join$64.$$arity = -1);
        Opal.def(self76, '$keep_if', $Array_keep_if$65 = function $$keep_if() {
            var $iter = $Array_keep_if$65.$$p, block = $iter || nil, $$66, self86 = this;
            if ($iter) $Array_keep_if$65.$$p = null;
            if ($iter) $Array_keep_if$65.$$p = null;
            if (block !== nil) {} else {
                return $send(self86, 'enum_for', [
                    "keep_if"
                ], ($$66 = function() {
                    var self = $$66.$$s == null ? this : $$66.$$s;
                    return self.$size();
                }, $$66.$$s = self86, $$66.$$arity = 0, $$66));
            }
            filterIf(self86, $truthy, block);
            return self86;
        }, $Array_keep_if$65.$$arity = 0);
        Opal.def(self76, '$last', $Array_last$67 = function $$last(count) {
            var self = this;
            if (count == null) {
                return self.length === 0 ? nil : self[self.length - 1];
            }
            count = $coerce_to(count, $$($nesting19, 'Integer'), 'to_int');
            if (count < 0) {
                self.$raise($$($nesting19, 'ArgumentError'), "negative array size");
            }
            if (count > self.length) {
                count = self.length;
            }
            return self.slice(self.length - count, self.length);
        }, $Array_last$67.$$arity = -1);
        Opal.def(self76, '$length', $Array_length$68 = function $$length() {
            var self = this;
            return self.length;
        }, $Array_length$68.$$arity = 0);
        Opal.alias(self76, "map", "collect");
        Opal.alias(self76, "map!", "collect!");
        Opal.def(self76, '$max', $Array_max$69 = function $$max(n) {
            var $iter = $Array_max$69.$$p, block = $iter || nil, self = this;
            if ($iter) $Array_max$69.$$p = null;
            if ($iter) $Array_max$69.$$p = null;
            return $send(self.$each(), 'max', [
                n
            ], block.$to_proc());
        }, $Array_max$69.$$arity = -1);
        Opal.def(self76, '$min', $Array_min$70 = function $$min() {
            var $iter = $Array_min$70.$$p, block = $iter || nil, self = this;
            if ($iter) $Array_min$70.$$p = null;
            if ($iter) $Array_min$70.$$p = null;
            return $send(self.$each(), 'min', [], block.$to_proc());
        }, $Array_min$70.$$arity = 0);
        function descending_factorial(from, how_many) {
            var count = how_many >= 0 ? 1 : 0;
            while(how_many){
                count *= from;
                from--;
                how_many--;
            }
            return count;
        }
        Opal.def(self76, '$permutation', $Array_permutation$71 = function $$permutation(num1) {
            var $iter = $Array_permutation$71.$$p, block = $iter || nil, $$72, self87 = this, perm1 = nil, used1 = nil;
            if ($iter) $Array_permutation$71.$$p = null;
            if ($iter) $Array_permutation$71.$$p = null;
            if (block !== nil) {} else {
                return $send(self87, 'enum_for', [
                    "permutation",
                    num1
                ], ($$72 = function() {
                    var self = $$72.$$s == null ? this : $$72.$$s;
                    return descending_factorial(self.length, num1 === undefined ? self.length : num1);
                }, $$72.$$s = self87, $$72.$$arity = 0, $$72));
            }
            var permute, offensive, output;
            if (num1 === undefined) {
                num1 = self87.length;
            } else {
                num1 = $coerce_to(num1, $$($nesting19, 'Integer'), 'to_int');
            }
            if (num1 < 0 || self87.length < num1) {} else if (num1 === 0) {
                Opal.yield1(block, []);
            } else if (num1 === 1) {
                for(var i227 = 0; i227 < self87.length; i227++){
                    Opal.yield1(block, [
                        self87[i227]
                    ]);
                }
            } else {
                perm1 = $$($nesting19, 'Array').$new(num1);
                used1 = $$($nesting19, 'Array').$new(self87.length, false);
                permute = function(num, perm, index, used, blk) {
                    self87 = this;
                    for(var i228 = 0; i228 < self87.length; i228++){
                        if (used['$[]'](i228)['$!']()) {
                            perm[index] = i228;
                            if (index < num - 1) {
                                used[i228] = true;
                                permute.call(self87, num, perm, index + 1, used, blk);
                                used[i228] = false;
                            } else {
                                output = [];
                                for(var j = 0; j < perm.length; j++){
                                    output.push(self87[perm[j]]);
                                }
                                $yield1(blk, output);
                            }
                        }
                    }
                };
                if (block !== nil) {
                    offensive = self87.slice();
                    permute.call(offensive, num1, perm1, 0, used1, block);
                } else {
                    permute.call(self87, num1, perm1, 0, used1, block);
                }
            }
            return self87;
        }, $Array_permutation$71.$$arity = -1);
        Opal.def(self76, '$repeated_permutation', $Array_repeated_permutation$73 = function $$repeated_permutation(n) {
            var $$74, $iter = $Array_repeated_permutation$73.$$p, $yield = $iter || nil, self88 = this, num = nil;
            if ($iter) $Array_repeated_permutation$73.$$p = null;
            num = $$($nesting19, 'Opal')['$coerce_to!'](n, $$($nesting19, 'Integer'), "to_int");
            if ($yield !== nil) {} else {
                return $send(self88, 'enum_for', [
                    "repeated_permutation",
                    num
                ], ($$74 = function() {
                    var self = $$74.$$s == null ? this : $$74.$$s;
                    if ($truthy($rb_ge(num, 0))) {
                        return self.$size()['$**'](num);
                    } else {
                        return 0;
                    }
                }, $$74.$$s = self88, $$74.$$arity = 0, $$74));
            }
            function iterate(max, buffer, self) {
                if (buffer.length == max) {
                    var copy7 = buffer.slice();
                    Opal.yield1($yield, copy7);
                    return;
                }
                for(var i229 = 0; i229 < self.length; i229++){
                    buffer.push(self[i229]);
                    iterate(max, buffer, self);
                    buffer.pop();
                }
            }
            iterate(num, [], self88.slice());
            return self88;
        }, $Array_repeated_permutation$73.$$arity = 1);
        Opal.def(self76, '$pop', $Array_pop$75 = function $$pop(count) {
            var self = this;
            if ($truthy(count === undefined)) {
                if ($truthy(self.length === 0)) {
                    return nil;
                }
                return self.pop();
            }
            count = $coerce_to(count, $$($nesting19, 'Integer'), 'to_int');
            if ($truthy(count < 0)) {
                self.$raise($$($nesting19, 'ArgumentError'), "negative array size");
            }
            if ($truthy(self.length === 0)) {
                return [];
            }
            if ($truthy(count === 1)) {
                return [
                    self.pop()
                ];
            } else if ($truthy(count > self.length)) {
                return self.splice(0, self.length);
            } else {
                return self.splice(self.length - count, self.length);
            }
        }, $Array_pop$75.$$arity = -1);
        Opal.def(self76, '$product', $Array_product$76 = function $$product($a) {
            var $iter = $Array_product$76.$$p, block = $iter || nil, $post_args, args66, self = this;
            if ($iter) $Array_product$76.$$p = null;
            if ($iter) $Array_product$76.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args66 = $post_args;
            var result = block !== nil ? null : [], n = args66.length + 1, counters = new Array(n), lengths = new Array(n), arrays = new Array(n), i230, m, subarray, len, resultlen = 1;
            arrays[0] = self;
            for(i230 = 1; i230 < n; i230++){
                arrays[i230] = $coerce_to(args66[i230 - 1], $$($nesting19, 'Array'), 'to_ary');
            }
            for(i230 = 0; i230 < n; i230++){
                len = arrays[i230].length;
                if (len === 0) {
                    return result || self;
                }
                resultlen *= len;
                if (resultlen > 2147483647) {
                    self.$raise($$($nesting19, 'RangeError'), "too big to product");
                }
                lengths[i230] = len;
                counters[i230] = 0;
            }
            outer_loop: for(;;){
                subarray = [];
                for(i230 = 0; i230 < n; i230++){
                    subarray.push(arrays[i230][counters[i230]]);
                }
                if (result) {
                    result.push(subarray);
                } else {
                    Opal.yield1(block, subarray);
                }
                m = n - 1;
                counters[m]++;
                while(counters[m] === lengths[m]){
                    counters[m] = 0;
                    if (--m < 0) break outer_loop;
                    counters[m]++;
                }
            }
            return result || self;
        }, $Array_product$76.$$arity = -1);
        Opal.def(self76, '$push', $Array_push$77 = function $$push($a) {
            var $post_args, objects, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            objects = $post_args;
            for(var i231 = 0, length = objects.length; i231 < length; i231++){
                self.push(objects[i231]);
            }
            return self;
        }, $Array_push$77.$$arity = -1);
        Opal.alias(self76, "append", "push");
        Opal.def(self76, '$rassoc', $Array_rassoc$78 = function $$rassoc(object) {
            var self = this;
            for(var i232 = 0, length = self.length, item; i232 < length; i232++){
                item = self[i232];
                if (item.length && item[1] !== undefined) {
                    if (item[1]['$=='](object)) {
                        return item;
                    }
                }
            }
            return nil;
        }, $Array_rassoc$78.$$arity = 1);
        Opal.def(self76, '$reject', $Array_reject$79 = function $$reject() {
            var $iter = $Array_reject$79.$$p, block = $iter || nil, $$80, self89 = this;
            if ($iter) $Array_reject$79.$$p = null;
            if ($iter) $Array_reject$79.$$p = null;
            if (block !== nil) {} else {
                return $send(self89, 'enum_for', [
                    "reject"
                ], ($$80 = function() {
                    var self = $$80.$$s == null ? this : $$80.$$s;
                    return self.$size();
                }, $$80.$$s = self89, $$80.$$arity = 0, $$80));
            }
            var result = [];
            for(var i233 = 0, length = self89.length, value; i233 < length; i233++){
                value = block(self89[i233]);
                if (value === false || value === nil) {
                    result.push(self89[i233]);
                }
            }
            return result;
        }, $Array_reject$79.$$arity = 0);
        Opal.def(self76, '$reject!', $Array_reject$excl$81 = function() {
            var $iter = $Array_reject$excl$81.$$p, block = $iter || nil, $$82, self90 = this, original = nil;
            if ($iter) $Array_reject$excl$81.$$p = null;
            if ($iter) $Array_reject$excl$81.$$p = null;
            if (block !== nil) {} else {
                return $send(self90, 'enum_for', [
                    "reject!"
                ], ($$82 = function() {
                    var self = $$82.$$s == null ? this : $$82.$$s;
                    return self.$size();
                }, $$82.$$s = self90, $$82.$$arity = 0, $$82));
            }
            original = self90.$length();
            $send(self90, 'delete_if', [], block.$to_proc());
            if (self90.$length()['$=='](original)) {
                return nil;
            } else {
                return self90;
            }
        }, $Array_reject$excl$81.$$arity = 0);
        Opal.def(self76, '$replace', $Array_replace$83 = function $$replace(other) {
            var self = this;
            other = function() {
                if ($truthy($$($nesting19, 'Array')['$==='](other))) {
                    return other.$to_a();
                } else {
                    return $coerce_to(other, $$($nesting19, 'Array'), 'to_ary').$to_a();
                }
                return nil;
            }();
            self.splice(0, self.length);
            self.push.apply(self, other);
            return self;
        }, $Array_replace$83.$$arity = 1);
        Opal.def(self76, '$reverse', $Array_reverse$84 = function $$reverse() {
            var self = this;
            return self.slice(0).reverse();
        }, $Array_reverse$84.$$arity = 0);
        Opal.def(self76, '$reverse!', $Array_reverse$excl$85 = function() {
            var self = this;
            return self.reverse();
        }, $Array_reverse$excl$85.$$arity = 0);
        Opal.def(self76, '$reverse_each', $Array_reverse_each$86 = function $$reverse_each() {
            var $iter = $Array_reverse_each$86.$$p, block = $iter || nil, $$87, self91 = this;
            if ($iter) $Array_reverse_each$86.$$p = null;
            if ($iter) $Array_reverse_each$86.$$p = null;
            if (block !== nil) {} else {
                return $send(self91, 'enum_for', [
                    "reverse_each"
                ], ($$87 = function() {
                    var self = $$87.$$s == null ? this : $$87.$$s;
                    return self.$size();
                }, $$87.$$s = self91, $$87.$$arity = 0, $$87));
            }
            $send(self91.$reverse(), 'each', [], block.$to_proc());
            return self91;
        }, $Array_reverse_each$86.$$arity = 0);
        Opal.def(self76, '$rindex', $Array_rindex$88 = function $$rindex(object) {
            var $iter = $Array_rindex$88.$$p, block = $iter || nil, self = this;
            if ($iter) $Array_rindex$88.$$p = null;
            if ($iter) $Array_rindex$88.$$p = null;
            var i234, value;
            if (object != null && block !== nil) {
                self.$warn("warning: given block not used");
            }
            if (object != null) {
                for(i234 = self.length - 1; i234 >= 0; i234--){
                    if (i234 >= self.length) {
                        break;
                    }
                    if (self[i234]['$=='](object)) {
                        return i234;
                    }
                }
            } else if (block !== nil) {
                for(i234 = self.length - 1; i234 >= 0; i234--){
                    if (i234 >= self.length) {
                        break;
                    }
                    value = block(self[i234]);
                    if (value !== false && value !== nil) {
                        return i234;
                    }
                }
            } else if (object == null) {
                return self.$enum_for("rindex");
            }
            return nil;
        }, $Array_rindex$88.$$arity = -1);
        Opal.def(self76, '$rotate', $Array_rotate$89 = function $$rotate(n) {
            var self = this;
            if (n == null) {
                n = 1;
            }
            var ary, idx, firstPart, lastPart;
            n = $coerce_to(n, $$($nesting19, 'Integer'), 'to_int');
            if (self.length === 1) {
                return self.slice();
            }
            if (self.length === 0) {
                return [];
            }
            ary = self.slice();
            idx = n % ary.length;
            firstPart = ary.slice(idx);
            lastPart = ary.slice(0, idx);
            return firstPart.concat(lastPart);
        }, $Array_rotate$89.$$arity = -1);
        Opal.def(self76, '$rotate!', $Array_rotate$excl$90 = function(cnt) {
            var self = this, ary = nil;
            if (cnt == null) {
                cnt = 1;
            }
            if (self.length === 0 || self.length === 1) {
                return self;
            }
            cnt = $coerce_to(cnt, $$($nesting19, 'Integer'), 'to_int');
            ary = self.$rotate(cnt);
            return self.$replace(ary);
        }, $Array_rotate$excl$90.$$arity = -1);
        (function($base, $super, $parent_nesting) {
            var self92 = $klass($base, $super, 'SampleRandom');
            var $nesting = [
                self92
            ].concat($parent_nesting), $SampleRandom_initialize$91, $SampleRandom_rand$92;
            self92.$$prototype.rng = nil;
            Opal.def(self92, '$initialize', $SampleRandom_initialize$91 = function $$initialize(rng) {
                var self = this;
                return self.rng = rng;
            }, $SampleRandom_initialize$91.$$arity = 1);
            return (Opal.def(self92, '$rand', $SampleRandom_rand$92 = function $$rand(size) {
                var self = this, random = nil;
                random = $coerce_to(self.rng.$rand(size), $$($nesting, 'Integer'), 'to_int');
                if ($truthy(random < 0)) {
                    self.$raise($$($nesting, 'RangeError'), "random value must be >= 0");
                }
                if ($truthy(random < size)) {} else {
                    self.$raise($$($nesting, 'RangeError'), "random value must be less than Array size");
                }
                return random;
            }, $SampleRandom_rand$92.$$arity = 1), nil) && 'rand';
        })($nesting19[0], null, $nesting19);
        Opal.def(self76, '$sample', $Array_sample$93 = function $$sample(count, options) {
            var self = this, o = nil, $ret_or_3 = nil, rng = nil, $ret_or_4 = nil;
            if ($truthy(count === undefined)) {
                return self.$at($$($nesting19, 'Kernel').$rand(self.length));
            }
            if ($truthy(options === undefined)) {
                if ($truthy(o = $$($nesting19, 'Opal')['$coerce_to?'](count, $$($nesting19, 'Hash'), "to_hash"))) {
                    options = o;
                    count = nil;
                } else {
                    options = nil;
                    count = $coerce_to(count, $$($nesting19, 'Integer'), 'to_int');
                }
            } else {
                count = $coerce_to(count, $$($nesting19, 'Integer'), 'to_int');
                options = $coerce_to(options, $$($nesting19, 'Hash'), 'to_hash');
            }
            if ($truthy(function() {
                if ($truthy($ret_or_3 = count)) {
                    return count < 0;
                } else {
                    return $ret_or_3;
                }
                return nil;
            }())) {
                self.$raise($$($nesting19, 'ArgumentError'), "count must be greater than 0");
            }
            if ($truthy(options)) {
                rng = options['$[]']("random");
            }
            rng = function() {
                if ($truthy(function() {
                    if ($truthy($ret_or_4 = rng)) {
                        return rng['$respond_to?']("rand");
                    } else {
                        return $ret_or_4;
                    }
                    return nil;
                }())) {
                    return $$($nesting19, 'SampleRandom').$new(rng);
                } else {
                    return $$($nesting19, 'Kernel');
                }
                return nil;
            }();
            if ($truthy(count)) {} else {
                return self[rng.$rand(self.length)];
            }
            var abandon, spin, result, i235, j, k, targetIndex, oldValue;
            if (count > self.length) {
                count = self.length;
            }
            switch(count){
                case 0:
                    return [];
                    break;
                case 1:
                    return [
                        self[rng.$rand(self.length)]
                    ];
                    break;
                case 2:
                    i235 = rng.$rand(self.length);
                    j = rng.$rand(self.length);
                    if (i235 === j) {
                        j = i235 === 0 ? i235 + 1 : i235 - 1;
                    }
                    return [
                        self[i235],
                        self[j]
                    ];
                    break;
                default:
                    if (self.length / count > 3) {
                        abandon = false;
                        spin = 0;
                        result = $$($nesting19, 'Array').$new(count);
                        i235 = 1;
                        result[0] = rng.$rand(self.length);
                        while(i235 < count){
                            k = rng.$rand(self.length);
                            j = 0;
                            while(j < i235){
                                while(k === result[j]){
                                    spin++;
                                    if (spin > 100) {
                                        abandon = true;
                                        break;
                                    }
                                    k = rng.$rand(self.length);
                                }
                                if (abandon) {
                                    break;
                                }
                                j++;
                            }
                            if (abandon) {
                                break;
                            }
                            result[i235] = k;
                            i235++;
                        }
                        if (!abandon) {
                            i235 = 0;
                            while(i235 < count){
                                result[i235] = self[result[i235]];
                                i235++;
                            }
                            return result;
                        }
                    }
                    result = self.slice();
                    for(var c = 0; c < count; c++){
                        targetIndex = rng.$rand(self.length);
                        oldValue = result[c];
                        result[c] = result[targetIndex];
                        result[targetIndex] = oldValue;
                    }
                    return count === self.length ? result : result['$[]'](0, count);
            }
        }, $Array_sample$93.$$arity = -1);
        Opal.def(self76, '$select', $Array_select$94 = function $$select() {
            var $iter = $Array_select$94.$$p, block = $iter || nil, $$95, self93 = this;
            if ($iter) $Array_select$94.$$p = null;
            if ($iter) $Array_select$94.$$p = null;
            if (block !== nil) {} else {
                return $send(self93, 'enum_for', [
                    "select"
                ], ($$95 = function() {
                    var self = $$95.$$s == null ? this : $$95.$$s;
                    return self.$size();
                }, $$95.$$s = self93, $$95.$$arity = 0, $$95));
            }
            var result = [];
            for(var i236 = 0, length = self93.length, item, value; i236 < length; i236++){
                item = self93[i236];
                value = $yield1(block, item);
                if ($truthy(value)) {
                    result.push(item);
                }
            }
            return result;
        }, $Array_select$94.$$arity = 0);
        Opal.def(self76, '$select!', $Array_select$excl$96 = function() {
            var $iter = $Array_select$excl$96.$$p, block = $iter || nil, $$97, self94 = this;
            if ($iter) $Array_select$excl$96.$$p = null;
            if ($iter) $Array_select$excl$96.$$p = null;
            if (block !== nil) {} else {
                return $send(self94, 'enum_for', [
                    "select!"
                ], ($$97 = function() {
                    var self = $$97.$$s == null ? this : $$97.$$s;
                    return self.$size();
                }, $$97.$$s = self94, $$97.$$arity = 0, $$97));
            }
            var original = self94.length;
            $send(self94, 'keep_if', [], block.$to_proc());
            return self94.length === original ? nil : self94;
        }, $Array_select$excl$96.$$arity = 0);
        Opal.alias(self76, "filter", "select");
        Opal.alias(self76, "filter!", "select!");
        Opal.def(self76, '$shift', $Array_shift$98 = function $$shift(count) {
            var self = this;
            if ($truthy(count === undefined)) {
                if ($truthy(self.length === 0)) {
                    return nil;
                }
                return shiftNoArg(self);
            }
            count = $coerce_to(count, $$($nesting19, 'Integer'), 'to_int');
            if ($truthy(count < 0)) {
                self.$raise($$($nesting19, 'ArgumentError'), "negative array size");
            }
            if ($truthy(self.length === 0)) {
                return [];
            }
            return self.splice(0, count);
        }, $Array_shift$98.$$arity = -1);
        Opal.alias(self76, "size", "length");
        Opal.def(self76, '$shuffle', $Array_shuffle$99 = function $$shuffle(rng) {
            var self = this;
            return self.$dup().$to_a()['$shuffle!'](rng);
        }, $Array_shuffle$99.$$arity = -1);
        Opal.def(self76, '$shuffle!', $Array_shuffle$excl$100 = function(rng) {
            var self = this;
            var randgen, i237 = self.length, j, tmp;
            if (rng !== undefined) {
                rng = $$($nesting19, 'Opal')['$coerce_to?'](rng, $$($nesting19, 'Hash'), "to_hash");
                if (rng !== nil) {
                    rng = rng['$[]']("random");
                    if (rng !== nil && rng['$respond_to?']("rand")) {
                        randgen = rng;
                    }
                }
            }
            while(i237){
                if (randgen) {
                    j = randgen.$rand(i237).$to_int();
                    if (j < 0) {
                        self.$raise($$($nesting19, 'RangeError'), "" + "random number too small " + j);
                    }
                    if (j >= i237) {
                        self.$raise($$($nesting19, 'RangeError'), "" + "random number too big " + j);
                    }
                } else {
                    j = self.$rand(i237);
                }
                tmp = self[--i237];
                self[i237] = self[j];
                self[j] = tmp;
            }
            return self;
        }, $Array_shuffle$excl$100.$$arity = -1);
        Opal.alias(self76, "slice", "[]");
        Opal.def(self76, '$slice!', $Array_slice$excl$101 = function(index, length) {
            var self = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;
            result = nil;
            if ($truthy(length === undefined)) {
                if ($truthy($$($nesting19, 'Range')['$==='](index))) {
                    range = index;
                    result = self['$[]'](range);
                    range_start = $coerce_to(range.begin, $$($nesting19, 'Integer'), 'to_int');
                    range_end = $coerce_to(range.end, $$($nesting19, 'Integer'), 'to_int');
                    if (range_start < 0) {
                        range_start += self.length;
                    }
                    if (range_end < 0) {
                        range_end += self.length;
                    } else if (range_end >= self.length) {
                        range_end = self.length - 1;
                        if (range.excl) {
                            range_end += 1;
                        }
                    }
                    var range_length = range_end - range_start;
                    if (range.excl) {
                        range_end -= 1;
                    } else {
                        range_length += 1;
                    }
                    if (range_start < self.length && range_start >= 0 && range_end < self.length && range_end >= 0 && range_length > 0) {
                        self.splice(range_start, range_length);
                    }
                } else {
                    start = $coerce_to(index, $$($nesting19, 'Integer'), 'to_int');
                    if (start < 0) {
                        start += self.length;
                    }
                    if (start < 0 || start >= self.length) {
                        return nil;
                    }
                    result = self[start];
                    if (start === 0) {
                        self.shift();
                    } else {
                        self.splice(start, 1);
                    }
                }
            } else {
                start = $coerce_to(index, $$($nesting19, 'Integer'), 'to_int');
                length = $coerce_to(length, $$($nesting19, 'Integer'), 'to_int');
                if (length < 0) {
                    return nil;
                }
                result = self['$[]'](start, length);
                if (start < 0) {
                    start += self.length;
                }
                if (start + length > self.length) {
                    length = self.length - start;
                }
                if (start < self.length && start >= 0) {
                    self.splice(start, length);
                }
            }
            return result;
        }, $Array_slice$excl$101.$$arity = -2);
        Opal.def(self76, '$sort', $Array_sort$102 = function $$sort() {
            var $iter = $Array_sort$102.$$p, block = $iter || nil, self = this;
            if ($iter) $Array_sort$102.$$p = null;
            if ($iter) $Array_sort$102.$$p = null;
            if ($truthy(self.length > 1)) {} else {
                return self;
            }
            if (block === nil) {
                block = function(a, b) {
                    return a['$<=>'](b);
                };
            }
            return self.slice().sort(function(x, y) {
                var ret = block(x, y);
                if (ret === nil) {
                    self.$raise($$($nesting19, 'ArgumentError'), "" + "comparison of " + x.$inspect() + " with " + y.$inspect() + " failed");
                }
                return $rb_gt(ret, 0) ? 1 : $rb_lt(ret, 0) ? -1 : 0;
            });
        }, $Array_sort$102.$$arity = 0);
        Opal.def(self76, '$sort!', $Array_sort$excl$103 = function() {
            var $iter = $Array_sort$excl$103.$$p, block = $iter || nil, self = this;
            if ($iter) $Array_sort$excl$103.$$p = null;
            if ($iter) $Array_sort$excl$103.$$p = null;
            var result;
            if (block !== nil) {
                result = $send(self.slice(), 'sort', [], block.$to_proc());
            } else {
                result = self.slice().$sort();
            }
            self.length = 0;
            for(var i238 = 0, length = result.length; i238 < length; i238++){
                self.push(result[i238]);
            }
            return self;
        }, $Array_sort$excl$103.$$arity = 0);
        Opal.def(self76, '$sort_by!', $Array_sort_by$excl$104 = function() {
            var $iter = $Array_sort_by$excl$104.$$p, block = $iter || nil, $$105, self95 = this;
            if ($iter) $Array_sort_by$excl$104.$$p = null;
            if ($iter) $Array_sort_by$excl$104.$$p = null;
            if (block !== nil) {} else {
                return $send(self95, 'enum_for', [
                    "sort_by!"
                ], ($$105 = function() {
                    var self = $$105.$$s == null ? this : $$105.$$s;
                    return self.$size();
                }, $$105.$$s = self95, $$105.$$arity = 0, $$105));
            }
            return self95.$replace($send(self95, 'sort_by', [], block.$to_proc()));
        }, $Array_sort_by$excl$104.$$arity = 0);
        Opal.def(self76, '$take', $Array_take$106 = function $$take(count) {
            var self = this;
            if (count < 0) {
                self.$raise($$($nesting19, 'ArgumentError'));
            }
            return self.slice(0, count);
        }, $Array_take$106.$$arity = 1);
        Opal.def(self76, '$take_while', $Array_take_while$107 = function $$take_while() {
            var $iter = $Array_take_while$107.$$p, block = $iter || nil, self = this;
            if ($iter) $Array_take_while$107.$$p = null;
            if ($iter) $Array_take_while$107.$$p = null;
            var result = [];
            for(var i239 = 0, length = self.length, item, value; i239 < length; i239++){
                item = self[i239];
                value = block(item);
                if (value === false || value === nil) {
                    return result;
                }
                result.push(item);
            }
            return result;
        }, $Array_take_while$107.$$arity = 0);
        Opal.def(self76, '$to_a', $Array_to_a$108 = function $$to_a() {
            var self = this;
            if (self.$$class === Opal.Array) {
                return self;
            } else {
                return Opal.Array.$new(self);
            }
        }, $Array_to_a$108.$$arity = 0);
        Opal.def(self76, '$to_ary', $Array_to_ary$109 = function $$to_ary() {
            var self = this;
            return self;
        }, $Array_to_ary$109.$$arity = 0);
        Opal.def(self76, '$to_h', $Array_to_h$110 = function $$to_h() {
            var $iter = $Array_to_h$110.$$p, block = $iter || nil, self = this, array = nil;
            if ($iter) $Array_to_h$110.$$p = null;
            if ($iter) $Array_to_h$110.$$p = null;
            array = self;
            if (block !== nil) {
                array = $send(array, 'map', [], block.$to_proc());
            }
            var i240, len = array.length, ary, key, val, hash = $hash2([], {});
            for(i240 = 0; i240 < len; i240++){
                ary = $$($nesting19, 'Opal')['$coerce_to?'](array[i240], $$($nesting19, 'Array'), "to_ary");
                if (!ary.$$is_array) {
                    self.$raise($$($nesting19, 'TypeError'), "" + "wrong element type " + ary.$class() + " at " + i240 + " (expected array)");
                }
                if (ary.length !== 2) {
                    self.$raise($$($nesting19, 'ArgumentError'), "" + "wrong array length at " + i240 + " (expected 2, was " + ary.$length() + ")");
                }
                key = ary[0];
                val = ary[1];
                $hash_put(hash, key, val);
            }
            return hash;
        }, $Array_to_h$110.$$arity = 0);
        Opal.alias(self76, "to_s", "inspect");
        Opal.def(self76, '$transpose', $Array_transpose$111 = function $$transpose() {
            var $$112, self96 = this, result = nil, max = nil;
            if ($truthy(self96['$empty?']())) {
                return [];
            }
            result = [];
            max = nil;
            $send(self96, 'each', [], ($$112 = function(row) {
                var self = $$112.$$s == null ? this : $$112.$$s, $$113, $ret_or_5 = nil;
                if (row == null) {
                    row = nil;
                }
                row = function() {
                    if ($truthy($$($nesting19, 'Array')['$==='](row))) {
                        return row.$to_a();
                    } else {
                        return $coerce_to(row, $$($nesting19, 'Array'), 'to_ary').$to_a();
                    }
                    return nil;
                }();
                max = function() {
                    if ($truthy($ret_or_5 = max)) {
                        return $ret_or_5;
                    } else {
                        return row.length;
                    }
                    return nil;
                }();
                if ($truthy(row.length['$!='](max))) {
                    self.$raise($$($nesting19, 'IndexError'), "" + "element size differs (" + row.length + " should be " + max + ")");
                }
                return $send(row.length, 'times', [], ($$113 = function(i241) {
                    var self = $$113.$$s == null ? this : $$113.$$s, entry = nil, $ret_or_6 = nil, $writer = nil;
                    if (i241 == null) {
                        i241 = nil;
                    }
                    entry = function() {
                        if ($truthy($ret_or_6 = result['$[]'](i241))) {
                            return $ret_or_6;
                        } else {
                            $writer = [
                                i241,
                                []
                            ];
                            $send(result, '[]=', Opal.to_a($writer));
                            return $writer[$rb_minus($writer["length"], 1)];
                        }
                        return nil;
                    }();
                    return entry['$<<'](row.$at(i241));
                }, $$113.$$s = self, $$113.$$arity = 1, $$113));
            }, $$112.$$s = self96, $$112.$$arity = 1, $$112));
            return result;
        }, $Array_transpose$111.$$arity = 0);
        Opal.def(self76, '$union', $Array_union$114 = function $$union($a) {
            var $post_args, arrays, $$115, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            arrays = $post_args;
            return $send(arrays, 'reduce', [
                self.$uniq()
            ], ($$115 = function(a, b) {
                $$115.$$s == null ? this : $$115.$$s;
                if (a == null) {
                    a = nil;
                }
                if (b == null) {
                    b = nil;
                }
                return a['$|'](b);
            }, $$115.$$s = self, $$115.$$arity = 2, $$115));
        }, $Array_union$114.$$arity = -1);
        Opal.def(self76, '$uniq', $Array_uniq$116 = function $$uniq() {
            var $iter = $Array_uniq$116.$$p, block = $iter || nil, self = this;
            if ($iter) $Array_uniq$116.$$p = null;
            if ($iter) $Array_uniq$116.$$p = null;
            var hash = $hash2([], {}), i242, length, item, key;
            if (block === nil) {
                for(i242 = 0, length = self.length; i242 < length; i242++){
                    item = self[i242];
                    if ($hash_get(hash, item) === undefined) {
                        $hash_put(hash, item, item);
                    }
                }
            } else {
                for(i242 = 0, length = self.length; i242 < length; i242++){
                    item = self[i242];
                    key = $yield1(block, item);
                    if ($hash_get(hash, key) === undefined) {
                        $hash_put(hash, key, item);
                    }
                }
            }
            return hash.$values();
        }, $Array_uniq$116.$$arity = 0);
        Opal.def(self76, '$uniq!', $Array_uniq$excl$117 = function() {
            var $iter = $Array_uniq$excl$117.$$p, block = $iter || nil, self = this;
            if ($iter) $Array_uniq$excl$117.$$p = null;
            if ($iter) $Array_uniq$excl$117.$$p = null;
            var original_length = self.length, hash = $hash2([], {}), i243, length, item, key;
            for(i243 = 0, length = original_length; i243 < length; i243++){
                item = self[i243];
                key = block === nil ? item : $yield1(block, item);
                if ($hash_get(hash, key) === undefined) {
                    $hash_put(hash, key, item);
                    continue;
                }
                self.splice(i243, 1);
                length--;
                i243--;
            }
            return self.length === original_length ? nil : self;
        }, $Array_uniq$excl$117.$$arity = 0);
        Opal.def(self76, '$unshift', $Array_unshift$118 = function $$unshift($a) {
            var $post_args, objects, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            objects = $post_args;
            var selfLength = self.length;
            var objectsLength = objects.length;
            if (objectsLength == 0) return self;
            var index = selfLength - objectsLength;
            for(var i244 = 0; i244 < objectsLength; i244++){
                self.push(self[index + i244]);
            }
            var len = selfLength - 1;
            while(len - objectsLength >= 0){
                self[len] = self[len - objectsLength];
                len--;
            }
            for(var j = 0; j < objectsLength; j++){
                self[j] = objects[j];
            }
            return self;
        }, $Array_unshift$118.$$arity = -1);
        Opal.alias(self76, "prepend", "unshift");
        Opal.def(self76, '$values_at', $Array_values_at$119 = function $$values_at($a) {
            var $post_args, args67, $$120, self97 = this, out = nil;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args67 = $post_args;
            out = [];
            $send(args67, 'each', [], ($$120 = function(elem) {
                var self98 = $$120.$$s == null ? this : $$120.$$s, $$121, finish3 = nil, start = nil, i3 = nil;
                if (elem == null) {
                    elem = nil;
                }
                if ($truthy(elem['$is_a?']($$($nesting19, 'Range')))) {
                    finish3 = $coerce_to(elem.$last(), $$($nesting19, 'Integer'), 'to_int');
                    start = $coerce_to(elem.$first(), $$($nesting19, 'Integer'), 'to_int');
                    if (start < 0) {
                        start = start + self98.length;
                        return nil;
                    }
                    if (finish3 < 0) {
                        finish3 = finish3 + self98.length;
                    }
                    if (elem['$exclude_end?']()) {
                        finish3--;
                    }
                    if (finish3 < start) {
                        return nil;
                    }
                    return $send(start, 'upto', [
                        finish3
                    ], ($$121 = function(i245) {
                        var self = $$121.$$s == null ? this : $$121.$$s;
                        if (i245 == null) {
                            i245 = nil;
                        }
                        return out['$<<'](self.$at(i245));
                    }, $$121.$$s = self98, $$121.$$arity = 1, $$121));
                } else {
                    i3 = $coerce_to(elem, $$($nesting19, 'Integer'), 'to_int');
                    return out['$<<'](self98.$at(i3));
                }
            }, $$120.$$s = self97, $$120.$$arity = 1, $$120));
            return out;
        }, $Array_values_at$119.$$arity = -1);
        Opal.def(self76, '$zip', $Array_zip$122 = function $$zip($a) {
            var $iter = $Array_zip$122.$$p, block = $iter || nil, $post_args, others, self = this, $ret_or_7 = nil;
            if ($iter) $Array_zip$122.$$p = null;
            if ($iter) $Array_zip$122.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            others = $post_args;
            var result = [], size = self.length, part, o, i246, j, jj;
            for(j = 0, jj = others.length; j < jj; j++){
                o = others[j];
                if (o.$$is_array) {
                    continue;
                }
                if (o.$$is_range || o.$$is_enumerator) {
                    others[j] = o.$take(size);
                    continue;
                }
                others[j] = (function() {
                    if ($truthy($ret_or_7 = $$($nesting19, 'Opal')['$coerce_to?'](o, $$($nesting19, 'Array'), "to_ary"))) {
                        return $ret_or_7;
                    } else {
                        return $$($nesting19, 'Opal')['$coerce_to!'](o, $$($nesting19, 'Enumerator'), "to_enum", "each");
                    }
                    return nil;
                })().$to_a();
            }
            for(i246 = 0; i246 < size; i246++){
                part = [
                    self[i246]
                ];
                for(j = 0, jj = others.length; j < jj; j++){
                    o = others[j][i246];
                    if (o == null) {
                        o = nil;
                    }
                    part[j + 1] = o;
                }
                result[i246] = part;
            }
            if (block !== nil) {
                for(i246 = 0; i246 < size; i246++){
                    block(result[i246]);
                }
                return nil;
            }
            return result;
        }, $Array_zip$122.$$arity = -1);
        Opal.defs(self76, '$inherited', $Array_inherited$123 = function $$inherited(klass) {
            klass.$$prototype.$to_a = function() {
                return this.slice(0, this.length);
            };
        }, $Array_inherited$123.$$arity = 1);
        Opal.def(self76, '$instance_variables', $Array_instance_variables$124 = function $$instance_variables() {
            var $$125, $iter = $Array_instance_variables$124.$$p, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
            if ($iter) $Array_instance_variables$124.$$p = null;
            for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                $zuper[$zuper_i] = arguments[$zuper_i];
            }
            return $send($send2(self, Opal.find_super_dispatcher(self, 'instance_variables', $Array_instance_variables$124, false, true), 'instance_variables', $zuper, $iter), 'reject', [], ($$125 = function(ivar) {
                var self = $$125.$$s == null ? this : $$125.$$s, $ret_or_8 = nil;
                if (ivar == null) {
                    ivar = nil;
                }
                if ($truthy($ret_or_8 = /^@\d+$/.test(ivar))) {
                    return $ret_or_8;
                } else {
                    return ivar['$==']("@length");
                }
            }, $$125.$$s = self, $$125.$$arity = 1, $$125));
        }, $Array_instance_variables$124.$$arity = 0);
        $$($nesting19, 'Opal').$pristine(self76.$singleton_class(), "allocate");
        $$($nesting19, 'Opal').$pristine(self76, "copy_instance_variables", "initialize_dup");
        return (Opal.def(self76, '$pack', $Array_pack$126 = function $$pack($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise("To use Array#pack, you must first require 'corelib/array/pack'.");
        }, $Array_pack$126.$$arity = -1), nil) && 'pack';
    }($nesting18[0], Array, $nesting18);
};
Opal.modules["corelib/hash"] = function(Opal) {
    function $rb_ge(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs >= rhs : lhs['$>='](rhs);
    }
    function $rb_gt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs > rhs : lhs['$>'](rhs);
    }
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    var self99 = Opal.top, $nesting20 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;
    Opal.add_stubs([
        '$require',
        '$include',
        '$coerce_to?',
        '$[]',
        '$merge!',
        '$allocate',
        '$raise',
        '$coerce_to!',
        '$each',
        '$fetch',
        '$>=',
        '$>',
        '$==',
        '$compare_by_identity',
        '$lambda?',
        '$abs',
        '$arity',
        '$enum_for',
        '$size',
        '$respond_to?',
        '$class',
        '$dig',
        '$except!',
        '$dup',
        '$delete',
        '$new',
        '$inspect',
        '$map',
        '$to_proc',
        '$flatten',
        '$eql?',
        '$default',
        '$default_proc',
        '$default_proc=',
        '$-',
        '$default=',
        '$to_h',
        '$proc'
    ]);
    self99.$require("corelib/enumerable");
    return function($base, $super, $parent_nesting) {
        var self100 = $klass($base, $super, 'Hash');
        var $nesting = [
            self100
        ].concat($parent_nesting), $Hash_$$$1, $Hash_allocate$2, $Hash_try_convert$3, $Hash_initialize$4, $Hash_$eq_eq$5, $Hash_$gt_eq$6, $Hash_$gt$8, $Hash_$lt$9, $Hash_$lt_eq$10, $Hash_$$$11, $Hash_$$$eq$12, $Hash_assoc$13, $Hash_clear$14, $Hash_clone$15, $Hash_compact$16, $Hash_compact$excl$17, $Hash_compare_by_identity$18, $Hash_compare_by_identity$ques$19, $Hash_default$20, $Hash_default$eq$21, $Hash_default_proc$22, $Hash_default_proc$eq$23, $Hash_delete$24, $Hash_delete_if$25, $Hash_dig$27, $Hash_each$28, $Hash_each_key$30, $Hash_each_value$32, $Hash_empty$ques$34, $Hash_except$35, $Hash_except$excl$36, $Hash_fetch$38, $Hash_fetch_values$39, $Hash_flatten$41, $Hash_has_key$ques$42, $Hash_has_value$ques$43, $Hash_hash$44, $Hash_index$45, $Hash_indexes$46, $Hash_inspect$47, $Hash_invert$48, $Hash_keep_if$49, $Hash_keys$51, $Hash_length$52, $Hash_merge$53, $Hash_merge$excl$54, $Hash_rassoc$55, $Hash_rehash$56, $Hash_reject$57, $Hash_reject$excl$59, $Hash_replace$61, $Hash_select$62, $Hash_select$excl$64, $Hash_shift$66, $Hash_slice$67, $Hash_to_a$68, $Hash_to_h$69, $Hash_to_hash$70, $Hash_to_proc$71, $Hash_transform_keys$73, $Hash_transform_keys$excl$75, $Hash_transform_values$77, $Hash_transform_values$excl$79, $Hash_values$81;
        self100.$include($$($nesting, 'Enumerable'));
        self100.$$prototype.$$is_hash = true;
        Opal.defs(self100, '$[]', $Hash_$$$1 = function($a) {
            var $post_args, argv2, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            argv2 = $post_args;
            var hash, argc = argv2.length, i247;
            if (argc === 1) {
                hash = $$($nesting, 'Opal')['$coerce_to?'](argv2['$[]'](0), $$($nesting, 'Hash'), "to_hash");
                if (hash !== nil) {
                    return self.$allocate()['$merge!'](hash);
                }
                argv2 = $$($nesting, 'Opal')['$coerce_to?'](argv2['$[]'](0), $$($nesting, 'Array'), "to_ary");
                if (argv2 === nil) {
                    self.$raise($$($nesting, 'ArgumentError'), "odd number of arguments for Hash");
                }
                argc = argv2.length;
                hash = self.$allocate();
                for(i247 = 0; i247 < argc; i247++){
                    if (!argv2[i247].$$is_array) continue;
                    switch(argv2[i247].length){
                        case 1:
                            hash.$store(argv2[i247][0], nil);
                            break;
                        case 2:
                            hash.$store(argv2[i247][0], argv2[i247][1]);
                            break;
                        default:
                            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid number of elements (" + argv2[i247].length + " for 1..2)");
                    }
                }
                return hash;
            }
            if (argc % 2 !== 0) {
                self.$raise($$($nesting, 'ArgumentError'), "odd number of arguments for Hash");
            }
            hash = self.$allocate();
            for(i247 = 0; i247 < argc; i247 += 2){
                hash.$store(argv2[i247], argv2[i247 + 1]);
            }
            return hash;
        }, $Hash_$$$1.$$arity = -1);
        Opal.defs(self100, '$allocate', $Hash_allocate$2 = function $$allocate() {
            var self = this;
            var hash = new self.$$constructor();
            Opal.hash_init(hash);
            hash.$$none = nil;
            hash.$$proc = nil;
            return hash;
        }, $Hash_allocate$2.$$arity = 0);
        Opal.defs(self100, '$try_convert', $Hash_try_convert$3 = function $$try_convert(obj) {
            return $$($nesting, 'Opal')['$coerce_to?'](obj, $$($nesting, 'Hash'), "to_hash");
        }, $Hash_try_convert$3.$$arity = 1);
        Opal.def(self100, '$initialize', $Hash_initialize$4 = function $$initialize(defaults) {
            var $iter = $Hash_initialize$4.$$p, block = $iter || nil, self = this;
            if ($iter) $Hash_initialize$4.$$p = null;
            if ($iter) $Hash_initialize$4.$$p = null;
            if (defaults !== undefined && block !== nil) {
                self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (1 for 0)");
            }
            self.$$none = defaults === undefined ? nil : defaults;
            self.$$proc = block;
            return self;
        }, $Hash_initialize$4.$$arity = -1);
        Opal.def(self100, '$==', $Hash_$eq_eq$5 = function(other) {
            var self = this;
            if (self === other) {
                return true;
            }
            if (!other.$$is_hash) {
                return false;
            }
            if (self.$$keys.length !== other.$$keys.length) {
                return false;
            }
            for(var i248 = 0, keys = self.$$keys, length = keys.length, key, value, other_value; i248 < length; i248++){
                key = keys[i248];
                if (key.$$is_string) {
                    value = self.$$smap[key];
                    other_value = other.$$smap[key];
                } else {
                    value = key.value;
                    other_value = Opal.hash_get(other, key.key);
                }
                if (other_value === undefined || !value['$eql?'](other_value)) {
                    return false;
                }
            }
            return true;
        }, $Hash_$eq_eq$5.$$arity = 1);
        Opal.def(self100, '$>=', $Hash_$gt_eq$6 = function(other) {
            var $$7, self101 = this, result = nil;
            other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
            if (self101.$$keys.length < other.$$keys.length) {
                return false;
            }
            result = true;
            $send(other, 'each', [], ($$7 = function(other_key, other_val) {
                var self = $$7.$$s == null ? this : $$7.$$s, val = nil;
                if (other_key == null) {
                    other_key = nil;
                }
                if (other_val == null) {
                    other_val = nil;
                }
                val = self.$fetch(other_key, null);
                if (val == null || val !== other_val) {
                    result = false;
                    return;
                }
            }, $$7.$$s = self101, $$7.$$arity = 2, $$7));
            return result;
        }, $Hash_$gt_eq$6.$$arity = 1);
        Opal.def(self100, '$>', $Hash_$gt$8 = function(other) {
            var self = this;
            other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
            if (self.$$keys.length <= other.$$keys.length) {
                return false;
            }
            return $rb_ge(self, other);
        }, $Hash_$gt$8.$$arity = 1);
        Opal.def(self100, '$<', $Hash_$lt$9 = function(other) {
            var self = this;
            other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
            return $rb_gt(other, self);
        }, $Hash_$lt$9.$$arity = 1);
        Opal.def(self100, '$<=', $Hash_$lt_eq$10 = function(other) {
            var self = this;
            other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
            return $rb_ge(other, self);
        }, $Hash_$lt_eq$10.$$arity = 1);
        Opal.def(self100, '$[]', $Hash_$$$11 = function(key) {
            var self = this;
            var value = Opal.hash_get(self, key);
            if (value !== undefined) {
                return value;
            }
            return self.$default(key);
        }, $Hash_$$$11.$$arity = 1);
        Opal.def(self100, '$[]=', $Hash_$$$eq$12 = function(key, value) {
            var self = this;
            Opal.hash_put(self, key, value);
            return value;
        }, $Hash_$$$eq$12.$$arity = 2);
        Opal.def(self100, '$assoc', $Hash_assoc$13 = function $$assoc(object) {
            var self = this;
            for(var i249 = 0, keys = self.$$keys, length = keys.length, key; i249 < length; i249++){
                key = keys[i249];
                if (key.$$is_string) {
                    if (key['$=='](object)) {
                        return [
                            key,
                            self.$$smap[key]
                        ];
                    }
                } else {
                    if (key.key['$=='](object)) {
                        return [
                            key.key,
                            key.value
                        ];
                    }
                }
            }
            return nil;
        }, $Hash_assoc$13.$$arity = 1);
        Opal.def(self100, '$clear', $Hash_clear$14 = function $$clear() {
            var self = this;
            Opal.hash_init(self);
            return self;
        }, $Hash_clear$14.$$arity = 0);
        Opal.def(self100, '$clone', $Hash_clone$15 = function $$clone() {
            var self = this;
            var hash = new self.$$class();
            Opal.hash_init(hash);
            Opal.hash_clone(self, hash);
            return hash;
        }, $Hash_clone$15.$$arity = 0);
        Opal.def(self100, '$compact', $Hash_compact$16 = function $$compact() {
            var self = this;
            var hash = Opal.hash();
            for(var i250 = 0, keys = self.$$keys, length = keys.length, key, value, obj; i250 < length; i250++){
                key = keys[i250];
                if (key.$$is_string) {
                    value = self.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                if (value !== nil) {
                    Opal.hash_put(hash, key, value);
                }
            }
            return hash;
        }, $Hash_compact$16.$$arity = 0);
        Opal.def(self100, '$compact!', $Hash_compact$excl$17 = function() {
            var self = this;
            var changes_were_made = false;
            for(var i251 = 0, keys = self.$$keys, length = keys.length, key, value, obj; i251 < length; i251++){
                key = keys[i251];
                if (key.$$is_string) {
                    value = self.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                if (value === nil) {
                    if (Opal.hash_delete(self, key) !== undefined) {
                        changes_were_made = true;
                        length--;
                        i251--;
                    }
                }
            }
            return changes_were_made ? self : nil;
        }, $Hash_compact$excl$17.$$arity = 0);
        Opal.def(self100, '$compare_by_identity', $Hash_compare_by_identity$18 = function $$compare_by_identity() {
            var self = this;
            var i252, ii, key, keys = self.$$keys, identity_hash;
            if (self.$$by_identity) return self;
            if (self.$$keys.length === 0) {
                self.$$by_identity = true;
                return self;
            }
            identity_hash = $hash2([], {}).$compare_by_identity();
            for(i252 = 0, ii = keys.length; i252 < ii; i252++){
                key = keys[i252];
                if (!key.$$is_string) key = key.key;
                Opal.hash_put(identity_hash, key, Opal.hash_get(self, key));
            }
            self.$$by_identity = true;
            self.$$map = identity_hash.$$map;
            self.$$smap = identity_hash.$$smap;
            return self;
        }, $Hash_compare_by_identity$18.$$arity = 0);
        Opal.def(self100, '$compare_by_identity?', $Hash_compare_by_identity$ques$19 = function() {
            var self = this;
            return self.$$by_identity === true;
        }, $Hash_compare_by_identity$ques$19.$$arity = 0);
        Opal.def(self100, '$default', $Hash_default$20 = function(key) {
            var self = this;
            if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {
                return self.$$proc.$call(self, key);
            }
            if (self.$$none === undefined) {
                return nil;
            }
            return self.$$none;
        }, $Hash_default$20.$$arity = -1);
        Opal.def(self100, '$default=', $Hash_default$eq$21 = function(object) {
            var self = this;
            self.$$proc = nil;
            self.$$none = object;
            return object;
        }, $Hash_default$eq$21.$$arity = 1);
        Opal.def(self100, '$default_proc', $Hash_default_proc$22 = function $$default_proc() {
            var self = this;
            if (self.$$proc !== undefined) {
                return self.$$proc;
            }
            return nil;
        }, $Hash_default_proc$22.$$arity = 0);
        Opal.def(self100, '$default_proc=', $Hash_default_proc$eq$23 = function(default_proc) {
            var self = this;
            var proc = default_proc;
            if (proc !== nil) {
                proc = $$($nesting, 'Opal')['$coerce_to!'](proc, $$($nesting, 'Proc'), "to_proc");
                if (proc['$lambda?']() && proc.$arity().$abs() !== 2) {
                    self.$raise($$($nesting, 'TypeError'), "default_proc takes two arguments");
                }
            }
            self.$$none = nil;
            self.$$proc = proc;
            return default_proc;
        }, $Hash_default_proc$eq$23.$$arity = 1);
        Opal.def(self100, '$delete', $Hash_delete$24 = function(key) {
            var $iter = $Hash_delete$24.$$p, block = $iter || nil, self = this;
            if ($iter) $Hash_delete$24.$$p = null;
            if ($iter) $Hash_delete$24.$$p = null;
            var value = Opal.hash_delete(self, key);
            if (value !== undefined) {
                return value;
            }
            if (block !== nil) {
                return Opal.yield1(block, key);
            }
            return nil;
        }, $Hash_delete$24.$$arity = 1);
        Opal.def(self100, '$delete_if', $Hash_delete_if$25 = function $$delete_if() {
            var $iter = $Hash_delete_if$25.$$p, block = $iter || nil, $$26, self102 = this;
            if ($iter) $Hash_delete_if$25.$$p = null;
            if ($iter) $Hash_delete_if$25.$$p = null;
            if ($truthy(block)) {} else {
                return $send(self102, 'enum_for', [
                    "delete_if"
                ], ($$26 = function() {
                    var self = $$26.$$s == null ? this : $$26.$$s;
                    return self.$size();
                }, $$26.$$s = self102, $$26.$$arity = 0, $$26));
            }
            for(var i253 = 0, keys = self102.$$keys, length = keys.length, key, value, obj; i253 < length; i253++){
                key = keys[i253];
                if (key.$$is_string) {
                    value = self102.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                obj = block(key, value);
                if (obj !== false && obj !== nil) {
                    if (Opal.hash_delete(self102, key) !== undefined) {
                        length--;
                        i253--;
                    }
                }
            }
            return self102;
        }, $Hash_delete_if$25.$$arity = 0);
        Opal.alias(self100, "dup", "clone");
        Opal.def(self100, '$dig', $Hash_dig$27 = function $$dig(key, $a) {
            var $post_args, keys, self = this, item = nil;
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            keys = $post_args;
            item = self['$[]'](key);
            if (item === nil || keys.length === 0) {
                return item;
            }
            if ($truthy(item['$respond_to?']("dig"))) {} else {
                self.$raise($$($nesting, 'TypeError'), "" + item.$class() + " does not have #dig method");
            }
            return $send(item, 'dig', Opal.to_a(keys));
        }, $Hash_dig$27.$$arity = -2);
        Opal.def(self100, '$each', $Hash_each$28 = function $$each() {
            var $iter = $Hash_each$28.$$p, block = $iter || nil, $$29, self103 = this;
            if ($iter) $Hash_each$28.$$p = null;
            if ($iter) $Hash_each$28.$$p = null;
            if ($truthy(block)) {} else {
                return $send(self103, 'enum_for', [
                    "each"
                ], ($$29 = function() {
                    var self = $$29.$$s == null ? this : $$29.$$s;
                    return self.$size();
                }, $$29.$$s = self103, $$29.$$arity = 0, $$29));
            }
            for(var i254 = 0, keys = self103.$$keys, length = keys.length, key, value; i254 < length; i254++){
                key = keys[i254];
                if (key.$$is_string) {
                    value = self103.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                Opal.yield1(block, [
                    key,
                    value
                ]);
            }
            return self103;
        }, $Hash_each$28.$$arity = 0);
        Opal.def(self100, '$each_key', $Hash_each_key$30 = function $$each_key() {
            var $iter = $Hash_each_key$30.$$p, block = $iter || nil, $$31, self104 = this;
            if ($iter) $Hash_each_key$30.$$p = null;
            if ($iter) $Hash_each_key$30.$$p = null;
            if ($truthy(block)) {} else {
                return $send(self104, 'enum_for', [
                    "each_key"
                ], ($$31 = function() {
                    var self = $$31.$$s == null ? this : $$31.$$s;
                    return self.$size();
                }, $$31.$$s = self104, $$31.$$arity = 0, $$31));
            }
            for(var i255 = 0, keys = self104.$$keys, length = keys.length, key; i255 < length; i255++){
                key = keys[i255];
                block(key.$$is_string ? key : key.key);
            }
            return self104;
        }, $Hash_each_key$30.$$arity = 0);
        Opal.alias(self100, "each_pair", "each");
        Opal.def(self100, '$each_value', $Hash_each_value$32 = function $$each_value() {
            var $iter = $Hash_each_value$32.$$p, block = $iter || nil, $$33, self105 = this;
            if ($iter) $Hash_each_value$32.$$p = null;
            if ($iter) $Hash_each_value$32.$$p = null;
            if ($truthy(block)) {} else {
                return $send(self105, 'enum_for', [
                    "each_value"
                ], ($$33 = function() {
                    var self = $$33.$$s == null ? this : $$33.$$s;
                    return self.$size();
                }, $$33.$$s = self105, $$33.$$arity = 0, $$33));
            }
            for(var i256 = 0, keys = self105.$$keys, length = keys.length, key; i256 < length; i256++){
                key = keys[i256];
                block(key.$$is_string ? self105.$$smap[key] : key.value);
            }
            return self105;
        }, $Hash_each_value$32.$$arity = 0);
        Opal.def(self100, '$empty?', $Hash_empty$ques$34 = function() {
            var self = this;
            return self.$$keys.length === 0;
        }, $Hash_empty$ques$34.$$arity = 0);
        Opal.alias(self100, "eql?", "==");
        Opal.def(self100, '$except', $Hash_except$35 = function $$except($a) {
            var $post_args, keys, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            keys = $post_args;
            return $send(self.$dup(), 'except!', Opal.to_a(keys));
        }, $Hash_except$35.$$arity = -1);
        Opal.def(self100, '$except!', $Hash_except$excl$36 = function($a) {
            var $post_args, keys, $$37, self106 = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            keys = $post_args;
            $send(keys, 'each', [], ($$37 = function(key) {
                var self = $$37.$$s == null ? this : $$37.$$s;
                if (key == null) {
                    key = nil;
                }
                return self.$delete(key);
            }, $$37.$$s = self106, $$37.$$arity = 1, $$37));
            return self106;
        }, $Hash_except$excl$36.$$arity = -1);
        Opal.def(self100, '$fetch', $Hash_fetch$38 = function $$fetch(key, defaults) {
            var $iter = $Hash_fetch$38.$$p, block = $iter || nil, self = this;
            if ($iter) $Hash_fetch$38.$$p = null;
            if ($iter) $Hash_fetch$38.$$p = null;
            var value = Opal.hash_get(self, key);
            if (value !== undefined) {
                return value;
            }
            if (block !== nil) {
                return block(key);
            }
            if (defaults !== undefined) {
                return defaults;
            }
            return self.$raise($$($nesting, 'KeyError').$new("" + "key not found: " + key.$inspect(), $hash2([
                "key",
                "receiver"
            ], {
                "key": key,
                "receiver": self
            })));
        }, $Hash_fetch$38.$$arity = -2);
        Opal.def(self100, '$fetch_values', $Hash_fetch_values$39 = function $$fetch_values($a) {
            var $iter = $Hash_fetch_values$39.$$p, block = $iter || nil, $post_args, keys, $$40, self107 = this;
            if ($iter) $Hash_fetch_values$39.$$p = null;
            if ($iter) $Hash_fetch_values$39.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            keys = $post_args;
            return $send(keys, 'map', [], ($$40 = function(key) {
                var self = $$40.$$s == null ? this : $$40.$$s;
                if (key == null) {
                    key = nil;
                }
                return $send(self, 'fetch', [
                    key
                ], block.$to_proc());
            }, $$40.$$s = self107, $$40.$$arity = 1, $$40));
        }, $Hash_fetch_values$39.$$arity = -1);
        Opal.def(self100, '$flatten', $Hash_flatten$41 = function $$flatten(level) {
            var self = this;
            if (level == null) {
                level = 1;
            }
            level = $$($nesting, 'Opal')['$coerce_to!'](level, $$($nesting, 'Integer'), "to_int");
            var result = [];
            for(var i257 = 0, keys = self.$$keys, length = keys.length, key, value; i257 < length; i257++){
                key = keys[i257];
                if (key.$$is_string) {
                    value = self.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                result.push(key);
                if (value.$$is_array) {
                    if (level === 1) {
                        result.push(value);
                        continue;
                    }
                    result = result.concat(value.$flatten(level - 2));
                    continue;
                }
                result.push(value);
            }
            return result;
        }, $Hash_flatten$41.$$arity = -1);
        Opal.def(self100, '$has_key?', $Hash_has_key$ques$42 = function(key) {
            var self = this;
            return Opal.hash_get(self, key) !== undefined;
        }, $Hash_has_key$ques$42.$$arity = 1);
        Opal.def(self100, '$has_value?', $Hash_has_value$ques$43 = function(value) {
            var self = this;
            for(var i258 = 0, keys = self.$$keys, length = keys.length, key; i258 < length; i258++){
                key = keys[i258];
                if ((key.$$is_string ? self.$$smap[key] : key.value)['$=='](value)) {
                    return true;
                }
            }
            return false;
        }, $Hash_has_value$ques$43.$$arity = 1);
        Opal.def(self100, '$hash', $Hash_hash$44 = function $$hash() {
            var self = this;
            var top = Opal.hash_ids === undefined, hash_id = self.$object_id(), result = [
                'Hash'
            ], key, item;
            try {
                if (top) {
                    Opal.hash_ids = Object.create(null);
                }
                if (Opal[hash_id]) {
                    return 'self';
                }
                for(key in Opal.hash_ids){
                    item = Opal.hash_ids[key];
                    if (self['$eql?'](item)) {
                        return 'self';
                    }
                }
                Opal.hash_ids[hash_id] = self;
                for(var i259 = 0, keys = self.$$keys, length = keys.length; i259 < length; i259++){
                    key = keys[i259];
                    if (key.$$is_string) {
                        result.push([
                            key,
                            self.$$smap[key].$hash()
                        ]);
                    } else {
                        result.push([
                            key.key_hash,
                            key.value.$hash()
                        ]);
                    }
                }
                return result.sort().join();
            } finally{
                if (top) {
                    Opal.hash_ids = undefined;
                }
            }
        }, $Hash_hash$44.$$arity = 0);
        Opal.alias(self100, "include?", "has_key?");
        Opal.def(self100, '$index', $Hash_index$45 = function $$index(object) {
            var self = this;
            for(var i260 = 0, keys = self.$$keys, length = keys.length, key, value; i260 < length; i260++){
                key = keys[i260];
                if (key.$$is_string) {
                    value = self.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                if (value['$=='](object)) {
                    return key;
                }
            }
            return nil;
        }, $Hash_index$45.$$arity = 1);
        Opal.def(self100, '$indexes', $Hash_indexes$46 = function $$indexes($a) {
            var $post_args, args68, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args68 = $post_args;
            var result = [];
            for(var i261 = 0, length = args68.length, key, value; i261 < length; i261++){
                key = args68[i261];
                value = Opal.hash_get(self, key);
                if (value === undefined) {
                    result.push(self.$default());
                    continue;
                }
                result.push(value);
            }
            return result;
        }, $Hash_indexes$46.$$arity = -1);
        Opal.alias(self100, "indices", "indexes");
        var inspect_ids;
        Opal.def(self100, '$inspect', $Hash_inspect$47 = function $$inspect() {
            var self = this;
            var top = inspect_ids === undefined, hash_id = self.$object_id(), result = [];
            try {
                if (top) {
                    inspect_ids = {};
                }
                if (inspect_ids.hasOwnProperty(hash_id)) {
                    return '{...}';
                }
                inspect_ids[hash_id] = true;
                for(var i262 = 0, keys = self.$$keys, length = keys.length, key, value; i262 < length; i262++){
                    key = keys[i262];
                    if (key.$$is_string) {
                        value = self.$$smap[key];
                    } else {
                        value = key.value;
                        key = key.key;
                    }
                    result.push(key.$inspect() + '=>' + value.$inspect());
                }
                return '{' + result.join(', ') + '}';
            } finally{
                if (top) {
                    inspect_ids = undefined;
                }
            }
        }, $Hash_inspect$47.$$arity = 0);
        Opal.def(self100, '$invert', $Hash_invert$48 = function $$invert() {
            var self = this;
            var hash = Opal.hash();
            for(var i263 = 0, keys = self.$$keys, length = keys.length, key, value; i263 < length; i263++){
                key = keys[i263];
                if (key.$$is_string) {
                    value = self.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                Opal.hash_put(hash, value, key);
            }
            return hash;
        }, $Hash_invert$48.$$arity = 0);
        Opal.def(self100, '$keep_if', $Hash_keep_if$49 = function $$keep_if() {
            var $iter = $Hash_keep_if$49.$$p, block = $iter || nil, $$50, self108 = this;
            if ($iter) $Hash_keep_if$49.$$p = null;
            if ($iter) $Hash_keep_if$49.$$p = null;
            if ($truthy(block)) {} else {
                return $send(self108, 'enum_for', [
                    "keep_if"
                ], ($$50 = function() {
                    var self = $$50.$$s == null ? this : $$50.$$s;
                    return self.$size();
                }, $$50.$$s = self108, $$50.$$arity = 0, $$50));
            }
            for(var i264 = 0, keys = self108.$$keys, length = keys.length, key, value, obj; i264 < length; i264++){
                key = keys[i264];
                if (key.$$is_string) {
                    value = self108.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                obj = block(key, value);
                if (obj === false || obj === nil) {
                    if (Opal.hash_delete(self108, key) !== undefined) {
                        length--;
                        i264--;
                    }
                }
            }
            return self108;
        }, $Hash_keep_if$49.$$arity = 0);
        Opal.alias(self100, "key", "index");
        Opal.alias(self100, "key?", "has_key?");
        Opal.def(self100, '$keys', $Hash_keys$51 = function $$keys() {
            var self = this;
            var result = [];
            for(var i265 = 0, keys = self.$$keys, length = keys.length, key; i265 < length; i265++){
                key = keys[i265];
                if (key.$$is_string) {
                    result.push(key);
                } else {
                    result.push(key.key);
                }
            }
            return result;
        }, $Hash_keys$51.$$arity = 0);
        Opal.def(self100, '$length', $Hash_length$52 = function $$length() {
            var self = this;
            return self.$$keys.length;
        }, $Hash_length$52.$$arity = 0);
        Opal.alias(self100, "member?", "has_key?");
        Opal.def(self100, '$merge', $Hash_merge$53 = function $$merge($a) {
            var $iter = $Hash_merge$53.$$p, block = $iter || nil, $post_args, others, self = this;
            if ($iter) $Hash_merge$53.$$p = null;
            if ($iter) $Hash_merge$53.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            others = $post_args;
            return $send(self.$dup(), 'merge!', Opal.to_a(others), block.$to_proc());
        }, $Hash_merge$53.$$arity = -1);
        Opal.def(self100, '$merge!', $Hash_merge$excl$54 = function($a) {
            var $iter = $Hash_merge$excl$54.$$p, block = $iter || nil, $post_args, others, self = this;
            if ($iter) $Hash_merge$excl$54.$$p = null;
            if ($iter) $Hash_merge$excl$54.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            others = $post_args;
            var i266, j, other, other_keys, length, key, value, other_value;
            for(i266 = 0; i266 < others.length; ++i266){
                other = $$($nesting, 'Opal')['$coerce_to!'](others[i266], $$($nesting, 'Hash'), "to_hash");
                other_keys = other.$$keys, length = other_keys.length;
                if (block === nil) {
                    for(j = 0; j < length; j++){
                        key = other_keys[j];
                        if (key.$$is_string) {
                            other_value = other.$$smap[key];
                        } else {
                            other_value = key.value;
                            key = key.key;
                        }
                        Opal.hash_put(self, key, other_value);
                    }
                } else {
                    for(j = 0; j < length; j++){
                        key = other_keys[j];
                        if (key.$$is_string) {
                            other_value = other.$$smap[key];
                        } else {
                            other_value = key.value;
                            key = key.key;
                        }
                        value = Opal.hash_get(self, key);
                        if (value === undefined) {
                            Opal.hash_put(self, key, other_value);
                            continue;
                        }
                        Opal.hash_put(self, key, block(key, value, other_value));
                    }
                }
            }
            return self;
        }, $Hash_merge$excl$54.$$arity = -1);
        Opal.def(self100, '$rassoc', $Hash_rassoc$55 = function $$rassoc(object) {
            var self = this;
            for(var i267 = 0, keys = self.$$keys, length = keys.length, key, value; i267 < length; i267++){
                key = keys[i267];
                if (key.$$is_string) {
                    value = self.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                if (value['$=='](object)) {
                    return [
                        key,
                        value
                    ];
                }
            }
            return nil;
        }, $Hash_rassoc$55.$$arity = 1);
        Opal.def(self100, '$rehash', $Hash_rehash$56 = function $$rehash() {
            var self = this;
            Opal.hash_rehash(self);
            return self;
        }, $Hash_rehash$56.$$arity = 0);
        Opal.def(self100, '$reject', $Hash_reject$57 = function $$reject() {
            var $iter = $Hash_reject$57.$$p, block = $iter || nil, $$58, self109 = this;
            if ($iter) $Hash_reject$57.$$p = null;
            if ($iter) $Hash_reject$57.$$p = null;
            if ($truthy(block)) {} else {
                return $send(self109, 'enum_for', [
                    "reject"
                ], ($$58 = function() {
                    var self = $$58.$$s == null ? this : $$58.$$s;
                    return self.$size();
                }, $$58.$$s = self109, $$58.$$arity = 0, $$58));
            }
            var hash = Opal.hash();
            for(var i268 = 0, keys = self109.$$keys, length = keys.length, key, value, obj; i268 < length; i268++){
                key = keys[i268];
                if (key.$$is_string) {
                    value = self109.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                obj = block(key, value);
                if (obj === false || obj === nil) {
                    Opal.hash_put(hash, key, value);
                }
            }
            return hash;
        }, $Hash_reject$57.$$arity = 0);
        Opal.def(self100, '$reject!', $Hash_reject$excl$59 = function() {
            var $iter = $Hash_reject$excl$59.$$p, block = $iter || nil, $$60, self110 = this;
            if ($iter) $Hash_reject$excl$59.$$p = null;
            if ($iter) $Hash_reject$excl$59.$$p = null;
            if ($truthy(block)) {} else {
                return $send(self110, 'enum_for', [
                    "reject!"
                ], ($$60 = function() {
                    var self = $$60.$$s == null ? this : $$60.$$s;
                    return self.$size();
                }, $$60.$$s = self110, $$60.$$arity = 0, $$60));
            }
            var changes_were_made = false;
            for(var i269 = 0, keys = self110.$$keys, length = keys.length, key, value, obj; i269 < length; i269++){
                key = keys[i269];
                if (key.$$is_string) {
                    value = self110.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                obj = block(key, value);
                if (obj !== false && obj !== nil) {
                    if (Opal.hash_delete(self110, key) !== undefined) {
                        changes_were_made = true;
                        length--;
                        i269--;
                    }
                }
            }
            return changes_were_made ? self110 : nil;
        }, $Hash_reject$excl$59.$$arity = 0);
        Opal.def(self100, '$replace', $Hash_replace$61 = function $$replace(other) {
            var self = this, $writer = nil;
            other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
            Opal.hash_init(self);
            for(var i270 = 0, other_keys = other.$$keys, length = other_keys.length, key, value, other_value; i270 < length; i270++){
                key = other_keys[i270];
                if (key.$$is_string) {
                    other_value = other.$$smap[key];
                } else {
                    other_value = key.value;
                    key = key.key;
                }
                Opal.hash_put(self, key, other_value);
            }
            if ($truthy(other.$default_proc())) {
                $writer = [
                    other.$default_proc()
                ];
                $send(self, 'default_proc=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
            } else {
                $writer = [
                    other.$default()
                ];
                $send(self, 'default=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
            }
            return self;
        }, $Hash_replace$61.$$arity = 1);
        Opal.def(self100, '$select', $Hash_select$62 = function $$select() {
            var $iter = $Hash_select$62.$$p, block = $iter || nil, $$63, self111 = this;
            if ($iter) $Hash_select$62.$$p = null;
            if ($iter) $Hash_select$62.$$p = null;
            if ($truthy(block)) {} else {
                return $send(self111, 'enum_for', [
                    "select"
                ], ($$63 = function() {
                    var self = $$63.$$s == null ? this : $$63.$$s;
                    return self.$size();
                }, $$63.$$s = self111, $$63.$$arity = 0, $$63));
            }
            var hash = Opal.hash();
            for(var i271 = 0, keys = self111.$$keys, length = keys.length, key, value, obj; i271 < length; i271++){
                key = keys[i271];
                if (key.$$is_string) {
                    value = self111.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                obj = block(key, value);
                if (obj !== false && obj !== nil) {
                    Opal.hash_put(hash, key, value);
                }
            }
            return hash;
        }, $Hash_select$62.$$arity = 0);
        Opal.def(self100, '$select!', $Hash_select$excl$64 = function() {
            var $iter = $Hash_select$excl$64.$$p, block = $iter || nil, $$65, self112 = this;
            if ($iter) $Hash_select$excl$64.$$p = null;
            if ($iter) $Hash_select$excl$64.$$p = null;
            if ($truthy(block)) {} else {
                return $send(self112, 'enum_for', [
                    "select!"
                ], ($$65 = function() {
                    var self = $$65.$$s == null ? this : $$65.$$s;
                    return self.$size();
                }, $$65.$$s = self112, $$65.$$arity = 0, $$65));
            }
            var result = nil;
            for(var i272 = 0, keys = self112.$$keys, length = keys.length, key, value, obj; i272 < length; i272++){
                key = keys[i272];
                if (key.$$is_string) {
                    value = self112.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                obj = block(key, value);
                if (obj === false || obj === nil) {
                    if (Opal.hash_delete(self112, key) !== undefined) {
                        length--;
                        i272--;
                    }
                    result = self112;
                }
            }
            return result;
        }, $Hash_select$excl$64.$$arity = 0);
        Opal.alias(self100, "filter", "select");
        Opal.alias(self100, "filter!", "select!");
        Opal.def(self100, '$shift', $Hash_shift$66 = function $$shift() {
            var self = this;
            var keys = self.$$keys, key;
            if (keys.length > 0) {
                key = keys[0];
                key = key.$$is_string ? key : key.key;
                return [
                    key,
                    Opal.hash_delete(self, key)
                ];
            }
            return self.$default(nil);
        }, $Hash_shift$66.$$arity = 0);
        Opal.alias(self100, "size", "length");
        Opal.def(self100, '$slice', $Hash_slice$67 = function $$slice($a) {
            var $post_args, keys, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            keys = $post_args;
            var result = Opal.hash();
            for(var i273 = 0, length = keys.length; i273 < length; i273++){
                var key = keys[i273], value = Opal.hash_get(self, key);
                if (value !== undefined) {
                    Opal.hash_put(result, key, value);
                }
            }
            return result;
        }, $Hash_slice$67.$$arity = -1);
        Opal.alias(self100, "store", "[]=");
        Opal.def(self100, '$to_a', $Hash_to_a$68 = function $$to_a() {
            var self = this;
            var result = [];
            for(var i274 = 0, keys = self.$$keys, length = keys.length, key, value; i274 < length; i274++){
                key = keys[i274];
                if (key.$$is_string) {
                    value = self.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                result.push([
                    key,
                    value
                ]);
            }
            return result;
        }, $Hash_to_a$68.$$arity = 0);
        Opal.def(self100, '$to_h', $Hash_to_h$69 = function $$to_h() {
            var $iter = $Hash_to_h$69.$$p, block = $iter || nil, self = this;
            if ($iter) $Hash_to_h$69.$$p = null;
            if ($iter) $Hash_to_h$69.$$p = null;
            if (block !== nil) {
                return $send(self, 'map', [], block.$to_proc()).$to_h();
            }
            if (self.$$class === Opal.Hash) {
                return self;
            }
            var hash = new Opal.Hash();
            Opal.hash_init(hash);
            Opal.hash_clone(self, hash);
            return hash;
        }, $Hash_to_h$69.$$arity = 0);
        Opal.def(self100, '$to_hash', $Hash_to_hash$70 = function $$to_hash() {
            var self = this;
            return self;
        }, $Hash_to_hash$70.$$arity = 0);
        Opal.def(self100, '$to_proc', $Hash_to_proc$71 = function $$to_proc() {
            var $$72, self113 = this;
            return $send(self113, 'proc', [], ($$72 = function(key) {
                var self = $$72.$$s == null ? this : $$72.$$s;
                if (key == null) {
                    self.$raise($$($nesting, 'ArgumentError'), "no key given");
                }
                return self['$[]'](key);
            }, $$72.$$s = self113, $$72.$$arity = -1, $$72));
        }, $Hash_to_proc$71.$$arity = 0);
        Opal.alias(self100, "to_s", "inspect");
        Opal.def(self100, '$transform_keys', $Hash_transform_keys$73 = function $$transform_keys() {
            var $iter = $Hash_transform_keys$73.$$p, block = $iter || nil, $$74, self114 = this;
            if ($iter) $Hash_transform_keys$73.$$p = null;
            if ($iter) $Hash_transform_keys$73.$$p = null;
            if ($truthy(block)) {} else {
                return $send(self114, 'enum_for', [
                    "transform_keys"
                ], ($$74 = function() {
                    var self = $$74.$$s == null ? this : $$74.$$s;
                    return self.$size();
                }, $$74.$$s = self114, $$74.$$arity = 0, $$74));
            }
            var result = Opal.hash();
            for(var i275 = 0, keys = self114.$$keys, length = keys.length, key, value; i275 < length; i275++){
                key = keys[i275];
                if (key.$$is_string) {
                    value = self114.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                key = Opal.yield1(block, key);
                Opal.hash_put(result, key, value);
            }
            return result;
        }, $Hash_transform_keys$73.$$arity = 0);
        Opal.def(self100, '$transform_keys!', $Hash_transform_keys$excl$75 = function() {
            var $iter = $Hash_transform_keys$excl$75.$$p, block = $iter || nil, $$76, self115 = this;
            if ($iter) $Hash_transform_keys$excl$75.$$p = null;
            if ($iter) $Hash_transform_keys$excl$75.$$p = null;
            if ($truthy(block)) {} else {
                return $send(self115, 'enum_for', [
                    "transform_keys!"
                ], ($$76 = function() {
                    var self = $$76.$$s == null ? this : $$76.$$s;
                    return self.$size();
                }, $$76.$$s = self115, $$76.$$arity = 0, $$76));
            }
            var keys = Opal.slice.call(self115.$$keys), i276, length = keys.length, key, value, new_key;
            for(i276 = 0; i276 < length; i276++){
                key = keys[i276];
                if (key.$$is_string) {
                    value = self115.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                new_key = Opal.yield1(block, key);
                Opal.hash_delete(self115, key);
                Opal.hash_put(self115, new_key, value);
            }
            return self115;
        }, $Hash_transform_keys$excl$75.$$arity = 0);
        Opal.def(self100, '$transform_values', $Hash_transform_values$77 = function $$transform_values() {
            var $iter = $Hash_transform_values$77.$$p, block = $iter || nil, $$78, self116 = this;
            if ($iter) $Hash_transform_values$77.$$p = null;
            if ($iter) $Hash_transform_values$77.$$p = null;
            if ($truthy(block)) {} else {
                return $send(self116, 'enum_for', [
                    "transform_values"
                ], ($$78 = function() {
                    var self = $$78.$$s == null ? this : $$78.$$s;
                    return self.$size();
                }, $$78.$$s = self116, $$78.$$arity = 0, $$78));
            }
            var result = Opal.hash();
            for(var i277 = 0, keys = self116.$$keys, length = keys.length, key, value; i277 < length; i277++){
                key = keys[i277];
                if (key.$$is_string) {
                    value = self116.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                value = Opal.yield1(block, value);
                Opal.hash_put(result, key, value);
            }
            return result;
        }, $Hash_transform_values$77.$$arity = 0);
        Opal.def(self100, '$transform_values!', $Hash_transform_values$excl$79 = function() {
            var $iter = $Hash_transform_values$excl$79.$$p, block = $iter || nil, $$80, self117 = this;
            if ($iter) $Hash_transform_values$excl$79.$$p = null;
            if ($iter) $Hash_transform_values$excl$79.$$p = null;
            if ($truthy(block)) {} else {
                return $send(self117, 'enum_for', [
                    "transform_values!"
                ], ($$80 = function() {
                    var self = $$80.$$s == null ? this : $$80.$$s;
                    return self.$size();
                }, $$80.$$s = self117, $$80.$$arity = 0, $$80));
            }
            for(var i278 = 0, keys = self117.$$keys, length = keys.length, key, value; i278 < length; i278++){
                key = keys[i278];
                if (key.$$is_string) {
                    value = self117.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                value = Opal.yield1(block, value);
                Opal.hash_put(self117, key, value);
            }
            return self117;
        }, $Hash_transform_values$excl$79.$$arity = 0);
        Opal.alias(self100, "update", "merge!");
        Opal.alias(self100, "value?", "has_value?");
        Opal.alias(self100, "values_at", "indexes");
        return (Opal.def(self100, '$values', $Hash_values$81 = function $$values() {
            var self = this;
            var result = [];
            for(var i279 = 0, keys = self.$$keys, length = keys.length, key; i279 < length; i279++){
                key = keys[i279];
                if (key.$$is_string) {
                    result.push(self.$$smap[key]);
                } else {
                    result.push(key.value);
                }
            }
            return result;
        }, $Hash_values$81.$$arity = 0), nil) && 'values';
    }($nesting20[0], null, $nesting20);
};
Opal.modules["corelib/number"] = function(Opal) {
    function $rb_gt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs > rhs : lhs['$>'](rhs);
    }
    function $rb_lt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs < rhs : lhs['$<'](rhs);
    }
    function $rb_plus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
    }
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    function $rb_divide(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs / rhs : lhs['$/'](rhs);
    }
    function $rb_times(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs * rhs : lhs['$*'](rhs);
    }
    function $rb_le(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs <= rhs : lhs['$<='](rhs);
    }
    function $rb_ge(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs >= rhs : lhs['$>='](rhs);
    }
    var self118 = Opal.top, $nesting21 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $send2 = Opal.send2, $send = Opal.send;
    Opal.add_stubs([
        '$require',
        '$bridge',
        '$raise',
        '$name',
        '$class',
        '$Float',
        '$respond_to?',
        '$coerce_to!',
        '$__coerced__',
        '$===',
        '$!',
        '$>',
        '$**',
        '$new',
        '$<',
        '$to_f',
        '$==',
        '$nan?',
        '$infinite?',
        '$enum_for',
        '$+',
        '$-',
        '$gcd',
        '$lcm',
        '$%',
        '$/',
        '$frexp',
        '$to_i',
        '$ldexp',
        '$rationalize',
        '$*',
        '$<<',
        '$to_r',
        '$truncate',
        '$-@',
        '$size',
        '$<=',
        '$>='
    ]);
    self118.$require("corelib/numeric");
    (function($base, $super, $parent_nesting9) {
        var self119 = $klass($base, $super, 'Number');
        var $nesting22 = [
            self119
        ].concat($parent_nesting9), $Number_coerce$2, $Number___id__$3, $Number_$plus$4, $Number_$minus$5, $Number_$$6, $Number_$slash$7, $Number_$percent$8, $Number_$$9, $Number_$$10, $Number_$$11, $Number_$lt$12, $Number_$lt_eq$13, $Number_$gt$14, $Number_$gt_eq$15, $Number_$lt_eq_gt$16, $Number_$lt$lt$17, $Number_$gt$gt$18, $Number_$$$19, $Number_$plus$$20, $Number_$minus$$21, $Number_$$22, $Number_$$$23, $Number_$eq_eq_eq$24, $Number_$eq_eq$25, $Number_abs$26, $Number_abs2$27, $Number_allbits$ques$28, $Number_anybits$ques$29, $Number_angle$30, $Number_bit_length$31, $Number_ceil$32, $Number_chr$33, $Number_denominator$34, $Number_downto$35, $Number_equal$ques$37, $Number_even$ques$38, $Number_floor$39, $Number_gcd$40, $Number_gcdlcm$41, $Number_integer$ques$42, $Number_is_a$ques$43, $Number_instance_of$ques$44, $Number_lcm$45, $Number_next$46, $Number_nobits$ques$47, $Number_nonzero$ques$48, $Number_numerator$49, $Number_odd$ques$50, $Number_ord$51, $Number_pow$52, $Number_pred$53, $Number_quo$54, $Number_rationalize$55, $Number_remainder$56, $Number_round$57, $Number_times$58, $Number_to_f$60, $Number_to_i$61, $Number_to_r$62, $Number_to_s$63, $Number_truncate$64, $Number_digits$65, $Number_divmod$66, $Number_upto$67, $Number_zero$ques$69, $Number_size$70, $Number_nan$ques$71, $Number_finite$ques$72, $Number_infinite$ques$73, $Number_positive$ques$74, $Number_negative$ques$75;
        $$($nesting22, 'Opal').$bridge(Number, self119);
        Opal.defineProperty(self119.$$prototype, '$$is_number', true);
        self119.$$is_number_class = true;
        (function(self120, $parent_nesting) {
            var $nesting = [
                self120
            ].concat($parent_nesting), $allocate$1;
            Opal.def(self120, '$allocate', $allocate$1 = function $$allocate() {
                var self = this;
                return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + self.$name());
            }, $allocate$1.$$arity = 0);
            Opal.udef(self120, '$' + "new");
            return nil;
        })(Opal.get_singleton_class(self119), $nesting22);
        Opal.def(self119, '$coerce', $Number_coerce$2 = function $$coerce(other) {
            var self = this;
            if (other === nil) {
                self.$raise($$($nesting22, 'TypeError'), "" + "can't convert " + other.$class() + " into Float");
            } else if (other.$$is_string) {
                return [
                    self.$Float(other),
                    self
                ];
            } else if (other['$respond_to?']("to_f")) {
                return [
                    $$($nesting22, 'Opal')['$coerce_to!'](other, $$($nesting22, 'Float'), "to_f"),
                    self
                ];
            } else if (other.$$is_number) {
                return [
                    other,
                    self
                ];
            } else {
                self.$raise($$($nesting22, 'TypeError'), "" + "can't convert " + other.$class() + " into Float");
            }
        }, $Number_coerce$2.$$arity = 1);
        Opal.def(self119, '$__id__', $Number___id__$3 = function $$__id__() {
            var self = this;
            return self * 2 + 1;
        }, $Number___id__$3.$$arity = 0);
        Opal.alias(self119, "object_id", "__id__");
        Opal.def(self119, '$+', $Number_$plus$4 = function(other) {
            var self = this;
            if (other.$$is_number) {
                return self + other;
            } else {
                return self.$__coerced__("+", other);
            }
        }, $Number_$plus$4.$$arity = 1);
        Opal.def(self119, '$-', $Number_$minus$5 = function(other) {
            var self = this;
            if (other.$$is_number) {
                return self - other;
            } else {
                return self.$__coerced__("-", other);
            }
        }, $Number_$minus$5.$$arity = 1);
        Opal.def(self119, '$*', $Number_$$6 = function(other) {
            var self = this;
            if (other.$$is_number) {
                return self * other;
            } else {
                return self.$__coerced__("*", other);
            }
        }, $Number_$$6.$$arity = 1);
        Opal.def(self119, '$/', $Number_$slash$7 = function(other) {
            var self = this;
            if (other.$$is_number) {
                return self / other;
            } else {
                return self.$__coerced__("/", other);
            }
        }, $Number_$slash$7.$$arity = 1);
        Opal.alias(self119, "fdiv", "/");
        Opal.def(self119, '$%', $Number_$percent$8 = function(other) {
            var self = this;
            if (other.$$is_number) {
                if (other == -Infinity) {
                    return other;
                } else if (other == 0) {
                    self.$raise($$($nesting22, 'ZeroDivisionError'), "divided by 0");
                } else if (other < 0 || self < 0) {
                    return (self % other + other) % other;
                } else {
                    return self % other;
                }
            } else {
                return self.$__coerced__("%", other);
            }
        }, $Number_$percent$8.$$arity = 1);
        Opal.def(self119, '$&', $Number_$$9 = function(other) {
            var self = this;
            if (other.$$is_number) {
                return self & other;
            } else {
                return self.$__coerced__("&", other);
            }
        }, $Number_$$9.$$arity = 1);
        Opal.def(self119, '$|', $Number_$$10 = function(other) {
            var self = this;
            if (other.$$is_number) {
                return self | other;
            } else {
                return self.$__coerced__("|", other);
            }
        }, $Number_$$10.$$arity = 1);
        Opal.def(self119, '$^', $Number_$$11 = function(other) {
            var self = this;
            if (other.$$is_number) {
                return self ^ other;
            } else {
                return self.$__coerced__("^", other);
            }
        }, $Number_$$11.$$arity = 1);
        Opal.def(self119, '$<', $Number_$lt$12 = function(other) {
            var self = this;
            if (other.$$is_number) {
                return self < other;
            } else {
                return self.$__coerced__("<", other);
            }
        }, $Number_$lt$12.$$arity = 1);
        Opal.def(self119, '$<=', $Number_$lt_eq$13 = function(other) {
            var self = this;
            if (other.$$is_number) {
                return self <= other;
            } else {
                return self.$__coerced__("<=", other);
            }
        }, $Number_$lt_eq$13.$$arity = 1);
        Opal.def(self119, '$>', $Number_$gt$14 = function(other) {
            var self = this;
            if (other.$$is_number) {
                return self > other;
            } else {
                return self.$__coerced__(">", other);
            }
        }, $Number_$gt$14.$$arity = 1);
        Opal.def(self119, '$>=', $Number_$gt_eq$15 = function(other) {
            var self = this;
            if (other.$$is_number) {
                return self >= other;
            } else {
                return self.$__coerced__(">=", other);
            }
        }, $Number_$gt_eq$15.$$arity = 1);
        var spaceship_operator = function(self, other) {
            if (other.$$is_number) {
                if (isNaN(self) || isNaN(other)) {
                    return nil;
                }
                if (self > other) {
                    return 1;
                } else if (self < other) {
                    return -1;
                } else {
                    return 0;
                }
            } else {
                return self.$__coerced__("<=>", other);
            }
        };
        Opal.def(self119, '$<=>', $Number_$lt_eq_gt$16 = function(other) {
            var self = this;
            try {
                return spaceship_operator(self, other);
            } catch ($err) {
                if (Opal.rescue($err, [
                    $$($nesting22, 'ArgumentError')
                ])) {
                    try {
                        return nil;
                    } finally{
                        Opal.pop_exception();
                    }
                } else {
                    throw $err;
                }
            }
        }, $Number_$lt_eq_gt$16.$$arity = 1);
        Opal.def(self119, '$<<', $Number_$lt$lt$17 = function(count) {
            var self = this;
            count = $$($nesting22, 'Opal')['$coerce_to!'](count, $$($nesting22, 'Integer'), "to_int");
            return count > 0 ? self << count : self >> -count;
        }, $Number_$lt$lt$17.$$arity = 1);
        Opal.def(self119, '$>>', $Number_$gt$gt$18 = function(count) {
            var self = this;
            count = $$($nesting22, 'Opal')['$coerce_to!'](count, $$($nesting22, 'Integer'), "to_int");
            return count > 0 ? self >> count : self << -count;
        }, $Number_$gt$gt$18.$$arity = 1);
        Opal.def(self119, '$[]', $Number_$$$19 = function(bit) {
            var self = this;
            bit = $$($nesting22, 'Opal')['$coerce_to!'](bit, $$($nesting22, 'Integer'), "to_int");
            if (bit < 0) {
                return 0;
            }
            if (bit >= 32) {
                return self < 0 ? 1 : 0;
            }
            return self >> bit & 1;
        }, $Number_$$$19.$$arity = 1);
        Opal.def(self119, '$+@', $Number_$plus$$20 = function() {
            var self = this;
            return +self;
        }, $Number_$plus$$20.$$arity = 0);
        Opal.def(self119, '$-@', $Number_$minus$$21 = function() {
            var self = this;
            return -self;
        }, $Number_$minus$$21.$$arity = 0);
        Opal.def(self119, '$~', $Number_$$22 = function() {
            var self = this;
            return ~self;
        }, $Number_$$22.$$arity = 0);
        Opal.def(self119, '$**', $Number_$$$23 = function(other) {
            var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;
            if ($truthy($$($nesting22, 'Integer')['$==='](other))) {
                if ($truthy(function() {
                    if ($truthy($ret_or_1 = $$($nesting22, 'Integer')['$==='](self)['$!']())) {
                        return $ret_or_1;
                    } else {
                        return $rb_gt(other, 0);
                    }
                    return nil;
                }())) {
                    return Math.pow(self, other);
                } else {
                    return $$($nesting22, 'Rational').$new(self, 1)['$**'](other);
                }
            } else if ($truthy(function() {
                if ($truthy($ret_or_2 = $rb_lt(self, 0))) {
                    if ($truthy($ret_or_3 = $$($nesting22, 'Float')['$==='](other))) {
                        return $ret_or_3;
                    } else {
                        return $$($nesting22, 'Rational')['$==='](other);
                    }
                } else {
                    return $ret_or_2;
                }
                return nil;
            }())) {
                return $$($nesting22, 'Complex').$new(self, 0)['$**'](other.$to_f());
            } else if ($truthy(other.$$is_number != null)) {
                return Math.pow(self, other);
            } else {
                return self.$__coerced__("**", other);
            }
        }, $Number_$$$23.$$arity = 1);
        Opal.def(self119, '$===', $Number_$eq_eq_eq$24 = function(other) {
            var self = this;
            if (other.$$is_number) {
                return self.valueOf() === other.valueOf();
            } else if (other['$respond_to?']("==")) {
                return other['$=='](self);
            } else {
                return false;
            }
        }, $Number_$eq_eq_eq$24.$$arity = 1);
        Opal.def(self119, '$==', $Number_$eq_eq$25 = function(other) {
            var self = this;
            if (other.$$is_number) {
                return self.valueOf() === other.valueOf();
            } else if (other['$respond_to?']("==")) {
                return other['$=='](self);
            } else {
                return false;
            }
        }, $Number_$eq_eq$25.$$arity = 1);
        Opal.def(self119, '$abs', $Number_abs$26 = function $$abs() {
            var self = this;
            return Math.abs(self);
        }, $Number_abs$26.$$arity = 0);
        Opal.def(self119, '$abs2', $Number_abs2$27 = function $$abs2() {
            var self = this;
            return Math.abs(self * self);
        }, $Number_abs2$27.$$arity = 0);
        Opal.def(self119, '$allbits?', $Number_allbits$ques$28 = function(mask) {
            var self = this;
            mask = $$($nesting22, 'Opal')['$coerce_to!'](mask, $$($nesting22, 'Integer'), "to_int");
            return (self & mask) == mask;
        }, $Number_allbits$ques$28.$$arity = 1);
        Opal.def(self119, '$anybits?', $Number_anybits$ques$29 = function(mask) {
            var self = this;
            mask = $$($nesting22, 'Opal')['$coerce_to!'](mask, $$($nesting22, 'Integer'), "to_int");
            return (self & mask) !== 0;
        }, $Number_anybits$ques$29.$$arity = 1);
        Opal.def(self119, '$angle', $Number_angle$30 = function $$angle() {
            var self = this;
            if ($truthy(self['$nan?']())) {
                return self;
            }
            if (self == 0) {
                if (1 / self > 0) {
                    return 0;
                } else {
                    return Math.PI;
                }
            } else if (self < 0) {
                return Math.PI;
            } else {
                return 0;
            }
        }, $Number_angle$30.$$arity = 0);
        Opal.alias(self119, "arg", "angle");
        Opal.alias(self119, "phase", "angle");
        Opal.def(self119, '$bit_length', $Number_bit_length$31 = function $$bit_length() {
            var self = this;
            if ($truthy($$($nesting22, 'Integer')['$==='](self))) {} else {
                self.$raise($$($nesting22, 'NoMethodError').$new("" + "undefined method `bit_length` for " + self + ":Float", "bit_length"));
            }
            if (self === 0 || self === -1) {
                return 0;
            }
            var result = 0, value = self < 0 ? ~self : self;
            while(value != 0){
                result += 1;
                value >>>= 1;
            }
            return result;
        }, $Number_bit_length$31.$$arity = 0);
        Opal.def(self119, '$ceil', $Number_ceil$32 = function $$ceil(ndigits) {
            var self = this;
            if (ndigits == null) {
                ndigits = 0;
            }
            var f = self.$to_f();
            if (f % 1 === 0 && ndigits >= 0) {
                return f;
            }
            var factor = Math.pow(10, ndigits), result = Math.ceil(f * factor) / factor;
            if (f % 1 === 0) {
                result = Math.round(result);
            }
            return result;
        }, $Number_ceil$32.$$arity = -1);
        Opal.def(self119, '$chr', $Number_chr$33 = function $$chr(encoding) {
            var self = this;
            return Opal.enc(String.fromCharCode(self), encoding || "BINARY");
        }, $Number_chr$33.$$arity = -1);
        Opal.def(self119, '$denominator', $Number_denominator$34 = function $$denominator() {
            var $iter = $Number_denominator$34.$$p, self = this, $ret_or_4 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
            if ($iter) $Number_denominator$34.$$p = null;
            for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                $zuper[$zuper_i] = arguments[$zuper_i];
            }
            if ($truthy(function() {
                if ($truthy($ret_or_4 = self['$nan?']())) {
                    return $ret_or_4;
                } else {
                    return self['$infinite?']();
                }
                return nil;
            }())) {
                return 1;
            } else {
                return $send2(self, Opal.find_super_dispatcher(self, 'denominator', $Number_denominator$34, false, true), 'denominator', $zuper, $iter);
            }
        }, $Number_denominator$34.$$arity = 0);
        Opal.def(self119, '$downto', $Number_downto$35 = function $$downto(stop) {
            var $iter = $Number_downto$35.$$p, block = $iter || nil, $$36, self121 = this;
            if ($iter) $Number_downto$35.$$p = null;
            if ($iter) $Number_downto$35.$$p = null;
            if (block !== nil) {} else {
                return $send(self121, 'enum_for', [
                    "downto",
                    stop
                ], ($$36 = function() {
                    var self = $$36.$$s == null ? this : $$36.$$s;
                    if ($truthy($$($nesting22, 'Numeric')['$==='](stop))) {} else {
                        self.$raise($$($nesting22, 'ArgumentError'), "" + "comparison of " + self.$class() + " with " + stop.$class() + " failed");
                    }
                    if ($truthy($rb_gt(stop, self))) {
                        return 0;
                    } else {
                        return $rb_plus($rb_minus(self, stop), 1);
                    }
                }, $$36.$$s = self121, $$36.$$arity = 0, $$36));
            }
            if (!stop.$$is_number) {
                self121.$raise($$($nesting22, 'ArgumentError'), "" + "comparison of " + self121.$class() + " with " + stop.$class() + " failed");
            }
            for(var i280 = self121; i280 >= stop; i280--){
                block(i280);
            }
            return self121;
        }, $Number_downto$35.$$arity = 1);
        Opal.alias(self119, "eql?", "==");
        Opal.def(self119, '$equal?', $Number_equal$ques$37 = function(other) {
            var self = this, $ret_or_5 = nil;
            if ($truthy($ret_or_5 = self['$=='](other))) {
                return $ret_or_5;
            } else {
                return isNaN(self) && isNaN(other);
            }
        }, $Number_equal$ques$37.$$arity = 1);
        Opal.def(self119, '$even?', $Number_even$ques$38 = function() {
            var self = this;
            return self % 2 === 0;
        }, $Number_even$ques$38.$$arity = 0);
        Opal.def(self119, '$floor', $Number_floor$39 = function $$floor(ndigits) {
            var self = this;
            if (ndigits == null) {
                ndigits = 0;
            }
            var f = self.$to_f();
            if (f % 1 === 0 && ndigits >= 0) {
                return f;
            }
            var factor = Math.pow(10, ndigits), result = Math.floor(f * factor) / factor;
            if (f % 1 === 0) {
                result = Math.round(result);
            }
            return result;
        }, $Number_floor$39.$$arity = -1);
        Opal.def(self119, '$gcd', $Number_gcd$40 = function $$gcd(other) {
            var self = this;
            if ($truthy($$($nesting22, 'Integer')['$==='](other))) {} else {
                self.$raise($$($nesting22, 'TypeError'), "not an integer");
            }
            var min27 = Math.abs(self), max = Math.abs(other);
            while(min27 > 0){
                var tmp = min27;
                min27 = max % min27;
                max = tmp;
            }
            return max;
        }, $Number_gcd$40.$$arity = 1);
        Opal.def(self119, '$gcdlcm', $Number_gcdlcm$41 = function $$gcdlcm(other) {
            var self = this;
            return [
                self.$gcd(other),
                self.$lcm(other)
            ];
        }, $Number_gcdlcm$41.$$arity = 1);
        Opal.def(self119, '$integer?', $Number_integer$ques$42 = function() {
            var self = this;
            return self % 1 === 0;
        }, $Number_integer$ques$42.$$arity = 0);
        Opal.def(self119, '$is_a?', $Number_is_a$ques$43 = function(klass) {
            var $iter = $Number_is_a$ques$43.$$p, self = this, $ret_or_6 = nil, $ret_or_7 = nil, $ret_or_8 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
            if ($iter) $Number_is_a$ques$43.$$p = null;
            for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                $zuper[$zuper_i] = arguments[$zuper_i];
            }
            if ($truthy(function() {
                if ($truthy($ret_or_6 = klass['$==']($$($nesting22, 'Integer')))) {
                    return $$($nesting22, 'Integer')['$==='](self);
                } else {
                    return $ret_or_6;
                }
                return nil;
            }())) {
                return true;
            }
            if ($truthy(function() {
                if ($truthy($ret_or_7 = klass['$==']($$($nesting22, 'Integer')))) {
                    return $$($nesting22, 'Integer')['$==='](self);
                } else {
                    return $ret_or_7;
                }
                return nil;
            }())) {
                return true;
            }
            if ($truthy(function() {
                if ($truthy($ret_or_8 = klass['$==']($$($nesting22, 'Float')))) {
                    return $$($nesting22, 'Float')['$==='](self);
                } else {
                    return $ret_or_8;
                }
                return nil;
            }())) {
                return true;
            }
            return $send2(self, Opal.find_super_dispatcher(self, 'is_a?', $Number_is_a$ques$43, false, true), 'is_a?', $zuper, $iter);
        }, $Number_is_a$ques$43.$$arity = 1);
        Opal.alias(self119, "kind_of?", "is_a?");
        Opal.def(self119, '$instance_of?', $Number_instance_of$ques$44 = function(klass) {
            var $iter = $Number_instance_of$ques$44.$$p, self = this, $ret_or_9 = nil, $ret_or_10 = nil, $ret_or_11 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
            if ($iter) $Number_instance_of$ques$44.$$p = null;
            for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                $zuper[$zuper_i] = arguments[$zuper_i];
            }
            if ($truthy(function() {
                if ($truthy($ret_or_9 = klass['$==']($$($nesting22, 'Integer')))) {
                    return $$($nesting22, 'Integer')['$==='](self);
                } else {
                    return $ret_or_9;
                }
                return nil;
            }())) {
                return true;
            }
            if ($truthy(function() {
                if ($truthy($ret_or_10 = klass['$==']($$($nesting22, 'Integer')))) {
                    return $$($nesting22, 'Integer')['$==='](self);
                } else {
                    return $ret_or_10;
                }
                return nil;
            }())) {
                return true;
            }
            if ($truthy(function() {
                if ($truthy($ret_or_11 = klass['$==']($$($nesting22, 'Float')))) {
                    return $$($nesting22, 'Float')['$==='](self);
                } else {
                    return $ret_or_11;
                }
                return nil;
            }())) {
                return true;
            }
            return $send2(self, Opal.find_super_dispatcher(self, 'instance_of?', $Number_instance_of$ques$44, false, true), 'instance_of?', $zuper, $iter);
        }, $Number_instance_of$ques$44.$$arity = 1);
        Opal.def(self119, '$lcm', $Number_lcm$45 = function $$lcm(other) {
            var self = this;
            if ($truthy($$($nesting22, 'Integer')['$==='](other))) {} else {
                self.$raise($$($nesting22, 'TypeError'), "not an integer");
            }
            if (self == 0 || other == 0) {
                return 0;
            } else {
                return Math.abs(self * other / self.$gcd(other));
            }
        }, $Number_lcm$45.$$arity = 1);
        Opal.alias(self119, "magnitude", "abs");
        Opal.alias(self119, "modulo", "%");
        Opal.def(self119, '$next', $Number_next$46 = function $$next() {
            var self = this;
            return self + 1;
        }, $Number_next$46.$$arity = 0);
        Opal.def(self119, '$nobits?', $Number_nobits$ques$47 = function(mask) {
            var self = this;
            mask = $$($nesting22, 'Opal')['$coerce_to!'](mask, $$($nesting22, 'Integer'), "to_int");
            return (self & mask) == 0;
        }, $Number_nobits$ques$47.$$arity = 1);
        Opal.def(self119, '$nonzero?', $Number_nonzero$ques$48 = function() {
            var self = this;
            return self == 0 ? nil : self;
        }, $Number_nonzero$ques$48.$$arity = 0);
        Opal.def(self119, '$numerator', $Number_numerator$49 = function $$numerator() {
            var $iter = $Number_numerator$49.$$p, self = this, $ret_or_12 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
            if ($iter) $Number_numerator$49.$$p = null;
            for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                $zuper[$zuper_i] = arguments[$zuper_i];
            }
            if ($truthy(function() {
                if ($truthy($ret_or_12 = self['$nan?']())) {
                    return $ret_or_12;
                } else {
                    return self['$infinite?']();
                }
                return nil;
            }())) {
                return self;
            } else {
                return $send2(self, Opal.find_super_dispatcher(self, 'numerator', $Number_numerator$49, false, true), 'numerator', $zuper, $iter);
            }
        }, $Number_numerator$49.$$arity = 0);
        Opal.def(self119, '$odd?', $Number_odd$ques$50 = function() {
            var self = this;
            return self % 2 !== 0;
        }, $Number_odd$ques$50.$$arity = 0);
        Opal.def(self119, '$ord', $Number_ord$51 = function $$ord() {
            var self = this;
            return self;
        }, $Number_ord$51.$$arity = 0);
        Opal.def(self119, '$pow', $Number_pow$52 = function $$pow(b, m) {
            var self = this;
            if (self == 0) {
                self.$raise($$($nesting22, 'ZeroDivisionError'), "divided by 0");
            }
            if (m === undefined) {
                return self['$**'](b);
            } else {
                if (!$$($nesting22, 'Integer')['$==='](b)) {
                    self.$raise($$($nesting22, 'TypeError'), "Integer#pow() 2nd argument not allowed unless a 1st argument is integer");
                }
                if (b < 0) {
                    self.$raise($$($nesting22, 'TypeError'), "Integer#pow() 1st argument cannot be negative when 2nd argument specified");
                }
                if (!$$($nesting22, 'Integer')['$==='](m)) {
                    self.$raise($$($nesting22, 'TypeError'), "Integer#pow() 2nd argument not allowed unless all arguments are integers");
                }
                if (m === 0) {
                    self.$raise($$($nesting22, 'ZeroDivisionError'), "divided by 0");
                }
                return self['$**'](b)['$%'](m);
            }
        }, $Number_pow$52.$$arity = -2);
        Opal.def(self119, '$pred', $Number_pred$53 = function $$pred() {
            var self = this;
            return self - 1;
        }, $Number_pred$53.$$arity = 0);
        Opal.def(self119, '$quo', $Number_quo$54 = function $$quo(other) {
            var $iter = $Number_quo$54.$$p, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
            if ($iter) $Number_quo$54.$$p = null;
            for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                $zuper[$zuper_i] = arguments[$zuper_i];
            }
            if ($truthy($$($nesting22, 'Integer')['$==='](self))) {
                return $send2(self, Opal.find_super_dispatcher(self, 'quo', $Number_quo$54, false, true), 'quo', $zuper, $iter);
            } else {
                return $rb_divide(self, other);
            }
        }, $Number_quo$54.$$arity = 1);
        Opal.def(self119, '$rationalize', $Number_rationalize$55 = function $$rationalize(eps) {
            var $a, $b, self = this, f = nil, n = nil;
            if (arguments.length > 1) {
                self.$raise($$($nesting22, 'ArgumentError'), "" + "wrong number of arguments (" + arguments.length + " for 0..1)");
            }
            if ($truthy($$($nesting22, 'Integer')['$==='](self))) {
                return $$($nesting22, 'Rational').$new(self, 1);
            } else if ($truthy(self['$infinite?']())) {
                return self.$raise($$($nesting22, 'FloatDomainError'), "Infinity");
            } else if ($truthy(self['$nan?']())) {
                return self.$raise($$($nesting22, 'FloatDomainError'), "NaN");
            } else if ($truthy(eps == null)) {
                $b = $$($nesting22, 'Math').$frexp(self), $a = Opal.to_ary($b), f = $a[0] == null ? nil : $a[0], n = $a[1] == null ? nil : $a[1], $b;
                f = $$($nesting22, 'Math').$ldexp(f, $$$($$($nesting22, 'Float'), 'MANT_DIG')).$to_i();
                n = $rb_minus(n, $$$($$($nesting22, 'Float'), 'MANT_DIG'));
                return $$($nesting22, 'Rational').$new($rb_times(2, f), 1['$<<']($rb_minus(1, n))).$rationalize($$($nesting22, 'Rational').$new(1, 1['$<<']($rb_minus(1, n))));
            } else {
                return self.$to_r().$rationalize(eps);
            }
        }, $Number_rationalize$55.$$arity = -1);
        Opal.def(self119, '$remainder', $Number_remainder$56 = function $$remainder(y) {
            var self = this;
            return $rb_minus(self, $rb_times(y, $rb_divide(self, y).$truncate()));
        }, $Number_remainder$56.$$arity = 1);
        Opal.def(self119, '$round', $Number_round$57 = function $$round(ndigits) {
            var $a, $b, self = this, $ret_or_13 = nil, $ret_or_14 = nil, $ret_or_15 = nil, _ = nil, exp = nil;
            if ($truthy($$($nesting22, 'Integer')['$==='](self))) {
                if ($truthy(ndigits == null)) {
                    return self;
                }
                if ($truthy(function() {
                    if ($truthy($ret_or_13 = $$($nesting22, 'Float')['$==='](ndigits))) {
                        return ndigits['$infinite?']();
                    } else {
                        return $ret_or_13;
                    }
                    return nil;
                }())) {
                    self.$raise($$($nesting22, 'RangeError'), "Infinity");
                }
                ndigits = $$($nesting22, 'Opal')['$coerce_to!'](ndigits, $$($nesting22, 'Integer'), "to_int");
                if ($truthy($rb_lt(ndigits, $$$($$($nesting22, 'Integer'), 'MIN')))) {
                    self.$raise($$($nesting22, 'RangeError'), "out of bounds");
                }
                if ($truthy(ndigits >= 0)) {
                    return self;
                }
                ndigits = ndigits['$-@']();
                if (0.415241 * ndigits - 0.125 > self.$size()) {
                    return 0;
                }
                var f = Math.pow(10, ndigits), x = Math.floor((Math.abs(self) + f / 2) / f) * f;
                return self < 0 ? -x : x;
            } else {
                if ($truthy(function() {
                    if ($truthy($ret_or_14 = self['$nan?']())) {
                        return ndigits == null;
                    } else {
                        return $ret_or_14;
                    }
                    return nil;
                }())) {
                    self.$raise($$($nesting22, 'FloatDomainError'), "NaN");
                }
                ndigits = $$($nesting22, 'Opal')['$coerce_to!'](ndigits || 0, $$($nesting22, 'Integer'), "to_int");
                if ($truthy($rb_le(ndigits, 0))) {
                    if ($truthy(self['$nan?']())) {
                        self.$raise($$($nesting22, 'RangeError'), "NaN");
                    } else if ($truthy(self['$infinite?']())) {
                        self.$raise($$($nesting22, 'FloatDomainError'), "Infinity");
                    }
                } else if (ndigits['$=='](0)) {
                    return Math.round(self);
                } else if ($truthy(function() {
                    if ($truthy($ret_or_15 = self['$nan?']())) {
                        return $ret_or_15;
                    } else {
                        return self['$infinite?']();
                    }
                    return nil;
                }())) {
                    return self;
                }
                $b = $$($nesting22, 'Math').$frexp(self), $a = Opal.to_ary($b), _ = $a[0] == null ? nil : $a[0], exp = $a[1] == null ? nil : $a[1], $b;
                if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus($$$($$($nesting22, 'Float'), 'DIG'), 2), function() {
                    if ($truthy($rb_gt(exp, 0))) {
                        return $rb_divide(exp, 4);
                    } else {
                        return $rb_minus($rb_divide(exp, 3), 1);
                    }
                    return nil;
                }())))) {
                    return self;
                }
                if ($truthy($rb_lt(ndigits, (function() {
                    if ($truthy($rb_gt(exp, 0))) {
                        return $rb_plus($rb_divide(exp, 3), 1);
                    } else {
                        return $rb_divide(exp, 4);
                    }
                    return nil;
                })()['$-@']()))) {
                    return 0;
                }
                return Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits);
            }
        }, $Number_round$57.$$arity = -1);
        Opal.alias(self119, "succ", "next");
        Opal.def(self119, '$times', $Number_times$58 = function $$times() {
            var $iter = $Number_times$58.$$p, block = $iter || nil, $$59, self122 = this;
            if ($iter) $Number_times$58.$$p = null;
            if ($iter) $Number_times$58.$$p = null;
            if ($truthy(block)) {} else {
                return $send(self122, 'enum_for', [
                    "times"
                ], ($$59 = function() {
                    var self = $$59.$$s == null ? this : $$59.$$s;
                    return self;
                }, $$59.$$s = self122, $$59.$$arity = 0, $$59));
            }
            for(var i281 = 0; i281 < self122; i281++){
                block(i281);
            }
            return self122;
        }, $Number_times$58.$$arity = 0);
        Opal.def(self119, '$to_f', $Number_to_f$60 = function $$to_f() {
            var self = this;
            return self;
        }, $Number_to_f$60.$$arity = 0);
        Opal.def(self119, '$to_i', $Number_to_i$61 = function $$to_i() {
            var self = this;
            return self < 0 ? Math.ceil(self) : Math.floor(self);
        }, $Number_to_i$61.$$arity = 0);
        Opal.alias(self119, "to_int", "to_i");
        Opal.def(self119, '$to_r', $Number_to_r$62 = function $$to_r() {
            var $a, $b, self = this, f = nil, e = nil;
            if ($truthy($$($nesting22, 'Integer')['$==='](self))) {
                return $$($nesting22, 'Rational').$new(self, 1);
            } else {
                $b = $$($nesting22, 'Math').$frexp(self), $a = Opal.to_ary($b), f = $a[0] == null ? nil : $a[0], e = $a[1] == null ? nil : $a[1], $b;
                f = $$($nesting22, 'Math').$ldexp(f, $$$($$($nesting22, 'Float'), 'MANT_DIG')).$to_i();
                e = $rb_minus(e, $$$($$($nesting22, 'Float'), 'MANT_DIG'));
                return $rb_times(f, $$$($$($nesting22, 'Float'), 'RADIX')['$**'](e)).$to_r();
            }
        }, $Number_to_r$62.$$arity = 0);
        Opal.def(self119, '$to_s', $Number_to_s$63 = function $$to_s(base12) {
            var self = this, $ret_or_16 = nil;
            if (base12 == null) {
                base12 = 10;
            }
            base12 = $$($nesting22, 'Opal')['$coerce_to!'](base12, $$($nesting22, 'Integer'), "to_int");
            if ($truthy(function() {
                if ($truthy($ret_or_16 = $rb_lt(base12, 2))) {
                    return $ret_or_16;
                } else {
                    return $rb_gt(base12, 36);
                }
                return nil;
            }())) {
                self.$raise($$($nesting22, 'ArgumentError'), "" + "invalid radix " + base12);
            }
            return self.toString(base12);
        }, $Number_to_s$63.$$arity = -1);
        Opal.def(self119, '$truncate', $Number_truncate$64 = function $$truncate(ndigits) {
            var self = this;
            if (ndigits == null) {
                ndigits = 0;
            }
            var f = self.$to_f();
            if (f % 1 === 0 && ndigits >= 0) {
                return f;
            }
            var factor = Math.pow(10, ndigits), result = parseInt(f * factor, 10) / factor;
            if (f % 1 === 0) {
                result = Math.round(result);
            }
            return result;
        }, $Number_truncate$64.$$arity = -1);
        Opal.alias(self119, "inspect", "to_s");
        Opal.def(self119, '$digits', $Number_digits$65 = function $$digits(base13) {
            var self = this;
            if (base13 == null) {
                base13 = 10;
            }
            if ($rb_lt(self, 0)) {
                self.$raise($$$($$($nesting22, 'Math'), 'DomainError'), "out of domain");
            }
            base13 = $$($nesting22, 'Opal')['$coerce_to!'](base13, $$($nesting22, 'Integer'), "to_int");
            if ($truthy($rb_lt(base13, 2))) {
                self.$raise($$($nesting22, 'ArgumentError'), "" + "invalid radix " + base13);
            }
            var value = self, result = [];
            while(value !== 0){
                result.push(value % base13);
                value = parseInt(value / base13, 10);
            }
            return result;
        }, $Number_digits$65.$$arity = -1);
        Opal.def(self119, '$divmod', $Number_divmod$66 = function $$divmod(other) {
            var $iter = $Number_divmod$66.$$p, self = this, $ret_or_17 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
            if ($iter) $Number_divmod$66.$$p = null;
            for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                $zuper[$zuper_i] = arguments[$zuper_i];
            }
            if ($truthy(function() {
                if ($truthy($ret_or_17 = self['$nan?']())) {
                    return $ret_or_17;
                } else {
                    return other['$nan?']();
                }
                return nil;
            }())) {
                return self.$raise($$($nesting22, 'FloatDomainError'), "NaN");
            } else if ($truthy(self['$infinite?']())) {
                return self.$raise($$($nesting22, 'FloatDomainError'), "Infinity");
            } else {
                return $send2(self, Opal.find_super_dispatcher(self, 'divmod', $Number_divmod$66, false, true), 'divmod', $zuper, $iter);
            }
        }, $Number_divmod$66.$$arity = 1);
        Opal.def(self119, '$upto', $Number_upto$67 = function $$upto(stop) {
            var $iter = $Number_upto$67.$$p, block = $iter || nil, $$68, self123 = this;
            if ($iter) $Number_upto$67.$$p = null;
            if ($iter) $Number_upto$67.$$p = null;
            if (block !== nil) {} else {
                return $send(self123, 'enum_for', [
                    "upto",
                    stop
                ], ($$68 = function() {
                    var self = $$68.$$s == null ? this : $$68.$$s;
                    if ($truthy($$($nesting22, 'Numeric')['$==='](stop))) {} else {
                        self.$raise($$($nesting22, 'ArgumentError'), "" + "comparison of " + self.$class() + " with " + stop.$class() + " failed");
                    }
                    if ($truthy($rb_lt(stop, self))) {
                        return 0;
                    } else {
                        return $rb_plus($rb_minus(stop, self), 1);
                    }
                }, $$68.$$s = self123, $$68.$$arity = 0, $$68));
            }
            if (!stop.$$is_number) {
                self123.$raise($$($nesting22, 'ArgumentError'), "" + "comparison of " + self123.$class() + " with " + stop.$class() + " failed");
            }
            for(var i282 = self123; i282 <= stop; i282++){
                block(i282);
            }
            return self123;
        }, $Number_upto$67.$$arity = 1);
        Opal.def(self119, '$zero?', $Number_zero$ques$69 = function() {
            var self = this;
            return self == 0;
        }, $Number_zero$ques$69.$$arity = 0);
        Opal.def(self119, '$size', $Number_size$70 = function $$size() {
            return 4;
        }, $Number_size$70.$$arity = 0);
        Opal.def(self119, '$nan?', $Number_nan$ques$71 = function() {
            var self = this;
            return isNaN(self);
        }, $Number_nan$ques$71.$$arity = 0);
        Opal.def(self119, '$finite?', $Number_finite$ques$72 = function() {
            var self = this;
            return self != Infinity && self != -Infinity && !isNaN(self);
        }, $Number_finite$ques$72.$$arity = 0);
        Opal.def(self119, '$infinite?', $Number_infinite$ques$73 = function() {
            var self = this;
            if (self == Infinity) {
                return +1;
            } else if (self == -Infinity) {
                return -1;
            } else {
                return nil;
            }
        }, $Number_infinite$ques$73.$$arity = 0);
        Opal.def(self119, '$positive?', $Number_positive$ques$74 = function() {
            var self = this;
            return self != 0 && (self == Infinity || 1 / self > 0);
        }, $Number_positive$ques$74.$$arity = 0);
        return (Opal.def(self119, '$negative?', $Number_negative$ques$75 = function() {
            var self = this;
            return self == -Infinity || 1 / self < 0;
        }, $Number_negative$ques$75.$$arity = 0), nil) && 'negative?';
    })($nesting21[0], $$($nesting21, 'Numeric'), $nesting21);
    Opal.const_set($nesting21[0], 'Fixnum', $$($nesting21, 'Number'));
    (function($base, $super, $parent_nesting10) {
        var self124 = $klass($base, $super, 'Integer');
        var $nesting23 = [
            self124
        ].concat($parent_nesting10);
        self124.$$is_number_class = true;
        self124.$$is_integer_class = true;
        (function(self125, $parent_nesting) {
            var $nesting = [
                self125
            ].concat($parent_nesting), $allocate$76, $sqrt$77;
            Opal.def(self125, '$allocate', $allocate$76 = function $$allocate() {
                var self = this;
                return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + self.$name());
            }, $allocate$76.$$arity = 0);
            Opal.udef(self125, '$' + "new");
            return (Opal.def(self125, '$sqrt', $sqrt$77 = function $$sqrt(n) {
                var self = this;
                n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
                if (n < 0) {
                    self.$raise($$$($$($nesting, 'Math'), 'DomainError'), "Numerical argument is out of domain - \"isqrt\"");
                }
                return parseInt(Math.sqrt(n), 10);
            }, $sqrt$77.$$arity = 1), nil) && 'sqrt';
        })(Opal.get_singleton_class(self124), $nesting23);
        Opal.const_set($nesting23[0], 'MAX', Math.pow(2, 30) - 1);
        return Opal.const_set($nesting23[0], 'MIN', -Math.pow(2, 30));
    })($nesting21[0], $$($nesting21, 'Numeric'), $nesting21);
    return function($base, $super, $parent_nesting11) {
        var self126 = $klass($base, $super, 'Float');
        var $nesting24 = [
            self126
        ].concat($parent_nesting11);
        self126.$$is_number_class = true;
        (function(self127, $parent_nesting) {
            var $nesting = [
                self127
            ].concat($parent_nesting), $allocate$78, $eq_eq_eq$79;
            Opal.def(self127, '$allocate', $allocate$78 = function $$allocate() {
                var self = this;
                return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + self.$name());
            }, $allocate$78.$$arity = 0);
            Opal.udef(self127, '$' + "new");
            return (Opal.def(self127, '$===', $eq_eq_eq$79 = function(other) {
                return !!other.$$is_number;
            }, $eq_eq_eq$79.$$arity = 1), nil) && '===';
        })(Opal.get_singleton_class(self126), $nesting24);
        Opal.const_set($nesting24[0], 'INFINITY', Infinity);
        Opal.const_set($nesting24[0], 'MAX', Number.MAX_VALUE);
        Opal.const_set($nesting24[0], 'MIN', Number.MIN_VALUE);
        Opal.const_set($nesting24[0], 'NAN', NaN);
        Opal.const_set($nesting24[0], 'DIG', 15);
        Opal.const_set($nesting24[0], 'MANT_DIG', 53);
        Opal.const_set($nesting24[0], 'RADIX', 2);
        return Opal.const_set($nesting24[0], 'EPSILON', Number.EPSILON || 2.2204460492503130808472633361816E-16);
    }($nesting21[0], $$($nesting21, 'Numeric'), $nesting21);
};
Opal.modules["corelib/range"] = function(Opal) {
    function $rb_lt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs < rhs : lhs['$<'](rhs);
    }
    function $rb_le(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs <= rhs : lhs['$<='](rhs);
    }
    function $rb_gt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs > rhs : lhs['$>'](rhs);
    }
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    function $rb_divide(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs / rhs : lhs['$/'](rhs);
    }
    function $rb_plus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
    }
    function $rb_times(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs * rhs : lhs['$*'](rhs);
    }
    function $rb_ge(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs >= rhs : lhs['$>='](rhs);
    }
    var self128 = Opal.top, $nesting25 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $send2 = Opal.send2, $send = Opal.send;
    Opal.add_stubs([
        '$require',
        '$include',
        '$attr_reader',
        '$raise',
        '$<=>',
        '$nil?',
        '$include?',
        '$!',
        '$<',
        '$<=',
        '$enum_for',
        '$size',
        '$upto',
        '$to_proc',
        '$respond_to?',
        '$class',
        '$succ',
        '$==',
        '$===',
        '$exclude_end?',
        '$eql?',
        '$begin',
        '$end',
        '$last',
        '$to_a',
        '$>',
        '$-@',
        '$-',
        '$to_i',
        '$coerce_to!',
        '$ceil',
        '$/',
        '$loop',
        '$+',
        '$*',
        '$>=',
        '$each_with_index',
        '$%',
        '$bsearch',
        '$inspect',
        '$[]',
        '$hash'
    ]);
    self128.$require("corelib/enumerable");
    return function($base, $super, $parent_nesting) {
        var self129 = $klass($base, $super, 'Range');
        var $nesting = [
            self129
        ].concat($parent_nesting), $Range_initialize$1, $Range_$eq_eq_eq$2, $Range_count$3, $Range_to_a$4, $Range_cover$ques$5, $Range_each$6, $Range_eql$ques$8, $Range_exclude_end$ques$9, $Range_first$10, $Range_last$11, $Range_max$12, $Range_min$13, $Range_size$14, $Range_step$15, $Range_bsearch$19, $Range_to_s$20, $Range_inspect$21, $Range_marshal_load$22, $Range_hash$23;
        self129.$$prototype.begin = self129.$$prototype.end = self129.$$prototype.excl = nil;
        self129.$include($$($nesting, 'Enumerable'));
        self129.$$prototype.$$is_range = true;
        self129.$attr_reader("begin", "end");
        Opal.def(self129, '$initialize', $Range_initialize$1 = function $$initialize(first, last, exclude) {
            var self = this, $ret_or_1 = nil, $ret_or_2 = nil;
            if (exclude == null) {
                exclude = false;
            }
            if ($truthy(self.begin)) {
                self.$raise($$($nesting, 'NameError'), "'initialize' called twice");
            }
            if ($truthy(function() {
                if ($truthy($ret_or_1 = function() {
                    if ($truthy($ret_or_2 = first['$<=>'](last))) {
                        return $ret_or_2;
                    } else {
                        return first['$nil?']();
                    }
                    return nil;
                }())) {
                    return $ret_or_1;
                } else {
                    return last['$nil?']();
                }
                return nil;
            }())) {} else {
                self.$raise($$($nesting, 'ArgumentError'), "bad value for range");
            }
            self.begin = first;
            self.end = last;
            return self.excl = exclude;
        }, $Range_initialize$1.$$arity = -3);
        Opal.def(self129, '$===', $Range_$eq_eq_eq$2 = function(value) {
            var self = this;
            return self['$include?'](value);
        }, $Range_$eq_eq_eq$2.$$arity = 1);
        function is_infinite(self) {
            if (self.begin === nil || self.end === nil || self.begin === -Infinity || self.end === Infinity || self.begin === Infinity || self.end === -Infinity) return true;
            return false;
        }
        Opal.def(self129, '$count', $Range_count$3 = function $$count() {
            var $iter = $Range_count$3.$$p, block = $iter || nil, self = this, $ret_or_3 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
            if ($iter) $Range_count$3.$$p = null;
            for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                $zuper[$zuper_i] = arguments[$zuper_i];
            }
            if ($iter) $Range_count$3.$$p = null;
            if ($truthy(function() {
                if ($truthy($ret_or_3 = (block !== nil)['$!']())) {
                    return is_infinite(self);
                } else {
                    return $ret_or_3;
                }
                return nil;
            }())) {
                return $$$($$($nesting, 'Float'), 'INFINITY');
            }
            return $send2(self, Opal.find_super_dispatcher(self, 'count', $Range_count$3, false, true), 'count', $zuper, $iter);
        }, $Range_count$3.$$arity = 0);
        Opal.def(self129, '$to_a', $Range_to_a$4 = function $$to_a() {
            var $iter = $Range_to_a$4.$$p, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
            if ($iter) $Range_to_a$4.$$p = null;
            for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                $zuper[$zuper_i] = arguments[$zuper_i];
            }
            if ($truthy(is_infinite(self))) {
                self.$raise($$($nesting, 'TypeError'), "cannot convert endless range to an array");
            }
            return $send2(self, Opal.find_super_dispatcher(self, 'to_a', $Range_to_a$4, false, true), 'to_a', $zuper, $iter);
        }, $Range_to_a$4.$$arity = 0);
        Opal.def(self129, '$cover?', $Range_cover$ques$5 = function(value) {
            var self = this, beg_cmp = nil, $ret_or_4 = nil, $ret_or_5 = nil, $ret_or_6 = nil, end_cmp = nil, $ret_or_7 = nil, $ret_or_8 = nil, $ret_or_9 = nil, $ret_or_10 = nil, $ret_or_11 = nil, $ret_or_12 = nil, $ret_or_13 = nil;
            beg_cmp = function() {
                if ($truthy($ret_or_4 = function() {
                    if ($truthy($ret_or_5 = function() {
                        if ($truthy($ret_or_6 = self.begin['$nil?']())) {
                            return -1;
                        } else {
                            return $ret_or_6;
                        }
                        return nil;
                    }())) {
                        return $ret_or_5;
                    } else {
                        return self.begin['$<=>'](value);
                    }
                    return nil;
                }())) {
                    return $ret_or_4;
                } else {
                    return false;
                }
                return nil;
            }();
            end_cmp = function() {
                if ($truthy($ret_or_7 = function() {
                    if ($truthy($ret_or_8 = function() {
                        if ($truthy($ret_or_9 = self.end['$nil?']())) {
                            return -1;
                        } else {
                            return $ret_or_9;
                        }
                        return nil;
                    }())) {
                        return $ret_or_8;
                    } else {
                        return value['$<=>'](self.end);
                    }
                    return nil;
                }())) {
                    return $ret_or_7;
                } else {
                    return false;
                }
                return nil;
            }();
            if ($truthy($ret_or_10 = function() {
                if ($truthy($ret_or_11 = function() {
                    if ($truthy(self.excl)) {
                        if ($truthy($ret_or_12 = end_cmp)) {
                            return $rb_lt(end_cmp, 0);
                        } else {
                            return $ret_or_12;
                        }
                    } else if ($truthy($ret_or_13 = end_cmp)) {
                        return $rb_le(end_cmp, 0);
                    } else {
                        return $ret_or_13;
                    }
                    return nil;
                }())) {
                    return beg_cmp;
                } else {
                    return $ret_or_11;
                }
                return nil;
            }())) {
                return $rb_le(beg_cmp, 0);
            } else {
                return $ret_or_10;
            }
        }, $Range_cover$ques$5.$$arity = 1);
        Opal.def(self129, '$each', $Range_each$6 = function $$each() {
            var $iter = $Range_each$6.$$p, block = $iter || nil, $$7, self130 = this, current = nil, last = nil, $ret_or_14 = nil, $ret_or_15 = nil;
            if ($iter) $Range_each$6.$$p = null;
            if ($iter) $Range_each$6.$$p = null;
            if (block !== nil) {} else {
                return $send(self130, 'enum_for', [
                    "each"
                ], ($$7 = function() {
                    var self = $$7.$$s == null ? this : $$7.$$s;
                    return self.$size();
                }, $$7.$$s = self130, $$7.$$arity = 0, $$7));
            }
            var i283, limit;
            if (self130.begin.$$is_number && self130.end.$$is_number) {
                if (self130.begin % 1 !== 0 || self130.end % 1 !== 0) {
                    self130.$raise($$($nesting, 'TypeError'), "can't iterate from Float");
                }
                for(i283 = self130.begin, limit = self130.end + function() {
                    if ($truthy(self130.excl)) {
                        return 0;
                    } else {
                        return 1;
                    }
                    return nil;
                }(); i283 < limit; i283++){
                    block(i283);
                }
                return self130;
            }
            if (self130.begin.$$is_string && self130.end.$$is_string) {
                $send(self130.begin, 'upto', [
                    self130.end,
                    self130.excl
                ], block.$to_proc());
                return self130;
            }
            current = self130.begin;
            last = self130.end;
            if ($truthy(current['$respond_to?']("succ"))) {} else {
                self130.$raise($$($nesting, 'TypeError'), "" + "can't iterate from " + current.$class());
            }
            while($truthy(function() {
                if ($truthy($ret_or_14 = self130.end['$nil?']())) {
                    return $ret_or_14;
                } else {
                    return $rb_lt(current['$<=>'](last), 0);
                }
                return nil;
            }())){
                Opal.yield1(block, current);
                current = current.$succ();
            }
            if ($truthy(function() {
                if ($truthy($ret_or_15 = self130.excl['$!']())) {
                    return current['$=='](last);
                } else {
                    return $ret_or_15;
                }
                return nil;
            }())) {
                Opal.yield1(block, current);
            }
            return self130;
        }, $Range_each$6.$$arity = 0);
        Opal.def(self129, '$eql?', $Range_eql$ques$8 = function(other) {
            var self = this, $ret_or_16 = nil, $ret_or_17 = nil;
            if ($truthy($$($nesting, 'Range')['$==='](other))) {} else {
                return false;
            }
            if ($truthy($ret_or_16 = function() {
                if ($truthy($ret_or_17 = self.excl['$==='](other['$exclude_end?']()))) {
                    return self.begin['$eql?'](other.$begin());
                } else {
                    return $ret_or_17;
                }
                return nil;
            }())) {
                return self.end['$eql?'](other.$end());
            } else {
                return $ret_or_16;
            }
        }, $Range_eql$ques$8.$$arity = 1);
        Opal.alias(self129, "==", "eql?");
        Opal.def(self129, '$exclude_end?', $Range_exclude_end$ques$9 = function() {
            var self = this;
            return self.excl;
        }, $Range_exclude_end$ques$9.$$arity = 0);
        Opal.def(self129, '$first', $Range_first$10 = function $$first(n) {
            var $iter = $Range_first$10.$$p, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
            if ($iter) $Range_first$10.$$p = null;
            for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                $zuper[$zuper_i] = arguments[$zuper_i];
            }
            if ($truthy(self.begin['$nil?']())) {
                self.$raise($$($nesting, 'RangeError'), "cannot get the minimum of beginless range");
            }
            if ($truthy(n == null)) {
                return self.begin;
            }
            return $send2(self, Opal.find_super_dispatcher(self, 'first', $Range_first$10, false, true), 'first', $zuper, $iter);
        }, $Range_first$10.$$arity = -1);
        Opal.alias(self129, "include?", "cover?");
        Opal.def(self129, '$last', $Range_last$11 = function $$last(n) {
            var self = this;
            if ($truthy(self.end['$nil?']())) {
                self.$raise($$($nesting, 'RangeError'), "cannot get the maximum of endless range");
            }
            if ($truthy(n == null)) {
                return self.end;
            }
            return self.$to_a().$last(n);
        }, $Range_last$11.$$arity = -1);
        Opal.def(self129, '$max', $Range_max$12 = function $$max() {
            var $iter = $Range_max$12.$$p, $yield = $iter || nil, self = this, $ret_or_18 = nil, $ret_or_19 = nil, $ret_or_20 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
            if ($iter) $Range_max$12.$$p = null;
            for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                $zuper[$zuper_i] = arguments[$zuper_i];
            }
            if ($truthy(self.end['$nil?']())) {
                return self.$raise($$($nesting, 'RangeError'), "cannot get the maximum of endless range");
            } else if ($yield !== nil) {
                return $send2(self, Opal.find_super_dispatcher(self, 'max', $Range_max$12, false, true), 'max', $zuper, $iter);
            } else if ($truthy(function() {
                if ($truthy($ret_or_18 = self.begin['$nil?']()['$!']())) {
                    if ($truthy($ret_or_19 = $rb_gt(self.begin, self.end))) {
                        return $ret_or_19;
                    } else if ($truthy($ret_or_20 = self.excl)) {
                        return self.begin['$=='](self.end);
                    } else {
                        return $ret_or_20;
                    }
                } else {
                    return $ret_or_18;
                }
                return nil;
            }())) {
                return nil;
            } else {
                return self.excl ? self.end - 1 : self.end;
            }
        }, $Range_max$12.$$arity = 0);
        Opal.alias(self129, "member?", "cover?");
        Opal.def(self129, '$min', $Range_min$13 = function $$min() {
            var $iter = $Range_min$13.$$p, $yield = $iter || nil, self = this, $ret_or_21 = nil, $ret_or_22 = nil, $ret_or_23 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
            if ($iter) $Range_min$13.$$p = null;
            for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                $zuper[$zuper_i] = arguments[$zuper_i];
            }
            if ($truthy(self.begin['$nil?']())) {
                return self.$raise($$($nesting, 'RangeError'), "cannot get the minimum of beginless range");
            } else if ($yield !== nil) {
                return $send2(self, Opal.find_super_dispatcher(self, 'min', $Range_min$13, false, true), 'min', $zuper, $iter);
            } else if ($truthy(function() {
                if ($truthy($ret_or_21 = self.end['$nil?']()['$!']())) {
                    if ($truthy($ret_or_22 = $rb_gt(self.begin, self.end))) {
                        return $ret_or_22;
                    } else if ($truthy($ret_or_23 = self.excl)) {
                        return self.begin['$=='](self.end);
                    } else {
                        return $ret_or_23;
                    }
                } else {
                    return $ret_or_21;
                }
                return nil;
            }())) {
                return nil;
            } else {
                return self.begin;
            }
        }, $Range_min$13.$$arity = 0);
        Opal.def(self129, '$size', $Range_size$14 = function $$size() {
            var self = this, infinity = nil, $ret_or_24 = nil, $ret_or_25 = nil, $ret_or_26 = nil, $ret_or_27 = nil, range_begin = nil, range_end = nil;
            infinity = $$$($$($nesting, 'Float'), 'INFINITY');
            if ($truthy(function() {
                if ($truthy($ret_or_24 = function() {
                    if ($truthy($ret_or_25 = self.begin['$=='](infinity))) {
                        return self.end['$nil?']()['$!']();
                    } else {
                        return $ret_or_25;
                    }
                    return nil;
                }())) {
                    return $ret_or_24;
                } else {
                    if ($truthy($ret_or_26 = self.end['$=='](infinity['$-@']()))) {
                        return self.begin['$nil?']()['$!']();
                    } else {
                        return $ret_or_26;
                    }
                }
                return nil;
            }())) {
                return 0;
            }
            if ($truthy(is_infinite(self))) {
                return infinity;
            }
            if ($truthy(function() {
                if ($truthy($ret_or_27 = $$($nesting, 'Numeric')['$==='](self.begin))) {
                    return $$($nesting, 'Numeric')['$==='](self.end);
                } else {
                    return $ret_or_27;
                }
                return nil;
            }())) {} else {
                return nil;
            }
            range_begin = self.begin;
            range_end = self.end;
            if ($truthy(self.excl)) {
                range_end = $rb_minus(range_end, 1);
            }
            if ($truthy($rb_lt(range_end, range_begin))) {
                return 0;
            }
            return (Math.abs(range_end - range_begin) + 1).$to_i();
        }, $Range_size$14.$$arity = 0);
        Opal.def(self129, '$step', $Range_step$15 = function $$step(n) {
            var $$16, $$17, $$18, $iter = $Range_step$15.$$p, $yield = $iter || nil, self131 = this, i284 = nil;
            if ($iter) $Range_step$15.$$p = null;
            if (n == null) {
                n = 1;
            }
            function coerceStepSize() {
                if (!n.$$is_number) {
                    n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
                }
                if (n < 0) {
                    self131.$raise($$($nesting, 'ArgumentError'), "step can't be negative");
                } else if (n === 0) {
                    self131.$raise($$($nesting, 'ArgumentError'), "step can't be 0");
                }
            }
            function enumeratorSize() {
                if (!self131.begin['$respond_to?']("succ")) {
                    return nil;
                }
                if (self131.begin.$$is_string && self131.end.$$is_string) {
                    return nil;
                }
                if (n % 1 === 0) {
                    return $rb_divide(self131.$size(), n).$ceil();
                } else {
                    var begin = self131.begin, end = self131.end, abs = Math.abs, floor = Math.floor, err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * $$$($$($nesting, 'Float'), 'EPSILON'), size;
                    if (err > 0.5) {
                        err = 0.5;
                    }
                    if (self131.excl) {
                        size = floor((end - begin) / n - err);
                        if (size * n + begin < end) {
                            size++;
                        }
                    } else {
                        size = floor((end - begin) / n + err) + 1;
                    }
                    return size;
                }
            }
            if ($yield !== nil) {} else {
                return $send(self131, 'enum_for', [
                    "step",
                    n
                ], ($$16 = function() {
                    $$16.$$s == null ? this : $$16.$$s;
                    coerceStepSize();
                    return enumeratorSize();
                }, $$16.$$s = self131, $$16.$$arity = 0, $$16));
            }
            coerceStepSize();
            if ($truthy(self131.begin.$$is_number && self131.end.$$is_number)) {
                i284 = 0;
                (function() {
                    var $brk = Opal.new_brk();
                    try {
                        return $send(self131, 'loop', [], ($$17 = function() {
                            var self = $$17.$$s == null ? this : $$17.$$s, current = nil;
                            if (self.begin == null) self.begin = nil;
                            if (self.excl == null) self.excl = nil;
                            if (self.end == null) self.end = nil;
                            current = $rb_plus(self.begin, $rb_times(i284, n));
                            if ($truthy(self.excl)) {
                                if ($truthy($rb_ge(current, self.end))) {
                                    Opal.brk(nil, $brk);
                                }
                            } else if ($truthy($rb_gt(current, self.end))) {
                                Opal.brk(nil, $brk);
                            }
                            Opal.yield1($yield, current);
                            return i284 = $rb_plus(i284, 1);
                        }, $$17.$$s = self131, $$17.$$brk = $brk, $$17.$$arity = 0, $$17));
                    } catch (err) {
                        if (err === $brk) {
                            return err.$v;
                        } else {
                            throw err;
                        }
                    }
                })();
            } else {
                if (self131.begin.$$is_string && self131.end.$$is_string && n % 1 !== 0) {
                    self131.$raise($$($nesting, 'TypeError'), "no implicit conversion to float from string");
                }
                $send(self131, 'each_with_index', [], ($$18 = function(value, idx) {
                    $$18.$$s == null ? this : $$18.$$s;
                    if (value == null) {
                        value = nil;
                    }
                    if (idx == null) {
                        idx = nil;
                    }
                    if (idx['$%'](n)['$=='](0)) {
                        return Opal.yield1($yield, value);
                    } else {
                        return nil;
                    }
                }, $$18.$$s = self131, $$18.$$arity = 2, $$18));
            }
            return self131;
        }, $Range_step$15.$$arity = -1);
        Opal.def(self129, '$bsearch', $Range_bsearch$19 = function $$bsearch() {
            var $iter = $Range_bsearch$19.$$p, block = $iter || nil, self = this;
            if ($iter) $Range_bsearch$19.$$p = null;
            if ($iter) $Range_bsearch$19.$$p = null;
            if (block !== nil) {} else {
                return self.$enum_for("bsearch");
            }
            if ($truthy(is_infinite(self) && (self.begin.$$is_number || self.end.$$is_number))) {
                self.$raise($$($nesting, 'NotImplementedError'), "Can't #bsearch an infinite range");
            }
            if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {} else {
                self.$raise($$($nesting, 'TypeError'), "" + "can't do binary search for " + self.begin.$class());
            }
            return $send(self.$to_a(), 'bsearch', [], block.$to_proc());
        }, $Range_bsearch$19.$$arity = 0);
        Opal.def(self129, '$to_s', $Range_to_s$20 = function $$to_s() {
            var self = this, $ret_or_28 = nil, $ret_or_29 = nil;
            return "" + function() {
                if ($truthy($ret_or_28 = self.begin)) {
                    return $ret_or_28;
                } else {
                    return "";
                }
                return nil;
            }() + function() {
                if ($truthy(self.excl)) {
                    return "...";
                } else {
                    return "..";
                }
                return nil;
            }() + function() {
                if ($truthy($ret_or_29 = self.end)) {
                    return $ret_or_29;
                } else {
                    return "";
                }
                return nil;
            }();
        }, $Range_to_s$20.$$arity = 0);
        Opal.def(self129, '$inspect', $Range_inspect$21 = function $$inspect() {
            var self = this, $ret_or_30 = nil, $ret_or_31 = nil;
            return "" + function() {
                if ($truthy($ret_or_30 = self.begin)) {
                    return self.begin.$inspect();
                } else {
                    return $ret_or_30;
                }
                return nil;
            }() + function() {
                if ($truthy(self.excl)) {
                    return "...";
                } else {
                    return "..";
                }
                return nil;
            }() + function() {
                if ($truthy($ret_or_31 = self.end)) {
                    return self.end.$inspect();
                } else {
                    return $ret_or_31;
                }
                return nil;
            }();
        }, $Range_inspect$21.$$arity = 0);
        Opal.def(self129, '$marshal_load', $Range_marshal_load$22 = function $$marshal_load(args69) {
            var self = this;
            self.begin = args69['$[]']("begin");
            self.end = args69['$[]']("end");
            return self.excl = args69['$[]']("excl");
        }, $Range_marshal_load$22.$$arity = 1);
        return (Opal.def(self129, '$hash', $Range_hash$23 = function $$hash() {
            var self = this;
            return [
                self.begin,
                self.end,
                self.excl
            ].$hash();
        }, $Range_hash$23.$$arity = 0), nil) && 'hash';
    }($nesting25[0], null, $nesting25);
};
Opal.modules["corelib/proc"] = function(Opal) {
    var self132 = Opal.top, $nesting26 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;
    Opal.add_stubs([
        '$raise',
        '$proc',
        '$call',
        '$to_proc',
        '$coerce_to!'
    ]);
    return function($base, $super, $parent_nesting) {
        var self133 = $klass($base, $super, 'Proc');
        var $nesting = [
            self133
        ].concat($parent_nesting), $Proc_new$1, $Proc_call$2, $Proc_$gt$gt$3, $Proc_$lt$lt$5, $Proc_to_proc$7, $Proc_lambda$ques$8, $Proc_arity$9, $Proc_source_location$10, $Proc_binding$11, $Proc_parameters$12, $Proc_curry$13, $Proc_dup$14;
        Opal.defineProperty(self133.$$prototype, '$$is_proc', true);
        Opal.defineProperty(self133.$$prototype, '$$is_lambda', false);
        Opal.defs(self133, '$new', $Proc_new$1 = function() {
            var $iter = $Proc_new$1.$$p, block = $iter || nil, self = this;
            if ($iter) $Proc_new$1.$$p = null;
            if ($iter) $Proc_new$1.$$p = null;
            if ($truthy(block)) {} else {
                self.$raise($$($nesting, 'ArgumentError'), "tried to create a Proc object without a block");
            }
            return block;
        }, $Proc_new$1.$$arity = 0);
        Opal.def(self133, '$call', $Proc_call$2 = function $$call($a) {
            var $iter = $Proc_call$2.$$p, block = $iter || nil, $post_args, args70, self = this;
            if ($iter) $Proc_call$2.$$p = null;
            if ($iter) $Proc_call$2.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args70 = $post_args;
            if (block !== nil) {
                self.$$p = block;
            }
            var result, $brk = self.$$brk;
            if ($brk) {
                try {
                    if (self.$$is_lambda) {
                        result = self.apply(null, args70);
                    } else {
                        result = Opal.yieldX(self, args70);
                    }
                } catch (err) {
                    if (err === $brk) {
                        return $brk.$v;
                    } else {
                        throw err;
                    }
                }
            } else {
                if (self.$$is_lambda) {
                    result = self.apply(null, args70);
                } else {
                    result = Opal.yieldX(self, args70);
                }
            }
            return result;
        }, $Proc_call$2.$$arity = -1);
        Opal.alias(self133, "[]", "call");
        Opal.alias(self133, "===", "call");
        Opal.alias(self133, "yield", "call");
        Opal.def(self133, '$>>', $Proc_$gt$gt$3 = function(other) {
            var $$4, $iter2 = $Proc_$gt$gt$3.$$p, self134 = this;
            if ($iter2) $Proc_$gt$gt$3.$$p = null;
            return $send(self134, 'proc', [], ($$4 = function($a) {
                var self = $$4.$$s == null ? this : $$4.$$s, $iter = $$4.$$p, block = $iter || nil, $post_args, args71, out = nil;
                if ($iter) $$4.$$p = null;
                $post_args = Opal.slice.call(arguments, 0, arguments.length);
                args71 = $post_args;
                out = $send(self, 'call', Opal.to_a(args71), block.$to_proc());
                return other.$call(out);
            }, $$4.$$s = self134, $$4.$$arity = -1, $$4));
        }, $Proc_$gt$gt$3.$$arity = 1);
        Opal.def(self133, '$<<', $Proc_$lt$lt$5 = function(other) {
            var $$6, $iter3 = $Proc_$lt$lt$5.$$p, self135 = this;
            if ($iter3) $Proc_$lt$lt$5.$$p = null;
            return $send(self135, 'proc', [], ($$6 = function($a) {
                var self = $$6.$$s == null ? this : $$6.$$s, $iter = $$6.$$p, block = $iter || nil, $post_args, args72, out = nil;
                if ($iter) $$6.$$p = null;
                $post_args = Opal.slice.call(arguments, 0, arguments.length);
                args72 = $post_args;
                out = $send(other, 'call', Opal.to_a(args72), block.$to_proc());
                return self.$call(out);
            }, $$6.$$s = self135, $$6.$$arity = -1, $$6));
        }, $Proc_$lt$lt$5.$$arity = 1);
        Opal.def(self133, '$to_proc', $Proc_to_proc$7 = function $$to_proc() {
            var self = this;
            return self;
        }, $Proc_to_proc$7.$$arity = 0);
        Opal.def(self133, '$lambda?', $Proc_lambda$ques$8 = function() {
            var self = this;
            return !!self.$$is_lambda;
        }, $Proc_lambda$ques$8.$$arity = 0);
        Opal.def(self133, '$arity', $Proc_arity$9 = function $$arity() {
            var self = this;
            if (self.$$is_curried) {
                return -1;
            } else {
                return self.$$arity;
            }
        }, $Proc_arity$9.$$arity = 0);
        Opal.def(self133, '$source_location', $Proc_source_location$10 = function $$source_location() {
            var self = this;
            if (self.$$is_curried) {
                return nil;
            }
            return nil;
        }, $Proc_source_location$10.$$arity = 0);
        Opal.def(self133, '$binding', $Proc_binding$11 = function $$binding() {
            var self = this;
            if (self.$$is_curried) {
                self.$raise($$($nesting, 'ArgumentError'), "Can't create Binding");
            }
            return nil;
        }, $Proc_binding$11.$$arity = 0);
        Opal.def(self133, '$parameters', $Proc_parameters$12 = function $$parameters() {
            var self = this;
            if (self.$$is_curried) {
                return [
                    [
                        "rest"
                    ]
                ];
            } else if (self.$$parameters) {
                if (self.$$is_lambda) {
                    return self.$$parameters;
                } else {
                    var result = [], i285, length;
                    for(i285 = 0, length = self.$$parameters.length; i285 < length; i285++){
                        var parameter = self.$$parameters[i285];
                        if (parameter[0] === 'req') {
                            parameter = [
                                'opt',
                                parameter[1]
                            ];
                        }
                        result.push(parameter);
                    }
                    return result;
                }
            } else {
                return [];
            }
        }, $Proc_parameters$12.$$arity = 0);
        Opal.def(self133, '$curry', $Proc_curry$13 = function $$curry(arity) {
            var self = this;
            if (arity === undefined) {
                arity = self.length;
            } else {
                arity = $$($nesting, 'Opal')['$coerce_to!'](arity, $$($nesting, 'Integer'), "to_int");
                if (self.$$is_lambda && arity !== self.length) {
                    self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + arity + " for " + self.length + ")");
                }
            }
            function curried() {
                var args73 = $slice.call(arguments), length = args73.length, result;
                if (length > arity && self.$$is_lambda && !self.$$is_curried) {
                    self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + length + " for " + arity + ")");
                }
                if (length >= arity) {
                    return self.$call.apply(self, args73);
                }
                result = function() {
                    return curried.apply(null, args73.concat($slice.call(arguments)));
                };
                result.$$is_lambda = self.$$is_lambda;
                result.$$is_curried = true;
                return result;
            }
            curried.$$is_lambda = self.$$is_lambda;
            curried.$$is_curried = true;
            return curried;
        }, $Proc_curry$13.$$arity = -1);
        Opal.def(self133, '$dup', $Proc_dup$14 = function $$dup() {
            var self = this;
            var original_proc = self.$$original_proc || self, proc = function() {
                return original_proc.apply(this, arguments);
            };
            for(var prop in self){
                if (self.hasOwnProperty(prop)) {
                    proc[prop] = self[prop];
                }
            }
            return proc;
        }, $Proc_dup$14.$$arity = 0);
        return Opal.alias(self133, "clone", "dup");
    }($nesting26[0], Function, $nesting26);
};
Opal.modules["corelib/method"] = function(Opal) {
    var self136 = Opal.top, $nesting27 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy;
    Opal.add_stubs([
        '$attr_reader',
        '$arity',
        '$>>',
        '$<<',
        '$new',
        '$class',
        '$join',
        '$source_location',
        '$raise'
    ]);
    (function($base, $super, $parent_nesting) {
        var self137 = $klass($base, $super, 'Method');
        var $nesting = [
            self137
        ].concat($parent_nesting), $Method_initialize$1, $Method_arity$2, $Method_parameters$3, $Method_source_location$4, $Method_comments$5, $Method_call$6, $Method_$gt$gt$7, $Method_$lt$lt$8, $Method_unbind$9, $Method_to_proc$10, $Method_inspect$11;
        self137.$$prototype.method = self137.$$prototype.receiver = self137.$$prototype.owner = self137.$$prototype.name = nil;
        self137.$attr_reader("owner", "receiver", "name");
        Opal.def(self137, '$initialize', $Method_initialize$1 = function $$initialize(receiver, owner, method, name113) {
            var self = this;
            self.receiver = receiver;
            self.owner = owner;
            self.name = name113;
            return self.method = method;
        }, $Method_initialize$1.$$arity = 4);
        Opal.def(self137, '$arity', $Method_arity$2 = function $$arity() {
            var self = this;
            return self.method.$arity();
        }, $Method_arity$2.$$arity = 0);
        Opal.def(self137, '$parameters', $Method_parameters$3 = function $$parameters() {
            var self = this;
            return self.method.$$parameters;
        }, $Method_parameters$3.$$arity = 0);
        Opal.def(self137, '$source_location', $Method_source_location$4 = function $$source_location() {
            var self = this, $ret_or_1 = nil;
            if ($truthy($ret_or_1 = self.method.$$source_location)) {
                return $ret_or_1;
            } else {
                return [
                    "(eval)",
                    0
                ];
            }
        }, $Method_source_location$4.$$arity = 0);
        Opal.def(self137, '$comments', $Method_comments$5 = function $$comments() {
            var self = this, $ret_or_2 = nil;
            if ($truthy($ret_or_2 = self.method.$$comments)) {
                return $ret_or_2;
            } else {
                return [];
            }
        }, $Method_comments$5.$$arity = 0);
        Opal.def(self137, '$call', $Method_call$6 = function $$call($a) {
            var $iter = $Method_call$6.$$p, block = $iter || nil, $post_args, args74, self = this;
            if ($iter) $Method_call$6.$$p = null;
            if ($iter) $Method_call$6.$$p = null;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args74 = $post_args;
            self.method.$$p = block;
            return self.method.apply(self.receiver, args74);
        }, $Method_call$6.$$arity = -1);
        Opal.alias(self137, "[]", "call");
        Opal.def(self137, '$>>', $Method_$gt$gt$7 = function(other) {
            var self = this;
            return self.method['$>>'](other);
        }, $Method_$gt$gt$7.$$arity = 1);
        Opal.def(self137, '$<<', $Method_$lt$lt$8 = function(other) {
            var self = this;
            return self.method['$<<'](other);
        }, $Method_$lt$lt$8.$$arity = 1);
        Opal.def(self137, '$unbind', $Method_unbind$9 = function $$unbind() {
            var self = this;
            return $$($nesting, 'UnboundMethod').$new(self.receiver.$class(), self.owner, self.method, self.name);
        }, $Method_unbind$9.$$arity = 0);
        Opal.def(self137, '$to_proc', $Method_to_proc$10 = function $$to_proc() {
            var self = this;
            var proc = self.$call.bind(self);
            proc.$$unbound = self.method;
            proc.$$is_lambda = true;
            proc.$$arity = self.method.$$arity;
            proc.$$parameters = self.method.$$parameters;
            return proc;
        }, $Method_to_proc$10.$$arity = 0);
        return (Opal.def(self137, '$inspect', $Method_inspect$11 = function $$inspect() {
            var self = this;
            return "" + "#<" + self.$class() + ": " + self.receiver.$class() + "#" + self.name + " (defined in " + self.owner + " in " + self.$source_location().$join(":") + ")>";
        }, $Method_inspect$11.$$arity = 0), nil) && 'inspect';
    })($nesting27[0], null, $nesting27);
    return function($base, $super, $parent_nesting) {
        var self138 = $klass($base, $super, 'UnboundMethod');
        var $nesting = [
            self138
        ].concat($parent_nesting), $UnboundMethod_initialize$12, $UnboundMethod_arity$13, $UnboundMethod_parameters$14, $UnboundMethod_source_location$15, $UnboundMethod_comments$16, $UnboundMethod_bind$17, $UnboundMethod_inspect$18;
        self138.$$prototype.method = self138.$$prototype.owner = self138.$$prototype.name = self138.$$prototype.source = nil;
        self138.$attr_reader("source", "owner", "name");
        Opal.def(self138, '$initialize', $UnboundMethod_initialize$12 = function $$initialize(source, owner, method, name114) {
            var self = this;
            self.source = source;
            self.owner = owner;
            self.method = method;
            return self.name = name114;
        }, $UnboundMethod_initialize$12.$$arity = 4);
        Opal.def(self138, '$arity', $UnboundMethod_arity$13 = function $$arity() {
            var self = this;
            return self.method.$arity();
        }, $UnboundMethod_arity$13.$$arity = 0);
        Opal.def(self138, '$parameters', $UnboundMethod_parameters$14 = function $$parameters() {
            var self = this;
            return self.method.$$parameters;
        }, $UnboundMethod_parameters$14.$$arity = 0);
        Opal.def(self138, '$source_location', $UnboundMethod_source_location$15 = function $$source_location() {
            var self = this, $ret_or_3 = nil;
            if ($truthy($ret_or_3 = self.method.$$source_location)) {
                return $ret_or_3;
            } else {
                return [
                    "(eval)",
                    0
                ];
            }
        }, $UnboundMethod_source_location$15.$$arity = 0);
        Opal.def(self138, '$comments', $UnboundMethod_comments$16 = function $$comments() {
            var self = this, $ret_or_4 = nil;
            if ($truthy($ret_or_4 = self.method.$$comments)) {
                return $ret_or_4;
            } else {
                return [];
            }
        }, $UnboundMethod_comments$16.$$arity = 0);
        Opal.def(self138, '$bind', $UnboundMethod_bind$17 = function $$bind(object) {
            var self = this;
            if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {
                return $$($nesting, 'Method').$new(object, self.owner, self.method, self.name);
            } else {
                self.$raise($$($nesting, 'TypeError'), "" + "can't bind singleton method to a different class (expected " + object + ".kind_of?(" + self.owner + " to be true)");
            }
        }, $UnboundMethod_bind$17.$$arity = 1);
        return (Opal.def(self138, '$inspect', $UnboundMethod_inspect$18 = function $$inspect() {
            var self = this;
            return "" + "#<" + self.$class() + ": " + self.source + "#" + self.name + " (defined in " + self.owner + " in " + self.$source_location().$join(":") + ")>";
        }, $UnboundMethod_inspect$18.$$arity = 0), nil) && 'inspect';
    }($nesting27[0], null, $nesting27);
};
Opal.modules["corelib/variables"] = function(Opal) {
    var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $gvars = Opal.gvars, $hash2 = Opal.hash2;
    Opal.add_stubs([
        '$new'
    ]);
    $gvars['&'] = $gvars['~'] = $gvars['`'] = $gvars["'"] = nil;
    $gvars.LOADED_FEATURES = $gvars["\""] = Opal.loaded_features;
    $gvars.LOAD_PATH = $gvars[":"] = [];
    $gvars["/"] = "\n";
    $gvars[","] = nil;
    Opal.const_set($nesting[0], 'ARGV', []);
    Opal.const_set($nesting[0], 'ARGF', $$($nesting, 'Object').$new());
    Opal.const_set($nesting[0], 'ENV', $hash2([], {}));
    $gvars.VERBOSE = false;
    $gvars.DEBUG = false;
    return $gvars.SAFE = 0;
};
Opal.modules["corelib/io"] = function(Opal) {
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    var self139 = Opal.top, $nesting28 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $module = Opal.module, $gvars = Opal.gvars, $send = Opal.send, $writer = nil;
    Opal.add_stubs([
        '$attr_accessor',
        '$size',
        '$write',
        '$String',
        '$chomp',
        '$getbyte',
        '$getc',
        '$raise',
        '$new',
        '$write_proc=',
        '$-',
        '$extend'
    ]);
    (function($base6, $super, $parent_nesting12) {
        var self140 = $klass($base6, $super, 'IO');
        var $nesting29 = [
            self140
        ].concat($parent_nesting12), $IO_tty$ques$1, $IO_closed$ques$2, $IO_write$3, $IO_flush$4;
        self140.$$prototype.tty = self140.$$prototype.closed = nil;
        Opal.const_set($nesting29[0], 'SEEK_SET', 0);
        Opal.const_set($nesting29[0], 'SEEK_CUR', 1);
        Opal.const_set($nesting29[0], 'SEEK_END', 2);
        Opal.def(self140, '$tty?', $IO_tty$ques$1 = function() {
            var self = this;
            return self.tty;
        }, $IO_tty$ques$1.$$arity = 0);
        Opal.def(self140, '$closed?', $IO_closed$ques$2 = function() {
            var self = this;
            return self.closed;
        }, $IO_closed$ques$2.$$arity = 0);
        self140.$attr_accessor("write_proc");
        Opal.def(self140, '$write', $IO_write$3 = function $$write(string) {
            var self = this;
            self.write_proc(string);
            return string.$size();
        }, $IO_write$3.$$arity = 1);
        self140.$attr_accessor("sync", "tty");
        Opal.def(self140, '$flush', $IO_flush$4 = function $$flush() {
            return nil;
        }, $IO_flush$4.$$arity = 0);
        (function($base, $parent_nesting) {
            var self141 = $module($base, 'Writable');
            var $nesting = [
                self141
            ].concat($parent_nesting), $Writable_$lt$lt$5, $Writable_print$6, $Writable_puts$7;
            Opal.def(self141, '$<<', $Writable_$lt$lt$5 = function(string) {
                var self = this;
                self.$write(string);
                return self;
            }, $Writable_$lt$lt$5.$$arity = 1);
            Opal.def(self141, '$print', $Writable_print$6 = function $$print($a) {
                var $post_args, args75, self = this;
                if ($gvars[","] == null) $gvars[","] = nil;
                $post_args = Opal.slice.call(arguments, 0, arguments.length);
                args75 = $post_args;
                for(var i286 = 0, ii = args75.length; i286 < ii; i286++){
                    args75[i286] = self.$String(args75[i286]);
                }
                self.$write(args75.join($gvars[","]));
                return nil;
            }, $Writable_print$6.$$arity = -1);
            return (Opal.def(self141, '$puts', $Writable_puts$7 = function $$puts($a) {
                var $post_args, args76, self = this;
                if ($gvars["/"] == null) $gvars["/"] = nil;
                $post_args = Opal.slice.call(arguments, 0, arguments.length);
                args76 = $post_args;
                for(var i287 = 0, ii = args76.length; i287 < ii; i287++){
                    args76[i287] = self.$String(args76[i287]).$chomp();
                }
                self.$write(args76.concat([
                    nil
                ]).join($gvars["/"]));
                return nil;
            }, $Writable_puts$7.$$arity = -1), nil) && 'puts';
        })($nesting29[0], $nesting29);
        return function($base, $parent_nesting) {
            var self142 = $module($base, 'Readable');
            var $nesting = [
                self142
            ].concat($parent_nesting), $Readable_readbyte$8, $Readable_readchar$9, $Readable_readline$10, $Readable_readpartial$11;
            Opal.def(self142, '$readbyte', $Readable_readbyte$8 = function $$readbyte() {
                var self = this;
                return self.$getbyte();
            }, $Readable_readbyte$8.$$arity = 0);
            Opal.def(self142, '$readchar', $Readable_readchar$9 = function $$readchar() {
                var self = this;
                return self.$getc();
            }, $Readable_readchar$9.$$arity = 0);
            Opal.def(self142, '$readline', $Readable_readline$10 = function $$readline(sep16) {
                var self = this;
                if ($gvars["/"] == null) $gvars["/"] = nil;
                if (sep16 == null) {
                    sep16 = $gvars["/"];
                }
                return self.$raise($$($nesting, 'NotImplementedError'));
            }, $Readable_readline$10.$$arity = -1);
            return (Opal.def(self142, '$readpartial', $Readable_readpartial$11 = function $$readpartial(integer, outbuf) {
                var self = this;
                if (outbuf == null) {
                    outbuf = nil;
                }
                return self.$raise($$($nesting, 'NotImplementedError'));
            }, $Readable_readpartial$11.$$arity = -2), nil) && 'readpartial';
        }($nesting29[0], $nesting29);
    })($nesting28[0], null, $nesting28);
    Opal.const_set($nesting28[0], 'STDERR', $gvars.stderr = $$($nesting28, 'IO').$new());
    Opal.const_set($nesting28[0], 'STDIN', $gvars.stdin = $$($nesting28, 'IO').$new());
    Opal.const_set($nesting28[0], 'STDOUT', $gvars.stdout = $$($nesting28, 'IO').$new());
    var console = Opal.global.console;
    $writer = [
        typeof process === 'object' && typeof process.stdout === 'object' ? function(s) {
            process.stdout.write(s);
        } : function(s) {
            console.log(s);
        }
    ];
    $send($$($nesting28, 'STDOUT'), 'write_proc=', Opal.to_a($writer));
    $writer[$rb_minus($writer["length"], 1)];
    $writer = [
        typeof process === 'object' && typeof process.stderr === 'object' ? function(s) {
            process.stderr.write(s);
        } : function(s) {
            console.warn(s);
        }
    ];
    $send($$($nesting28, 'STDERR'), 'write_proc=', Opal.to_a($writer));
    $writer[$rb_minus($writer["length"], 1)];
    $$($nesting28, 'STDOUT').$extend($$$($$($nesting28, 'IO'), 'Writable'));
    return $$($nesting28, 'STDERR').$extend($$$($$($nesting28, 'IO'), 'Writable'));
};
Opal.modules["opal/regexp_anchors"] = function(Opal) {
    var self143 = Opal.top, $nesting30 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module;
    Opal.add_stubs([
        '$new'
    ]);
    return function($base, $parent_nesting) {
        var self = $module($base, 'Opal');
        var $nesting = [
            self
        ].concat($parent_nesting);
        Opal.const_set($nesting[0], 'REGEXP_START', "^");
        Opal.const_set($nesting[0], 'REGEXP_END', "$");
        Opal.const_set($nesting[0], 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
        Opal.const_set($nesting[0], 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
        Opal.const_set($nesting[0], 'INLINE_IDENTIFIER_REGEXP', $$($nesting, 'Regexp').$new("" + "[^" + $$($nesting, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS') + "]*[^" + $$($nesting, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS') + "]"));
        Opal.const_set($nesting[0], 'FORBIDDEN_CONST_NAME_CHARS', "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
        return Opal.const_set($nesting[0], 'CONST_NAME_REGEXP', $$($nesting, 'Regexp').$new("" + $$($nesting, 'REGEXP_START') + "(::)?[A-Z][^" + $$($nesting, 'FORBIDDEN_CONST_NAME_CHARS') + "]*" + $$($nesting, 'REGEXP_END')));
    }($nesting30[0], $nesting30);
};
Opal.modules["opal/mini"] = function(Opal) {
    var self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;
    Opal.add_stubs([
        '$require'
    ]);
    self.$require("opal/base");
    self.$require("corelib/nil");
    self.$require("corelib/boolean");
    self.$require("corelib/string");
    self.$require("corelib/comparable");
    self.$require("corelib/enumerable");
    self.$require("corelib/enumerator");
    self.$require("corelib/array");
    self.$require("corelib/hash");
    self.$require("corelib/number");
    self.$require("corelib/range");
    self.$require("corelib/proc");
    self.$require("corelib/method");
    self.$require("corelib/regexp");
    self.$require("corelib/variables");
    self.$require("corelib/io");
    return self.$require("opal/regexp_anchors");
};
Opal.modules["corelib/kernel/format"] = function(Opal) {
    var self144 = Opal.top, $nesting31 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $coerce_to = Opal.coerce_to, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars;
    Opal.add_stubs([
        '$==',
        '$length',
        '$respond_to?',
        '$[]',
        '$coerce_to?',
        '$nil?',
        '$to_a',
        '$raise',
        '$to_int',
        '$fetch',
        '$Integer',
        '$Float',
        '$to_ary',
        '$to_str',
        '$inspect',
        '$to_s'
    ]);
    return function($base, $parent_nesting) {
        var self145 = $module($base, 'Kernel');
        var $nesting = [
            self145
        ].concat($parent_nesting), $Kernel_format$1;
        Opal.def(self145, '$format', $Kernel_format$1 = function $$format(format_string, $a) {
            var $post_args, args77, self = this, $ret_or_1 = nil, ary = nil;
            if ($gvars.DEBUG == null) $gvars.DEBUG = nil;
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            args77 = $post_args;
            if ($truthy(function() {
                if ($truthy($ret_or_1 = args77.$length()['$=='](1))) {
                    return args77['$[]'](0)['$respond_to?']("to_ary");
                } else {
                    return $ret_or_1;
                }
                return nil;
            }())) {
                ary = $$($nesting, 'Opal')['$coerce_to?'](args77['$[]'](0), $$($nesting, 'Array'), "to_ary");
                if ($truthy(ary['$nil?']())) {} else {
                    args77 = ary.$to_a();
                }
            }
            var result = '', begin_slice = 0, end_slice, i288, len = format_string.length, arg1, str1, exponent, width, precision, tmp_num, hash_parameter_key, closing_brace_char, base_number, base_prefix, base_neg_zero_regex, base_neg_zero_digit, next_arg, seq_arg_num = 1, pos_arg_num = 0, flags, FNONE = 0, FSHARP = 1, FMINUS = 2, FPLUS = 4, FZERO = 8, FSPACE = 16, FWIDTH = 32, FPREC = 64, FPREC0 = 128;
            function CHECK_FOR_FLAGS() {
                if (flags & FWIDTH) {
                    self.$raise($$($nesting, 'ArgumentError'), "flag after width");
                }
                if (flags & FPREC0) {
                    self.$raise($$($nesting, 'ArgumentError'), "flag after precision");
                }
            }
            function CHECK_FOR_WIDTH() {
                if (flags & FWIDTH) {
                    self.$raise($$($nesting, 'ArgumentError'), "width given twice");
                }
                if (flags & FPREC0) {
                    self.$raise($$($nesting, 'ArgumentError'), "width after precision");
                }
            }
            function GET_NTH_ARG(num) {
                if (num >= args77.length) {
                    self.$raise($$($nesting, 'ArgumentError'), "too few arguments");
                }
                return args77[num];
            }
            function GET_NEXT_ARG() {
                switch(pos_arg_num){
                    case -1:
                        self.$raise($$($nesting, 'ArgumentError'), "" + "unnumbered(" + seq_arg_num + ") mixed with numbered");
                    case -2:
                        self.$raise($$($nesting, 'ArgumentError'), "" + "unnumbered(" + seq_arg_num + ") mixed with named");
                }
                pos_arg_num = seq_arg_num++;
                return GET_NTH_ARG(pos_arg_num - 1);
            }
            function GET_POS_ARG(num) {
                if (pos_arg_num > 0) {
                    self.$raise($$($nesting, 'ArgumentError'), "" + "numbered(" + num + ") after unnumbered(" + pos_arg_num + ")");
                }
                if (pos_arg_num === -2) {
                    self.$raise($$($nesting, 'ArgumentError'), "" + "numbered(" + num + ") after named");
                }
                if (num < 1) {
                    self.$raise($$($nesting, 'ArgumentError'), "" + "invalid index - " + num + "$");
                }
                pos_arg_num = -1;
                return GET_NTH_ARG(num - 1);
            }
            function GET_ARG() {
                return next_arg === undefined ? GET_NEXT_ARG() : next_arg;
            }
            function READ_NUM(label) {
                var num, str = '';
                for(;; i288++){
                    if (i288 === len) {
                        self.$raise($$($nesting, 'ArgumentError'), "malformed format string - %*[0-9]");
                    }
                    if (format_string.charCodeAt(i288) < 48 || format_string.charCodeAt(i288) > 57) {
                        i288--;
                        num = parseInt(str, 10) || 0;
                        if (num > 2147483647) {
                            self.$raise($$($nesting, 'ArgumentError'), "" + label + " too big");
                        }
                        return num;
                    }
                    str += format_string.charAt(i288);
                }
            }
            function READ_NUM_AFTER_ASTER(label) {
                var arg, num = READ_NUM(label);
                if (format_string.charAt(i288 + 1) === '$') {
                    i288++;
                    arg = GET_POS_ARG(num);
                } else {
                    arg = GET_NEXT_ARG();
                }
                return arg.$to_int();
            }
            for(i288 = format_string.indexOf('%'); i288 !== -1; i288 = format_string.indexOf('%', i288)){
                str1 = undefined;
                flags = FNONE;
                width = -1;
                precision = -1;
                next_arg = undefined;
                end_slice = i288;
                i288++;
                switch(format_string.charAt(i288)){
                    case '%':
                        begin_slice = i288;
                    case '':
                    case '\n':
                    case '\0':
                        i288++;
                        continue;
                }
                format_sequence: for(; i288 < len; i288++){
                    switch(format_string.charAt(i288)){
                        case ' ':
                            CHECK_FOR_FLAGS();
                            flags |= FSPACE;
                            continue format_sequence;
                        case '#':
                            CHECK_FOR_FLAGS();
                            flags |= FSHARP;
                            continue format_sequence;
                        case '+':
                            CHECK_FOR_FLAGS();
                            flags |= FPLUS;
                            continue format_sequence;
                        case '-':
                            CHECK_FOR_FLAGS();
                            flags |= FMINUS;
                            continue format_sequence;
                        case '0':
                            CHECK_FOR_FLAGS();
                            flags |= FZERO;
                            continue format_sequence;
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                            tmp_num = READ_NUM('width');
                            if (format_string.charAt(i288 + 1) === '$') {
                                if (i288 + 2 === len) {
                                    str1 = '%';
                                    i288++;
                                    break format_sequence;
                                }
                                if (next_arg !== undefined) {
                                    self.$raise($$($nesting, 'ArgumentError'), "" + "value given twice - %" + tmp_num + "$");
                                }
                                next_arg = GET_POS_ARG(tmp_num);
                                i288++;
                            } else {
                                CHECK_FOR_WIDTH();
                                flags |= FWIDTH;
                                width = tmp_num;
                            }
                            continue format_sequence;
                        case '<':
                        case '\{':
                            closing_brace_char = format_string.charAt(i288) === '<' ? '>' : '\}';
                            hash_parameter_key = '';
                            i288++;
                            for(;; i288++){
                                if (i288 === len) {
                                    self.$raise($$($nesting, 'ArgumentError'), "malformed name - unmatched parenthesis");
                                }
                                if (format_string.charAt(i288) === closing_brace_char) {
                                    if (pos_arg_num > 0) {
                                        self.$raise($$($nesting, 'ArgumentError'), "" + "named " + hash_parameter_key + " after unnumbered(" + pos_arg_num + ")");
                                    }
                                    if (pos_arg_num === -1) {
                                        self.$raise($$($nesting, 'ArgumentError'), "" + "named " + hash_parameter_key + " after numbered");
                                    }
                                    pos_arg_num = -2;
                                    if (args77[0] === undefined || !args77[0].$$is_hash) {
                                        self.$raise($$($nesting, 'ArgumentError'), "one hash required");
                                    }
                                    next_arg = args77[0].$fetch(hash_parameter_key);
                                    if (closing_brace_char === '>') {
                                        continue format_sequence;
                                    } else {
                                        str1 = next_arg.toString();
                                        if (precision !== -1) {
                                            str1 = str1.slice(0, precision);
                                        }
                                        if (flags & FMINUS) {
                                            while(str1.length < width){
                                                str1 = str1 + ' ';
                                            }
                                        } else {
                                            while(str1.length < width){
                                                str1 = ' ' + str1;
                                            }
                                        }
                                        break format_sequence;
                                    }
                                }
                                hash_parameter_key += format_string.charAt(i288);
                            }
                        case '*':
                            i288++;
                            CHECK_FOR_WIDTH();
                            flags |= FWIDTH;
                            width = READ_NUM_AFTER_ASTER('width');
                            if (width < 0) {
                                flags |= FMINUS;
                                width = -width;
                            }
                            continue format_sequence;
                        case '.':
                            if (flags & FPREC0) {
                                self.$raise($$($nesting, 'ArgumentError'), "precision given twice");
                            }
                            flags |= FPREC | FPREC0;
                            precision = 0;
                            i288++;
                            if (format_string.charAt(i288) === '*') {
                                i288++;
                                precision = READ_NUM_AFTER_ASTER('precision');
                                if (precision < 0) {
                                    flags &= ~FPREC;
                                }
                                continue format_sequence;
                            }
                            precision = READ_NUM('precision');
                            continue format_sequence;
                        case 'd':
                        case 'i':
                        case 'u':
                            arg1 = self.$Integer(GET_ARG());
                            if (arg1 >= 0) {
                                str1 = arg1.toString();
                                while(str1.length < precision){
                                    str1 = '0' + str1;
                                }
                                if (flags & FMINUS) {
                                    if (flags & FPLUS || flags & FSPACE) {
                                        str1 = (flags & FPLUS ? '+' : ' ') + str1;
                                    }
                                    while(str1.length < width){
                                        str1 = str1 + ' ';
                                    }
                                } else {
                                    if (flags & FZERO && precision === -1) {
                                        while(str1.length < width - (flags & FPLUS || flags & FSPACE ? 1 : 0)){
                                            str1 = '0' + str1;
                                        }
                                        if (flags & FPLUS || flags & FSPACE) {
                                            str1 = (flags & FPLUS ? '+' : ' ') + str1;
                                        }
                                    } else {
                                        if (flags & FPLUS || flags & FSPACE) {
                                            str1 = (flags & FPLUS ? '+' : ' ') + str1;
                                        }
                                        while(str1.length < width){
                                            str1 = ' ' + str1;
                                        }
                                    }
                                }
                            } else {
                                str1 = (-arg1).toString();
                                while(str1.length < precision){
                                    str1 = '0' + str1;
                                }
                                if (flags & FMINUS) {
                                    str1 = '-' + str1;
                                    while(str1.length < width){
                                        str1 = str1 + ' ';
                                    }
                                } else {
                                    if (flags & FZERO && precision === -1) {
                                        while(str1.length < width - 1){
                                            str1 = '0' + str1;
                                        }
                                        str1 = '-' + str1;
                                    } else {
                                        str1 = '-' + str1;
                                        while(str1.length < width){
                                            str1 = ' ' + str1;
                                        }
                                    }
                                }
                            }
                            break format_sequence;
                        case 'b':
                        case 'B':
                        case 'o':
                        case 'x':
                        case 'X':
                            switch(format_string.charAt(i288)){
                                case 'b':
                                case 'B':
                                    base_number = 2;
                                    base_prefix = '0b';
                                    base_neg_zero_regex = /^1+/;
                                    base_neg_zero_digit = '1';
                                    break;
                                case 'o':
                                    base_number = 8;
                                    base_prefix = '0';
                                    base_neg_zero_regex = /^3?7+/;
                                    base_neg_zero_digit = '7';
                                    break;
                                case 'x':
                                case 'X':
                                    base_number = 16;
                                    base_prefix = '0x';
                                    base_neg_zero_regex = /^f+/;
                                    base_neg_zero_digit = 'f';
                                    break;
                            }
                            arg1 = self.$Integer(GET_ARG());
                            if (arg1 >= 0) {
                                str1 = arg1.toString(base_number);
                                while(str1.length < precision){
                                    str1 = '0' + str1;
                                }
                                if (flags & FMINUS) {
                                    if (flags & FPLUS || flags & FSPACE) {
                                        str1 = (flags & FPLUS ? '+' : ' ') + str1;
                                    }
                                    if (flags & FSHARP && arg1 !== 0) {
                                        str1 = base_prefix + str1;
                                    }
                                    while(str1.length < width){
                                        str1 = str1 + ' ';
                                    }
                                } else {
                                    if (flags & FZERO && precision === -1) {
                                        while(str1.length < width - (flags & FPLUS || flags & FSPACE ? 1 : 0) - (flags & FSHARP && arg1 !== 0 ? base_prefix.length : 0)){
                                            str1 = '0' + str1;
                                        }
                                        if (flags & FSHARP && arg1 !== 0) {
                                            str1 = base_prefix + str1;
                                        }
                                        if (flags & FPLUS || flags & FSPACE) {
                                            str1 = (flags & FPLUS ? '+' : ' ') + str1;
                                        }
                                    } else {
                                        if (flags & FSHARP && arg1 !== 0) {
                                            str1 = base_prefix + str1;
                                        }
                                        if (flags & FPLUS || flags & FSPACE) {
                                            str1 = (flags & FPLUS ? '+' : ' ') + str1;
                                        }
                                        while(str1.length < width){
                                            str1 = ' ' + str1;
                                        }
                                    }
                                }
                            } else {
                                if (flags & FPLUS || flags & FSPACE) {
                                    str1 = (-arg1).toString(base_number);
                                    while(str1.length < precision){
                                        str1 = '0' + str1;
                                    }
                                    if (flags & FMINUS) {
                                        if (flags & FSHARP) {
                                            str1 = base_prefix + str1;
                                        }
                                        str1 = '-' + str1;
                                        while(str1.length < width){
                                            str1 = str1 + ' ';
                                        }
                                    } else {
                                        if (flags & FZERO && precision === -1) {
                                            while(str1.length < width - 1 - (flags & FSHARP ? 2 : 0)){
                                                str1 = '0' + str1;
                                            }
                                            if (flags & FSHARP) {
                                                str1 = base_prefix + str1;
                                            }
                                            str1 = '-' + str1;
                                        } else {
                                            if (flags & FSHARP) {
                                                str1 = base_prefix + str1;
                                            }
                                            str1 = '-' + str1;
                                            while(str1.length < width){
                                                str1 = ' ' + str1;
                                            }
                                        }
                                    }
                                } else {
                                    str1 = (arg1 >>> 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);
                                    while(str1.length < precision - 2){
                                        str1 = base_neg_zero_digit + str1;
                                    }
                                    if (flags & FMINUS) {
                                        str1 = '..' + str1;
                                        if (flags & FSHARP) {
                                            str1 = base_prefix + str1;
                                        }
                                        while(str1.length < width){
                                            str1 = str1 + ' ';
                                        }
                                    } else {
                                        if (flags & FZERO && precision === -1) {
                                            while(str1.length < width - 2 - (flags & FSHARP ? base_prefix.length : 0)){
                                                str1 = base_neg_zero_digit + str1;
                                            }
                                            str1 = '..' + str1;
                                            if (flags & FSHARP) {
                                                str1 = base_prefix + str1;
                                            }
                                        } else {
                                            str1 = '..' + str1;
                                            if (flags & FSHARP) {
                                                str1 = base_prefix + str1;
                                            }
                                            while(str1.length < width){
                                                str1 = ' ' + str1;
                                            }
                                        }
                                    }
                                }
                            }
                            if (format_string.charAt(i288) === format_string.charAt(i288).toUpperCase()) {
                                str1 = str1.toUpperCase();
                            }
                            break format_sequence;
                        case 'f':
                        case 'e':
                        case 'E':
                        case 'g':
                        case 'G':
                            arg1 = self.$Float(GET_ARG());
                            if (arg1 >= 0 || isNaN(arg1)) {
                                if (arg1 === Infinity) {
                                    str1 = 'Inf';
                                } else {
                                    switch(format_string.charAt(i288)){
                                        case 'f':
                                            str1 = arg1.toFixed(precision === -1 ? 6 : precision);
                                            break;
                                        case 'e':
                                        case 'E':
                                            str1 = arg1.toExponential(precision === -1 ? 6 : precision);
                                            break;
                                        case 'g':
                                        case 'G':
                                            str1 = arg1.toExponential();
                                            exponent = parseInt(str1.split('e')[1], 10);
                                            if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                                                str1 = arg1.toPrecision(precision === -1 ? flags & FSHARP ? 6 : undefined : precision);
                                            }
                                            break;
                                    }
                                }
                                if (flags & FMINUS) {
                                    if (flags & FPLUS || flags & FSPACE) {
                                        str1 = (flags & FPLUS ? '+' : ' ') + str1;
                                    }
                                    while(str1.length < width){
                                        str1 = str1 + ' ';
                                    }
                                } else {
                                    if (flags & FZERO && arg1 !== Infinity && !isNaN(arg1)) {
                                        while(str1.length < width - (flags & FPLUS || flags & FSPACE ? 1 : 0)){
                                            str1 = '0' + str1;
                                        }
                                        if (flags & FPLUS || flags & FSPACE) {
                                            str1 = (flags & FPLUS ? '+' : ' ') + str1;
                                        }
                                    } else {
                                        if (flags & FPLUS || flags & FSPACE) {
                                            str1 = (flags & FPLUS ? '+' : ' ') + str1;
                                        }
                                        while(str1.length < width){
                                            str1 = ' ' + str1;
                                        }
                                    }
                                }
                            } else {
                                if (arg1 === -Infinity) {
                                    str1 = 'Inf';
                                } else {
                                    switch(format_string.charAt(i288)){
                                        case 'f':
                                            str1 = (-arg1).toFixed(precision === -1 ? 6 : precision);
                                            break;
                                        case 'e':
                                        case 'E':
                                            str1 = (-arg1).toExponential(precision === -1 ? 6 : precision);
                                            break;
                                        case 'g':
                                        case 'G':
                                            str1 = (-arg1).toExponential();
                                            exponent = parseInt(str1.split('e')[1], 10);
                                            if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                                                str1 = (-arg1).toPrecision(precision === -1 ? flags & FSHARP ? 6 : undefined : precision);
                                            }
                                            break;
                                    }
                                }
                                if (flags & FMINUS) {
                                    str1 = '-' + str1;
                                    while(str1.length < width){
                                        str1 = str1 + ' ';
                                    }
                                } else {
                                    if (flags & FZERO && arg1 !== -Infinity) {
                                        while(str1.length < width - 1){
                                            str1 = '0' + str1;
                                        }
                                        str1 = '-' + str1;
                                    } else {
                                        str1 = '-' + str1;
                                        while(str1.length < width){
                                            str1 = ' ' + str1;
                                        }
                                    }
                                }
                            }
                            if (format_string.charAt(i288) === format_string.charAt(i288).toUpperCase() && arg1 !== Infinity && arg1 !== -Infinity && !isNaN(arg1)) {
                                str1 = str1.toUpperCase();
                            }
                            str1 = str1.replace(/([eE][-+]?)([0-9])$/, '$10$2');
                            break format_sequence;
                        case 'a':
                        case 'A':
                            self.$raise($$($nesting, 'NotImplementedError'), "`A` and `a` format field types are not implemented in Opal yet");
                        case 'c':
                            arg1 = GET_ARG();
                            if (arg1['$respond_to?']("to_ary")) {
                                arg1 = arg1.$to_ary()[0];
                            }
                            if (arg1['$respond_to?']("to_str")) {
                                str1 = arg1.$to_str();
                            } else {
                                str1 = String.fromCharCode($coerce_to(arg1, $$($nesting, 'Integer'), 'to_int'));
                            }
                            if (str1.length !== 1) {
                                self.$raise($$($nesting, 'ArgumentError'), "%c requires a character");
                            }
                            if (flags & FMINUS) {
                                while(str1.length < width){
                                    str1 = str1 + ' ';
                                }
                            } else {
                                while(str1.length < width){
                                    str1 = ' ' + str1;
                                }
                            }
                            break format_sequence;
                        case 'p':
                            str1 = GET_ARG().$inspect();
                            if (precision !== -1) {
                                str1 = str1.slice(0, precision);
                            }
                            if (flags & FMINUS) {
                                while(str1.length < width){
                                    str1 = str1 + ' ';
                                }
                            } else {
                                while(str1.length < width){
                                    str1 = ' ' + str1;
                                }
                            }
                            break format_sequence;
                        case 's':
                            str1 = GET_ARG().$to_s();
                            if (precision !== -1) {
                                str1 = str1.slice(0, precision);
                            }
                            if (flags & FMINUS) {
                                while(str1.length < width){
                                    str1 = str1 + ' ';
                                }
                            } else {
                                while(str1.length < width){
                                    str1 = ' ' + str1;
                                }
                            }
                            break format_sequence;
                        default:
                            self.$raise($$($nesting, 'ArgumentError'), "" + "malformed format string - %" + format_string.charAt(i288));
                    }
                }
                if (str1 === undefined) {
                    self.$raise($$($nesting, 'ArgumentError'), "malformed format string - %");
                }
                result += format_string.slice(begin_slice, end_slice) + str1;
                begin_slice = i288 + 1;
            }
            if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args77.length) {
                self.$raise($$($nesting, 'ArgumentError'), "too many arguments for format string");
            }
            return result + format_string.slice(begin_slice);
        }, $Kernel_format$1.$$arity = -2);
        return Opal.alias(self145, "sprintf", "format");
    }($nesting31[0], $nesting31);
};
Opal.modules["corelib/string/encoding"] = function(Opal) {
    function $rb_plus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
    }
    function $rb_lt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs < rhs : lhs['$<'](rhs);
    }
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    var $$14, $$17, $$20, $$22, $$25, $$27, self146 = Opal.top, $nesting32 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $writer = nil;
    Opal.add_stubs([
        '$require',
        '$+',
        '$[]',
        '$clone',
        '$initialize',
        '$new',
        '$instance_eval',
        '$to_proc',
        '$each',
        '$const_set',
        '$tr',
        '$==',
        '$default_external',
        '$attr_accessor',
        '$singleton_class',
        '$attr_reader',
        '$raise',
        '$register',
        '$length',
        '$bytes',
        '$force_encoding',
        '$dup',
        '$bytesize',
        '$enum_for',
        '$each_byte',
        '$to_a',
        '$each_char',
        '$each_codepoint',
        '$coerce_to!',
        '$find',
        '$<',
        '$default_external=',
        '$-'
    ]);
    self146.$require("corelib/string");
    (function($base7, $super4, $parent_nesting13) {
        var self147 = $klass($base7, $super4, 'Encoding');
        var $nesting = [
            self147
        ].concat($parent_nesting13), $Encoding_register$1, $Encoding_find$3, $Encoding_initialize$4, $Encoding_ascii_compatible$ques$5, $Encoding_dummy$ques$6, $Encoding_binary$ques$7, $Encoding_to_s$8, $Encoding_inspect$9, $Encoding_charsize$10, $Encoding_each_char$11, $Encoding_each_byte$12, $Encoding_bytesize$13;
        self147.$$prototype.ascii = self147.$$prototype.dummy = self147.$$prototype.name = nil;
        Opal.defs(self147, '$register', $Encoding_register$1 = function $$register(name115, options) {
            var $iter = $Encoding_register$1.$$p, block = $iter || nil, $$2, self148 = this, names = nil, $ret_or_1 = nil, ascii = nil, $ret_or_2 = nil, dummy = nil, $ret_or_3 = nil, encoding = nil, register = nil;
            if ($iter) $Encoding_register$1.$$p = null;
            if ($iter) $Encoding_register$1.$$p = null;
            if (options == null) {
                options = $hash2([], {});
            }
            names = $rb_plus([
                name115
            ], function() {
                if ($truthy($ret_or_1 = options['$[]']("aliases"))) {
                    return $ret_or_1;
                } else {
                    return [];
                }
                return nil;
            }());
            ascii = function() {
                if ($truthy($ret_or_2 = options['$[]']("ascii"))) {
                    return $ret_or_2;
                } else {
                    return false;
                }
                return nil;
            }();
            dummy = function() {
                if ($truthy($ret_or_3 = options['$[]']("dummy"))) {
                    return $ret_or_3;
                } else {
                    return false;
                }
                return nil;
            }();
            if ($truthy(options['$[]']("inherits"))) {
                encoding = options['$[]']("inherits").$clone();
                encoding.$initialize(name115, names, ascii, dummy);
            } else {
                encoding = self148.$new(name115, names, ascii, dummy);
            }
            if (block !== nil) {
                $send(encoding, 'instance_eval', [], block.$to_proc());
            }
            register = Opal.encodings;
            return $send(names, 'each', [], ($$2 = function(encoding_name) {
                var self = $$2.$$s == null ? this : $$2.$$s;
                if (encoding_name == null) {
                    encoding_name = nil;
                }
                self.$const_set(encoding_name.$tr("-", "_"), encoding);
                return register[encoding_name] = encoding;
            }, $$2.$$s = self148, $$2.$$arity = 1, $$2));
        }, $Encoding_register$1.$$arity = -2);
        Opal.defs(self147, '$find', $Encoding_find$3 = function $$find(name116) {
            var self = this;
            if (name116['$==']("default_external")) {
                return self.$default_external();
            }
            return Opal.find_encoding(name116);
        }, $Encoding_find$3.$$arity = 1);
        self147.$singleton_class().$attr_accessor("default_external");
        self147.$attr_reader("name", "names");
        Opal.def(self147, '$initialize', $Encoding_initialize$4 = function $$initialize(name117, names, ascii, dummy) {
            var self = this;
            self.name = name117;
            self.names = names;
            self.ascii = ascii;
            return self.dummy = dummy;
        }, $Encoding_initialize$4.$$arity = 4);
        Opal.def(self147, '$ascii_compatible?', $Encoding_ascii_compatible$ques$5 = function() {
            var self = this;
            return self.ascii;
        }, $Encoding_ascii_compatible$ques$5.$$arity = 0);
        Opal.def(self147, '$dummy?', $Encoding_dummy$ques$6 = function() {
            var self = this;
            return self.dummy;
        }, $Encoding_dummy$ques$6.$$arity = 0);
        Opal.def(self147, '$binary?', $Encoding_binary$ques$7 = function() {
            return false;
        }, $Encoding_binary$ques$7.$$arity = 0);
        Opal.def(self147, '$to_s', $Encoding_to_s$8 = function $$to_s() {
            var self = this;
            return self.name;
        }, $Encoding_to_s$8.$$arity = 0);
        Opal.def(self147, '$inspect', $Encoding_inspect$9 = function $$inspect() {
            var self = this;
            return "" + "#<Encoding:" + self.name + function() {
                if ($truthy(self.dummy)) {
                    return " (dummy)";
                } else {
                    return nil;
                }
                return nil;
            }() + ">";
        }, $Encoding_inspect$9.$$arity = 0);
        Opal.def(self147, '$charsize', $Encoding_charsize$10 = function $$charsize(string) {
            var len = 0;
            for(var i289 = 0, length = string.length; i289 < length; i289++){
                var charcode = string.charCodeAt(i289);
                if (!(charcode >= 0xD800 && charcode <= 0xDBFF)) {
                    len++;
                }
            }
            return len;
        }, $Encoding_charsize$10.$$arity = 1);
        Opal.def(self147, '$each_char', $Encoding_each_char$11 = function $$each_char(string) {
            var $iter = $Encoding_each_char$11.$$p, block = $iter || nil;
            if ($iter) $Encoding_each_char$11.$$p = null;
            if ($iter) $Encoding_each_char$11.$$p = null;
            var low_surrogate = "";
            for(var i290 = 0, length = string.length; i290 < length; i290++){
                var charcode = string.charCodeAt(i290);
                var chr = string.charAt(i290);
                if (charcode >= 0xDC00 && charcode <= 0xDFFF) {
                    low_surrogate = chr;
                    continue;
                } else if (charcode >= 0xD800 && charcode <= 0xDBFF) {
                    chr = low_surrogate + chr;
                }
                if (string.encoding.name != "UTF-8") {
                    chr = new String(chr);
                    chr.encoding = string.encoding;
                }
                Opal.yield1(block, chr);
            }
        }, $Encoding_each_char$11.$$arity = 1);
        Opal.def(self147, '$each_byte', $Encoding_each_byte$12 = function $$each_byte($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'));
        }, $Encoding_each_byte$12.$$arity = -1);
        Opal.def(self147, '$bytesize', $Encoding_bytesize$13 = function $$bytesize($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'));
        }, $Encoding_bytesize$13.$$arity = -1);
        (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'EncodingError');
            [
                self
            ].concat($parent_nesting);
            return nil;
        })($nesting[0], $$($nesting, 'StandardError'), $nesting);
        return function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'CompatibilityError');
            [
                self
            ].concat($parent_nesting);
            return nil;
        }($nesting[0], $$($nesting, 'EncodingError'), $nesting);
    })($nesting32[0], null, $nesting32);
    $send($$($nesting32, 'Encoding'), 'register', [
        "UTF-8",
        $hash2([
            "aliases",
            "ascii"
        ], {
            "aliases": [
                "CP65001"
            ],
            "ascii": true
        })
    ], ($$14 = function() {
        var self = $$14.$$s == null ? this : $$14.$$s, $each_byte$15, $bytesize$16;
        Opal.def(self, '$each_byte', $each_byte$15 = function $$each_byte(string) {
            var $iter = $each_byte$15.$$p, block = $iter || nil;
            if ($iter) $each_byte$15.$$p = null;
            if ($iter) $each_byte$15.$$p = null;
            var units = Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            for(var i291 = 0; i291 < length; ++i291){
                codePoint = string.charCodeAt(i291);
                if (codePoint > 0xD7FF && codePoint < 0xE000) {
                    if (!leadSurrogate) {
                        if (codePoint > 0xDBFF) {
                            if ((units -= 3) > -1) {
                                Opal.yield1(block, 0xEF);
                                Opal.yield1(block, 0xBF);
                                Opal.yield1(block, 0xBD);
                            }
                            continue;
                        } else if (i291 + 1 === length) {
                            if ((units -= 3) > -1) {
                                Opal.yield1(block, 0xEF);
                                Opal.yield1(block, 0xBF);
                                Opal.yield1(block, 0xBD);
                            }
                            continue;
                        }
                        leadSurrogate = codePoint;
                        continue;
                    }
                    if (codePoint < 0xDC00) {
                        if ((units -= 3) > -1) {
                            Opal.yield1(block, 0xEF);
                            Opal.yield1(block, 0xBF);
                            Opal.yield1(block, 0xBD);
                        }
                        leadSurrogate = codePoint;
                        continue;
                    }
                    codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
                } else if (leadSurrogate) {
                    if ((units -= 3) > -1) {
                        Opal.yield1(block, 0xEF);
                        Opal.yield1(block, 0xBF);
                        Opal.yield1(block, 0xBD);
                    }
                }
                leadSurrogate = null;
                if (codePoint < 0x80) {
                    if ((units -= 1) < 0) break;
                    Opal.yield1(block, codePoint);
                } else if (codePoint < 0x800) {
                    if ((units -= 2) < 0) break;
                    Opal.yield1(block, codePoint >> 0x6 | 0xC0);
                    Opal.yield1(block, codePoint & 0x3F | 0x80);
                } else if (codePoint < 0x10000) {
                    if ((units -= 3) < 0) break;
                    Opal.yield1(block, codePoint >> 0xC | 0xE0);
                    Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
                    Opal.yield1(block, codePoint & 0x3F | 0x80);
                } else if (codePoint < 0x110000) {
                    if ((units -= 4) < 0) break;
                    Opal.yield1(block, codePoint >> 0x12 | 0xF0);
                    Opal.yield1(block, codePoint >> 0xC & 0x3F | 0x80);
                    Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
                    Opal.yield1(block, codePoint & 0x3F | 0x80);
                } else {}
            }
        }, $each_byte$15.$$arity = 1);
        return (Opal.def(self, '$bytesize', $bytesize$16 = function $$bytesize(string) {
            return string.$bytes().$length();
        }, $bytesize$16.$$arity = 1), nil) && 'bytesize';
    }, $$14.$$s = self146, $$14.$$arity = 0, $$14));
    $send($$($nesting32, 'Encoding'), 'register', [
        "UTF-16LE"
    ], ($$17 = function() {
        var self = $$17.$$s == null ? this : $$17.$$s, $each_byte$18, $bytesize$19;
        Opal.def(self, '$each_byte', $each_byte$18 = function $$each_byte(string) {
            var $iter = $each_byte$18.$$p, block = $iter || nil;
            if ($iter) $each_byte$18.$$p = null;
            if ($iter) $each_byte$18.$$p = null;
            for(var i292 = 0, length = string.length; i292 < length; i292++){
                var code = string.charCodeAt(i292);
                Opal.yield1(block, code & 0xff);
                Opal.yield1(block, code >> 8);
            }
        }, $each_byte$18.$$arity = 1);
        return (Opal.def(self, '$bytesize', $bytesize$19 = function $$bytesize(string) {
            return string.length * 2;
        }, $bytesize$19.$$arity = 1), nil) && 'bytesize';
    }, $$17.$$s = self146, $$17.$$arity = 0, $$17));
    $send($$($nesting32, 'Encoding'), 'register', [
        "UTF-16BE",
        $hash2([
            "inherits"
        ], {
            "inherits": $$$($$($nesting32, 'Encoding'), 'UTF_16LE')
        })
    ], ($$20 = function() {
        var self = $$20.$$s == null ? this : $$20.$$s, $each_byte$21;
        return (Opal.def(self, '$each_byte', $each_byte$21 = function $$each_byte(string) {
            var $iter = $each_byte$21.$$p, block = $iter || nil;
            if ($iter) $each_byte$21.$$p = null;
            if ($iter) $each_byte$21.$$p = null;
            for(var i293 = 0, length = string.length; i293 < length; i293++){
                var code = string.charCodeAt(i293);
                Opal.yield1(block, code >> 8);
                Opal.yield1(block, code & 0xff);
            }
        }, $each_byte$21.$$arity = 1), nil) && 'each_byte';
    }, $$20.$$s = self146, $$20.$$arity = 0, $$20));
    $send($$($nesting32, 'Encoding'), 'register', [
        "UTF-32LE"
    ], ($$22 = function() {
        var self = $$22.$$s == null ? this : $$22.$$s, $each_byte$23, $bytesize$24;
        Opal.def(self, '$each_byte', $each_byte$23 = function $$each_byte(string) {
            var $iter = $each_byte$23.$$p, block = $iter || nil;
            if ($iter) $each_byte$23.$$p = null;
            if ($iter) $each_byte$23.$$p = null;
            for(var i294 = 0, length = string.length; i294 < length; i294++){
                var code = string.charCodeAt(i294);
                Opal.yield1(block, code & 0xff);
                Opal.yield1(block, code >> 8);
                Opal.yield1(block, 0);
                Opal.yield1(block, 0);
            }
        }, $each_byte$23.$$arity = 1);
        return (Opal.def(self, '$bytesize', $bytesize$24 = function $$bytesize(string) {
            return string.length * 4;
        }, $bytesize$24.$$arity = 1), nil) && 'bytesize';
    }, $$22.$$s = self146, $$22.$$arity = 0, $$22));
    $send($$($nesting32, 'Encoding'), 'register', [
        "UTF-32BE",
        $hash2([
            "inherits"
        ], {
            "inherits": $$$($$($nesting32, 'Encoding'), 'UTF_32LE')
        })
    ], ($$25 = function() {
        var self = $$25.$$s == null ? this : $$25.$$s, $each_byte$26;
        return (Opal.def(self, '$each_byte', $each_byte$26 = function $$each_byte(string) {
            var $iter = $each_byte$26.$$p, block = $iter || nil;
            if ($iter) $each_byte$26.$$p = null;
            if ($iter) $each_byte$26.$$p = null;
            for(var i295 = 0, length = string.length; i295 < length; i295++){
                var code = string.charCodeAt(i295);
                Opal.yield1(block, 0);
                Opal.yield1(block, 0);
                Opal.yield1(block, code >> 8);
                Opal.yield1(block, code & 0xff);
            }
        }, $each_byte$26.$$arity = 1), nil) && 'each_byte';
    }, $$25.$$s = self146, $$25.$$arity = 0, $$25));
    $send($$($nesting32, 'Encoding'), 'register', [
        "ASCII-8BIT",
        $hash2([
            "aliases",
            "ascii"
        ], {
            "aliases": [
                "BINARY"
            ],
            "ascii": true
        })
    ], ($$27 = function() {
        var self = $$27.$$s == null ? this : $$27.$$s, $each_char$28, $charsize$29, $each_byte$30, $bytesize$31, $binary$ques$32;
        Opal.def(self, '$each_char', $each_char$28 = function $$each_char(string) {
            var $iter = $each_char$28.$$p, block = $iter || nil;
            if ($iter) $each_char$28.$$p = null;
            if ($iter) $each_char$28.$$p = null;
            for(var i296 = 0, length = string.length; i296 < length; i296++){
                var chr = new String(string.charAt(i296));
                chr.encoding = string.encoding;
                Opal.yield1(block, chr);
            }
        }, $each_char$28.$$arity = 1);
        Opal.def(self, '$charsize', $charsize$29 = function $$charsize(string) {
            return string.length;
        }, $charsize$29.$$arity = 1);
        Opal.def(self, '$each_byte', $each_byte$30 = function $$each_byte(string) {
            var $iter = $each_byte$30.$$p, block = $iter || nil;
            if ($iter) $each_byte$30.$$p = null;
            if ($iter) $each_byte$30.$$p = null;
            for(var i297 = 0, length = string.length; i297 < length; i297++){
                var code = string.charCodeAt(i297);
                Opal.yield1(block, code & 0xff);
            }
        }, $each_byte$30.$$arity = 1);
        Opal.def(self, '$bytesize', $bytesize$31 = function $$bytesize(string) {
            return string.length;
        }, $bytesize$31.$$arity = 1);
        return (Opal.def(self, '$binary?', $binary$ques$32 = function() {
            return true;
        }, $binary$ques$32.$$arity = 0), nil) && 'binary?';
    }, $$27.$$s = self146, $$27.$$arity = 0, $$27));
    $$($nesting32, 'Encoding').$register("ISO-8859-1", $hash2([
        "aliases",
        "ascii",
        "inherits"
    ], {
        "aliases": [
            "ISO8859-1"
        ],
        "ascii": true,
        "inherits": $$$($$($nesting32, 'Encoding'), 'ASCII_8BIT')
    }));
    $$($nesting32, 'Encoding').$register("US-ASCII", $hash2([
        "aliases",
        "ascii",
        "inherits"
    ], {
        "aliases": [
            "ASCII"
        ],
        "ascii": true,
        "inherits": $$$($$($nesting32, 'Encoding'), 'ASCII_8BIT')
    }));
    (function($base, $super, $parent_nesting) {
        var self149 = $klass($base, $super, 'String');
        var $nesting = [
            self149
        ].concat($parent_nesting), $String_b$33, $String_bytesize$34, $String_each_byte$35, $String_bytes$37, $String_each_char$38, $String_chars$40, $String_each_codepoint$41, $String_codepoints$42, $String_encode$43, $String_force_encoding$44, $String_getbyte$45, $String_initialize_copy$46, $String_length$47, $String_valid_encoding$ques$48;
        self149.$$prototype.internal_encoding = self149.$$prototype.bytes = self149.$$prototype.encoding = nil;
        self149.$attr_reader("encoding");
        self149.$attr_reader("internal_encoding");
        Opal.defineProperty(String.prototype, 'bytes', nil);
        Opal.defineProperty(String.prototype, 'encoding', $$$($$($nesting, 'Encoding'), 'UTF_8'));
        Opal.defineProperty(String.prototype, 'internal_encoding', $$$($$($nesting, 'Encoding'), 'UTF_8'));
        Opal.def(self149, '$b', $String_b$33 = function $$b() {
            var self = this;
            return self.$dup().$force_encoding("binary");
        }, $String_b$33.$$arity = 0);
        Opal.def(self149, '$bytesize', $String_bytesize$34 = function $$bytesize() {
            var self = this;
            return self.internal_encoding.$bytesize(self);
        }, $String_bytesize$34.$$arity = 0);
        Opal.def(self149, '$each_byte', $String_each_byte$35 = function $$each_byte() {
            var $iter = $String_each_byte$35.$$p, block = $iter || nil, $$36, self150 = this;
            if ($iter) $String_each_byte$35.$$p = null;
            if ($iter) $String_each_byte$35.$$p = null;
            if (block !== nil) {} else {
                return $send(self150, 'enum_for', [
                    "each_byte"
                ], ($$36 = function() {
                    var self = $$36.$$s == null ? this : $$36.$$s;
                    return self.$bytesize();
                }, $$36.$$s = self150, $$36.$$arity = 0, $$36));
            }
            $send(self150.internal_encoding, 'each_byte', [
                self150
            ], block.$to_proc());
            return self150;
        }, $String_each_byte$35.$$arity = 0);
        Opal.def(self149, '$bytes', $String_bytes$37 = function $$bytes() {
            var self = this, $ret_or_4 = nil;
            if (typeof self === 'string') {
                return new String(self).$each_byte().$to_a();
            }
            self.bytes = function() {
                if ($truthy($ret_or_4 = self.bytes)) {
                    return $ret_or_4;
                } else {
                    return self.$each_byte().$to_a();
                }
                return nil;
            }();
            return self.bytes.$dup();
        }, $String_bytes$37.$$arity = 0);
        Opal.def(self149, '$each_char', $String_each_char$38 = function $$each_char() {
            var $iter = $String_each_char$38.$$p, block = $iter || nil, $$39, self151 = this;
            if ($iter) $String_each_char$38.$$p = null;
            if ($iter) $String_each_char$38.$$p = null;
            if (block !== nil) {} else {
                return $send(self151, 'enum_for', [
                    "each_char"
                ], ($$39 = function() {
                    var self = $$39.$$s == null ? this : $$39.$$s;
                    return self.$length();
                }, $$39.$$s = self151, $$39.$$arity = 0, $$39));
            }
            $send(self151.encoding, 'each_char', [
                self151
            ], block.$to_proc());
            return self151;
        }, $String_each_char$38.$$arity = 0);
        Opal.def(self149, '$chars', $String_chars$40 = function $$chars() {
            var $iter = $String_chars$40.$$p, block = $iter || nil, self = this;
            if ($iter) $String_chars$40.$$p = null;
            if ($iter) $String_chars$40.$$p = null;
            if ($truthy(block)) {} else {
                return self.$each_char().$to_a();
            }
            return $send(self, 'each_char', [], block.$to_proc());
        }, $String_chars$40.$$arity = 0);
        Opal.def(self149, '$each_codepoint', $String_each_codepoint$41 = function $$each_codepoint() {
            var $iter = $String_each_codepoint$41.$$p, block = $iter || nil, self = this;
            if ($iter) $String_each_codepoint$41.$$p = null;
            if ($iter) $String_each_codepoint$41.$$p = null;
            if (block !== nil) {} else {
                return self.$enum_for("each_codepoint");
            }
            for(var i298 = 0, length = self.length; i298 < length; i298++){
                Opal.yield1(block, self.codePointAt(i298));
            }
            return self;
        }, $String_each_codepoint$41.$$arity = 0);
        Opal.def(self149, '$codepoints', $String_codepoints$42 = function $$codepoints() {
            var $iter = $String_codepoints$42.$$p, block = $iter || nil, self = this;
            if ($iter) $String_codepoints$42.$$p = null;
            if ($iter) $String_codepoints$42.$$p = null;
            if (block !== nil) {
                return $send(self, 'each_codepoint', [], block.$to_proc());
            }
            return self.$each_codepoint().$to_a();
        }, $String_codepoints$42.$$arity = 0);
        Opal.def(self149, '$encode', $String_encode$43 = function $$encode(encoding) {
            var self = this;
            return Opal.enc(self, encoding);
        }, $String_encode$43.$$arity = 1);
        Opal.def(self149, '$force_encoding', $String_force_encoding$44 = function $$force_encoding(encoding) {
            var self = this;
            var str = self;
            if (encoding === str.encoding) {
                return str;
            }
            encoding = $$($nesting, 'Opal')['$coerce_to!'](encoding, $$($nesting, 'String'), "to_s");
            encoding = $$($nesting, 'Encoding').$find(encoding);
            if (encoding === str.encoding) {
                return str;
            }
            str = Opal.set_encoding(str, encoding);
            return str;
        }, $String_force_encoding$44.$$arity = 1);
        Opal.def(self149, '$getbyte', $String_getbyte$45 = function $$getbyte(idx) {
            var self = this, string_bytes = nil;
            string_bytes = self.$bytes();
            idx = $$($nesting, 'Opal')['$coerce_to!'](idx, $$($nesting, 'Integer'), "to_int");
            if ($truthy($rb_lt(string_bytes.$length(), idx))) {
                return nil;
            }
            return string_bytes['$[]'](idx);
        }, $String_getbyte$45.$$arity = 1);
        Opal.def(self149, '$initialize_copy', $String_initialize_copy$46 = function $$initialize_copy(other) {
            return "" + "\n" + "      self.encoding = other.encoding;\n" + "      self.internal_encoding = other.internal_encoding;\n" + "    ";
        }, $String_initialize_copy$46.$$arity = 1);
        Opal.def(self149, '$length', $String_length$47 = function $$length() {
            var self = this;
            return self.length;
        }, $String_length$47.$$arity = 0);
        Opal.alias(self149, "size", "length");
        return (Opal.def(self149, '$valid_encoding?', $String_valid_encoding$ques$48 = function() {
            return true;
        }, $String_valid_encoding$ques$48.$$arity = 0), nil) && 'valid_encoding?';
    })($nesting32[0], null, $nesting32);
    $writer = [
        $$$($$($nesting32, 'Encoding'), 'UTF_8')
    ];
    $send($$($nesting32, 'Encoding'), 'default_external=', Opal.to_a($writer));
    return $writer[$rb_minus($writer["length"], 1)];
};
Opal.modules["corelib/math"] = function(Opal) {
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    function $rb_divide(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs / rhs : lhs['$/'](rhs);
    }
    var self152 = Opal.top, $nesting33 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $type_error = Opal.type_error, $module = Opal.module, $truthy = Opal.truthy;
    Opal.add_stubs([
        '$new',
        '$raise',
        '$Float',
        '$Integer',
        '$module_function',
        '$checked',
        '$float!',
        '$===',
        '$gamma',
        '$-',
        '$integer!',
        '$/',
        '$infinite?'
    ]);
    return function($base, $parent_nesting) {
        var self153 = $module($base, 'Math');
        var $nesting = [
            self153
        ].concat($parent_nesting), $Math_checked$1, $Math_float$excl$2, $Math_integer$excl$3, $Math_acos$4, $Math_acosh$5, $Math_asin$6, $Math_asinh$7, $Math_atan$8, $Math_atan2$9, $Math_atanh$10, $Math_cbrt$11, $Math_cos$12, $Math_cosh$13, $Math_erf$14, $Math_erfc$15, $Math_exp$16, $Math_frexp$17, $Math_gamma$18, $Math_hypot$19, $Math_ldexp$20, $Math_lgamma$21, $Math_log$22, $Math_log10$23, $Math_log2$24, $Math_sin$25, $Math_sinh$26, $Math_sqrt$27, $Math_tan$28, $Math_tanh$29;
        Opal.const_set($nesting[0], 'E', Math.E);
        Opal.const_set($nesting[0], 'PI', Math.PI);
        Opal.const_set($nesting[0], 'DomainError', $$($nesting, 'Class').$new($$($nesting, 'StandardError')));
        Opal.defs(self153, '$checked', $Math_checked$1 = function $$checked(method, $a) {
            var $post_args, args78, self = this;
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            args78 = $post_args;
            if (isNaN(args78[0]) || args78.length == 2 && isNaN(args78[1])) {
                return NaN;
            }
            var result = Math[method].apply(null, args78);
            if (isNaN(result)) {
                self.$raise($$($nesting, 'DomainError'), "" + "Numerical argument is out of domain - \"" + method + "\"");
            }
            return result;
        }, $Math_checked$1.$$arity = -2);
        Opal.defs(self153, '$float!', $Math_float$excl$2 = function(value) {
            var self = this;
            try {
                return self.$Float(value);
            } catch ($err) {
                if (Opal.rescue($err, [
                    $$($nesting, 'ArgumentError')
                ])) {
                    try {
                        return self.$raise($type_error(value, $$($nesting, 'Float')));
                    } finally{
                        Opal.pop_exception();
                    }
                } else {
                    throw $err;
                }
            }
        }, $Math_float$excl$2.$$arity = 1);
        Opal.defs(self153, '$integer!', $Math_integer$excl$3 = function(value) {
            var self = this;
            try {
                return self.$Integer(value);
            } catch ($err) {
                if (Opal.rescue($err, [
                    $$($nesting, 'ArgumentError')
                ])) {
                    try {
                        return self.$raise($type_error(value, $$($nesting, 'Integer')));
                    } finally{
                        Opal.pop_exception();
                    }
                } else {
                    throw $err;
                }
            }
        }, $Math_integer$excl$3.$$arity = 1);
        self153.$module_function();
        Opal.def(self153, '$acos', $Math_acos$4 = function $$acos(x) {
            return $$($nesting, 'Math').$checked("acos", $$($nesting, 'Math')['$float!'](x));
        }, $Math_acos$4.$$arity = 1);
        if ($truthy(typeof Math.acosh !== "undefined")) {} else {
            Math.acosh = function(x) {
                return Math.log(x + Math.sqrt(x * x - 1));
            };
        }
        Opal.def(self153, '$acosh', $Math_acosh$5 = function $$acosh(x) {
            return $$($nesting, 'Math').$checked("acosh", $$($nesting, 'Math')['$float!'](x));
        }, $Math_acosh$5.$$arity = 1);
        Opal.def(self153, '$asin', $Math_asin$6 = function $$asin(x) {
            return $$($nesting, 'Math').$checked("asin", $$($nesting, 'Math')['$float!'](x));
        }, $Math_asin$6.$$arity = 1);
        if ($truthy(typeof Math.asinh !== "undefined")) {} else {
            Math.asinh = function(x) {
                return Math.log(x + Math.sqrt(x * x + 1));
            };
        }
        Opal.def(self153, '$asinh', $Math_asinh$7 = function $$asinh(x) {
            return $$($nesting, 'Math').$checked("asinh", $$($nesting, 'Math')['$float!'](x));
        }, $Math_asinh$7.$$arity = 1);
        Opal.def(self153, '$atan', $Math_atan$8 = function $$atan(x) {
            return $$($nesting, 'Math').$checked("atan", $$($nesting, 'Math')['$float!'](x));
        }, $Math_atan$8.$$arity = 1);
        Opal.def(self153, '$atan2', $Math_atan2$9 = function $$atan2(y, x) {
            return $$($nesting, 'Math').$checked("atan2", $$($nesting, 'Math')['$float!'](y), $$($nesting, 'Math')['$float!'](x));
        }, $Math_atan2$9.$$arity = 2);
        if ($truthy(typeof Math.atanh !== "undefined")) {} else {
            Math.atanh = function(x) {
                return 0.5 * Math.log((1 + x) / (1 - x));
            };
        }
        Opal.def(self153, '$atanh', $Math_atanh$10 = function $$atanh(x) {
            return $$($nesting, 'Math').$checked("atanh", $$($nesting, 'Math')['$float!'](x));
        }, $Math_atanh$10.$$arity = 1);
        if ($truthy(typeof Math.cbrt !== "undefined")) {} else {
            Math.cbrt = function(x) {
                if (x == 0) {
                    return 0;
                }
                if (x < 0) {
                    return -Math.cbrt(-x);
                }
                var r = x, ex = 0;
                while(r < 0.125){
                    r *= 8;
                    ex--;
                }
                while(r > 1.0){
                    r *= 0.125;
                    ex++;
                }
                r = (-0.46946116 * r + 1.072302) * r + 0.3812513;
                while(ex < 0){
                    r *= 0.5;
                    ex++;
                }
                while(ex > 0){
                    r *= 2;
                    ex--;
                }
                r = 2.0 / 3.0 * r + 1.0 / 3.0 * x / (r * r);
                r = 2.0 / 3.0 * r + 1.0 / 3.0 * x / (r * r);
                r = 2.0 / 3.0 * r + 1.0 / 3.0 * x / (r * r);
                r = 2.0 / 3.0 * r + 1.0 / 3.0 * x / (r * r);
                return r;
            };
        }
        Opal.def(self153, '$cbrt', $Math_cbrt$11 = function $$cbrt(x) {
            return $$($nesting, 'Math').$checked("cbrt", $$($nesting, 'Math')['$float!'](x));
        }, $Math_cbrt$11.$$arity = 1);
        Opal.def(self153, '$cos', $Math_cos$12 = function $$cos(x) {
            return $$($nesting, 'Math').$checked("cos", $$($nesting, 'Math')['$float!'](x));
        }, $Math_cos$12.$$arity = 1);
        if ($truthy(typeof Math.cosh !== "undefined")) {} else {
            Math.cosh = function(x) {
                return (Math.exp(x) + Math.exp(-x)) / 2;
            };
        }
        Opal.def(self153, '$cosh', $Math_cosh$13 = function $$cosh(x) {
            return $$($nesting, 'Math').$checked("cosh", $$($nesting, 'Math')['$float!'](x));
        }, $Math_cosh$13.$$arity = 1);
        if ($truthy(typeof Math.erf !== "undefined")) {} else {
            Opal.defineProperty(Math, 'erf', function(x) {
                var A1 = 0.254829592, A2 = -0.284496736, A3 = 1.421413741, A4 = -1.453152027, A5 = 1.061405429, P = 0.3275911;
                var sign = 1;
                if (x < 0) {
                    sign = -1;
                }
                x = Math.abs(x);
                var t = 1.0 / (1.0 + P * x);
                var y = 1.0 - ((((A5 * t + A4) * t + A3) * t + A2) * t + A1) * t * Math.exp(-x * x);
                return sign * y;
            });
        }
        Opal.def(self153, '$erf', $Math_erf$14 = function $$erf(x) {
            return $$($nesting, 'Math').$checked("erf", $$($nesting, 'Math')['$float!'](x));
        }, $Math_erf$14.$$arity = 1);
        if ($truthy(typeof Math.erfc !== "undefined")) {} else {
            Opal.defineProperty(Math, 'erfc', function(x) {
                var z = Math.abs(x), t = 1.0 / (0.5 * z + 1.0);
                var A1 = t * 0.17087277 + -0.82215223, A2 = t * A1 + 1.48851587, A3 = t * A2 + -1.13520398, A4 = t * A3 + 0.27886807, A5 = t * A4 + -0.18628806, A6 = t * A5 + 0.09678418, A7 = t * A6 + 0.37409196, A8 = t * A7 + 1.00002368, A9 = t * A8, A10 = -z * z - 1.26551223 + A9;
                var a = t * Math.exp(A10);
                if (x < 0.0) {
                    return 2.0 - a;
                } else {
                    return a;
                }
            });
        }
        Opal.def(self153, '$erfc', $Math_erfc$15 = function $$erfc(x) {
            return $$($nesting, 'Math').$checked("erfc", $$($nesting, 'Math')['$float!'](x));
        }, $Math_erfc$15.$$arity = 1);
        Opal.def(self153, '$exp', $Math_exp$16 = function $$exp(x) {
            return $$($nesting, 'Math').$checked("exp", $$($nesting, 'Math')['$float!'](x));
        }, $Math_exp$16.$$arity = 1);
        Opal.def(self153, '$frexp', $Math_frexp$17 = function $$frexp(x) {
            x = $$($nesting, 'Math')['$float!'](x);
            if (isNaN(x)) {
                return [
                    NaN,
                    0
                ];
            }
            var ex = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1, frac = x / Math.pow(2, ex);
            return [
                frac,
                ex
            ];
        }, $Math_frexp$17.$$arity = 1);
        Opal.def(self153, '$gamma', $Math_gamma$18 = function $$gamma(n) {
            var self = this;
            n = $$($nesting, 'Math')['$float!'](n);
            var i299, t, x, value, result, twoN, threeN, fourN, fiveN;
            var G = 4.7421875;
            var P = [
                0.99999999999999709182,
                57.156235665862923517,
                -59.597960355475491248,
                14.136097974741747174,
                -0.49191381609762019978,
                0.33994649984811888699e-4,
                0.46523628927048575665e-4,
                -0.98374475304879564677e-4,
                0.15808870322491248884e-3,
                -0.21026444172410488319e-3,
                0.21743961811521264320e-3,
                -0.16431810653676389022e-3,
                0.84418223983852743293e-4,
                -0.26190838401581408670e-4,
                0.36899182659531622704e-5
            ];
            if (isNaN(n)) {
                return NaN;
            }
            if (n === 0 && 1 / n < 0) {
                return -Infinity;
            }
            if (n === -1 || n === -Infinity) {
                self.$raise($$($nesting, 'DomainError'), "Numerical argument is out of domain - \"gamma\"");
            }
            if ($$($nesting, 'Integer')['$==='](n)) {
                if (n <= 0) {
                    return isFinite(n) ? Infinity : NaN;
                }
                if (n > 171) {
                    return Infinity;
                }
                value = n - 2;
                result = n - 1;
                while(value > 1){
                    result *= value;
                    value--;
                }
                if (result == 0) {
                    result = 1;
                }
                return result;
            }
            if (n < 0.5) {
                return Math.PI / (Math.sin(Math.PI * n) * $$($nesting, 'Math').$gamma($rb_minus(1, n)));
            }
            if (n >= 171.35) {
                return Infinity;
            }
            if (n > 85.0) {
                twoN = n * n;
                threeN = twoN * n;
                fourN = threeN * n;
                fiveN = fourN * n;
                return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n) * (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n));
            }
            n -= 1;
            x = P[0];
            for(i299 = 1; i299 < P.length; ++i299){
                x += P[i299] / (n + i299);
            }
            t = n + G + 0.5;
            return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
        }, $Math_gamma$18.$$arity = 1);
        if ($truthy(typeof Math.hypot !== "undefined")) {} else {
            Math.hypot = function(x, y) {
                return Math.sqrt(x * x + y * y);
            };
        }
        Opal.def(self153, '$hypot', $Math_hypot$19 = function $$hypot(x, y) {
            return $$($nesting, 'Math').$checked("hypot", $$($nesting, 'Math')['$float!'](x), $$($nesting, 'Math')['$float!'](y));
        }, $Math_hypot$19.$$arity = 2);
        Opal.def(self153, '$ldexp', $Math_ldexp$20 = function $$ldexp(mantissa, exponent) {
            var self = this;
            mantissa = $$($nesting, 'Math')['$float!'](mantissa);
            exponent = $$($nesting, 'Math')['$integer!'](exponent);
            if (isNaN(exponent)) {
                self.$raise($$($nesting, 'RangeError'), "float NaN out of range of integer");
            }
            return mantissa * Math.pow(2, exponent);
        }, $Math_ldexp$20.$$arity = 2);
        Opal.def(self153, '$lgamma', $Math_lgamma$21 = function $$lgamma(n) {
            if (n == -1) {
                return [
                    Infinity,
                    1
                ];
            } else {
                return [
                    Math.log(Math.abs($$($nesting, 'Math').$gamma(n))),
                    $$($nesting, 'Math').$gamma(n) < 0 ? -1 : 1
                ];
            }
        }, $Math_lgamma$21.$$arity = 1);
        Opal.def(self153, '$log', $Math_log$22 = function $$log(x, base14) {
            var self = this;
            if ($truthy($$($nesting, 'String')['$==='](x))) {
                self.$raise($type_error(x, $$($nesting, 'Float')));
            }
            if ($truthy(base14 == null)) {
                return $$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](x));
            } else {
                if ($truthy($$($nesting, 'String')['$==='](base14))) {
                    self.$raise($type_error(base14, $$($nesting, 'Float')));
                }
                return $rb_divide($$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](x)), $$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](base14)));
            }
        }, $Math_log$22.$$arity = -2);
        if ($truthy(typeof Math.log10 !== "undefined")) {} else {
            Math.log10 = function(x) {
                return Math.log(x) / Math.LN10;
            };
        }
        Opal.def(self153, '$log10', $Math_log10$23 = function $$log10(x) {
            var self = this;
            if ($truthy($$($nesting, 'String')['$==='](x))) {
                self.$raise($type_error(x, $$($nesting, 'Float')));
            }
            return $$($nesting, 'Math').$checked("log10", $$($nesting, 'Math')['$float!'](x));
        }, $Math_log10$23.$$arity = 1);
        if ($truthy(typeof Math.log2 !== "undefined")) {} else {
            Math.log2 = function(x) {
                return Math.log(x) / Math.LN2;
            };
        }
        Opal.def(self153, '$log2', $Math_log2$24 = function $$log2(x) {
            var self = this;
            if ($truthy($$($nesting, 'String')['$==='](x))) {
                self.$raise($type_error(x, $$($nesting, 'Float')));
            }
            return $$($nesting, 'Math').$checked("log2", $$($nesting, 'Math')['$float!'](x));
        }, $Math_log2$24.$$arity = 1);
        Opal.def(self153, '$sin', $Math_sin$25 = function $$sin(x) {
            return $$($nesting, 'Math').$checked("sin", $$($nesting, 'Math')['$float!'](x));
        }, $Math_sin$25.$$arity = 1);
        if ($truthy(typeof Math.sinh !== "undefined")) {} else {
            Math.sinh = function(x) {
                return (Math.exp(x) - Math.exp(-x)) / 2;
            };
        }
        Opal.def(self153, '$sinh', $Math_sinh$26 = function $$sinh(x) {
            return $$($nesting, 'Math').$checked("sinh", $$($nesting, 'Math')['$float!'](x));
        }, $Math_sinh$26.$$arity = 1);
        Opal.def(self153, '$sqrt', $Math_sqrt$27 = function $$sqrt(x) {
            return $$($nesting, 'Math').$checked("sqrt", $$($nesting, 'Math')['$float!'](x));
        }, $Math_sqrt$27.$$arity = 1);
        Opal.def(self153, '$tan', $Math_tan$28 = function $$tan(x) {
            x = $$($nesting, 'Math')['$float!'](x);
            if ($truthy(x['$infinite?']())) {
                return $$$($$($nesting, 'Float'), 'NAN');
            }
            return $$($nesting, 'Math').$checked("tan", $$($nesting, 'Math')['$float!'](x));
        }, $Math_tan$28.$$arity = 1);
        if ($truthy(typeof Math.tanh !== "undefined")) {} else {
            Math.tanh = function(x) {
                if (x == Infinity) {
                    return 1;
                } else if (x == -Infinity) {
                    return -1;
                } else {
                    return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
                }
            };
        }
        return (Opal.def(self153, '$tanh', $Math_tanh$29 = function $$tanh(x) {
            return $$($nesting, 'Math').$checked("tanh", $$($nesting, 'Math')['$float!'](x));
        }, $Math_tanh$29.$$arity = 1), nil) && 'tanh';
    }($nesting33[0], $nesting33);
};
Opal.modules["corelib/complex"] = function(Opal) {
    function $rb_times(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs * rhs : lhs['$*'](rhs);
    }
    function $rb_plus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
    }
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    function $rb_divide(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs / rhs : lhs['$/'](rhs);
    }
    function $rb_gt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs > rhs : lhs['$>'](rhs);
    }
    var self154 = Opal.top, $nesting34 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $module = Opal.module;
    Opal.add_stubs([
        '$require',
        '$===',
        '$real?',
        '$raise',
        '$new',
        '$*',
        '$cos',
        '$sin',
        '$attr_reader',
        '$class',
        '$==',
        '$real',
        '$imag',
        '$Complex',
        '$-@',
        '$+',
        '$__coerced__',
        '$-',
        '$nan?',
        '$/',
        '$conj',
        '$abs2',
        '$quo',
        '$polar',
        '$exp',
        '$log',
        '$>',
        '$!=',
        '$divmod',
        '$**',
        '$hypot',
        '$atan2',
        '$lcm',
        '$denominator',
        '$finite?',
        '$infinite?',
        '$numerator',
        '$abs',
        '$arg',
        '$rationalize',
        '$to_f',
        '$to_i',
        '$to_r',
        '$inspect',
        '$positive?',
        '$zero?',
        '$Rational'
    ]);
    self154.$require("corelib/numeric");
    (function($base, $super, $parent_nesting14) {
        var self155 = $klass($base, $super, 'Complex');
        var $nesting = [
            self155
        ].concat($parent_nesting14), $Complex_rect$1, $Complex_polar$2, $Complex_initialize$3, $Complex_coerce$4, $Complex_$eq_eq$5, $Complex_$minus$$6, $Complex_$plus$7, $Complex_$minus$8, $Complex_$$9, $Complex_$slash$10, $Complex_$$$11, $Complex_abs$12, $Complex_abs2$13, $Complex_angle$14, $Complex_conj$15, $Complex_denominator$16, $Complex_eql$ques$17, $Complex_fdiv$18, $Complex_finite$ques$19, $Complex_hash$20, $Complex_infinite$ques$21, $Complex_inspect$22, $Complex_numerator$23, $Complex_polar$24, $Complex_rationalize$25, $Complex_real$ques$26, $Complex_rect$27, $Complex_to_f$28, $Complex_to_i$29, $Complex_to_r$30, $Complex_to_s$31;
        self155.$$prototype.real = self155.$$prototype.imag = nil;
        Opal.defs(self155, '$rect', $Complex_rect$1 = function $$rect(real, imag) {
            var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;
            if (imag == null) {
                imag = 0;
            }
            if ($truthy(function() {
                if ($truthy($ret_or_1 = function() {
                    if ($truthy($ret_or_2 = function() {
                        if ($truthy($ret_or_3 = $$($nesting, 'Numeric')['$==='](real))) {
                            return real['$real?']();
                        } else {
                            return $ret_or_3;
                        }
                        return nil;
                    }())) {
                        return $$($nesting, 'Numeric')['$==='](imag);
                    } else {
                        return $ret_or_2;
                    }
                    return nil;
                }())) {
                    return imag['$real?']();
                } else {
                    return $ret_or_1;
                }
                return nil;
            }())) {} else {
                self.$raise($$($nesting, 'TypeError'), "not a real");
            }
            return self.$new(real, imag);
        }, $Complex_rect$1.$$arity = -2);
        (function(self, $parent_nesting) {
            [
                self
            ].concat($parent_nesting);
            return Opal.alias(self, "rectangular", "rect");
        })(Opal.get_singleton_class(self155), $nesting);
        Opal.defs(self155, '$polar', $Complex_polar$2 = function $$polar(r, theta) {
            var self = this, $ret_or_4 = nil, $ret_or_5 = nil, $ret_or_6 = nil;
            if (theta == null) {
                theta = 0;
            }
            if ($truthy(function() {
                if ($truthy($ret_or_4 = function() {
                    if ($truthy($ret_or_5 = function() {
                        if ($truthy($ret_or_6 = $$($nesting, 'Numeric')['$==='](r))) {
                            return r['$real?']();
                        } else {
                            return $ret_or_6;
                        }
                        return nil;
                    }())) {
                        return $$($nesting, 'Numeric')['$==='](theta);
                    } else {
                        return $ret_or_5;
                    }
                    return nil;
                }())) {
                    return theta['$real?']();
                } else {
                    return $ret_or_4;
                }
                return nil;
            }())) {} else {
                self.$raise($$($nesting, 'TypeError'), "not a real");
            }
            return self.$new($rb_times(r, $$($nesting, 'Math').$cos(theta)), $rb_times(r, $$($nesting, 'Math').$sin(theta)));
        }, $Complex_polar$2.$$arity = -2);
        self155.$attr_reader("real", "imag");
        Opal.def(self155, '$initialize', $Complex_initialize$3 = function $$initialize(real, imag) {
            var self = this;
            if (imag == null) {
                imag = 0;
            }
            self.real = real;
            return self.imag = imag;
        }, $Complex_initialize$3.$$arity = -2);
        Opal.def(self155, '$coerce', $Complex_coerce$4 = function $$coerce(other) {
            var self = this, $ret_or_7 = nil;
            if ($truthy($$($nesting, 'Complex')['$==='](other))) {
                return [
                    other,
                    self
                ];
            } else if ($truthy(function() {
                if ($truthy($ret_or_7 = $$($nesting, 'Numeric')['$==='](other))) {
                    return other['$real?']();
                } else {
                    return $ret_or_7;
                }
                return nil;
            }())) {
                return [
                    $$($nesting, 'Complex').$new(other, 0),
                    self
                ];
            } else {
                return self.$raise($$($nesting, 'TypeError'), "" + other.$class() + " can't be coerced into Complex");
            }
        }, $Complex_coerce$4.$$arity = 1);
        Opal.def(self155, '$==', $Complex_$eq_eq$5 = function(other) {
            var self = this, $ret_or_8 = nil, $ret_or_9 = nil, $ret_or_10 = nil;
            if ($truthy($$($nesting, 'Complex')['$==='](other))) {
                if ($truthy($ret_or_8 = self.real['$=='](other.$real()))) {
                    return self.imag['$=='](other.$imag());
                } else {
                    return $ret_or_8;
                }
            } else if ($truthy(function() {
                if ($truthy($ret_or_9 = $$($nesting, 'Numeric')['$==='](other))) {
                    return other['$real?']();
                } else {
                    return $ret_or_9;
                }
                return nil;
            }())) {
                if ($truthy($ret_or_10 = self.real['$=='](other))) {
                    return self.imag['$=='](0);
                } else {
                    return $ret_or_10;
                }
            } else {
                return other['$=='](self);
            }
        }, $Complex_$eq_eq$5.$$arity = 1);
        Opal.def(self155, '$-@', $Complex_$minus$$6 = function() {
            var self = this;
            return self.$Complex(self.real['$-@'](), self.imag['$-@']());
        }, $Complex_$minus$$6.$$arity = 0);
        Opal.def(self155, '$+', $Complex_$plus$7 = function(other) {
            var self = this, $ret_or_11 = nil;
            if ($truthy($$($nesting, 'Complex')['$==='](other))) {
                return self.$Complex($rb_plus(self.real, other.$real()), $rb_plus(self.imag, other.$imag()));
            } else if ($truthy(function() {
                if ($truthy($ret_or_11 = $$($nesting, 'Numeric')['$==='](other))) {
                    return other['$real?']();
                } else {
                    return $ret_or_11;
                }
                return nil;
            }())) {
                return self.$Complex($rb_plus(self.real, other), self.imag);
            } else {
                return self.$__coerced__("+", other);
            }
        }, $Complex_$plus$7.$$arity = 1);
        Opal.def(self155, '$-', $Complex_$minus$8 = function(other) {
            var self = this, $ret_or_12 = nil;
            if ($truthy($$($nesting, 'Complex')['$==='](other))) {
                return self.$Complex($rb_minus(self.real, other.$real()), $rb_minus(self.imag, other.$imag()));
            } else if ($truthy(function() {
                if ($truthy($ret_or_12 = $$($nesting, 'Numeric')['$==='](other))) {
                    return other['$real?']();
                } else {
                    return $ret_or_12;
                }
                return nil;
            }())) {
                return self.$Complex($rb_minus(self.real, other), self.imag);
            } else {
                return self.$__coerced__("-", other);
            }
        }, $Complex_$minus$8.$$arity = 1);
        Opal.def(self155, '$*', $Complex_$$9 = function(other) {
            var self = this, $ret_or_13 = nil;
            if ($truthy($$($nesting, 'Complex')['$==='](other))) {
                return self.$Complex($rb_minus($rb_times(self.real, other.$real()), $rb_times(self.imag, other.$imag())), $rb_plus($rb_times(self.real, other.$imag()), $rb_times(self.imag, other.$real())));
            } else if ($truthy(function() {
                if ($truthy($ret_or_13 = $$($nesting, 'Numeric')['$==='](other))) {
                    return other['$real?']();
                } else {
                    return $ret_or_13;
                }
                return nil;
            }())) {
                return self.$Complex($rb_times(self.real, other), $rb_times(self.imag, other));
            } else {
                return self.$__coerced__("*", other);
            }
        }, $Complex_$$9.$$arity = 1);
        Opal.def(self155, '$/', $Complex_$slash$10 = function(other) {
            var self = this, $ret_or_14 = nil, $ret_or_15 = nil, $ret_or_16 = nil, $ret_or_17 = nil, $ret_or_18 = nil, $ret_or_19 = nil, $ret_or_20 = nil, $ret_or_21 = nil;
            if ($truthy($$($nesting, 'Complex')['$==='](other))) {
                if ($truthy(function() {
                    if ($truthy($ret_or_14 = function() {
                        if ($truthy($ret_or_15 = function() {
                            if ($truthy($ret_or_16 = function() {
                                if ($truthy($ret_or_17 = $$($nesting, 'Number')['$==='](self.real))) {
                                    return self.real['$nan?']();
                                } else {
                                    return $ret_or_17;
                                }
                                return nil;
                            }())) {
                                return $ret_or_16;
                            } else {
                                if ($truthy($ret_or_18 = $$($nesting, 'Number')['$==='](self.imag))) {
                                    return self.imag['$nan?']();
                                } else {
                                    return $ret_or_18;
                                }
                            }
                            return nil;
                        }())) {
                            return $ret_or_15;
                        } else {
                            if ($truthy($ret_or_19 = $$($nesting, 'Number')['$==='](other.$real()))) {
                                return other.$real()['$nan?']();
                            } else {
                                return $ret_or_19;
                            }
                        }
                        return nil;
                    }())) {
                        return $ret_or_14;
                    } else {
                        if ($truthy($ret_or_20 = $$($nesting, 'Number')['$==='](other.$imag()))) {
                            return other.$imag()['$nan?']();
                        } else {
                            return $ret_or_20;
                        }
                    }
                    return nil;
                }())) {
                    return $$($nesting, 'Complex').$new($$$($$($nesting, 'Float'), 'NAN'), $$$($$($nesting, 'Float'), 'NAN'));
                } else {
                    return $rb_divide($rb_times(self, other.$conj()), other.$abs2());
                }
            } else if ($truthy(function() {
                if ($truthy($ret_or_21 = $$($nesting, 'Numeric')['$==='](other))) {
                    return other['$real?']();
                } else {
                    return $ret_or_21;
                }
                return nil;
            }())) {
                return self.$Complex(self.real.$quo(other), self.imag.$quo(other));
            } else {
                return self.$__coerced__("/", other);
            }
        }, $Complex_$slash$10.$$arity = 1);
        Opal.def(self155, '$**', $Complex_$$$11 = function(other) {
            var $a, $b, $c, $d, self = this, r = nil, theta = nil, ore = nil, oim = nil, nr = nil, ntheta = nil, x = nil, z = nil, n = nil, div = nil, mod65 = nil, $ret_or_22 = nil;
            if (other['$=='](0)) {
                return $$($nesting, 'Complex').$new(1, 0);
            }
            if ($truthy($$($nesting, 'Complex')['$==='](other))) {
                $b = self.$polar(), $a = Opal.to_ary($b), r = $a[0] == null ? nil : $a[0], theta = $a[1] == null ? nil : $a[1], $b;
                ore = other.$real();
                oim = other.$imag();
                nr = $$($nesting, 'Math').$exp($rb_minus($rb_times(ore, $$($nesting, 'Math').$log(r)), $rb_times(oim, theta)));
                ntheta = $rb_plus($rb_times(theta, ore), $rb_times(oim, $$($nesting, 'Math').$log(r)));
                return $$($nesting, 'Complex').$polar(nr, ntheta);
            } else if ($truthy($$($nesting, 'Integer')['$==='](other))) {
                if ($truthy($rb_gt(other, 0))) {
                    x = self;
                    z = x;
                    n = $rb_minus(other, 1);
                    while($truthy(n['$!='](0))){
                        $c = n.$divmod(2), $b = Opal.to_ary($c), div = $b[0] == null ? nil : $b[0], mod65 = $b[1] == null ? nil : $b[1], $c;
                        while(mod65['$=='](0)){
                            x = self.$Complex($rb_minus($rb_times(x.$real(), x.$real()), $rb_times(x.$imag(), x.$imag())), $rb_times($rb_times(2, x.$real()), x.$imag()));
                            n = div;
                            $d = n.$divmod(2), $c = Opal.to_ary($d), div = $c[0] == null ? nil : $c[0], mod65 = $c[1] == null ? nil : $c[1], $d;
                        }
                        z = $rb_times(z, x);
                        n = $rb_minus(n, 1);
                    }
                    return z;
                } else {
                    return $rb_divide($$($nesting, 'Rational').$new(1, 1), self)['$**'](other['$-@']());
                }
            } else if ($truthy(function() {
                if ($truthy($ret_or_22 = $$($nesting, 'Float')['$==='](other))) {
                    return $ret_or_22;
                } else {
                    return $$($nesting, 'Rational')['$==='](other);
                }
                return nil;
            }())) {
                $b = self.$polar(), $a = Opal.to_ary($b), r = $a[0] == null ? nil : $a[0], theta = $a[1] == null ? nil : $a[1], $b;
                return $$($nesting, 'Complex').$polar(r['$**'](other), $rb_times(theta, other));
            } else {
                return self.$__coerced__("**", other);
            }
        }, $Complex_$$$11.$$arity = 1);
        Opal.def(self155, '$abs', $Complex_abs$12 = function $$abs() {
            var self = this;
            return $$($nesting, 'Math').$hypot(self.real, self.imag);
        }, $Complex_abs$12.$$arity = 0);
        Opal.def(self155, '$abs2', $Complex_abs2$13 = function $$abs2() {
            var self = this;
            return $rb_plus($rb_times(self.real, self.real), $rb_times(self.imag, self.imag));
        }, $Complex_abs2$13.$$arity = 0);
        Opal.def(self155, '$angle', $Complex_angle$14 = function $$angle() {
            var self = this;
            return $$($nesting, 'Math').$atan2(self.imag, self.real);
        }, $Complex_angle$14.$$arity = 0);
        Opal.alias(self155, "arg", "angle");
        Opal.def(self155, '$conj', $Complex_conj$15 = function $$conj() {
            var self = this;
            return self.$Complex(self.real, self.imag['$-@']());
        }, $Complex_conj$15.$$arity = 0);
        Opal.alias(self155, "conjugate", "conj");
        Opal.def(self155, '$denominator', $Complex_denominator$16 = function $$denominator() {
            var self = this;
            return self.real.$denominator().$lcm(self.imag.$denominator());
        }, $Complex_denominator$16.$$arity = 0);
        Opal.alias(self155, "divide", "/");
        Opal.def(self155, '$eql?', $Complex_eql$ques$17 = function(other) {
            var self = this, $ret_or_23 = nil, $ret_or_24 = nil;
            if ($truthy($ret_or_23 = function() {
                if ($truthy($ret_or_24 = $$($nesting, 'Complex')['$==='](other))) {
                    return self.real.$class()['$=='](self.imag.$class());
                } else {
                    return $ret_or_24;
                }
                return nil;
            }())) {
                return self['$=='](other);
            } else {
                return $ret_or_23;
            }
        }, $Complex_eql$ques$17.$$arity = 1);
        Opal.def(self155, '$fdiv', $Complex_fdiv$18 = function $$fdiv(other) {
            var self = this;
            if ($truthy($$($nesting, 'Numeric')['$==='](other))) {} else {
                self.$raise($$($nesting, 'TypeError'), "" + other.$class() + " can't be coerced into Complex");
            }
            return $rb_divide(self, other);
        }, $Complex_fdiv$18.$$arity = 1);
        Opal.def(self155, '$finite?', $Complex_finite$ques$19 = function() {
            var self = this, $ret_or_25 = nil;
            if ($truthy($ret_or_25 = self.real['$finite?']())) {
                return self.imag['$finite?']();
            } else {
                return $ret_or_25;
            }
        }, $Complex_finite$ques$19.$$arity = 0);
        Opal.def(self155, '$hash', $Complex_hash$20 = function $$hash() {
            var self = this;
            return "" + "Complex:" + self.real + ":" + self.imag;
        }, $Complex_hash$20.$$arity = 0);
        Opal.alias(self155, "imaginary", "imag");
        Opal.def(self155, '$infinite?', $Complex_infinite$ques$21 = function() {
            var self = this, $ret_or_26 = nil;
            if ($truthy($ret_or_26 = self.real['$infinite?']())) {
                return $ret_or_26;
            } else {
                return self.imag['$infinite?']();
            }
        }, $Complex_infinite$ques$21.$$arity = 0);
        Opal.def(self155, '$inspect', $Complex_inspect$22 = function $$inspect() {
            var self = this;
            return "" + "(" + self + ")";
        }, $Complex_inspect$22.$$arity = 0);
        Opal.alias(self155, "magnitude", "abs");
        Opal.udef(self155, '$' + "negative?");
        Opal.def(self155, '$numerator', $Complex_numerator$23 = function $$numerator() {
            var self = this, d = nil;
            d = self.$denominator();
            return self.$Complex($rb_times(self.real.$numerator(), $rb_divide(d, self.real.$denominator())), $rb_times(self.imag.$numerator(), $rb_divide(d, self.imag.$denominator())));
        }, $Complex_numerator$23.$$arity = 0);
        Opal.alias(self155, "phase", "arg");
        Opal.def(self155, '$polar', $Complex_polar$24 = function $$polar() {
            var self = this;
            return [
                self.$abs(),
                self.$arg()
            ];
        }, $Complex_polar$24.$$arity = 0);
        Opal.udef(self155, '$' + "positive?");
        Opal.alias(self155, "quo", "/");
        Opal.def(self155, '$rationalize', $Complex_rationalize$25 = function $$rationalize(eps) {
            var self = this;
            if (arguments.length > 1) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + arguments.length + " for 0..1)");
            }
            if ($truthy(self.imag['$!='](0))) {
                self.$raise($$($nesting, 'RangeError'), "" + "can't' convert " + self + " into Rational");
            }
            return self.$real().$rationalize(eps);
        }, $Complex_rationalize$25.$$arity = -1);
        Opal.def(self155, '$real?', $Complex_real$ques$26 = function() {
            return false;
        }, $Complex_real$ques$26.$$arity = 0);
        Opal.def(self155, '$rect', $Complex_rect$27 = function $$rect() {
            var self = this;
            return [
                self.real,
                self.imag
            ];
        }, $Complex_rect$27.$$arity = 0);
        Opal.alias(self155, "rectangular", "rect");
        Opal.udef(self155, '$' + "step");
        Opal.def(self155, '$to_f', $Complex_to_f$28 = function $$to_f() {
            var self = this;
            if (self.imag['$=='](0)) {} else {
                self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + self + " into Float");
            }
            return self.real.$to_f();
        }, $Complex_to_f$28.$$arity = 0);
        Opal.def(self155, '$to_i', $Complex_to_i$29 = function $$to_i() {
            var self = this;
            if (self.imag['$=='](0)) {} else {
                self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + self + " into Integer");
            }
            return self.real.$to_i();
        }, $Complex_to_i$29.$$arity = 0);
        Opal.def(self155, '$to_r', $Complex_to_r$30 = function $$to_r() {
            var self = this;
            if (self.imag['$=='](0)) {} else {
                self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + self + " into Rational");
            }
            return self.real.$to_r();
        }, $Complex_to_r$30.$$arity = 0);
        Opal.def(self155, '$to_s', $Complex_to_s$31 = function $$to_s() {
            var self = this, result = nil, $ret_or_27 = nil, $ret_or_28 = nil, $ret_or_29 = nil, $ret_or_30 = nil, $ret_or_31 = nil;
            result = self.real.$inspect();
            result = $rb_plus(result, function() {
                if ($truthy(function() {
                    if ($truthy($ret_or_27 = function() {
                        if ($truthy($ret_or_28 = function() {
                            if ($truthy($ret_or_29 = $$($nesting, 'Number')['$==='](self.imag))) {
                                return self.imag['$nan?']();
                            } else {
                                return $ret_or_29;
                            }
                            return nil;
                        }())) {
                            return $ret_or_28;
                        } else {
                            return self.imag['$positive?']();
                        }
                        return nil;
                    }())) {
                        return $ret_or_27;
                    } else {
                        return self.imag['$zero?']();
                    }
                    return nil;
                }())) {
                    return "+";
                } else {
                    return "-";
                }
                return nil;
            }());
            result = $rb_plus(result, self.imag.$abs().$inspect());
            if ($truthy(function() {
                if ($truthy($ret_or_30 = $$($nesting, 'Number')['$==='](self.imag))) {
                    if ($truthy($ret_or_31 = self.imag['$nan?']())) {
                        return $ret_or_31;
                    } else {
                        return self.imag['$infinite?']();
                    }
                } else {
                    return $ret_or_30;
                }
                return nil;
            }())) {
                result = $rb_plus(result, "*");
            }
            return $rb_plus(result, "i");
        }, $Complex_to_s$31.$$arity = 0);
        return Opal.const_set($nesting[0], 'I', self155.$new(0, 1));
    })($nesting34[0], $$($nesting34, 'Numeric'), $nesting34);
    (function($base, $parent_nesting) {
        var self = $module($base, 'Kernel');
        var $nesting = [
            self
        ].concat($parent_nesting), $Kernel_Complex$32;
        return (Opal.def(self, '$Complex', $Kernel_Complex$32 = function $$Complex(real, imag) {
            if (imag == null) {
                imag = nil;
            }
            if ($truthy(imag)) {
                return $$($nesting, 'Complex').$new(real, imag);
            } else {
                return $$($nesting, 'Complex').$new(real, 0);
            }
        }, $Kernel_Complex$32.$$arity = -2), nil) && 'Complex';
    })($nesting34[0], $nesting34);
    return function($base, $super, $parent_nesting) {
        var self156 = $klass($base, $super, 'String');
        var $nesting = [
            self156
        ].concat($parent_nesting), $String_to_c$33;
        return (Opal.def(self156, '$to_c', $String_to_c$33 = function $$to_c() {
            var self = this;
            var str = self, re = /[+-]?[\d_]+(\.[\d_]+)?(e\d+)?/, match1 = str.match(re), real, imag;
            function isFloat() {
                return re.test(str);
            }
            function cutFloat() {
                var match = str.match(re);
                var number = match[0];
                str = str.slice(number.length);
                return number.replace(/_/g, '');
            }
            function cutNumber() {
                if (isFloat()) {
                    var numerator = parseFloat(cutFloat());
                    if (str[0] === '/') {
                        str = str.slice(1);
                        if (isFloat()) {
                            var denominator = parseFloat(cutFloat());
                            return self.$Rational(numerator, denominator);
                        } else {
                            str = '/' + str;
                            return numerator;
                        }
                    } else {
                        return numerator;
                    }
                } else {
                    return null;
                }
            }
            real = cutNumber();
            if (!real) {
                if (str[0] === 'i') {
                    return self.$Complex(0, 1);
                }
                if (str[0] === '-' && str[1] === 'i') {
                    return self.$Complex(0, -1);
                }
                if (str[0] === '+' && str[1] === 'i') {
                    return self.$Complex(0, 1);
                }
                return self.$Complex(0, 0);
            }
            imag = cutNumber();
            if (!imag) {
                if (str[0] === 'i') {
                    return self.$Complex(0, real);
                } else {
                    return self.$Complex(real, 0);
                }
            } else {
                return self.$Complex(real, imag);
            }
        }, $String_to_c$33.$$arity = 0), nil) && 'to_c';
    }($nesting34[0], null, $nesting34);
};
Opal.modules["corelib/rational"] = function(Opal) {
    function $rb_lt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs < rhs : lhs['$<'](rhs);
    }
    function $rb_divide(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs / rhs : lhs['$/'](rhs);
    }
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    function $rb_times(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs * rhs : lhs['$*'](rhs);
    }
    function $rb_plus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
    }
    function $rb_gt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs > rhs : lhs['$>'](rhs);
    }
    function $rb_le(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs <= rhs : lhs['$<='](rhs);
    }
    var self157 = Opal.top, $nesting35 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $module = Opal.module;
    Opal.add_stubs([
        '$require',
        '$to_i',
        '$==',
        '$raise',
        '$<',
        '$-@',
        '$new',
        '$gcd',
        '$/',
        '$nil?',
        '$===',
        '$reduce',
        '$to_r',
        '$equal?',
        '$!',
        '$coerce_to!',
        '$to_f',
        '$numerator',
        '$denominator',
        '$<=>',
        '$-',
        '$*',
        '$__coerced__',
        '$+',
        '$Rational',
        '$>',
        '$**',
        '$abs',
        '$ceil',
        '$with_precision',
        '$floor',
        '$<=',
        '$truncate',
        '$send',
        '$convert'
    ]);
    self157.$require("corelib/numeric");
    (function($base, $super, $parent_nesting) {
        var self158 = $klass($base, $super, 'Rational');
        var $nesting = [
            self158
        ].concat($parent_nesting), $Rational_reduce$1, $Rational_convert$2, $Rational_initialize$3, $Rational_numerator$4, $Rational_denominator$5, $Rational_coerce$6, $Rational_$eq_eq$7, $Rational_$lt_eq_gt$8, $Rational_$plus$9, $Rational_$minus$10, $Rational_$$11, $Rational_$slash$12, $Rational_$$$13, $Rational_abs$14, $Rational_ceil$15, $Rational_floor$16, $Rational_hash$17, $Rational_inspect$18, $Rational_rationalize$19, $Rational_round$20, $Rational_to_f$21, $Rational_to_i$22, $Rational_to_r$23, $Rational_to_s$24, $Rational_truncate$25, $Rational_with_precision$26;
        self158.$$prototype.num = self158.$$prototype.den = nil;
        Opal.defs(self158, '$reduce', $Rational_reduce$1 = function $$reduce(num, den) {
            var self = this, gcd = nil;
            num = num.$to_i();
            den = den.$to_i();
            if (den['$=='](0)) {
                self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0");
            } else if ($truthy($rb_lt(den, 0))) {
                num = num['$-@']();
                den = den['$-@']();
            } else if (den['$=='](1)) {
                return self.$new(num, den);
            }
            gcd = num.$gcd(den);
            return self.$new($rb_divide(num, gcd), $rb_divide(den, gcd));
        }, $Rational_reduce$1.$$arity = 2);
        Opal.defs(self158, '$convert', $Rational_convert$2 = function $$convert(num, den) {
            var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil, $ret_or_5 = nil, $ret_or_6 = nil, $ret_or_7 = nil, $ret_or_8 = nil;
            if ($truthy(function() {
                if ($truthy($ret_or_1 = num['$nil?']())) {
                    return $ret_or_1;
                } else {
                    return den['$nil?']();
                }
                return nil;
            }())) {
                self.$raise($$($nesting, 'TypeError'), "cannot convert nil into Rational");
            }
            if ($truthy(function() {
                if ($truthy($ret_or_2 = $$($nesting, 'Integer')['$==='](num))) {
                    return $$($nesting, 'Integer')['$==='](den);
                } else {
                    return $ret_or_2;
                }
                return nil;
            }())) {
                return self.$reduce(num, den);
            }
            if ($truthy(function() {
                if ($truthy($ret_or_3 = function() {
                    if ($truthy($ret_or_4 = $$($nesting, 'Float')['$==='](num))) {
                        return $ret_or_4;
                    } else {
                        return $$($nesting, 'String')['$==='](num);
                    }
                    return nil;
                }())) {
                    return $ret_or_3;
                } else {
                    return $$($nesting, 'Complex')['$==='](num);
                }
                return nil;
            }())) {
                num = num.$to_r();
            }
            if ($truthy(function() {
                if ($truthy($ret_or_5 = function() {
                    if ($truthy($ret_or_6 = $$($nesting, 'Float')['$==='](den))) {
                        return $ret_or_6;
                    } else {
                        return $$($nesting, 'String')['$==='](den);
                    }
                    return nil;
                }())) {
                    return $ret_or_5;
                } else {
                    return $$($nesting, 'Complex')['$==='](den);
                }
                return nil;
            }())) {
                den = den.$to_r();
            }
            if ($truthy(function() {
                if ($truthy($ret_or_7 = den['$equal?'](1))) {
                    return $$($nesting, 'Integer')['$==='](num)['$!']();
                } else {
                    return $ret_or_7;
                }
                return nil;
            }())) {
                return $$($nesting, 'Opal')['$coerce_to!'](num, $$($nesting, 'Rational'), "to_r");
            } else if ($truthy(function() {
                if ($truthy($ret_or_8 = $$($nesting, 'Numeric')['$==='](num))) {
                    return $$($nesting, 'Numeric')['$==='](den);
                } else {
                    return $ret_or_8;
                }
                return nil;
            }())) {
                return $rb_divide(num, den);
            } else {
                return self.$reduce(num, den);
            }
        }, $Rational_convert$2.$$arity = 2);
        Opal.def(self158, '$initialize', $Rational_initialize$3 = function $$initialize(num, den) {
            var self = this;
            self.num = num;
            return self.den = den;
        }, $Rational_initialize$3.$$arity = 2);
        Opal.def(self158, '$numerator', $Rational_numerator$4 = function $$numerator() {
            var self = this;
            return self.num;
        }, $Rational_numerator$4.$$arity = 0);
        Opal.def(self158, '$denominator', $Rational_denominator$5 = function $$denominator() {
            var self = this;
            return self.den;
        }, $Rational_denominator$5.$$arity = 0);
        Opal.def(self158, '$coerce', $Rational_coerce$6 = function $$coerce(other) {
            var self = this, $case = nil;
            return function() {
                $case = other;
                if ($$($nesting, 'Rational')['$===']($case)) {
                    return [
                        other,
                        self
                    ];
                } else if ($$($nesting, 'Integer')['$===']($case)) {
                    return [
                        other.$to_r(),
                        self
                    ];
                } else if ($$($nesting, 'Float')['$===']($case)) {
                    return [
                        other,
                        self.$to_f()
                    ];
                } else {
                    return nil;
                }
            }();
        }, $Rational_coerce$6.$$arity = 1);
        Opal.def(self158, '$==', $Rational_$eq_eq$7 = function(other) {
            var self = this, $case = nil, $ret_or_9 = nil, $ret_or_10 = nil;
            return function() {
                $case = other;
                if ($$($nesting, 'Rational')['$===']($case)) {
                    if ($truthy($ret_or_9 = self.num['$=='](other.$numerator()))) {
                        return self.den['$=='](other.$denominator());
                    } else {
                        return $ret_or_9;
                    }
                } else if ($$($nesting, 'Integer')['$===']($case)) {
                    if ($truthy($ret_or_10 = self.num['$=='](other))) {
                        return self.den['$=='](1);
                    } else {
                        return $ret_or_10;
                    }
                } else if ($$($nesting, 'Float')['$===']($case)) {
                    return self.$to_f()['$=='](other);
                } else {
                    return other['$=='](self);
                }
            }();
        }, $Rational_$eq_eq$7.$$arity = 1);
        Opal.def(self158, '$<=>', $Rational_$lt_eq_gt$8 = function(other) {
            var self = this, $case = nil;
            return function() {
                $case = other;
                if ($$($nesting, 'Rational')['$===']($case)) {
                    return $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()))['$<=>'](0);
                } else if ($$($nesting, 'Integer')['$===']($case)) {
                    return $rb_minus(self.num, $rb_times(self.den, other))['$<=>'](0);
                } else if ($$($nesting, 'Float')['$===']($case)) {
                    return self.$to_f()['$<=>'](other);
                } else {
                    return self.$__coerced__("<=>", other);
                }
            }();
        }, $Rational_$lt_eq_gt$8.$$arity = 1);
        Opal.def(self158, '$+', $Rational_$plus$9 = function(other) {
            var self = this, $case = nil, num = nil, den = nil;
            return function() {
                $case = other;
                if ($$($nesting, 'Rational')['$===']($case)) {
                    num = $rb_plus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
                    den = $rb_times(self.den, other.$denominator());
                    return self.$Rational(num, den);
                } else if ($$($nesting, 'Integer')['$===']($case)) {
                    return self.$Rational($rb_plus(self.num, $rb_times(other, self.den)), self.den);
                } else if ($$($nesting, 'Float')['$===']($case)) {
                    return $rb_plus(self.$to_f(), other);
                } else {
                    return self.$__coerced__("+", other);
                }
            }();
        }, $Rational_$plus$9.$$arity = 1);
        Opal.def(self158, '$-', $Rational_$minus$10 = function(other) {
            var self = this, $case = nil, num = nil, den = nil;
            return function() {
                $case = other;
                if ($$($nesting, 'Rational')['$===']($case)) {
                    num = $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
                    den = $rb_times(self.den, other.$denominator());
                    return self.$Rational(num, den);
                } else if ($$($nesting, 'Integer')['$===']($case)) {
                    return self.$Rational($rb_minus(self.num, $rb_times(other, self.den)), self.den);
                } else if ($$($nesting, 'Float')['$===']($case)) {
                    return $rb_minus(self.$to_f(), other);
                } else {
                    return self.$__coerced__("-", other);
                }
            }();
        }, $Rational_$minus$10.$$arity = 1);
        Opal.def(self158, '$*', $Rational_$$11 = function(other) {
            var self = this, $case = nil, num = nil, den = nil;
            return function() {
                $case = other;
                if ($$($nesting, 'Rational')['$===']($case)) {
                    num = $rb_times(self.num, other.$numerator());
                    den = $rb_times(self.den, other.$denominator());
                    return self.$Rational(num, den);
                } else if ($$($nesting, 'Integer')['$===']($case)) {
                    return self.$Rational($rb_times(self.num, other), self.den);
                } else if ($$($nesting, 'Float')['$===']($case)) {
                    return $rb_times(self.$to_f(), other);
                } else {
                    return self.$__coerced__("*", other);
                }
            }();
        }, $Rational_$$11.$$arity = 1);
        Opal.def(self158, '$/', $Rational_$slash$12 = function(other) {
            var self = this, $case = nil, num = nil, den = nil;
            return function() {
                $case = other;
                if ($$($nesting, 'Rational')['$===']($case)) {
                    num = $rb_times(self.num, other.$denominator());
                    den = $rb_times(self.den, other.$numerator());
                    return self.$Rational(num, den);
                } else if ($$($nesting, 'Integer')['$===']($case)) {
                    if (other['$=='](0)) {
                        return $rb_divide(self.$to_f(), 0.0);
                    } else {
                        return self.$Rational(self.num, $rb_times(self.den, other));
                    }
                } else if ($$($nesting, 'Float')['$===']($case)) {
                    return $rb_divide(self.$to_f(), other);
                } else {
                    return self.$__coerced__("/", other);
                }
            }();
        }, $Rational_$slash$12.$$arity = 1);
        Opal.def(self158, '$**', $Rational_$$$13 = function(other) {
            var self = this, $case = nil, $ret_or_11 = nil, $ret_or_12 = nil;
            return function() {
                $case = other;
                if ($$($nesting, 'Integer')['$===']($case)) {
                    if ($truthy(function() {
                        if ($truthy($ret_or_11 = self['$=='](0))) {
                            return $rb_lt(other, 0);
                        } else {
                            return $ret_or_11;
                        }
                        return nil;
                    }())) {
                        return $$$($$($nesting, 'Float'), 'INFINITY');
                    } else if ($truthy($rb_gt(other, 0))) {
                        return self.$Rational(self.num['$**'](other), self.den['$**'](other));
                    } else if ($truthy($rb_lt(other, 0))) {
                        return self.$Rational(self.den['$**'](other['$-@']()), self.num['$**'](other['$-@']()));
                    } else {
                        return self.$Rational(1, 1);
                    }
                } else if ($$($nesting, 'Float')['$===']($case)) {
                    return self.$to_f()['$**'](other);
                } else if ($$($nesting, 'Rational')['$===']($case)) {
                    if (other['$=='](0)) {
                        return self.$Rational(1, 1);
                    } else if (other.$denominator()['$=='](1)) {
                        if ($truthy($rb_lt(other, 0))) {
                            return self.$Rational(self.den['$**'](other.$numerator().$abs()), self.num['$**'](other.$numerator().$abs()));
                        } else {
                            return self.$Rational(self.num['$**'](other.$numerator()), self.den['$**'](other.$numerator()));
                        }
                    } else if ($truthy(function() {
                        if ($truthy($ret_or_12 = self['$=='](0))) {
                            return $rb_lt(other, 0);
                        } else {
                            return $ret_or_12;
                        }
                        return nil;
                    }())) {
                        return self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0");
                    } else {
                        return self.$to_f()['$**'](other);
                    }
                } else {
                    return self.$__coerced__("**", other);
                }
            }();
        }, $Rational_$$$13.$$arity = 1);
        Opal.def(self158, '$abs', $Rational_abs$14 = function $$abs() {
            var self = this;
            return self.$Rational(self.num.$abs(), self.den.$abs());
        }, $Rational_abs$14.$$arity = 0);
        Opal.def(self158, '$ceil', $Rational_ceil$15 = function $$ceil(precision) {
            var self = this;
            if (precision == null) {
                precision = 0;
            }
            if (precision['$=='](0)) {
                return $rb_divide(self.num['$-@'](), self.den)['$-@']().$ceil();
            } else {
                return self.$with_precision("ceil", precision);
            }
        }, $Rational_ceil$15.$$arity = -1);
        Opal.alias(self158, "divide", "/");
        Opal.def(self158, '$floor', $Rational_floor$16 = function $$floor(precision) {
            var self = this;
            if (precision == null) {
                precision = 0;
            }
            if (precision['$=='](0)) {
                return $rb_divide(self.num['$-@'](), self.den)['$-@']().$floor();
            } else {
                return self.$with_precision("floor", precision);
            }
        }, $Rational_floor$16.$$arity = -1);
        Opal.def(self158, '$hash', $Rational_hash$17 = function $$hash() {
            var self = this;
            return "" + "Rational:" + self.num + ":" + self.den;
        }, $Rational_hash$17.$$arity = 0);
        Opal.def(self158, '$inspect', $Rational_inspect$18 = function $$inspect() {
            var self = this;
            return "" + "(" + self + ")";
        }, $Rational_inspect$18.$$arity = 0);
        Opal.alias(self158, "quo", "/");
        Opal.def(self158, '$rationalize', $Rational_rationalize$19 = function $$rationalize(eps) {
            var self = this;
            if (arguments.length > 1) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + arguments.length + " for 0..1)");
            }
            if (eps == null) {
                return self;
            }
            var e = eps.$abs(), a = $rb_minus(self, e), b = $rb_plus(self, e);
            var p0 = 0, p1 = 1, q0 = 1, q1 = 0, p2, q2;
            var c, k, t;
            while(true){
                c = a.$ceil();
                if ($rb_le(c, b)) {
                    break;
                }
                k = c - 1;
                p2 = k * p1 + p0;
                q2 = k * q1 + q0;
                t = $rb_divide(1, $rb_minus(b, k));
                b = $rb_divide(1, $rb_minus(a, k));
                a = t;
                p0 = p1;
                q0 = q1;
                p1 = p2;
                q1 = q2;
            }
            return self.$Rational(c * p1 + p0, c * q1 + q0);
        }, $Rational_rationalize$19.$$arity = -1);
        Opal.def(self158, '$round', $Rational_round$20 = function $$round(precision) {
            var self = this, num = nil, den = nil, approx = nil;
            if (precision == null) {
                precision = 0;
            }
            if (precision['$=='](0)) {} else {
                return self.$with_precision("round", precision);
            }
            if (self.num['$=='](0)) {
                return 0;
            }
            if (self.den['$=='](1)) {
                return self.num;
            }
            num = $rb_plus($rb_times(self.num.$abs(), 2), self.den);
            den = $rb_times(self.den, 2);
            approx = $rb_divide(num, den).$truncate();
            if ($truthy($rb_lt(self.num, 0))) {
                return approx['$-@']();
            } else {
                return approx;
            }
        }, $Rational_round$20.$$arity = -1);
        Opal.def(self158, '$to_f', $Rational_to_f$21 = function $$to_f() {
            var self = this;
            return $rb_divide(self.num, self.den);
        }, $Rational_to_f$21.$$arity = 0);
        Opal.def(self158, '$to_i', $Rational_to_i$22 = function $$to_i() {
            var self = this;
            return self.$truncate();
        }, $Rational_to_i$22.$$arity = 0);
        Opal.def(self158, '$to_r', $Rational_to_r$23 = function $$to_r() {
            var self = this;
            return self;
        }, $Rational_to_r$23.$$arity = 0);
        Opal.def(self158, '$to_s', $Rational_to_s$24 = function $$to_s() {
            var self = this;
            return "" + self.num + "/" + self.den;
        }, $Rational_to_s$24.$$arity = 0);
        Opal.def(self158, '$truncate', $Rational_truncate$25 = function $$truncate(precision) {
            var self = this;
            if (precision == null) {
                precision = 0;
            }
            if (precision['$=='](0)) {
                if ($truthy($rb_lt(self.num, 0))) {
                    return self.$ceil();
                } else {
                    return self.$floor();
                }
            } else {
                return self.$with_precision("truncate", precision);
            }
        }, $Rational_truncate$25.$$arity = -1);
        return (Opal.def(self158, '$with_precision', $Rational_with_precision$26 = function $$with_precision(method, precision) {
            var self = this, p = nil, s = nil;
            if ($truthy($$($nesting, 'Integer')['$==='](precision))) {} else {
                self.$raise($$($nesting, 'TypeError'), "not an Integer");
            }
            p = 10['$**'](precision);
            s = $rb_times(self, p);
            if ($truthy($rb_lt(precision, 1))) {
                return $rb_divide(s.$send(method), p).$to_i();
            } else {
                return self.$Rational(s.$send(method), p);
            }
        }, $Rational_with_precision$26.$$arity = 2), nil) && 'with_precision';
    })($nesting35[0], $$($nesting35, 'Numeric'), $nesting35);
    (function($base, $parent_nesting) {
        var self = $module($base, 'Kernel');
        var $nesting = [
            self
        ].concat($parent_nesting), $Kernel_Rational$27;
        return (Opal.def(self, '$Rational', $Kernel_Rational$27 = function $$Rational(numerator, denominator) {
            if (denominator == null) {
                denominator = 1;
            }
            return $$($nesting, 'Rational').$convert(numerator, denominator);
        }, $Kernel_Rational$27.$$arity = -2), nil) && 'Rational';
    })($nesting35[0], $nesting35);
    return function($base, $super, $parent_nesting) {
        var self159 = $klass($base, $super, 'String');
        var $nesting = [
            self159
        ].concat($parent_nesting), $String_to_r$28;
        return (Opal.def(self159, '$to_r', $String_to_r$28 = function $$to_r() {
            var self = this;
            var str = self.trimLeft(), re = /^[+-]?[\d_]+(\.[\d_]+)?/, match2 = str.match(re), numerator, denominator;
            function isFloat() {
                return re.test(str);
            }
            function cutFloat() {
                var match = str.match(re);
                var number = match[0];
                str = str.slice(number.length);
                return number.replace(/_/g, '');
            }
            if (isFloat()) {
                numerator = parseFloat(cutFloat());
                if (str[0] === '/') {
                    str = str.slice(1);
                    if (isFloat()) {
                        denominator = parseFloat(cutFloat());
                        return self.$Rational(numerator, denominator);
                    } else {
                        return self.$Rational(numerator, 1);
                    }
                } else {
                    return self.$Rational(numerator, 1);
                }
            } else {
                return self.$Rational(0, 1);
            }
        }, $String_to_r$28.$$arity = 0), nil) && 'to_r';
    }($nesting35[0], null, $nesting35);
};
Opal.modules["corelib/time"] = function(Opal) {
    function $rb_gt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs > rhs : lhs['$>'](rhs);
    }
    function $rb_lt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs < rhs : lhs['$<'](rhs);
    }
    function $rb_plus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
    }
    function $rb_divide(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs / rhs : lhs['$/'](rhs);
    }
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    function $rb_le(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs <= rhs : lhs['$<='](rhs);
    }
    var self160 = Opal.top, $nesting36 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range;
    Opal.add_stubs([
        '$require',
        '$include',
        '$===',
        '$raise',
        '$coerce_to!',
        '$respond_to?',
        '$to_str',
        '$to_i',
        '$new',
        '$<=>',
        '$to_f',
        '$nil?',
        '$>',
        '$<',
        '$strftime',
        '$year',
        '$month',
        '$day',
        '$+',
        '$round',
        '$/',
        '$-',
        '$copy_instance_variables',
        '$initialize_dup',
        '$is_a?',
        '$zero?',
        '$wday',
        '$utc?',
        '$mon',
        '$yday',
        '$hour',
        '$min',
        '$sec',
        '$rjust',
        '$ljust',
        '$zone',
        '$to_s',
        '$[]',
        '$cweek_cyear',
        '$isdst',
        '$<=',
        '$!=',
        '$==',
        '$ceil'
    ]);
    self160.$require("corelib/comparable");
    return function($base, $super, $parent_nesting15) {
        var self161 = $klass($base, $super, 'Time');
        var $nesting = [
            self161
        ].concat($parent_nesting15), $Time_at$1, $Time_new$2, $Time_local$3, $Time_gm$4, $Time_now$5, $Time_$plus$6, $Time_$minus$7, $Time_$lt_eq_gt$8, $Time_$eq_eq$9, $Time_asctime$10, $Time_day$11, $Time_yday$12, $Time_isdst$13, $Time_dup$14, $Time_eql$ques$15, $Time_friday$ques$16, $Time_hash$17, $Time_hour$18, $Time_inspect$19, $Time_min$20, $Time_mon$21, $Time_monday$ques$22, $Time_saturday$ques$23, $Time_sec$24, $Time_succ$25, $Time_usec$26, $Time_zone$27, $Time_getgm$28, $Time_gmtime$29, $Time_gmt$ques$30, $Time_gmt_offset$31, $Time_strftime$32, $Time_sunday$ques$33, $Time_thursday$ques$34, $Time_to_a$35, $Time_to_f$36, $Time_to_i$37, $Time_tuesday$ques$38, $Time_wday$39, $Time_wednesday$ques$40, $Time_year$41, $Time_cweek_cyear$42;
        self161.$include($$($nesting, 'Comparable'));
        var days_of_week = [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday",
            "Sunday"
        ], short_days = [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
        ], short_months = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
        ], long_months = [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
        ];
        Opal.defs(self161, '$at', $Time_at$1 = function $$at(seconds, frac) {
            var self = this;
            var result;
            if ($$($nesting, 'Time')['$==='](seconds)) {
                if (frac !== undefined) {
                    self.$raise($$($nesting, 'TypeError'), "can't convert Time into an exact number");
                }
                result = new Date(seconds.getTime());
                result.is_utc = seconds.is_utc;
                return result;
            }
            if (!seconds.$$is_number) {
                seconds = $$($nesting, 'Opal')['$coerce_to!'](seconds, $$($nesting, 'Integer'), "to_int");
            }
            if (frac === undefined) {
                return new Date(seconds * 1000);
            }
            if (!frac.$$is_number) {
                frac = $$($nesting, 'Opal')['$coerce_to!'](frac, $$($nesting, 'Integer'), "to_int");
            }
            return new Date(seconds * 1000 + frac / 1000);
        }, $Time_at$1.$$arity = -2);
        function time_params(year, month, day, hour, min28, sec) {
            if (year.$$is_string) {
                year = parseInt(year, 10);
            } else {
                year = $$($nesting, 'Opal')['$coerce_to!'](year, $$($nesting, 'Integer'), "to_int");
            }
            if (month === nil) {
                month = 1;
            } else if (!month.$$is_number) {
                if (month['$respond_to?']("to_str")) {
                    month = month.$to_str();
                    switch(month.toLowerCase()){
                        case 'jan':
                            month = 1;
                            break;
                        case 'feb':
                            month = 2;
                            break;
                        case 'mar':
                            month = 3;
                            break;
                        case 'apr':
                            month = 4;
                            break;
                        case 'may':
                            month = 5;
                            break;
                        case 'jun':
                            month = 6;
                            break;
                        case 'jul':
                            month = 7;
                            break;
                        case 'aug':
                            month = 8;
                            break;
                        case 'sep':
                            month = 9;
                            break;
                        case 'oct':
                            month = 10;
                            break;
                        case 'nov':
                            month = 11;
                            break;
                        case 'dec':
                            month = 12;
                            break;
                        default:
                            month = month.$to_i();
                    }
                } else {
                    month = $$($nesting, 'Opal')['$coerce_to!'](month, $$($nesting, 'Integer'), "to_int");
                }
            }
            if (month < 1 || month > 12) {
                self161.$raise($$($nesting, 'ArgumentError'), "" + "month out of range: " + month);
            }
            month = month - 1;
            if (day === nil) {
                day = 1;
            } else if (day.$$is_string) {
                day = parseInt(day, 10);
            } else {
                day = $$($nesting, 'Opal')['$coerce_to!'](day, $$($nesting, 'Integer'), "to_int");
            }
            if (day < 1 || day > 31) {
                self161.$raise($$($nesting, 'ArgumentError'), "" + "day out of range: " + day);
            }
            if (hour === nil) {
                hour = 0;
            } else if (hour.$$is_string) {
                hour = parseInt(hour, 10);
            } else {
                hour = $$($nesting, 'Opal')['$coerce_to!'](hour, $$($nesting, 'Integer'), "to_int");
            }
            if (hour < 0 || hour > 24) {
                self161.$raise($$($nesting, 'ArgumentError'), "" + "hour out of range: " + hour);
            }
            if (min28 === nil) {
                min28 = 0;
            } else if (min28.$$is_string) {
                min28 = parseInt(min28, 10);
            } else {
                min28 = $$($nesting, 'Opal')['$coerce_to!'](min28, $$($nesting, 'Integer'), "to_int");
            }
            if (min28 < 0 || min28 > 59) {
                self161.$raise($$($nesting, 'ArgumentError'), "" + "min out of range: " + min28);
            }
            if (sec === nil) {
                sec = 0;
            } else if (!sec.$$is_number) {
                if (sec.$$is_string) {
                    sec = parseInt(sec, 10);
                } else {
                    sec = $$($nesting, 'Opal')['$coerce_to!'](sec, $$($nesting, 'Integer'), "to_int");
                }
            }
            if (sec < 0 || sec > 60) {
                self161.$raise($$($nesting, 'ArgumentError'), "" + "sec out of range: " + sec);
            }
            return [
                year,
                month,
                day,
                hour,
                min28,
                sec
            ];
        }
        Opal.defs(self161, '$new', $Time_new$2 = function(year, month, day, hour, min29, sec, utc_offset) {
            var self = this;
            if (month == null) {
                month = nil;
            }
            if (day == null) {
                day = nil;
            }
            if (hour == null) {
                hour = nil;
            }
            if (min29 == null) {
                min29 = nil;
            }
            if (sec == null) {
                sec = nil;
            }
            if (utc_offset == null) {
                utc_offset = nil;
            }
            var args79, result;
            if (year === undefined) {
                return new Date();
            }
            if (utc_offset !== nil) {
                self.$raise($$($nesting, 'ArgumentError'), "Opal does not support explicitly specifying UTC offset for Time");
            }
            args79 = time_params(year, month, day, hour, min29, sec);
            year = args79[0];
            month = args79[1];
            day = args79[2];
            hour = args79[3];
            min29 = args79[4];
            sec = args79[5];
            result = new Date(year, month, day, hour, min29, 0, sec * 1000);
            if (year < 100) {
                result.setFullYear(year);
            }
            return result;
        }, $Time_new$2.$$arity = -1);
        Opal.defs(self161, '$local', $Time_local$3 = function $$local(year, month, day, hour, min30, sec, millisecond, _dummy1, _dummy2, _dummy3) {
            if (month == null) {
                month = nil;
            }
            if (day == null) {
                day = nil;
            }
            if (hour == null) {
                hour = nil;
            }
            if (min30 == null) {
                min30 = nil;
            }
            if (sec == null) {
                sec = nil;
            }
            if (millisecond == null) {
                millisecond = nil;
            }
            if (_dummy1 == null) {
                _dummy1 = nil;
            }
            if (_dummy2 == null) {
                _dummy2 = nil;
            }
            if (_dummy3 == null) {
                _dummy3 = nil;
            }
            var args80, result;
            if (arguments.length === 10) {
                args80 = $slice.call(arguments);
                year = args80[5];
                month = args80[4];
                day = args80[3];
                hour = args80[2];
                min30 = args80[1];
                sec = args80[0];
            }
            args80 = time_params(year, month, day, hour, min30, sec);
            year = args80[0];
            month = args80[1];
            day = args80[2];
            hour = args80[3];
            min30 = args80[4];
            sec = args80[5];
            result = new Date(year, month, day, hour, min30, 0, sec * 1000);
            if (year < 100) {
                result.setFullYear(year);
            }
            return result;
        }, $Time_local$3.$$arity = -2);
        Opal.defs(self161, '$gm', $Time_gm$4 = function $$gm(year, month, day, hour, min31, sec, millisecond, _dummy1, _dummy2, _dummy3) {
            if (month == null) {
                month = nil;
            }
            if (day == null) {
                day = nil;
            }
            if (hour == null) {
                hour = nil;
            }
            if (min31 == null) {
                min31 = nil;
            }
            if (sec == null) {
                sec = nil;
            }
            if (millisecond == null) {
                millisecond = nil;
            }
            if (_dummy1 == null) {
                _dummy1 = nil;
            }
            if (_dummy2 == null) {
                _dummy2 = nil;
            }
            if (_dummy3 == null) {
                _dummy3 = nil;
            }
            var args81, result;
            if (arguments.length === 10) {
                args81 = $slice.call(arguments);
                year = args81[5];
                month = args81[4];
                day = args81[3];
                hour = args81[2];
                min31 = args81[1];
                sec = args81[0];
            }
            args81 = time_params(year, month, day, hour, min31, sec);
            year = args81[0];
            month = args81[1];
            day = args81[2];
            hour = args81[3];
            min31 = args81[4];
            sec = args81[5];
            result = new Date(Date.UTC(year, month, day, hour, min31, 0, sec * 1000));
            if (year < 100) {
                result.setUTCFullYear(year);
            }
            result.is_utc = true;
            return result;
        }, $Time_gm$4.$$arity = -2);
        (function(self, $parent_nesting) {
            [
                self
            ].concat($parent_nesting);
            Opal.alias(self, "mktime", "local");
            return Opal.alias(self, "utc", "gm");
        })(Opal.get_singleton_class(self161), $nesting);
        Opal.defs(self161, '$now', $Time_now$5 = function $$now() {
            var self = this;
            return self.$new();
        }, $Time_now$5.$$arity = 0);
        Opal.def(self161, '$+', $Time_$plus$6 = function(other) {
            var self = this;
            if ($truthy($$($nesting, 'Time')['$==='](other))) {
                self.$raise($$($nesting, 'TypeError'), "time + time?");
            }
            if (!other.$$is_number) {
                other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Integer'), "to_int");
            }
            var result = new Date(self.getTime() + other * 1000);
            result.is_utc = self.is_utc;
            return result;
        }, $Time_$plus$6.$$arity = 1);
        Opal.def(self161, '$-', $Time_$minus$7 = function(other) {
            var self = this;
            if ($truthy($$($nesting, 'Time')['$==='](other))) {
                return (self.getTime() - other.getTime()) / 1000;
            }
            if (!other.$$is_number) {
                other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Integer'), "to_int");
            }
            var result = new Date(self.getTime() - other * 1000);
            result.is_utc = self.is_utc;
            return result;
        }, $Time_$minus$7.$$arity = 1);
        Opal.def(self161, '$<=>', $Time_$lt_eq_gt$8 = function(other) {
            var self = this, r = nil;
            if ($truthy($$($nesting, 'Time')['$==='](other))) {
                return self.$to_f()['$<=>'](other.$to_f());
            } else {
                r = other['$<=>'](self);
                if ($truthy(r['$nil?']())) {
                    return nil;
                } else if ($truthy($rb_gt(r, 0))) {
                    return -1;
                } else if ($truthy($rb_lt(r, 0))) {
                    return 1;
                } else {
                    return 0;
                }
            }
        }, $Time_$lt_eq_gt$8.$$arity = 1);
        Opal.def(self161, '$==', $Time_$eq_eq$9 = function(other) {
            var self = this, $ret_or_1 = nil;
            if ($truthy($ret_or_1 = $$($nesting, 'Time')['$==='](other))) {
                return self.$to_f() === other.$to_f();
            } else {
                return $ret_or_1;
            }
        }, $Time_$eq_eq$9.$$arity = 1);
        Opal.def(self161, '$asctime', $Time_asctime$10 = function $$asctime() {
            var self = this;
            return self.$strftime("%a %b %e %H:%M:%S %Y");
        }, $Time_asctime$10.$$arity = 0);
        Opal.alias(self161, "ctime", "asctime");
        Opal.def(self161, '$day', $Time_day$11 = function $$day() {
            var self = this;
            return self.is_utc ? self.getUTCDate() : self.getDate();
        }, $Time_day$11.$$arity = 0);
        Opal.def(self161, '$yday', $Time_yday$12 = function $$yday() {
            var self = this, start_of_year = nil, start_of_day = nil, one_day = nil;
            start_of_year = $$($nesting, 'Time').$new(self.$year()).$to_i();
            start_of_day = $$($nesting, 'Time').$new(self.$year(), self.$month(), self.$day()).$to_i();
            one_day = 86400;
            return $rb_plus($rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(), 1);
        }, $Time_yday$12.$$arity = 0);
        Opal.def(self161, '$isdst', $Time_isdst$13 = function $$isdst() {
            var self = this;
            var jan = new Date(self.getFullYear(), 0, 1), jul = new Date(self.getFullYear(), 6, 1);
            return self.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
        }, $Time_isdst$13.$$arity = 0);
        Opal.alias(self161, "dst?", "isdst");
        Opal.def(self161, '$dup', $Time_dup$14 = function $$dup() {
            var self = this, copy8 = nil;
            copy8 = new Date(self.getTime());
            copy8.$copy_instance_variables(self);
            copy8.$initialize_dup(self);
            return copy8;
        }, $Time_dup$14.$$arity = 0);
        Opal.def(self161, '$eql?', $Time_eql$ques$15 = function(other) {
            var self = this, $ret_or_2 = nil;
            if ($truthy($ret_or_2 = other['$is_a?']($$($nesting, 'Time')))) {
                return self['$<=>'](other)['$zero?']();
            } else {
                return $ret_or_2;
            }
        }, $Time_eql$ques$15.$$arity = 1);
        Opal.def(self161, '$friday?', $Time_friday$ques$16 = function() {
            var self = this;
            return self.$wday() == 5;
        }, $Time_friday$ques$16.$$arity = 0);
        Opal.def(self161, '$hash', $Time_hash$17 = function $$hash() {
            var self = this;
            return 'Time:' + self.getTime();
        }, $Time_hash$17.$$arity = 0);
        Opal.def(self161, '$hour', $Time_hour$18 = function $$hour() {
            var self = this;
            return self.is_utc ? self.getUTCHours() : self.getHours();
        }, $Time_hour$18.$$arity = 0);
        Opal.def(self161, '$inspect', $Time_inspect$19 = function $$inspect() {
            var self = this;
            if ($truthy(self['$utc?']())) {
                return self.$strftime("%Y-%m-%d %H:%M:%S UTC");
            } else {
                return self.$strftime("%Y-%m-%d %H:%M:%S %z");
            }
        }, $Time_inspect$19.$$arity = 0);
        Opal.alias(self161, "mday", "day");
        Opal.def(self161, '$min', $Time_min$20 = function $$min() {
            var self = this;
            return self.is_utc ? self.getUTCMinutes() : self.getMinutes();
        }, $Time_min$20.$$arity = 0);
        Opal.def(self161, '$mon', $Time_mon$21 = function $$mon() {
            var self = this;
            return (self.is_utc ? self.getUTCMonth() : self.getMonth()) + 1;
        }, $Time_mon$21.$$arity = 0);
        Opal.def(self161, '$monday?', $Time_monday$ques$22 = function() {
            var self = this;
            return self.$wday() == 1;
        }, $Time_monday$ques$22.$$arity = 0);
        Opal.alias(self161, "month", "mon");
        Opal.def(self161, '$saturday?', $Time_saturday$ques$23 = function() {
            var self = this;
            return self.$wday() == 6;
        }, $Time_saturday$ques$23.$$arity = 0);
        Opal.def(self161, '$sec', $Time_sec$24 = function $$sec() {
            var self = this;
            return self.is_utc ? self.getUTCSeconds() : self.getSeconds();
        }, $Time_sec$24.$$arity = 0);
        Opal.def(self161, '$succ', $Time_succ$25 = function $$succ() {
            var self = this;
            var result = new Date(self.getTime() + 1000);
            result.is_utc = self.is_utc;
            return result;
        }, $Time_succ$25.$$arity = 0);
        Opal.def(self161, '$usec', $Time_usec$26 = function $$usec() {
            var self = this;
            return self.getMilliseconds() * 1000;
        }, $Time_usec$26.$$arity = 0);
        Opal.def(self161, '$zone', $Time_zone$27 = function $$zone() {
            var self = this;
            var string = self.toString(), result;
            if (string.indexOf('(') == -1) {
                result = string.match(/[A-Z]{3,4}/)[0];
            } else {
                result = string.match(/\((.+)\)(?:\s|$)/)[1];
            }
            if (result == "GMT" && /(GMT\W*\d{4})/.test(string)) {
                return RegExp.$1;
            } else {
                return result;
            }
        }, $Time_zone$27.$$arity = 0);
        Opal.def(self161, '$getgm', $Time_getgm$28 = function $$getgm() {
            var self = this;
            var result = new Date(self.getTime());
            result.is_utc = true;
            return result;
        }, $Time_getgm$28.$$arity = 0);
        Opal.alias(self161, "getutc", "getgm");
        Opal.def(self161, '$gmtime', $Time_gmtime$29 = function $$gmtime() {
            var self = this;
            self.is_utc = true;
            return self;
        }, $Time_gmtime$29.$$arity = 0);
        Opal.alias(self161, "utc", "gmtime");
        Opal.def(self161, '$gmt?', $Time_gmt$ques$30 = function() {
            var self = this;
            return self.is_utc === true;
        }, $Time_gmt$ques$30.$$arity = 0);
        Opal.def(self161, '$gmt_offset', $Time_gmt_offset$31 = function $$gmt_offset() {
            var self = this;
            return self.is_utc ? 0 : -self.getTimezoneOffset() * 60;
        }, $Time_gmt_offset$31.$$arity = 0);
        Opal.def(self161, '$strftime', $Time_strftime$32 = function $$strftime(format9) {
            var self = this;
            return format9.replace(/%([\-_#^0]*:{0,2})(\d+)?([EO]*)(.)/g, function(full, flags, width, _, conv) {
                var result = "", zero = flags.indexOf('0') !== -1, pad = flags.indexOf('-') === -1, blank = flags.indexOf('_') !== -1, upcase = flags.indexOf('^') !== -1, invert = flags.indexOf('#') !== -1, colons = (flags.match(':') || []).length;
                width = parseInt(width, 10);
                if (zero && blank) {
                    if (flags.indexOf('0') < flags.indexOf('_')) {
                        zero = false;
                    } else {
                        blank = false;
                    }
                }
                switch(conv){
                    case 'Y':
                        result += self.$year();
                        break;
                    case 'C':
                        zero = !blank;
                        result += Math.round(self.$year() / 100);
                        break;
                    case 'y':
                        zero = !blank;
                        result += self.$year() % 100;
                        break;
                    case 'm':
                        zero = !blank;
                        result += self.$mon();
                        break;
                    case 'B':
                        result += long_months[self.$mon() - 1];
                        break;
                    case 'b':
                    case 'h':
                        blank = !zero;
                        result += short_months[self.$mon() - 1];
                        break;
                    case 'd':
                        zero = !blank;
                        result += self.$day();
                        break;
                    case 'e':
                        blank = !zero;
                        result += self.$day();
                        break;
                    case 'j':
                        zero = !blank;
                        width = isNaN(width) ? 3 : width;
                        result += self.$yday();
                        break;
                    case 'H':
                        zero = !blank;
                        result += self.$hour();
                        break;
                    case 'k':
                        blank = !zero;
                        result += self.$hour();
                        break;
                    case 'I':
                        zero = !blank;
                        result += self.$hour() % 12 || 12;
                        break;
                    case 'l':
                        blank = !zero;
                        result += self.$hour() % 12 || 12;
                        break;
                    case 'P':
                        result += self.$hour() >= 12 ? "pm" : "am";
                        break;
                    case 'p':
                        result += self.$hour() >= 12 ? "PM" : "AM";
                        break;
                    case 'M':
                        zero = !blank;
                        result += self.$min();
                        break;
                    case 'S':
                        zero = !blank;
                        result += self.$sec();
                        break;
                    case 'L':
                        zero = !blank;
                        width = isNaN(width) ? 3 : width;
                        result += self.getMilliseconds();
                        break;
                    case 'N':
                        width = isNaN(width) ? 9 : width;
                        result += self.getMilliseconds().toString().$rjust(3, "0");
                        result = result.$ljust(width, "0");
                        break;
                    case 'z':
                        var offset = self.getTimezoneOffset(), hours = Math.floor(Math.abs(offset) / 60), minutes = Math.abs(offset) % 60;
                        result += offset < 0 ? "+" : "-";
                        result += hours < 10 ? "0" : "";
                        result += hours;
                        if (colons > 0) {
                            result += ":";
                        }
                        result += minutes < 10 ? "0" : "";
                        result += minutes;
                        if (colons > 1) {
                            result += ":00";
                        }
                        break;
                    case 'Z':
                        result += self.$zone();
                        break;
                    case 'A':
                        result += days_of_week[self.$wday()];
                        break;
                    case 'a':
                        result += short_days[self.$wday()];
                        break;
                    case 'u':
                        result += self.$wday() + 1;
                        break;
                    case 'w':
                        result += self.$wday();
                        break;
                    case 'V':
                        result += self.$cweek_cyear()['$[]'](0).$to_s().$rjust(2, "0");
                        break;
                    case 'G':
                        result += self.$cweek_cyear()['$[]'](1);
                        break;
                    case 'g':
                        result += self.$cweek_cyear()['$[]'](1)['$[]']($range(-2, -1, false));
                        break;
                    case 's':
                        result += self.$to_i();
                        break;
                    case 'n':
                        result += "\n";
                        break;
                    case 't':
                        result += "\t";
                        break;
                    case '%':
                        result += "%";
                        break;
                    case 'c':
                        result += self.$strftime("%a %b %e %T %Y");
                        break;
                    case 'D':
                    case 'x':
                        result += self.$strftime("%m/%d/%y");
                        break;
                    case 'F':
                        result += self.$strftime("%Y-%m-%d");
                        break;
                    case 'v':
                        result += self.$strftime("%e-%^b-%4Y");
                        break;
                    case 'r':
                        result += self.$strftime("%I:%M:%S %p");
                        break;
                    case 'R':
                        result += self.$strftime("%H:%M");
                        break;
                    case 'T':
                    case 'X':
                        result += self.$strftime("%H:%M:%S");
                        break;
                    default:
                        return full;
                }
                if (upcase) {
                    result = result.toUpperCase();
                }
                if (invert) {
                    result = result.replace(/[A-Z]/, function(c) {
                        c.toLowerCase();
                    }).replace(/[a-z]/, function(c) {
                        c.toUpperCase();
                    });
                }
                if (pad && (zero || blank)) {
                    result = result.$rjust(isNaN(width) ? 2 : width, blank ? " " : "0");
                }
                return result;
            });
        }, $Time_strftime$32.$$arity = 1);
        Opal.def(self161, '$sunday?', $Time_sunday$ques$33 = function() {
            var self = this;
            return self.$wday() == 0;
        }, $Time_sunday$ques$33.$$arity = 0);
        Opal.def(self161, '$thursday?', $Time_thursday$ques$34 = function() {
            var self = this;
            return self.$wday() == 4;
        }, $Time_thursday$ques$34.$$arity = 0);
        Opal.def(self161, '$to_a', $Time_to_a$35 = function $$to_a() {
            var self = this;
            return [
                self.$sec(),
                self.$min(),
                self.$hour(),
                self.$day(),
                self.$month(),
                self.$year(),
                self.$wday(),
                self.$yday(),
                self.$isdst(),
                self.$zone()
            ];
        }, $Time_to_a$35.$$arity = 0);
        Opal.def(self161, '$to_f', $Time_to_f$36 = function $$to_f() {
            var self = this;
            return self.getTime() / 1000;
        }, $Time_to_f$36.$$arity = 0);
        Opal.def(self161, '$to_i', $Time_to_i$37 = function $$to_i() {
            var self = this;
            return parseInt(self.getTime() / 1000, 10);
        }, $Time_to_i$37.$$arity = 0);
        Opal.alias(self161, "to_s", "inspect");
        Opal.def(self161, '$tuesday?', $Time_tuesday$ques$38 = function() {
            var self = this;
            return self.$wday() == 2;
        }, $Time_tuesday$ques$38.$$arity = 0);
        Opal.alias(self161, "tv_sec", "to_i");
        Opal.alias(self161, "tv_usec", "usec");
        Opal.alias(self161, "utc?", "gmt?");
        Opal.alias(self161, "gmtoff", "gmt_offset");
        Opal.alias(self161, "utc_offset", "gmt_offset");
        Opal.def(self161, '$wday', $Time_wday$39 = function $$wday() {
            var self = this;
            return self.is_utc ? self.getUTCDay() : self.getDay();
        }, $Time_wday$39.$$arity = 0);
        Opal.def(self161, '$wednesday?', $Time_wednesday$ques$40 = function() {
            var self = this;
            return self.$wday() == 3;
        }, $Time_wednesday$ques$40.$$arity = 0);
        Opal.def(self161, '$year', $Time_year$41 = function $$year() {
            var self = this;
            return self.is_utc ? self.getUTCFullYear() : self.getFullYear();
        }, $Time_year$41.$$arity = 0);
        return (Opal.def(self161, '$cweek_cyear', $Time_cweek_cyear$42 = function $$cweek_cyear() {
            var self = this, jan01 = nil, jan01_wday = nil, year = nil, $ret_or_3 = nil, offset = nil, week = nil, dec31 = nil, dec31_wday = nil, $ret_or_4 = nil;
            jan01 = $$($nesting, 'Time').$new(self.$year(), 1, 1);
            jan01_wday = jan01.$wday();
            year = self.$year();
            if ($truthy(function() {
                if ($truthy($ret_or_3 = $rb_le(jan01_wday, 4))) {
                    return jan01_wday['$!='](0);
                } else {
                    return $ret_or_3;
                }
                return nil;
            }())) {
                offset = $rb_minus(jan01_wday, 1);
            } else {
                offset = $rb_minus($rb_minus(jan01_wday, 7), 1);
                if (offset['$=='](-8)) {
                    offset = -1;
                }
            }
            week = $rb_divide($rb_plus(self.$yday(), offset), 7.0).$ceil();
            if ($truthy($rb_le(week, 0))) {
                return $$($nesting, 'Time').$new($rb_minus(self.$year(), 1), 12, 31).$cweek_cyear();
            } else if (week['$=='](53)) {
                dec31 = $$($nesting, 'Time').$new(self.$year(), 12, 31);
                dec31_wday = dec31.$wday();
                if ($truthy(function() {
                    if ($truthy($ret_or_4 = $rb_le(dec31_wday, 3))) {
                        return dec31_wday['$!='](0);
                    } else {
                        return $ret_or_4;
                    }
                    return nil;
                }())) {
                    week = 1;
                    year = $rb_plus(year, 1);
                }
            }
            return [
                week,
                year
            ];
        }, $Time_cweek_cyear$42.$$arity = 0), nil) && 'cweek_cyear';
    }($nesting36[0], Date, $nesting36);
};
Opal.modules["corelib/struct"] = function(Opal) {
    function $rb_gt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs > rhs : lhs['$>'](rhs);
    }
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    function $rb_lt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs < rhs : lhs['$<'](rhs);
    }
    function $rb_ge(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs >= rhs : lhs['$>='](rhs);
    }
    function $rb_plus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
    }
    var self162 = Opal.top, $nesting37 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;
    Opal.add_stubs([
        '$require',
        '$include',
        '$const_name!',
        '$unshift',
        '$map',
        '$coerce_to!',
        '$new',
        '$each',
        '$define_struct_attribute',
        '$allocate',
        '$initialize',
        '$alias_method',
        '$module_eval',
        '$to_proc',
        '$const_set',
        '$==',
        '$raise',
        '$<<',
        '$members',
        '$define_method',
        '$instance_eval',
        '$class',
        '$last',
        '$>',
        '$length',
        '$-',
        '$keys',
        '$any?',
        '$join',
        '$[]',
        '$[]=',
        '$each_with_index',
        '$hash',
        '$===',
        '$<',
        '$-@',
        '$size',
        '$>=',
        '$include?',
        '$to_sym',
        '$instance_of?',
        '$__id__',
        '$eql?',
        '$enum_for',
        '$name',
        '$+',
        '$each_pair',
        '$inspect',
        '$to_h',
        '$args',
        '$each_with_object',
        '$flatten',
        '$to_a',
        '$respond_to?',
        '$dig'
    ]);
    self162.$require("corelib/enumerable");
    return function($base, $super, $parent_nesting16) {
        var self163 = $klass($base, $super, 'Struct');
        var $nesting = [
            self163
        ].concat($parent_nesting16), $Struct_new$1, $Struct_define_struct_attribute$6, $Struct_members$9, $Struct_inherited$10, $Struct_initialize$12, $Struct_initialize_copy$15, $Struct_members$16, $Struct_hash$17, $Struct_$$$18, $Struct_$$$eq$19, $Struct_$eq_eq$20, $Struct_eql$ques$21, $Struct_each$22, $Struct_each_pair$25, $Struct_length$28, $Struct_to_a$29, $Struct_inspect$31, $Struct_to_h$33, $Struct_values_at$35, $Struct_dig$37;
        self163.$include($$($nesting, 'Enumerable'));
        Opal.defs(self163, '$new', $Struct_new$1 = function(const_name, $a, $b) {
            var $iter = $Struct_new$1.$$p, block = $iter || nil, $post_args2, $kwargs, args1, keyword_init, $$2, $$3, self164 = this, klass = nil;
            if ($iter) $Struct_new$1.$$p = null;
            if ($iter) $Struct_new$1.$$p = null;
            $post_args2 = Opal.slice.call(arguments, 1, arguments.length);
            $kwargs = Opal.extract_kwargs($post_args2);
            if ($kwargs == null) {
                $kwargs = $hash2([], {});
            } else if (!$kwargs.$$is_hash) {
                throw Opal.ArgumentError.$new('expected kwargs');
            }
            args1 = $post_args2;
            keyword_init = $kwargs.$$smap["keyword_init"];
            if (keyword_init == null) {
                keyword_init = false;
            }
            if ($truthy(const_name)) {
                try {
                    const_name = $$($nesting, 'Opal')['$const_name!'](const_name);
                } catch ($err) {
                    if (Opal.rescue($err, [
                        $$($nesting, 'TypeError'),
                        $$($nesting, 'NameError')
                    ])) {
                        try {
                            args1.$unshift(const_name);
                            const_name = nil;
                        } finally{
                            Opal.pop_exception();
                        }
                    } else {
                        throw $err;
                    }
                }
            }
            $send(args1, 'map', [], ($$2 = function(arg) {
                $$2.$$s == null ? this : $$2.$$s;
                if (arg == null) {
                    arg = nil;
                }
                return $$($nesting, 'Opal')['$coerce_to!'](arg, $$($nesting, 'String'), "to_str");
            }, $$2.$$s = self164, $$2.$$arity = 1, $$2));
            klass = $send($$($nesting, 'Class'), 'new', [
                self164
            ], ($$3 = function() {
                var self165 = $$3.$$s == null ? this : $$3.$$s, $$4;
                $send(args1, 'each', [], ($$4 = function(arg) {
                    var self = $$4.$$s == null ? this : $$4.$$s;
                    if (arg == null) {
                        arg = nil;
                    }
                    return self.$define_struct_attribute(arg);
                }, $$4.$$s = self165, $$4.$$arity = 1, $$4));
                return function(self166, $parent_nesting) {
                    var $nesting = [
                        self166
                    ].concat($parent_nesting), $new$5;
                    Opal.def(self166, '$new', $new$5 = function($a) {
                        var $post_args, args82, self = this, instance = nil;
                        $post_args = Opal.slice.call(arguments, 0, arguments.length);
                        args82 = $post_args;
                        instance = self.$allocate();
                        instance.$$data = {};
                        $send(instance, 'initialize', Opal.to_a(args82));
                        return instance;
                    }, $new$5.$$arity = -1);
                    return self166.$alias_method("[]", "new");
                }(Opal.get_singleton_class(self165), $nesting);
            }, $$3.$$s = self164, $$3.$$arity = 0, $$3));
            if ($truthy(block)) {
                $send(klass, 'module_eval', [], block.$to_proc());
            }
            klass.$$keyword_init = keyword_init;
            if ($truthy(const_name)) {
                $$($nesting, 'Struct').$const_set(const_name, klass);
            }
            return klass;
        }, $Struct_new$1.$$arity = -2);
        Opal.defs(self163, '$define_struct_attribute', $Struct_define_struct_attribute$6 = function $$define_struct_attribute(name118) {
            var $$7, $$8, self167 = this;
            if (self167['$==']($$($nesting, 'Struct'))) {
                self167.$raise($$($nesting, 'ArgumentError'), "you cannot define attributes to the Struct class");
            }
            self167.$members()['$<<'](name118);
            $send(self167, 'define_method', [
                name118
            ], ($$7 = function() {
                var self = $$7.$$s == null ? this : $$7.$$s;
                return self.$$data[name118];
            }, $$7.$$s = self167, $$7.$$arity = 0, $$7));
            return $send(self167, 'define_method', [
                "" + name118 + "="
            ], ($$8 = function(value) {
                var self = $$8.$$s == null ? this : $$8.$$s;
                if (value == null) {
                    value = nil;
                }
                return self.$$data[name118] = value;
            }, $$8.$$s = self167, $$8.$$arity = 1, $$8));
        }, $Struct_define_struct_attribute$6.$$arity = 1);
        Opal.defs(self163, '$members', $Struct_members$9 = function $$members() {
            var self = this, $ret_or_1 = nil;
            if (self.members == null) self.members = nil;
            if (self['$==']($$($nesting, 'Struct'))) {
                self.$raise($$($nesting, 'ArgumentError'), "the Struct class has no members");
            }
            return self.members = function() {
                if ($truthy($ret_or_1 = self.members)) {
                    return $ret_or_1;
                } else {
                    return [];
                }
                return nil;
            }();
        }, $Struct_members$9.$$arity = 0);
        Opal.defs(self163, '$inherited', $Struct_inherited$10 = function $$inherited(klass) {
            var $$11, self168 = this, members = nil;
            if (self168.members == null) self168.members = nil;
            members = self168.members;
            return $send(klass, 'instance_eval', [], ($$11 = function() {
                var self = $$11.$$s == null ? this : $$11.$$s;
                return self.members = members;
            }, $$11.$$s = self168, $$11.$$arity = 0, $$11));
        }, $Struct_inherited$10.$$arity = 1);
        Opal.def(self163, '$initialize', $Struct_initialize$12 = function $$initialize($a) {
            var $post_args, args83, $$13, $$14, self169 = this, kwargs = nil, $ret_or_2 = nil, $ret_or_3 = nil, extra = nil;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args83 = $post_args;
            if ($truthy(self169.$class().$$keyword_init)) {
                kwargs = function() {
                    if ($truthy($ret_or_2 = args83.$last())) {
                        return $ret_or_2;
                    } else {
                        return $hash2([], {});
                    }
                    return nil;
                }();
                if ($truthy(function() {
                    if ($truthy($ret_or_3 = $rb_gt(args83.$length(), 1))) {
                        return $ret_or_3;
                    } else {
                        return args83.length === 1 && !kwargs.$$is_hash;
                    }
                    return nil;
                }())) {
                    self169.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (given " + args83.$length() + ", expected 0)");
                }
                extra = $rb_minus(kwargs.$keys(), self169.$class().$members());
                if ($truthy(extra['$any?']())) {
                    self169.$raise($$($nesting, 'ArgumentError'), "" + "unknown keywords: " + extra.$join(", "));
                }
                return $send(self169.$class().$members(), 'each', [], ($$13 = function(name119) {
                    var self = $$13.$$s == null ? this : $$13.$$s, $writer = nil;
                    if (name119 == null) {
                        name119 = nil;
                    }
                    $writer = [
                        name119,
                        kwargs['$[]'](name119)
                    ];
                    $send(self, '[]=', Opal.to_a($writer));
                    return $writer[$rb_minus($writer["length"], 1)];
                }, $$13.$$s = self169, $$13.$$arity = 1, $$13));
            } else {
                if ($truthy($rb_gt(args83.$length(), self169.$class().$members().$length()))) {
                    self169.$raise($$($nesting, 'ArgumentError'), "struct size differs");
                }
                return $send(self169.$class().$members(), 'each_with_index', [], ($$14 = function(name120, index) {
                    var self = $$14.$$s == null ? this : $$14.$$s, $writer = nil;
                    if (name120 == null) {
                        name120 = nil;
                    }
                    if (index == null) {
                        index = nil;
                    }
                    $writer = [
                        name120,
                        args83['$[]'](index)
                    ];
                    $send(self, '[]=', Opal.to_a($writer));
                    return $writer[$rb_minus($writer["length"], 1)];
                }, $$14.$$s = self169, $$14.$$arity = 2, $$14));
            }
        }, $Struct_initialize$12.$$arity = -1);
        Opal.def(self163, '$initialize_copy', $Struct_initialize_copy$15 = function $$initialize_copy(from) {
            var self = this;
            self.$$data = {};
            var keys = Object.keys(from.$$data), i300, max, name121;
            for(i300 = 0, max = keys.length; i300 < max; i300++){
                name121 = keys[i300];
                self.$$data[name121] = from.$$data[name121];
            }
        }, $Struct_initialize_copy$15.$$arity = 1);
        Opal.def(self163, '$members', $Struct_members$16 = function $$members() {
            var self = this;
            return self.$class().$members();
        }, $Struct_members$16.$$arity = 0);
        Opal.def(self163, '$hash', $Struct_hash$17 = function $$hash() {
            var self = this;
            return $$($nesting, 'Hash').$new(self.$$data).$hash();
        }, $Struct_hash$17.$$arity = 0);
        Opal.def(self163, '$[]', $Struct_$$$18 = function(name122) {
            var self = this;
            if ($truthy($$($nesting, 'Integer')['$==='](name122))) {
                if ($truthy($rb_lt(name122, self.$class().$members().$size()['$-@']()))) {
                    self.$raise($$($nesting, 'IndexError'), "" + "offset " + name122 + " too small for struct(size:" + self.$class().$members().$size() + ")");
                }
                if ($truthy($rb_ge(name122, self.$class().$members().$size()))) {
                    self.$raise($$($nesting, 'IndexError'), "" + "offset " + name122 + " too large for struct(size:" + self.$class().$members().$size() + ")");
                }
                name122 = self.$class().$members()['$[]'](name122);
            } else if ($truthy($$($nesting, 'String')['$==='](name122))) {
                if (!self.$$data.hasOwnProperty(name122)) {
                    self.$raise($$($nesting, 'NameError').$new("" + "no member '" + name122 + "' in struct", name122));
                }
            } else {
                self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + name122.$class() + " into Integer");
            }
            name122 = $$($nesting, 'Opal')['$coerce_to!'](name122, $$($nesting, 'String'), "to_str");
            return self.$$data[name122];
        }, $Struct_$$$18.$$arity = 1);
        Opal.def(self163, '$[]=', $Struct_$$$eq$19 = function(name123, value) {
            var self = this;
            if ($truthy($$($nesting, 'Integer')['$==='](name123))) {
                if ($truthy($rb_lt(name123, self.$class().$members().$size()['$-@']()))) {
                    self.$raise($$($nesting, 'IndexError'), "" + "offset " + name123 + " too small for struct(size:" + self.$class().$members().$size() + ")");
                }
                if ($truthy($rb_ge(name123, self.$class().$members().$size()))) {
                    self.$raise($$($nesting, 'IndexError'), "" + "offset " + name123 + " too large for struct(size:" + self.$class().$members().$size() + ")");
                }
                name123 = self.$class().$members()['$[]'](name123);
            } else if ($truthy($$($nesting, 'String')['$==='](name123))) {
                if ($truthy(self.$class().$members()['$include?'](name123.$to_sym()))) {} else {
                    self.$raise($$($nesting, 'NameError').$new("" + "no member '" + name123 + "' in struct", name123));
                }
            } else {
                self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + name123.$class() + " into Integer");
            }
            name123 = $$($nesting, 'Opal')['$coerce_to!'](name123, $$($nesting, 'String'), "to_str");
            return self.$$data[name123] = value;
        }, $Struct_$$$eq$19.$$arity = 2);
        Opal.def(self163, '$==', $Struct_$eq_eq$20 = function(other3) {
            var self = this;
            if ($truthy(other3['$instance_of?'](self.$class()))) {} else {
                return false;
            }
            var recursed1 = {}, recursed2 = {};
            function _eqeq(struct, other) {
                var key, a, b;
                recursed1[struct.$__id__()] = true;
                recursed2[other.$__id__()] = true;
                for(key in struct.$$data){
                    a = struct.$$data[key];
                    b = other.$$data[key];
                    if ($$($nesting, 'Struct')['$==='](a)) {
                        if (!recursed1.hasOwnProperty(a.$__id__()) || !recursed2.hasOwnProperty(b.$__id__())) {
                            if (!_eqeq(a, b)) {
                                return false;
                            }
                        }
                    } else {
                        if (!a['$=='](b)) {
                            return false;
                        }
                    }
                }
                return true;
            }
            return _eqeq(self, other3);
        }, $Struct_$eq_eq$20.$$arity = 1);
        Opal.def(self163, '$eql?', $Struct_eql$ques$21 = function(other4) {
            var self = this;
            if ($truthy(other4['$instance_of?'](self.$class()))) {} else {
                return false;
            }
            var recursed1 = {}, recursed2 = {};
            function _eqeq(struct, other) {
                var key, a, b;
                recursed1[struct.$__id__()] = true;
                recursed2[other.$__id__()] = true;
                for(key in struct.$$data){
                    a = struct.$$data[key];
                    b = other.$$data[key];
                    if ($$($nesting, 'Struct')['$==='](a)) {
                        if (!recursed1.hasOwnProperty(a.$__id__()) || !recursed2.hasOwnProperty(b.$__id__())) {
                            if (!_eqeq(a, b)) {
                                return false;
                            }
                        }
                    } else {
                        if (!a['$eql?'](b)) {
                            return false;
                        }
                    }
                }
                return true;
            }
            return _eqeq(self, other4);
        }, $Struct_eql$ques$21.$$arity = 1);
        Opal.def(self163, '$each', $Struct_each$22 = function $$each() {
            var $$23, $$24, $iter = $Struct_each$22.$$p, $yield = $iter || nil, self170 = this;
            if ($iter) $Struct_each$22.$$p = null;
            if ($yield !== nil) {} else {
                return $send(self170, 'enum_for', [
                    "each"
                ], ($$23 = function() {
                    var self = $$23.$$s == null ? this : $$23.$$s;
                    return self.$size();
                }, $$23.$$s = self170, $$23.$$arity = 0, $$23));
            }
            $send(self170.$class().$members(), 'each', [], ($$24 = function(name124) {
                var self = $$24.$$s == null ? this : $$24.$$s;
                if (name124 == null) {
                    name124 = nil;
                }
                return Opal.yield1($yield, self['$[]'](name124));
            }, $$24.$$s = self170, $$24.$$arity = 1, $$24));
            return self170;
        }, $Struct_each$22.$$arity = 0);
        Opal.def(self163, '$each_pair', $Struct_each_pair$25 = function $$each_pair() {
            var $$26, $$27, $iter = $Struct_each_pair$25.$$p, $yield = $iter || nil, self171 = this;
            if ($iter) $Struct_each_pair$25.$$p = null;
            if ($yield !== nil) {} else {
                return $send(self171, 'enum_for', [
                    "each_pair"
                ], ($$26 = function() {
                    var self = $$26.$$s == null ? this : $$26.$$s;
                    return self.$size();
                }, $$26.$$s = self171, $$26.$$arity = 0, $$26));
            }
            $send(self171.$class().$members(), 'each', [], ($$27 = function(name125) {
                var self = $$27.$$s == null ? this : $$27.$$s;
                if (name125 == null) {
                    name125 = nil;
                }
                return Opal.yield1($yield, [
                    name125,
                    self['$[]'](name125)
                ]);
            }, $$27.$$s = self171, $$27.$$arity = 1, $$27));
            return self171;
        }, $Struct_each_pair$25.$$arity = 0);
        Opal.def(self163, '$length', $Struct_length$28 = function $$length() {
            var self = this;
            return self.$class().$members().$length();
        }, $Struct_length$28.$$arity = 0);
        Opal.alias(self163, "size", "length");
        Opal.def(self163, '$to_a', $Struct_to_a$29 = function $$to_a() {
            var $$30, self172 = this;
            return $send(self172.$class().$members(), 'map', [], ($$30 = function(name126) {
                var self = $$30.$$s == null ? this : $$30.$$s;
                if (name126 == null) {
                    name126 = nil;
                }
                return self['$[]'](name126);
            }, $$30.$$s = self172, $$30.$$arity = 1, $$30));
        }, $Struct_to_a$29.$$arity = 0);
        Opal.alias(self163, "values", "to_a");
        Opal.def(self163, '$inspect', $Struct_inspect$31 = function $$inspect() {
            var $$32, self = this, result = nil, $ret_or_4 = nil;
            result = "#<struct ";
            if ($truthy(function() {
                if ($truthy($ret_or_4 = $$($nesting, 'Struct')['$==='](self))) {
                    return self.$class().$name();
                } else {
                    return $ret_or_4;
                }
                return nil;
            }())) {
                result = $rb_plus(result, "" + self.$class() + " ");
            }
            result = $rb_plus(result, $send(self.$each_pair(), 'map', [], ($$32 = function(name127, value) {
                $$32.$$s == null ? this : $$32.$$s;
                if (name127 == null) {
                    name127 = nil;
                }
                if (value == null) {
                    value = nil;
                }
                return "" + name127 + "=" + value.$inspect();
            }, $$32.$$s = self, $$32.$$arity = 2, $$32)).$join(", "));
            result = $rb_plus(result, ">");
            return result;
        }, $Struct_inspect$31.$$arity = 0);
        Opal.alias(self163, "to_s", "inspect");
        Opal.def(self163, '$to_h', $Struct_to_h$33 = function $$to_h() {
            var $iter = $Struct_to_h$33.$$p, block = $iter || nil, $$34, self173 = this;
            if ($iter) $Struct_to_h$33.$$p = null;
            if ($iter) $Struct_to_h$33.$$p = null;
            if (block !== nil) {
                return $send($send(self173, 'map', [], block.$to_proc()), 'to_h', Opal.to_a(self173.$args()));
            }
            return $send(self173.$class().$members(), 'each_with_object', [
                $hash2([], {})
            ], ($$34 = function(name128, h) {
                var self = $$34.$$s == null ? this : $$34.$$s, $writer = nil;
                if (name128 == null) {
                    name128 = nil;
                }
                if (h == null) {
                    h = nil;
                }
                $writer = [
                    name128,
                    self['$[]'](name128)
                ];
                $send(h, '[]=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];
            }, $$34.$$s = self173, $$34.$$arity = 2, $$34));
        }, $Struct_to_h$33.$$arity = 0);
        Opal.def(self163, '$values_at', $Struct_values_at$35 = function $$values_at($a) {
            var $post_args, args84, $$36, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            args84 = $post_args;
            args84 = $send(args84, 'map', [], ($$36 = function(arg) {
                $$36.$$s == null ? this : $$36.$$s;
                if (arg == null) {
                    arg = nil;
                }
                return arg.$$is_range ? arg.$to_a() : arg;
            }, $$36.$$s = self, $$36.$$arity = 1, $$36)).$flatten();
            var result = [];
            for(var i301 = 0, len = args84.length; i301 < len; i301++){
                if (!args84[i301].$$is_number) {
                    self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + args84[i301].$class() + " into Integer");
                }
                result.push(self['$[]'](args84[i301]));
            }
            return result;
        }, $Struct_values_at$35.$$arity = -1);
        return (Opal.def(self163, '$dig', $Struct_dig$37 = function $$dig(key, $a) {
            var $post_args, keys, self = this, item = nil;
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            keys = $post_args;
            item = function() {
                if ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key))) {
                    return self.$$data[key] || nil;
                } else {
                    return nil;
                }
                return nil;
            }();
            if (item === nil || keys.length === 0) {
                return item;
            }
            if ($truthy(item['$respond_to?']("dig"))) {} else {
                self.$raise($$($nesting, 'TypeError'), "" + item.$class() + " does not have #dig method");
            }
            return $send(item, 'dig', Opal.to_a(keys));
        }, $Struct_dig$37.$$arity = -2), nil) && 'dig';
    }($nesting37[0], null, $nesting37);
};
Opal.modules["corelib/main"] = function(Opal) {
    var $to_s$1, $include$2, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;
    Opal.add_stubs([
        '$include'
    ]);
    Opal.defs(self, '$to_s', $to_s$1 = function $$to_s() {
        return "main";
    }, $to_s$1.$$arity = 0);
    return (Opal.defs(self, '$include', $include$2 = function $$include(mod66) {
        return $$($nesting, 'Object').$include(mod66);
    }, $include$2.$$arity = 1), nil) && 'include';
};
Opal.modules["corelib/dir"] = function(Opal) {
    var self174 = Opal.top, $nesting38 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy;
    Opal.add_stubs([
        '$[]'
    ]);
    return function($base, $super, $parent_nesting17) {
        var self175 = $klass($base, $super, 'Dir');
        var $nesting39 = [
            self175
        ].concat($parent_nesting17);
        return function(self, $parent_nesting) {
            var $nesting = [
                self
            ].concat($parent_nesting), $chdir$1, $pwd$2, $home$3;
            Opal.def(self, '$chdir', $chdir$1 = function $$chdir(dir) {
                var $iter = $chdir$1.$$p, $yield = $iter || nil, prev_cwd = nil;
                if ($iter) $chdir$1.$$p = null;
                return function() {
                    try {
                        prev_cwd = Opal.current_dir;
                        Opal.current_dir = dir;
                        return Opal.yieldX($yield, []);
                    } finally{
                        Opal.current_dir = prev_cwd;
                    }
                }();
            }, $chdir$1.$$arity = 1);
            Opal.def(self, '$pwd', $pwd$2 = function $$pwd() {
                return Opal.current_dir || '.';
            }, $pwd$2.$$arity = 0);
            Opal.alias(self, "getwd", "pwd");
            return (Opal.def(self, '$home', $home$3 = function $$home() {
                var $ret_or_1 = nil;
                if ($truthy($ret_or_1 = $$($nesting, 'ENV')['$[]']("HOME"))) {
                    return $ret_or_1;
                } else {
                    return ".";
                }
            }, $home$3.$$arity = 0), nil) && 'home';
        }(Opal.get_singleton_class(self175), $nesting39);
    }($nesting38[0], null, $nesting38);
};
Opal.modules["corelib/file"] = function(Opal) {
    function $rb_plus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
    }
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    var self176 = Opal.top, $nesting40 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $klass = Opal.klass, $range = Opal.range, $send = Opal.send;
    Opal.add_stubs([
        '$respond_to?',
        '$to_path',
        '$pwd',
        '$split',
        '$sub',
        '$+',
        '$unshift',
        '$join',
        '$home',
        '$raise',
        '$start_with?',
        '$absolute_path',
        '$coerce_to!',
        '$basename',
        '$empty?',
        '$rindex',
        '$[]',
        '$nil?',
        '$==',
        '$-',
        '$length',
        '$gsub',
        '$find',
        '$=~',
        '$map',
        '$each_with_index',
        '$flatten',
        '$reject',
        '$to_proc',
        '$end_with?'
    ]);
    return function($base, $super, $parent_nesting18) {
        var self177 = $klass($base, $super, 'File');
        var $nesting41 = [
            self177
        ].concat($parent_nesting18), windows_root_rx = nil;
        Opal.const_set($nesting41[0], 'Separator', Opal.const_set($nesting41[0], 'SEPARATOR', "/"));
        Opal.const_set($nesting41[0], 'ALT_SEPARATOR', nil);
        Opal.const_set($nesting41[0], 'PATH_SEPARATOR', ":");
        Opal.const_set($nesting41[0], 'FNM_SYSCASE', 0);
        windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
        return function(self178, $parent_nesting) {
            var $nesting = [
                self178
            ].concat($parent_nesting), $absolute_path$1, $expand_path$2, $dirname$3, $basename$4, $extname$5, $exist$ques$6, $directory$ques$7, $join$9, $split$12;
            Opal.def(self178, '$absolute_path', $absolute_path$1 = function $$absolute_path(path7, basedir) {
                var sep17 = nil, sep_chars = nil, new_parts = nil, $ret_or_1 = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;
                if (basedir == null) {
                    basedir = nil;
                }
                sep17 = $$($nesting, 'SEPARATOR');
                sep_chars = $sep_chars();
                new_parts = [];
                path7 = function() {
                    if ($truthy(path7['$respond_to?']("to_path"))) {
                        return path7.$to_path();
                    } else {
                        return path7;
                    }
                    return nil;
                }();
                basedir = function() {
                    if ($truthy($ret_or_1 = basedir)) {
                        return $ret_or_1;
                    } else {
                        return $$($nesting, 'Dir').$pwd();
                    }
                    return nil;
                }();
                path_abs = path7.substr(0, sep17.length) === sep17 || windows_root_rx.test(path7);
                basedir_abs = basedir.substr(0, sep17.length) === sep17 || windows_root_rx.test(basedir);
                if ($truthy(path_abs)) {
                    parts = path7.$split(Opal.regexp([
                        "[",
                        sep_chars,
                        "]"
                    ]));
                    leading_sep = windows_root_rx.test(path7) ? '' : path7.$sub(Opal.regexp([
                        "^([",
                        sep_chars,
                        "]+).*$"
                    ]), "\\1");
                    abs = true;
                } else {
                    parts = $rb_plus(basedir.$split(Opal.regexp([
                        "[",
                        sep_chars,
                        "]"
                    ])), path7.$split(Opal.regexp([
                        "[",
                        sep_chars,
                        "]"
                    ])));
                    leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub(Opal.regexp([
                        "^([",
                        sep_chars,
                        "]+).*$"
                    ]), "\\1");
                    abs = basedir_abs;
                }
                var part;
                for(var i302 = 0, ii = parts.length; i302 < ii; i302++){
                    part = parts[i302];
                    if (part === nil || part === '' && (new_parts.length === 0 || abs) || part === '.' && (new_parts.length === 0 || abs)) {
                        continue;
                    }
                    if (part === '..') {
                        new_parts.pop();
                    } else {
                        new_parts.push(part);
                    }
                }
                if (!abs && parts[0] !== '.') {
                    new_parts.$unshift(".");
                }
                new_path = new_parts.$join(sep17);
                if ($truthy(abs)) {
                    new_path = $rb_plus(leading_sep, new_path);
                }
                return new_path;
            }, $absolute_path$1.$$arity = -2);
            Opal.def(self178, '$expand_path', $expand_path$2 = function $$expand_path(path8, basedir) {
                var self = this, sep18 = nil, sep_chars = nil, home = nil, leading_sep = nil, home_path_regexp = nil;
                if (basedir == null) {
                    basedir = nil;
                }
                sep18 = $$($nesting, 'SEPARATOR');
                sep_chars = $sep_chars();
                if ($truthy(path8[0] === '~' || basedir && basedir[0] === '~')) {
                    home = $$($nesting, 'Dir').$home();
                    if ($truthy(home)) {} else {
                        self.$raise($$($nesting, 'ArgumentError'), "couldn't find HOME environment -- expanding `~'");
                    }
                    leading_sep = windows_root_rx.test(home) ? '' : home.$sub(Opal.regexp([
                        "^([",
                        sep_chars,
                        "]+).*$"
                    ]), "\\1");
                    if ($truthy(home['$start_with?'](leading_sep))) {} else {
                        self.$raise($$($nesting, 'ArgumentError'), "non-absolute home");
                    }
                    home = $rb_plus(home, sep18);
                    home_path_regexp = Opal.regexp([
                        "^\\~(?:",
                        sep18,
                        "|$)"
                    ]);
                    path8 = path8.$sub(home_path_regexp, home);
                    if ($truthy(basedir)) {
                        basedir = basedir.$sub(home_path_regexp, home);
                    }
                }
                return self.$absolute_path(path8, basedir);
            }, $expand_path$2.$$arity = -2);
            Opal.alias(self178, "realpath", "expand_path");
            function $coerce_to_path(path9) {
                if ($truthy(path9['$respond_to?']("to_path"))) {
                    path9 = path9.$to_path();
                }
                path9 = $$($nesting, 'Opal')['$coerce_to!'](path9, $$($nesting, 'String'), "to_str");
                return path9;
            }
            function $sep_chars() {
                if ($$($nesting, 'ALT_SEPARATOR') === nil) {
                    return Opal.escape_regexp($$($nesting, 'SEPARATOR'));
                } else {
                    return Opal.escape_regexp($rb_plus($$($nesting, 'SEPARATOR'), $$($nesting, 'ALT_SEPARATOR')));
                }
            }
            Opal.def(self178, '$dirname', $dirname$3 = function $$dirname(path10) {
                var sep_chars = nil;
                sep_chars = $sep_chars();
                path10 = $coerce_to_path(path10);
                var absolute = path10.match(new RegExp("" + "^[" + sep_chars + "]"));
                path10 = path10.replace(new RegExp("" + "[" + sep_chars + "]+$"), '');
                path10 = path10.replace(new RegExp("" + "[^" + sep_chars + "]+$"), '');
                path10 = path10.replace(new RegExp("" + "[" + sep_chars + "]+$"), '');
                if (path10 === '') {
                    return absolute ? '/' : '.';
                }
                return path10;
            }, $dirname$3.$$arity = 1);
            Opal.def(self178, '$basename', $basename$4 = function $$basename(name129, suffix) {
                var sep_chars = nil;
                if (suffix == null) {
                    suffix = nil;
                }
                sep_chars = $sep_chars();
                name129 = $coerce_to_path(name129);
                if (name129.length == 0) {
                    return name129;
                }
                if (suffix !== nil) {
                    suffix = $$($nesting, 'Opal')['$coerce_to!'](suffix, $$($nesting, 'String'), "to_str");
                } else {
                    suffix = null;
                }
                name129 = name129.replace(new RegExp("" + "(.)[" + sep_chars + "]*$"), '$1');
                name129 = name129.replace(new RegExp("" + "^(?:.*[" + sep_chars + "])?([^" + sep_chars + "]+)$"), '$1');
                if (suffix === ".*") {
                    name129 = name129.replace(/\.[^\.]+$/, '');
                } else if (suffix !== null) {
                    suffix = Opal.escape_regexp(suffix);
                    name129 = name129.replace(new RegExp("" + suffix + "$"), '');
                }
                return name129;
            }, $basename$4.$$arity = -2);
            Opal.def(self178, '$extname', $extname$5 = function $$extname(path11) {
                var self = this, filename = nil, last_dot_idx = nil, $ret_or_2 = nil;
                path11 = $coerce_to_path(path11);
                filename = self.$basename(path11);
                if ($truthy(filename['$empty?']())) {
                    return "";
                }
                last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(".");
                if ($truthy(function() {
                    if ($truthy($ret_or_2 = last_dot_idx['$nil?']())) {
                        return $ret_or_2;
                    } else {
                        return $rb_plus(last_dot_idx, 1)['$==']($rb_minus(filename.$length(), 1));
                    }
                    return nil;
                }())) {
                    return "";
                } else {
                    return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false));
                }
            }, $extname$5.$$arity = 1);
            Opal.def(self178, '$exist?', $exist$ques$6 = function(path12) {
                return Opal.modules[path12] != null;
            }, $exist$ques$6.$$arity = 1);
            Opal.alias(self178, "exists?", "exist?");
            Opal.def(self178, '$directory?', $directory$ques$7 = function(path13) {
                var $$8, self = this, files = nil, file = nil;
                files = [];
                for(var key in Opal.modules){
                    files.push(key);
                }
                path13 = path13.$gsub(Opal.regexp([
                    "(^.",
                    $$($nesting, 'SEPARATOR'),
                    "+|",
                    $$($nesting, 'SEPARATOR'),
                    "+$)"
                ]));
                file = $send(files, 'find', [], ($$8 = function(f) {
                    $$8.$$s == null ? this : $$8.$$s;
                    if (f == null) {
                        f = nil;
                    }
                    return f['$=~'](Opal.regexp([
                        "^",
                        path13
                    ]));
                }, $$8.$$s = self, $$8.$$arity = 1, $$8));
                return file;
            }, $directory$ques$7.$$arity = 1);
            Opal.def(self178, '$join', $join$9 = function $$join($a) {
                var $post_args, paths, $$10, $$11, self = this, result = nil;
                $post_args = Opal.slice.call(arguments, 0, arguments.length);
                paths = $post_args;
                if ($truthy(paths['$empty?']())) {
                    return "";
                }
                result = "";
                paths = $send(paths.$flatten().$each_with_index(), 'map', [], ($$10 = function(item, index) {
                    var self = $$10.$$s == null ? this : $$10.$$s, $ret_or_3 = nil, $ret_or_4 = nil;
                    if (item == null) {
                        item = nil;
                    }
                    if (index == null) {
                        index = nil;
                    }
                    if ($truthy(function() {
                        if ($truthy($ret_or_3 = index['$=='](0))) {
                            return item['$empty?']();
                        } else {
                            return $ret_or_3;
                        }
                        return nil;
                    }())) {
                        return $$($nesting, 'SEPARATOR');
                    } else if ($truthy(function() {
                        if ($truthy($ret_or_4 = paths.$length()['$==']($rb_plus(index, 1)))) {
                            return item['$empty?']();
                        } else {
                            return $ret_or_4;
                        }
                        return nil;
                    }())) {
                        return $$($nesting, 'SEPARATOR');
                    } else {
                        return item;
                    }
                }, $$10.$$s = self, $$10.$$arity = 2, $$10));
                paths = $send(paths, 'reject', [], "empty?".$to_proc());
                $send(paths, 'each_with_index', [], ($$11 = function(item, index) {
                    var self = $$11.$$s == null ? this : $$11.$$s, next_item = nil, $ret_or_5 = nil, $ret_or_6 = nil;
                    if (item == null) {
                        item = nil;
                    }
                    if (index == null) {
                        index = nil;
                    }
                    next_item = paths['$[]']($rb_plus(index, 1));
                    if ($truthy(next_item['$nil?']())) {
                        return result = "" + result + item;
                    } else {
                        if ($truthy(function() {
                            if ($truthy($ret_or_5 = item['$end_with?']($$($nesting, 'SEPARATOR')))) {
                                return next_item['$start_with?']($$($nesting, 'SEPARATOR'));
                            } else {
                                return $ret_or_5;
                            }
                            return nil;
                        }())) {
                            item = item.$sub(Opal.regexp([
                                $$($nesting, 'SEPARATOR'),
                                "+$"
                            ]), "");
                        }
                        return result = function() {
                            if ($truthy(function() {
                                if ($truthy($ret_or_6 = item['$end_with?']($$($nesting, 'SEPARATOR')))) {
                                    return $ret_or_6;
                                } else {
                                    return next_item['$start_with?']($$($nesting, 'SEPARATOR'));
                                }
                                return nil;
                            }())) {
                                return "" + result + item;
                            } else {
                                return "" + result + item + $$($nesting, 'SEPARATOR');
                            }
                            return nil;
                        }();
                    }
                }, $$11.$$s = self, $$11.$$arity = 2, $$11));
                return result;
            }, $join$9.$$arity = -1);
            return (Opal.def(self178, '$split', $split$12 = function $$split(path14) {
                return path14.$split($$($nesting, 'SEPARATOR'));
            }, $split$12.$$arity = 1), nil) && 'split';
        }(Opal.get_singleton_class(self177), $nesting41);
    }($nesting40[0], $$($nesting40, 'IO'), $nesting40);
};
Opal.modules["corelib/process"] = function(Opal) {
    var self179 = Opal.top, $nesting42 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy;
    Opal.add_stubs([
        '$const_set',
        '$size',
        '$<<',
        '$__register_clock__',
        '$to_f',
        '$now',
        '$new',
        '$[]',
        '$raise'
    ]);
    (function($base, $super, $parent_nesting) {
        var self180 = $klass($base, $super, 'Process');
        var $nesting = [
            self180
        ].concat($parent_nesting), $Process___register_clock__$1, $Process_pid$2, $Process_times$3, $Process_clock_gettime$4, monotonic = nil;
        self180.__clocks__ = [];
        Opal.defs(self180, '$__register_clock__', $Process___register_clock__$1 = function $$__register_clock__(name130, func) {
            var self = this;
            if (self.__clocks__ == null) self.__clocks__ = nil;
            self.$const_set(name130, self.__clocks__.$size());
            return self.__clocks__['$<<'](func);
        }, $Process___register_clock__$1.$$arity = 2);
        self180.$__register_clock__("CLOCK_REALTIME", function() {
            return Date.now();
        });
        monotonic = false;
        if (Opal.global.performance) {
            monotonic = function() {
                return performance.now();
            };
        } else if (Opal.global.process && process.hrtime) {
            var hrtime_base = process.hrtime();
            monotonic = function() {
                var hrtime1 = process.hrtime(hrtime_base);
                var us = hrtime1[1] / 1000 | 0;
                return hrtime1[0] * 1000 + us / 1000;
            };
        }
        if ($truthy(monotonic)) {
            self180.$__register_clock__("CLOCK_MONOTONIC", monotonic);
        }
        Opal.defs(self180, '$pid', $Process_pid$2 = function $$pid() {
            return 0;
        }, $Process_pid$2.$$arity = 0);
        Opal.defs(self180, '$times', $Process_times$3 = function $$times() {
            var t = nil;
            t = $$($nesting, 'Time').$now().$to_f();
            return $$$($$($nesting, 'Benchmark'), 'Tms').$new(t, t, t, t, t);
        }, $Process_times$3.$$arity = 0);
        return (Opal.defs(self180, '$clock_gettime', $Process_clock_gettime$4 = function $$clock_gettime(clock_id, unit) {
            var self = this, $ret_or_1 = nil, clock = nil;
            if (self.__clocks__ == null) self.__clocks__ = nil;
            if (unit == null) {
                unit = "float_second";
            }
            if ($truthy($ret_or_1 = clock = self.__clocks__['$[]'](clock_id))) {} else {
                self.$raise($$$($$($nesting, 'Errno'), 'EINVAL'), "" + "clock_gettime(" + clock_id + ") " + self.__clocks__['$[]'](clock_id));
            }
            var ms = clock();
            switch(unit){
                case 'float_second':
                    return ms / 1000;
                case 'float_millisecond':
                    return ms / 1;
                case 'float_microsecond':
                    return ms * 1000;
                case 'second':
                    return ms / 1000 | 0;
                case 'millisecond':
                    return ms / 1 | 0;
                case 'microsecond':
                    return ms * 1000 | 0;
                case 'nanosecond':
                    return ms * 1000000 | 0;
                default:
                    self.$raise($$($nesting, 'ArgumentError'), "" + "unexpected unit: " + unit);
            }
        }, $Process_clock_gettime$4.$$arity = -2), nil) && 'clock_gettime';
    })($nesting42[0], null, $nesting42);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Signal');
        var $nesting = [
            self
        ].concat($parent_nesting), $Signal_trap$5;
        return (Opal.defs(self, '$trap', $Signal_trap$5 = function $$trap($a) {
            var $post_args;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return nil;
        }, $Signal_trap$5.$$arity = -1), nil) && 'trap';
    })($nesting42[0], null, $nesting42);
    return function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'GC');
        var $nesting = [
            self
        ].concat($parent_nesting), $GC_start$6;
        return (Opal.defs(self, '$start', $GC_start$6 = function $$start() {
            return nil;
        }, $GC_start$6.$$arity = 0), nil) && 'start';
    }($nesting42[0], null, $nesting42);
};
Opal.modules["corelib/random/formatter"] = function(Opal) {
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    function $rb_divide(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs / rhs : lhs['$/'](rhs);
    }
    var self181 = Opal.top, $nesting43 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $module = Opal.module, $send = Opal.send, $range = Opal.range;
    Opal.add_stubs([
        '$_verify_count',
        '$bytes',
        '$encode',
        '$strict_encode64',
        '$random_bytes',
        '$urlsafe_encode64',
        '$split',
        '$hex',
        '$[]=',
        '$-',
        '$[]',
        '$map',
        '$to_proc',
        '$join',
        '$times',
        '$<<',
        '$|',
        '$ord',
        '$/',
        '$abs',
        '$random_float',
        '$raise',
        '$coerce_to!',
        '$flatten',
        '$new',
        '$random_number',
        '$length',
        '$include',
        '$extend'
    ]);
    return function($base8, $super, $parent_nesting19) {
        var self182 = $klass($base8, $super, 'Random');
        var $nesting44 = [
            self182
        ].concat($parent_nesting19);
        (function($base, $parent_nesting) {
            var self183 = $module($base, 'Formatter');
            var $nesting = [
                self183
            ].concat($parent_nesting), $Formatter_hex$1, $Formatter_random_bytes$2, $Formatter_base64$3, $Formatter_urlsafe_base64$4, $Formatter_uuid$5, $Formatter_random_float$6, $Formatter_random_number$8, $Formatter_alphanumeric$9;
            Opal.def(self183, '$hex', $Formatter_hex$1 = function $$hex(count) {
                var self = this;
                if (count == null) {
                    count = nil;
                }
                count = $$($nesting, 'Random').$_verify_count(count);
                var bytes = self.$bytes(count);
                var out = "";
                for(var i303 = 0; i303 < count; i303++){
                    out += bytes.charCodeAt(i303).toString(16).padStart(2, '0');
                }
                return out.$encode("US-ASCII");
            }, $Formatter_hex$1.$$arity = -1);
            Opal.def(self183, '$random_bytes', $Formatter_random_bytes$2 = function $$random_bytes(count) {
                var self = this;
                if (count == null) {
                    count = nil;
                }
                return self.$bytes(count);
            }, $Formatter_random_bytes$2.$$arity = -1);
            Opal.def(self183, '$base64', $Formatter_base64$3 = function $$base64(count) {
                var self = this;
                if (count == null) {
                    count = nil;
                }
                return $$($nesting, 'Base64').$strict_encode64(self.$random_bytes(count)).$encode("US-ASCII");
            }, $Formatter_base64$3.$$arity = -1);
            Opal.def(self183, '$urlsafe_base64', $Formatter_urlsafe_base64$4 = function $$urlsafe_base64(count, padding) {
                var self = this;
                if (count == null) {
                    count = nil;
                }
                if (padding == null) {
                    padding = false;
                }
                return $$($nesting, 'Base64').$urlsafe_encode64(self.$random_bytes(count), padding).$encode("US-ASCII");
            }, $Formatter_urlsafe_base64$4.$$arity = -1);
            Opal.def(self183, '$uuid', $Formatter_uuid$5 = function $$uuid() {
                var self = this, str = nil, $writer = nil;
                str = self.$hex(16).$split("");
                $writer = [
                    12,
                    "4"
                ];
                $send(str, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
                $writer = [
                    16,
                    (parseInt(str['$[]'](16), 16) & 3 | 8).toString(16)
                ];
                $send(str, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
                str = [
                    str['$[]']($range(0, 8, true)),
                    str['$[]']($range(8, 12, true)),
                    str['$[]']($range(12, 16, true)),
                    str['$[]']($range(16, 20, true)),
                    str['$[]']($range(20, 32, true))
                ];
                str = $send(str, 'map', [], "join".$to_proc());
                return str.$join("-");
            }, $Formatter_uuid$5.$$arity = 0);
            Opal.def(self183, '$random_float', $Formatter_random_float$6 = function $$random_float() {
                var $$7, self = this, bs = nil, num = nil;
                bs = self.$bytes(4);
                num = 0;
                $send(4, 'times', [], ($$7 = function(i304) {
                    $$7.$$s == null ? this : $$7.$$s;
                    if (i304 == null) {
                        i304 = nil;
                    }
                    num = num['$<<'](8);
                    return num = num['$|'](bs['$[]'](i304).$ord());
                }, $$7.$$s = self, $$7.$$arity = 1, $$7));
                return $rb_divide(num.$abs(), 2147483647);
            }, $Formatter_random_float$6.$$arity = 0);
            Opal.def(self183, '$random_number', $Formatter_random_number$8 = function $$random_number(limit) {
                var self = this;
                function randomFloat() {
                    return self.$random_float();
                }
                function randomInt(max) {
                    return Math.floor(randomFloat() * max);
                }
                function randomRange() {
                    var min32 = limit.begin, max = limit.end;
                    if (min32 === nil || max === nil) {
                        return nil;
                    }
                    var length = max - min32;
                    if (length < 0) {
                        return nil;
                    }
                    if (length === 0) {
                        return min32;
                    }
                    if (max % 1 === 0 && min32 % 1 === 0 && !limit.excl) {
                        length++;
                    }
                    return randomInt(length) + min32;
                }
                if (limit == null) {
                    return randomFloat();
                } else if (limit.$$is_range) {
                    return randomRange();
                } else if (limit.$$is_number) {
                    if (limit <= 0) {
                        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid argument - " + limit);
                    }
                    if (limit % 1 === 0) {
                        return randomInt(limit);
                    } else {
                        return randomFloat() * limit;
                    }
                } else {
                    limit = $$($nesting, 'Opal')['$coerce_to!'](limit, $$($nesting, 'Integer'), "to_int");
                    if (limit <= 0) {
                        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid argument - " + limit);
                    }
                    return randomInt(limit);
                }
            }, $Formatter_random_number$8.$$arity = -1);
            return (Opal.def(self183, '$alphanumeric', $Formatter_alphanumeric$9 = function $$alphanumeric(count) {
                var $$10, self184 = this, map = nil;
                if (count == null) {
                    count = nil;
                }
                count = $$($nesting, 'Random').$_verify_count(count);
                map = $send([
                    $range("0", "9", false),
                    $range("a", "z", false),
                    $range("A", "Z", false)
                ], 'map', [], "to_a".$to_proc()).$flatten();
                return $send($$($nesting, 'Array'), 'new', [
                    count
                ], ($$10 = function(i305) {
                    var self = $$10.$$s == null ? this : $$10.$$s;
                    if (i305 == null) {
                        i305 = nil;
                    }
                    return map['$[]'](self.$random_number(map.$length()));
                }, $$10.$$s = self184, $$10.$$arity = 1, $$10)).$join();
            }, $Formatter_alphanumeric$9.$$arity = -1), nil) && 'alphanumeric';
        })($nesting44[0], $nesting44);
        self182.$include($$$($$($nesting44, 'Random'), 'Formatter'));
        return self182.$extend($$$($$($nesting44, 'Random'), 'Formatter'));
    }($nesting43[0], null, $nesting43);
};
Opal.modules["corelib/random"] = function(Opal) {
    var self185 = Opal.top, $nesting45 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $falsy = Opal.falsy, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;
    Opal.add_stubs([
        '$attr_reader',
        '$to_int',
        '$raise',
        '$new_seed',
        '$coerce_to!',
        '$reseed',
        '$rand',
        '$seed',
        '$bytes',
        '$===',
        '$==',
        '$state',
        '$_verify_count',
        '$encode',
        '$join',
        '$new',
        '$chr',
        '$random_number',
        '$random_float',
        '$const_defined?',
        '$const_set'
    ]);
    return function($base, $super, $parent_nesting) {
        var self186 = $klass($base, $super, 'Random');
        var $nesting = [
            self186
        ].concat($parent_nesting), $Random__verify_count$1, $Random_initialize$2, $Random_reseed$3, $Random_new_seed$4, $Random_rand$5, $Random_srand$6, $Random_urandom$7, $Random_$eq_eq$8, $Random_bytes$9, $Random_bytes$11, $Random_rand$12, $Random_random_float$13, $Random_random_float$14, $Random_generator$eq$15;
        self186.$attr_reader("seed", "state");
        Opal.defs(self186, '$_verify_count', $Random__verify_count$1 = function $$_verify_count(count) {
            var self = this;
            if ($falsy(count)) count = 16;
            if (typeof count !== "number") count = count.$to_int();
            if (count < 0) self.$raise($$($nesting, 'ArgumentError'), "negative string size (or size too big)");
            count = Math.floor(count);
            return count;
        }, $Random__verify_count$1.$$arity = 1);
        Opal.def(self186, '$initialize', $Random_initialize$2 = function $$initialize(seed) {
            var self = this;
            if (seed == null) {
                seed = $$($nesting, 'Random').$new_seed();
            }
            seed = $$($nesting, 'Opal')['$coerce_to!'](seed, $$($nesting, 'Integer'), "to_int");
            self.state = seed;
            return self.$reseed(seed);
        }, $Random_initialize$2.$$arity = -1);
        Opal.def(self186, '$reseed', $Random_reseed$3 = function $$reseed(seed) {
            var self = this;
            self.seed = seed;
            return self.$rng = Opal.$$rand.reseed(seed);
        }, $Random_reseed$3.$$arity = 1);
        Opal.defs(self186, '$new_seed', $Random_new_seed$4 = function $$new_seed() {
            return Opal.$$rand.new_seed();
        }, $Random_new_seed$4.$$arity = 0);
        Opal.defs(self186, '$rand', $Random_rand$5 = function $$rand(limit) {
            return $$($nesting, 'DEFAULT').$rand(limit);
        }, $Random_rand$5.$$arity = -1);
        Opal.defs(self186, '$srand', $Random_srand$6 = function $$srand(n) {
            var previous_seed = nil;
            if (n == null) {
                n = $$($nesting, 'Random').$new_seed();
            }
            n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
            previous_seed = $$($nesting, 'DEFAULT').$seed();
            $$($nesting, 'DEFAULT').$reseed(n);
            return previous_seed;
        }, $Random_srand$6.$$arity = -1);
        Opal.defs(self186, '$urandom', $Random_urandom$7 = function $$urandom(size) {
            return $$$('::', 'SecureRandom').$bytes(size);
        }, $Random_urandom$7.$$arity = 1);
        Opal.def(self186, '$==', $Random_$eq_eq$8 = function(other) {
            var self = this, $ret_or_1 = nil;
            if ($truthy($$($nesting, 'Random')['$==='](other))) {} else {
                return false;
            }
            if ($truthy($ret_or_1 = self.$seed()['$=='](other.$seed()))) {
                return self.$state()['$=='](other.$state());
            } else {
                return $ret_or_1;
            }
        }, $Random_$eq_eq$8.$$arity = 1);
        Opal.def(self186, '$bytes', $Random_bytes$9 = function $$bytes(length) {
            var $$10, self187 = this;
            length = $$($nesting, 'Random').$_verify_count(length);
            return $send($$($nesting, 'Array'), 'new', [
                length
            ], ($$10 = function() {
                var self = $$10.$$s == null ? this : $$10.$$s;
                return self.$rand(255).$chr();
            }, $$10.$$s = self187, $$10.$$arity = 0, $$10)).$join().$encode("ASCII-8BIT");
        }, $Random_bytes$9.$$arity = 1);
        Opal.defs(self186, '$bytes', $Random_bytes$11 = function $$bytes(length) {
            return $$($nesting, 'DEFAULT').$bytes(length);
        }, $Random_bytes$11.$$arity = 1);
        Opal.def(self186, '$rand', $Random_rand$12 = function $$rand(limit) {
            var self = this;
            return self.$random_number(limit);
        }, $Random_rand$12.$$arity = -1);
        Opal.def(self186, '$random_float', $Random_random_float$13 = function $$random_float() {
            var self = this;
            self.state++;
            return Opal.$$rand.rand(self.$rng);
        }, $Random_random_float$13.$$arity = 0);
        Opal.defs(self186, '$random_float', $Random_random_float$14 = function $$random_float() {
            return $$($nesting, 'DEFAULT').$random_float();
        }, $Random_random_float$14.$$arity = 0);
        return (Opal.defs(self186, '$generator=', $Random_generator$eq$15 = function(generator) {
            var self = this;
            Opal.$$rand = generator;
            if ($truthy(self['$const_defined?']("DEFAULT"))) {
                return $$($nesting, 'DEFAULT').$reseed();
            } else {
                return self.$const_set("DEFAULT", self.$new(self.$new_seed()));
            }
        }, $Random_generator$eq$15.$$arity = 1), nil) && 'generator=';
    }($nesting45[0], null, $nesting45);
};
Opal.modules["corelib/random/mersenne_twister"] = function(Opal) {
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    var self188 = Opal.top, $nesting46 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, mersenne_twister = nil;
    Opal.add_stubs([
        '$generator=',
        '$-'
    ]);
    mersenne_twister = function() {
        var N = 624;
        var M = 397;
        var MATRIX_A = 0x9908b0df;
        var UMASK = 0x80000000;
        var LMASK = 0x7fffffff;
        var MIXBITS = function(u, v) {
            return u & UMASK | v & LMASK;
        };
        var TWIST = function(u, v) {
            return MIXBITS(u, v) >>> 1 ^ (v & 0x1 ? MATRIX_A : 0x0);
        };
        function init(s) {
            var mt = {
                left: 0,
                next: N,
                state: new Array(N)
            };
            init_genrand(mt, s);
            return mt;
        }
        function init_genrand(mt, s) {
            var j;
            mt.state[0] = s >>> 0;
            for(j = 1; j < N; j++){
                mt.state[j] = 1812433253 * (mt.state[j - 1] ^ mt.state[j - 1] >> 30 >>> 0) + j;
                mt.state[j] &= 0xffffffff;
            }
            mt.left = 1;
            mt.next = N;
        }
        function next_state(mt) {
            var p = 0, _p = mt.state;
            var j;
            mt.left = N;
            mt.next = 0;
            for(j = N - M + 1; --j; p++)_p[p] = _p[p + M] ^ TWIST(_p[p + 0], _p[p + 1]);
            for(j = M; --j; p++)_p[p] = _p[p + (M - N)] ^ TWIST(_p[p + 0], _p[p + 1]);
            _p[p] = _p[p + (M - N)] ^ TWIST(_p[p + 0], _p[0]);
        }
        function genrand_int32(mt) {
            var y;
            if (--mt.left <= 0) next_state(mt);
            y = mt.state[mt.next++];
            y ^= y >>> 11;
            y ^= y << 7 & 0x9d2c5680;
            y ^= y << 15 & 0xefc60000;
            y ^= y >>> 18;
            return y >>> 0;
        }
        function int_pair_to_real_exclusive(a, b) {
            a >>>= 5;
            b >>>= 6;
            return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0);
        }
        function genrand_real(mt) {
            var a = genrand_int32(mt), b = genrand_int32(mt);
            return int_pair_to_real_exclusive(a, b);
        }
        return {
            genrand_real: genrand_real,
            init: init
        };
    }();
    return function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Random');
        var $nesting = [
            self
        ].concat($parent_nesting), $writer = nil;
        var MAX_INT = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
        Opal.const_set($nesting[0], 'MERSENNE_TWISTER_GENERATOR', {
            new_seed: function() {
                return Math.round(Math.random() * MAX_INT);
            },
            reseed: function(seed) {
                return mersenne_twister.init(seed);
            },
            rand: function(mt) {
                return mersenne_twister.genrand_real(mt);
            }
        });
        $writer = [
            $$($nesting, 'MERSENNE_TWISTER_GENERATOR')
        ];
        $send(self, 'generator=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
    }($nesting46[0], null, $nesting46);
};
Opal.modules["corelib/unsupported"] = function(Opal) {
    var $public$35, $private$36, self189 = Opal.top, $nesting47 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $module = Opal.module;
    Opal.add_stubs([
        '$raise',
        '$warn',
        '$%'
    ]);
    var warnings = {};
    function handle_unsupported_feature(message) {
        switch(Opal.config.unsupported_features_severity){
            case 'error':
                $$($nesting47, 'Kernel').$raise($$($nesting47, 'NotImplementedError'), message);
                break;
            case 'warning':
                warn(message);
                break;
            default:
        }
    }
    function warn(string) {
        if (warnings[string]) {
            return;
        }
        warnings[string] = true;
        self189.$warn(string);
    }
    (function($base, $super, $parent_nesting) {
        var self190 = $klass($base, $super, 'String');
        var $nesting = [
            self190
        ].concat($parent_nesting), $String_$lt$lt$1, $String_capitalize$excl$2, $String_chomp$excl$3, $String_chop$excl$4, $String_downcase$excl$5, $String_gsub$excl$6, $String_lstrip$excl$7, $String_next$excl$8, $String_reverse$excl$9, $String_slice$excl$10, $String_squeeze$excl$11, $String_strip$excl$12, $String_sub$excl$13, $String_succ$excl$14, $String_swapcase$excl$15, $String_tr$excl$16, $String_tr_s$excl$17, $String_upcase$excl$18, $String_prepend$19, $String_$$$eq$20, $String_clear$21, $String_encode$excl$22, $String_unicode_normalize$excl$23;
        var ERROR = "String#%s not supported. Mutable String methods are not supported in Opal.";
        Opal.def(self190, '$<<', $String_$lt$lt$1 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("<<"));
        }, $String_$lt$lt$1.$$arity = -1);
        Opal.def(self190, '$capitalize!', $String_capitalize$excl$2 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("capitalize!"));
        }, $String_capitalize$excl$2.$$arity = -1);
        Opal.def(self190, '$chomp!', $String_chomp$excl$3 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("chomp!"));
        }, $String_chomp$excl$3.$$arity = -1);
        Opal.def(self190, '$chop!', $String_chop$excl$4 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("chop!"));
        }, $String_chop$excl$4.$$arity = -1);
        Opal.def(self190, '$downcase!', $String_downcase$excl$5 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("downcase!"));
        }, $String_downcase$excl$5.$$arity = -1);
        Opal.def(self190, '$gsub!', $String_gsub$excl$6 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("gsub!"));
        }, $String_gsub$excl$6.$$arity = -1);
        Opal.def(self190, '$lstrip!', $String_lstrip$excl$7 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("lstrip!"));
        }, $String_lstrip$excl$7.$$arity = -1);
        Opal.def(self190, '$next!', $String_next$excl$8 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("next!"));
        }, $String_next$excl$8.$$arity = -1);
        Opal.def(self190, '$reverse!', $String_reverse$excl$9 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("reverse!"));
        }, $String_reverse$excl$9.$$arity = -1);
        Opal.def(self190, '$slice!', $String_slice$excl$10 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("slice!"));
        }, $String_slice$excl$10.$$arity = -1);
        Opal.def(self190, '$squeeze!', $String_squeeze$excl$11 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("squeeze!"));
        }, $String_squeeze$excl$11.$$arity = -1);
        Opal.def(self190, '$strip!', $String_strip$excl$12 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("strip!"));
        }, $String_strip$excl$12.$$arity = -1);
        Opal.def(self190, '$sub!', $String_sub$excl$13 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("sub!"));
        }, $String_sub$excl$13.$$arity = -1);
        Opal.def(self190, '$succ!', $String_succ$excl$14 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("succ!"));
        }, $String_succ$excl$14.$$arity = -1);
        Opal.def(self190, '$swapcase!', $String_swapcase$excl$15 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("swapcase!"));
        }, $String_swapcase$excl$15.$$arity = -1);
        Opal.def(self190, '$tr!', $String_tr$excl$16 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("tr!"));
        }, $String_tr$excl$16.$$arity = -1);
        Opal.def(self190, '$tr_s!', $String_tr_s$excl$17 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("tr_s!"));
        }, $String_tr_s$excl$17.$$arity = -1);
        Opal.def(self190, '$upcase!', $String_upcase$excl$18 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("upcase!"));
        }, $String_upcase$excl$18.$$arity = -1);
        Opal.def(self190, '$prepend', $String_prepend$19 = function $$prepend($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("prepend"));
        }, $String_prepend$19.$$arity = -1);
        Opal.def(self190, '$[]=', $String_$$$eq$20 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("[]="));
        }, $String_$$$eq$20.$$arity = -1);
        Opal.def(self190, '$clear', $String_clear$21 = function $$clear($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("clear"));
        }, $String_clear$21.$$arity = -1);
        Opal.def(self190, '$encode!', $String_encode$excl$22 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("encode!"));
        }, $String_encode$excl$22.$$arity = -1);
        return (Opal.def(self190, '$unicode_normalize!', $String_unicode_normalize$excl$23 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), ERROR['$%']("unicode_normalize!"));
        }, $String_unicode_normalize$excl$23.$$arity = -1), nil) && 'unicode_normalize!';
    })($nesting47[0], null, $nesting47);
    (function($base, $parent_nesting) {
        var self191 = $module($base, 'Kernel');
        var $nesting = [
            self191
        ].concat($parent_nesting), $Kernel_freeze$24, $Kernel_frozen$ques$25;
        var ERROR = "Object freezing is not supported by Opal";
        Opal.def(self191, '$freeze', $Kernel_freeze$24 = function $$freeze() {
            var self = this;
            handle_unsupported_feature(ERROR);
            return self;
        }, $Kernel_freeze$24.$$arity = 0);
        return (Opal.def(self191, '$frozen?', $Kernel_frozen$ques$25 = function() {
            handle_unsupported_feature(ERROR);
            return false;
        }, $Kernel_frozen$ques$25.$$arity = 0), nil) && 'frozen?';
    })($nesting47[0], $nesting47);
    (function($base, $parent_nesting) {
        var self192 = $module($base, 'Kernel');
        var $nesting = [
            self192
        ].concat($parent_nesting), $Kernel_taint$26, $Kernel_untaint$27, $Kernel_tainted$ques$28;
        var ERROR = "Object tainting is not supported by Opal";
        Opal.def(self192, '$taint', $Kernel_taint$26 = function $$taint() {
            var self = this;
            handle_unsupported_feature(ERROR);
            return self;
        }, $Kernel_taint$26.$$arity = 0);
        Opal.def(self192, '$untaint', $Kernel_untaint$27 = function $$untaint() {
            var self = this;
            handle_unsupported_feature(ERROR);
            return self;
        }, $Kernel_untaint$27.$$arity = 0);
        return (Opal.def(self192, '$tainted?', $Kernel_tainted$ques$28 = function() {
            handle_unsupported_feature(ERROR);
            return false;
        }, $Kernel_tainted$ques$28.$$arity = 0), nil) && 'tainted?';
    })($nesting47[0], $nesting47);
    (function($base, $super, $parent_nesting) {
        var self193 = $klass($base, $super, 'Module');
        var $nesting = [
            self193
        ].concat($parent_nesting), $Module_public$29, $Module_private_class_method$30, $Module_private_method_defined$ques$31, $Module_private_constant$32;
        Opal.def(self193, '$public', $Module_public$29 = function($a) {
            var $post_args, methods, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            methods = $post_args;
            if (methods.length === 0) {
                self.$$module_function = false;
            }
            return nil;
        }, $Module_public$29.$$arity = -1);
        Opal.alias(self193, "private", "public");
        Opal.alias(self193, "protected", "public");
        Opal.alias(self193, "nesting", "public");
        Opal.def(self193, '$private_class_method', $Module_private_class_method$30 = function $$private_class_method($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self;
        }, $Module_private_class_method$30.$$arity = -1);
        Opal.alias(self193, "public_class_method", "private_class_method");
        Opal.def(self193, '$private_method_defined?', $Module_private_method_defined$ques$31 = function(obj) {
            return false;
        }, $Module_private_method_defined$ques$31.$$arity = 1);
        Opal.def(self193, '$private_constant', $Module_private_constant$32 = function $$private_constant($a) {
            var $post_args;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return nil;
        }, $Module_private_constant$32.$$arity = -1);
        Opal.alias(self193, "protected_method_defined?", "private_method_defined?");
        Opal.alias(self193, "public_instance_methods", "instance_methods");
        Opal.alias(self193, "public_instance_method", "instance_method");
        return Opal.alias(self193, "public_method_defined?", "method_defined?");
    })($nesting47[0], null, $nesting47);
    (function($base, $parent_nesting) {
        var self = $module($base, 'Kernel');
        var $nesting = [
            self
        ].concat($parent_nesting), $Kernel_private_methods$33;
        Opal.def(self, '$private_methods', $Kernel_private_methods$33 = function $$private_methods($a) {
            var $post_args;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return [];
        }, $Kernel_private_methods$33.$$arity = -1);
        return Opal.alias(self, "private_instance_methods", "private_methods");
    })($nesting47[0], $nesting47);
    (function($base, $parent_nesting) {
        var self194 = $module($base, 'Kernel');
        var $nesting = [
            self194
        ].concat($parent_nesting), $Kernel_eval$34;
        return (Opal.def(self194, '$eval', $Kernel_eval$34 = function($a) {
            var $post_args, self = this;
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            return self.$raise($$($nesting, 'NotImplementedError'), "" + "To use Kernel#eval, you must first require 'opal-parser'. " + ("" + "See https://github.com/opal/opal/blob/" + $$($nesting, 'RUBY_ENGINE_VERSION') + "/docs/opal_parser.md for details."));
        }, $Kernel_eval$34.$$arity = -1), nil) && 'eval';
    })($nesting47[0], $nesting47);
    Opal.defs(self189, '$public', $public$35 = function($a) {
        var $post_args;
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        return nil;
    }, $public$35.$$arity = -1);
    return (Opal.defs(self189, '$private', $private$36 = function($a) {
        var $post_args;
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        return nil;
    }, $private$36.$$arity = -1), nil) && 'private';
};
(function(Opal) {
    var self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;
    Opal.add_stubs([
        '$require'
    ]);
    self.$require("opal/base");
    self.$require("opal/mini");
    self.$require("corelib/kernel/format");
    self.$require("corelib/string/encoding");
    self.$require("corelib/math");
    self.$require("corelib/complex");
    self.$require("corelib/rational");
    self.$require("corelib/time");
    self.$require("corelib/struct");
    self.$require("corelib/io");
    self.$require("corelib/main");
    self.$require("corelib/dir");
    self.$require("corelib/file");
    self.$require("corelib/process");
    self.$require("corelib/random/formatter");
    self.$require("corelib/random");
    self.$require("corelib/random/mersenne_twister");
    return self.$require("corelib/unsupported");
})(Opal);
(function(Opal) {
    function $rb_gt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs > rhs : lhs['$>'](rhs);
    }
    function $rb_plus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
    }
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    function $rb_lt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs < rhs : lhs['$<'](rhs);
    }
    function $rb_times(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs * rhs : lhs['$*'](rhs);
    }
    var self195 = Opal.top, $nesting48 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send2 = Opal.send2, $truthy = Opal.truthy, $send = Opal.send;
    Opal.add_stubs([
        '$include',
        '$<=>',
        '$attr_reader',
        '$nonzero?',
        '$d',
        '$zero?',
        '$new',
        '$class',
        '$-@',
        '$+@',
        '$===',
        '$coerce',
        '$==',
        '$>',
        '$+',
        '$allocate',
        '$join',
        '$compact',
        '$map',
        '$to_proc',
        '$downcase',
        '$wrap',
        '$raise',
        '$clone',
        '$jd',
        '$>>',
        '$wday',
        '$year',
        '$month',
        '$day',
        '$-',
        '$to_s',
        '$to_i',
        '$<',
        '$*',
        '$reverse',
        '$step',
        '$abs',
        '$each'
    ]);
    return function($base9, $super5, $parent_nesting20) {
        var self196 = $klass($base9, $super5, 'Date');
        var $nesting49 = [
            self196
        ].concat($parent_nesting20), $Date_initialize$16, $Date_$minus$17, $Date_$plus$18, $Date_$lt$19, $Date_$lt_eq$20, $Date_$gt$21, $Date_$gt_eq$22, $Date_$lt_eq_gt$23, $Date_$gt$gt$24, $Date_$lt$lt$25, $Date_clone$26, $Date_day$27, $Date_friday$ques$28, $Date_jd$29, $Date_julian$ques$30, $Date_monday$ques$31, $Date_month$32, $Date_next$33, $Date_next_day$34, $Date_next_month$35, $Date_next_year$36, $Date_prev_day$37, $Date_prev_month$38, $Date_prev_year$39, $Date_saturday$ques$40, $Date_strftime$41, $Date_sunday$ques$42, $Date_thursday$ques$43, $Date_to_s$44, $Date_to_time$45, $Date_to_n$46, $Date_tuesday$ques$47, $Date_step$48, $Date_upto$51, $Date_downto$52, $Date_wday$53, $Date_wednesday$ques$54, $Date_year$55, $Date_cwday$56, $Date_cweek$57;
        self196.$$prototype.date = nil;
        self196.$include($$($nesting49, 'Comparable'));
        (function($base, $super, $parent_nesting) {
            var self197 = $klass($base, $super, 'Infinity');
            var $nesting = [
                self197
            ].concat($parent_nesting), $Infinity_initialize$1, $Infinity_zero$ques$2, $Infinity_finite$ques$3, $Infinity_infinite$ques$4, $Infinity_nan$ques$5, $Infinity_abs$6, $Infinity_$minus$$7, $Infinity_$plus$$8, $Infinity_$lt_eq_gt$9, $Infinity_coerce$10, $Infinity_to_f$11;
            self197.$$prototype.d = nil;
            self197.$include($$($nesting, 'Comparable'));
            Opal.def(self197, '$initialize', $Infinity_initialize$1 = function $$initialize(d) {
                var self = this;
                if (d == null) {
                    d = 1;
                }
                return self.d = d['$<=>'](0);
            }, $Infinity_initialize$1.$$arity = -1);
            self197.$attr_reader("d");
            Opal.def(self197, '$zero?', $Infinity_zero$ques$2 = function() {
                return false;
            }, $Infinity_zero$ques$2.$$arity = 0);
            Opal.def(self197, '$finite?', $Infinity_finite$ques$3 = function() {
                return false;
            }, $Infinity_finite$ques$3.$$arity = 0);
            Opal.def(self197, '$infinite?', $Infinity_infinite$ques$4 = function() {
                var self = this;
                return self.$d()['$nonzero?']();
            }, $Infinity_infinite$ques$4.$$arity = 0);
            Opal.def(self197, '$nan?', $Infinity_nan$ques$5 = function() {
                var self = this;
                return self.$d()['$zero?']();
            }, $Infinity_nan$ques$5.$$arity = 0);
            Opal.def(self197, '$abs', $Infinity_abs$6 = function $$abs() {
                var self = this;
                return self.$class().$new();
            }, $Infinity_abs$6.$$arity = 0);
            Opal.def(self197, '$-@', $Infinity_$minus$$7 = function() {
                var self = this;
                return self.$class().$new(self.$d()['$-@']());
            }, $Infinity_$minus$$7.$$arity = 0);
            Opal.def(self197, '$+@', $Infinity_$plus$$8 = function() {
                var self = this;
                return self.$class().$new(self.$d()['$+@']());
            }, $Infinity_$plus$$8.$$arity = 0);
            Opal.def(self197, '$<=>', $Infinity_$lt_eq_gt$9 = function(other) {
                var $a, $b, self = this, $case = nil, l = nil, r = nil;
                return function() {
                    $case = other;
                    if ($$($nesting, 'Infinity')['$===']($case)) {
                        return self.$d()['$<=>'](other.$d());
                    } else if ($$($nesting, 'Numeric')['$===']($case)) {
                        return self.$d();
                    } else {
                        try {
                            $b = other.$coerce(self), $a = Opal.to_ary($b), l = $a[0] == null ? nil : $a[0], r = $a[1] == null ? nil : $a[1], $b;
                            return l['$<=>'](r);
                        } catch ($err) {
                            if (Opal.rescue($err, [
                                $$($nesting, 'NoMethodError')
                            ])) {
                                try {
                                    return nil;
                                } finally{
                                    Opal.pop_exception();
                                }
                            } else {
                                throw $err;
                            }
                        }
                    }
                }();
            }, $Infinity_$lt_eq_gt$9.$$arity = 1);
            Opal.def(self197, '$coerce', $Infinity_coerce$10 = function $$coerce(other) {
                var $iter = $Infinity_coerce$10.$$p, self = this, $case = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
                if ($iter) $Infinity_coerce$10.$$p = null;
                for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                    $zuper[$zuper_i] = arguments[$zuper_i];
                }
                return function() {
                    $case = other;
                    if ($$($nesting, 'Numeric')['$===']($case)) {
                        return [
                            self.$d()['$-@'](),
                            self.$d()
                        ];
                    } else {
                        return $send2(self, Opal.find_super_dispatcher(self, 'coerce', $Infinity_coerce$10, false, true), 'coerce', $zuper, $iter);
                    }
                }();
            }, $Infinity_coerce$10.$$arity = 1);
            return (Opal.def(self197, '$to_f', $Infinity_to_f$11 = function $$to_f() {
                var self = this;
                if (self.d['$=='](0)) {
                    return 0;
                }
                if ($truthy($rb_gt(self.d, 0))) {
                    return $$$($$($nesting, 'Float'), 'INFINITY');
                } else {
                    return $$$($$($nesting, 'Float'), 'INFINITY')['$-@']();
                }
            }, $Infinity_to_f$11.$$arity = 0), nil) && 'to_f';
        })($nesting49[0], $$($nesting49, 'Numeric'), $nesting49);
        Opal.const_set($nesting49[0], 'JULIAN', $$($nesting49, 'Infinity').$new());
        Opal.const_set($nesting49[0], 'GREGORIAN', $$($nesting49, 'Infinity').$new()['$-@']());
        Opal.const_set($nesting49[0], 'ITALY', 2299161);
        Opal.const_set($nesting49[0], 'ENGLAND', 2361222);
        Opal.const_set($nesting49[0], 'MONTHNAMES', $rb_plus([
            nil
        ], [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
        ]));
        Opal.const_set($nesting49[0], 'ABBR_MONTHNAMES', [
            "jan",
            "feb",
            "mar",
            "apr",
            "may",
            "jun",
            "jul",
            "aug",
            "sep",
            "oct",
            "nov",
            "dec"
        ]);
        Opal.const_set($nesting49[0], 'DAYNAMES', [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
        ]);
        Opal.const_set($nesting49[0], 'ABBR_DAYNAMES', [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
        ]);
        (function(self198, $parent_nesting) {
            var $nesting = [
                self198
            ].concat($parent_nesting), $wrap$12, $parse$13, $today$14, $gregorian_leap$ques$15;
            Opal.alias(self198, "civil", "new");
            Opal.def(self198, '$wrap', $wrap$12 = function $$wrap(native$) {
                var self = this, instance = nil;
                instance = self.$allocate();
                instance.date = native$;
                return instance;
            }, $wrap$12.$$arity = 1);
            Opal.def(self198, '$parse', $parse$13 = function $$parse(string, comp) {
                var self = this;
                if (comp == null) {
                    comp = true;
                }
                var current_date = new Date();
                var current_day = current_date.getDate(), current_month = current_date.getMonth(), current_year = current_date.getFullYear(), current_wday = current_date.getDay(), full_month_name_regexp = $$($nesting, 'MONTHNAMES').$compact().$join("|");
                function match1(match) {
                    return match[1];
                }
                function match2(match) {
                    return match[2];
                }
                function match3(match) {
                    return match[3];
                }
                function match4(match) {
                    return match[4];
                }
                function fromShortYear(fn) {
                    return function(match) {
                        var short_year = fn(match);
                        if (short_year >= 69) {
                            short_year += 1900;
                        } else {
                            short_year += 2000;
                        }
                        return short_year;
                    };
                }
                function fromMonthAbbr(fn) {
                    return function(match) {
                        var abbr = fn(match).toLowerCase();
                        return $$($nesting, 'ABBR_MONTHNAMES').indexOf(abbr) + 1;
                    };
                }
                function toInt(fn) {
                    return function(match) {
                        var value = fn(match);
                        return parseInt(value, 10);
                    };
                }
                function to2000(fn) {
                    return function(match) {
                        var value = fn(match);
                        if (comp) {
                            return value + 2000;
                        } else {
                            return value;
                        }
                    };
                }
                function fromDayName(fn) {
                    return function(match) {
                        var dayname = fn(match), wday = $send($$($nesting, 'DAYNAMES'), 'map', [], "downcase".$to_proc()).indexOf(dayname.$downcase());
                        return current_day - current_wday + wday;
                    };
                }
                function fromFullMonthName(fn) {
                    return function(match) {
                        var month_name = fn(match);
                        return $send($$($nesting, 'MONTHNAMES').$compact(), 'map', [], "downcase".$to_proc()).indexOf(month_name.$downcase()) + 1;
                    };
                }
                var rules = [
                    {
                        regexp: /^(\d{2})$/,
                        year: current_year,
                        month: current_month,
                        day: toInt(match1)
                    },
                    {
                        regexp: /^(\d{3})$/,
                        year: current_year,
                        month: 0,
                        day: toInt(match1)
                    },
                    {
                        regexp: /^(\d{2})(\d{2})$/,
                        year: current_year,
                        month: toInt(match1),
                        day: toInt(match2)
                    },
                    {
                        regexp: /^(\d{2})(\d{3})$/,
                        year: fromShortYear(toInt(match1)),
                        month: 0,
                        day: toInt(match2)
                    },
                    {
                        regexp: /^(\d{2})(\d{2})(\d{2})$/,
                        year: fromShortYear(toInt(match1)),
                        month: toInt(match2),
                        day: toInt(match3)
                    },
                    {
                        regexp: /^(\d{4})(\d{3})$/,
                        year: toInt(match1),
                        month: 0,
                        day: toInt(match2)
                    },
                    {
                        regexp: /^(\d{4})(\d{2})(\d{2})$/,
                        year: toInt(match1),
                        month: toInt(match2),
                        day: toInt(match3)
                    },
                    {
                        regexp: /^([a-z]{3})[\s\.\/\-](\d{3,4})$/,
                        year: toInt(match2),
                        month: fromMonthAbbr(match1),
                        day: 1
                    },
                    {
                        regexp: /^(\d{1,2})[\s\.\/\-]([a-z]{3})[\s\.\/\-](\d{3,4})$/i,
                        year: toInt(match3),
                        month: fromMonthAbbr(match2),
                        day: toInt(match1)
                    },
                    {
                        regexp: /^([a-z]{3})[\s\.\/\-](\d{1,2})[\s\.\/\-](\d{3,4})$/i,
                        year: toInt(match3),
                        month: fromMonthAbbr(match1),
                        day: toInt(match2)
                    },
                    {
                        regexp: /^(\d{3,4})[\s\.\/\-]([a-z]{3})[\s\.\/\-](\d{1,2})$/i,
                        year: toInt(match1),
                        month: fromMonthAbbr(match2),
                        day: toInt(match3)
                    },
                    {
                        regexp: /^(\-?\d{3,4})[\s\.\/\-](\d{1,2})[\s\.\/\-](\d{1,2})$/,
                        year: toInt(match1),
                        month: toInt(match2),
                        day: toInt(match3)
                    },
                    {
                        regexp: /^(\d{2})[\s\.\/\-](\d{1,2})[\s\.\/\-](\d{1,2})$/,
                        year: to2000(toInt(match1)),
                        month: toInt(match2),
                        day: toInt(match3)
                    },
                    {
                        regexp: /^(\d{1,2})[\s\.\/\-](\d{1,2})[\s\.\/\-](\-?\d{3,4})$/,
                        year: toInt(match3),
                        month: toInt(match2),
                        day: toInt(match1)
                    },
                    {
                        regexp: new RegExp("^(" + $$($nesting, 'DAYNAMES').$join("|") + ")$", 'i'),
                        year: current_year,
                        month: current_month,
                        day: fromDayName(match1)
                    },
                    {
                        regexp: new RegExp("^(" + full_month_name_regexp + ")[\\s\\.\\/\\-](\\d{1,2})(th|nd|rd)[\\s\\.\\/\\-](\\-?\\d{3,4})$", "i"),
                        year: toInt(match4),
                        month: fromFullMonthName(match1),
                        day: toInt(match2)
                    },
                    {
                        regexp: new RegExp("^(" + full_month_name_regexp + ")[\\s\\.\\/\\-](\\d{1,2})(th|nd|rd)", "i"),
                        year: current_year,
                        month: fromFullMonthName(match1),
                        day: toInt(match2)
                    },
                    {
                        regexp: new RegExp("^(\\d{1,2})(th|nd|rd)[\\s\\.\\/\\-](" + full_month_name_regexp + ")[\\s\\.\\/\\-](\\-?\\d{3,4})$", "i"),
                        year: toInt(match4),
                        month: fromFullMonthName(match3),
                        day: toInt(match1)
                    },
                    {
                        regexp: new RegExp("^(\\-?\\d{3,4})[\\s\\.\\/\\-](" + full_month_name_regexp + ")[\\s\\.\\/\\-](\\d{1,2})(th|nd|rd)$", "i"),
                        year: toInt(match1),
                        month: fromFullMonthName(match2),
                        day: toInt(match3)
                    }
                ];
                var rule, i306, match5;
                for(i306 = 0; i306 < rules.length; i306++){
                    rule = rules[i306];
                    match5 = rule.regexp.exec(string);
                    if (match5) {
                        var year = rule.year;
                        if (typeof year === 'function') {
                            year = year(match5);
                        }
                        var month = rule.month;
                        if (typeof month === 'function') {
                            month = month(match5) - 1;
                        }
                        var day = rule.day;
                        if (typeof day === 'function') {
                            day = day(match5);
                        }
                        var result = new Date(year, month, day);
                        if (year >= 0 && year <= 1970) {
                            result.setFullYear(year);
                        }
                        return self.$wrap(result);
                    }
                }
                return self.$raise($$($nesting, 'ArgumentError'), "invalid date");
            }, $parse$13.$$arity = -2);
            Opal.def(self198, '$today', $today$14 = function $$today() {
                var self = this;
                return self.$wrap(new Date());
            }, $today$14.$$arity = 0);
            return (Opal.def(self198, '$gregorian_leap?', $gregorian_leap$ques$15 = function(year) {
                return new Date(year, 1, 29).getMonth() - 1 === 0;
            }, $gregorian_leap$ques$15.$$arity = 1), nil) && 'gregorian_leap?';
        })(Opal.get_singleton_class(self196), $nesting49);
        Opal.def(self196, '$initialize', $Date_initialize$16 = function $$initialize(year, month, day, start) {
            var self = this;
            if (year == null) {
                year = -4712;
            }
            if (month == null) {
                month = 1;
            }
            if (day == null) {
                day = 1;
            }
            if (start == null) {
                start = $$($nesting49, 'ITALY');
            }
            if (year === 1582 && month === 10 && day > 4 && day < 15) {
                day = 4;
            }
            return self.date = new Date(year, month - 1, day);
        }, $Date_initialize$16.$$arity = -1);
        Opal.def(self196, '$-', $Date_$minus$17 = function(date) {
            var self = this;
            if (date.$$is_number) {
                var result = self.$clone();
                result.date.setDate(self.date.getDate() - date);
                return result;
            } else if (date.date) {
                return Math.round((self.date - date.date) / (1000 * 60 * 60 * 24));
            } else {
                self.$raise($$($nesting49, 'TypeError'));
            }
        }, $Date_$minus$17.$$arity = 1);
        Opal.def(self196, '$+', $Date_$plus$18 = function(date) {
            var self = this;
            if (date.$$is_number) {
                var result = self.$clone();
                result.date.setDate(self.date.getDate() + date);
                return result;
            } else {
                self.$raise($$($nesting49, 'TypeError'));
            }
        }, $Date_$plus$18.$$arity = 1);
        Opal.def(self196, '$<', $Date_$lt$19 = function(other) {
            var self = this;
            var a = self.date, b = other.date;
            a.setHours(0, 0, 0, 0);
            b.setHours(0, 0, 0, 0);
            return a < b;
        }, $Date_$lt$19.$$arity = 1);
        Opal.def(self196, '$<=', $Date_$lt_eq$20 = function(other) {
            var self = this;
            var a = self.date, b = other.date;
            a.setHours(0, 0, 0, 0);
            b.setHours(0, 0, 0, 0);
            return a <= b;
        }, $Date_$lt_eq$20.$$arity = 1);
        Opal.def(self196, '$>', $Date_$gt$21 = function(other) {
            var self = this;
            var a = self.date, b = other.date;
            a.setHours(0, 0, 0, 0);
            b.setHours(0, 0, 0, 0);
            return a > b;
        }, $Date_$gt$21.$$arity = 1);
        Opal.def(self196, '$>=', $Date_$gt_eq$22 = function(other) {
            var self = this;
            var a = self.date, b = other.date;
            a.setHours(0, 0, 0, 0);
            b.setHours(0, 0, 0, 0);
            return a >= b;
        }, $Date_$gt_eq$22.$$arity = 1);
        Opal.def(self196, '$<=>', $Date_$lt_eq_gt$23 = function(other) {
            var self = this;
            if (other.$$is_number) {
                return self.$jd()['$<=>'](other);
            }
            if ($$($nesting49, 'Date')['$==='](other)) {
                var a = self.date, b = other.date;
                a.setHours(0, 0, 0, 0);
                b.setHours(0, 0, 0, 0);
                if (a < b) {
                    return -1;
                } else if (a > b) {
                    return 1;
                } else {
                    return 0;
                }
            } else {
                return nil;
            }
        }, $Date_$lt_eq_gt$23.$$arity = 1);
        Opal.def(self196, '$>>', $Date_$gt$gt$24 = function(n) {
            var self = this;
            if (!n.$$is_number) {
                self.$raise($$($nesting49, 'TypeError'));
            }
            var result = self.$clone(), date = result.date, cur = date.getDate();
            date.setDate(1);
            date.setMonth(date.getMonth() + n);
            date.setDate(Math.min(cur, days_in_month(date.getFullYear(), date.getMonth())));
            return result;
        }, $Date_$gt$gt$24.$$arity = 1);
        Opal.def(self196, '$<<', $Date_$lt$lt$25 = function(n) {
            var self = this;
            if (!n.$$is_number) {
                self.$raise($$($nesting49, 'TypeError'));
            }
            return self['$>>'](-n);
        }, $Date_$lt$lt$25.$$arity = 1);
        Opal.alias(self196, "eql?", "==");
        Opal.def(self196, '$clone', $Date_clone$26 = function $$clone() {
            var self = this;
            return $$($nesting49, 'Date').$wrap(new Date(self.date.getTime()));
        }, $Date_clone$26.$$arity = 0);
        Opal.def(self196, '$day', $Date_day$27 = function $$day() {
            var self = this;
            return self.date.getDate();
        }, $Date_day$27.$$arity = 0);
        Opal.def(self196, '$friday?', $Date_friday$ques$28 = function() {
            var self = this;
            return self.$wday()['$=='](5);
        }, $Date_friday$ques$28.$$arity = 0);
        Opal.def(self196, '$jd', $Date_jd$29 = function $$jd() {
            var self = this;
            var mm = self.date.getMonth() + 1, dd = self.date.getDate(), yy = self.date.getFullYear(), hr = 12, mn = 0, sc = 0, ggg, s, a, j1, jd;
            hr = hr + mn / 60 + sc / 3600;
            ggg = 1;
            if (yy <= 1585) {
                ggg = 0;
            }
            jd = -1 * Math.floor(7 * (Math.floor((mm + 9) / 12) + yy) / 4);
            s = 1;
            if (mm - 9 < 0) {
                s = -1;
            }
            a = Math.abs(mm - 9);
            j1 = Math.floor(yy + s * Math.floor(a / 7));
            j1 = -1 * Math.floor((Math.floor(j1 / 100) + 1) * 3 / 4);
            jd = jd + Math.floor(275 * mm / 9) + dd + ggg * j1;
            jd = jd + 1721027 + 2 * ggg + 367 * yy - 0.5;
            jd = jd + hr / 24;
            return jd;
        }, $Date_jd$29.$$arity = 0);
        Opal.def(self196, '$julian?', $Date_julian$ques$30 = function() {
            var self = this;
            return self.date < new Date(1582, 10 - 1, 15, 12);
        }, $Date_julian$ques$30.$$arity = 0);
        Opal.def(self196, '$monday?', $Date_monday$ques$31 = function() {
            var self = this;
            return self.$wday()['$=='](1);
        }, $Date_monday$ques$31.$$arity = 0);
        Opal.def(self196, '$month', $Date_month$32 = function $$month() {
            var self = this;
            return self.date.getMonth() + 1;
        }, $Date_month$32.$$arity = 0);
        Opal.def(self196, '$next', $Date_next$33 = function $$next() {
            var self = this;
            return $rb_plus(self, 1);
        }, $Date_next$33.$$arity = 0);
        Opal.def(self196, '$next_day', $Date_next_day$34 = function $$next_day(n) {
            var self = this;
            if (n == null) {
                n = 1;
            }
            return $rb_plus(self, n);
        }, $Date_next_day$34.$$arity = -1);
        Opal.def(self196, '$next_month', $Date_next_month$35 = function $$next_month(n) {
            var self = this;
            if (n == null) {
                n = 1;
            }
            var result = self.$clone(), date = result.date, cur = date.getDate();
            date.setDate(1);
            date.setMonth(date.getMonth() + n);
            date.setDate(Math.min(cur, days_in_month(date.getFullYear(), date.getMonth())));
            return result;
        }, $Date_next_month$35.$$arity = -1);
        Opal.def(self196, '$next_year', $Date_next_year$36 = function $$next_year(years) {
            var self = this;
            if (years == null) {
                years = 1;
            }
            return self.$class().$new($rb_plus(self.$year(), years), self.$month(), self.$day());
        }, $Date_next_year$36.$$arity = -1);
        Opal.def(self196, '$prev_day', $Date_prev_day$37 = function $$prev_day(n) {
            var self = this;
            if (n == null) {
                n = 1;
            }
            return $rb_minus(self, n);
        }, $Date_prev_day$37.$$arity = -1);
        Opal.def(self196, '$prev_month', $Date_prev_month$38 = function $$prev_month(n) {
            var self = this;
            if (n == null) {
                n = 1;
            }
            var result = self.$clone(), date = result.date, cur = date.getDate();
            date.setDate(1);
            date.setMonth(date.getMonth() - n);
            date.setDate(Math.min(cur, days_in_month(date.getFullYear(), date.getMonth())));
            return result;
        }, $Date_prev_month$38.$$arity = -1);
        Opal.def(self196, '$prev_year', $Date_prev_year$39 = function $$prev_year(years) {
            var self = this;
            if (years == null) {
                years = 1;
            }
            return self.$class().$new($rb_minus(self.$year(), years), self.$month(), self.$day());
        }, $Date_prev_year$39.$$arity = -1);
        Opal.def(self196, '$saturday?', $Date_saturday$ques$40 = function() {
            var self = this;
            return self.$wday()['$=='](6);
        }, $Date_saturday$ques$40.$$arity = 0);
        Opal.def(self196, '$strftime', $Date_strftime$41 = function $$strftime(format10) {
            var self = this;
            if (format10 == null) {
                format10 = "";
            }
            if (format10 == '') {
                return self.$to_s();
            }
            return self.date.$strftime(format10);
        }, $Date_strftime$41.$$arity = -1);
        Opal.alias(self196, "succ", "next");
        Opal.def(self196, '$sunday?', $Date_sunday$ques$42 = function() {
            var self = this;
            return self.$wday()['$=='](0);
        }, $Date_sunday$ques$42.$$arity = 0);
        Opal.def(self196, '$thursday?', $Date_thursday$ques$43 = function() {
            var self = this;
            return self.$wday()['$=='](4);
        }, $Date_thursday$ques$43.$$arity = 0);
        Opal.def(self196, '$to_s', $Date_to_s$44 = function $$to_s() {
            var self = this;
            var d = self.date, year = d.getFullYear(), month = d.getMonth() + 1, day = d.getDate();
            if (month < 10) {
                month = '0' + month;
            }
            if (day < 10) {
                day = '0' + day;
            }
            return year + '-' + month + '-' + day;
        }, $Date_to_s$44.$$arity = 0);
        Opal.def(self196, '$to_time', $Date_to_time$45 = function $$to_time() {
            var self = this;
            return $$($nesting49, 'Time').$new(self.$year(), self.$month(), self.$day());
        }, $Date_to_time$45.$$arity = 0);
        Opal.def(self196, '$to_n', $Date_to_n$46 = function $$to_n() {
            var self = this;
            return self.date;
        }, $Date_to_n$46.$$arity = 0);
        Opal.def(self196, '$tuesday?', $Date_tuesday$ques$47 = function() {
            var self = this;
            return self.$wday()['$=='](2);
        }, $Date_tuesday$ques$47.$$arity = 0);
        Opal.def(self196, '$step', $Date_step$48 = function $$step(limit, step) {
            var $iter = $Date_step$48.$$p, block = $iter || nil, $$49, $$50, self199 = this, steps_count = nil, steps = nil, result = nil;
            if ($iter) $Date_step$48.$$p = null;
            if ($iter) $Date_step$48.$$p = null;
            if (step == null) {
                step = 1;
            }
            steps_count = $rb_minus(limit, self199).$to_i();
            steps = function() {
                if ($truthy($rb_lt($rb_times(steps_count, step), 0))) {
                    return [];
                } else if ($truthy($rb_lt(steps_count, 0))) {
                    return $send(Opal.Range.$new(0, steps_count['$-@'](), false).$step(step.$abs()), 'map', [], "-@".$to_proc()).$reverse();
                } else {
                    return Opal.Range.$new(0, steps_count, false).$step(step.$abs());
                }
                return nil;
            }();
            result = $send(steps, 'map', [], ($$49 = function(i307) {
                var self = $$49.$$s == null ? this : $$49.$$s;
                if (i307 == null) {
                    i307 = nil;
                }
                return $rb_plus(self, i307);
            }, $$49.$$s = self199, $$49.$$arity = 1, $$49));
            if (block !== nil) {
                $send(result, 'each', [], ($$50 = function(i308) {
                    $$50.$$s == null ? this : $$50.$$s;
                    if (i308 == null) {
                        i308 = nil;
                    }
                    return Opal.yield1(block, i308);
                }, $$50.$$s = self199, $$50.$$arity = 1, $$50));
                return self199;
            } else {
                return result;
            }
        }, $Date_step$48.$$arity = -2);
        Opal.def(self196, '$upto', $Date_upto$51 = function $$upto(max) {
            var $iter = $Date_upto$51.$$p, block = $iter || nil, self = this;
            if ($iter) $Date_upto$51.$$p = null;
            if ($iter) $Date_upto$51.$$p = null;
            return $send(self, 'step', [
                max,
                1
            ], block.$to_proc());
        }, $Date_upto$51.$$arity = 1);
        Opal.def(self196, '$downto', $Date_downto$52 = function $$downto(min33) {
            var $iter = $Date_downto$52.$$p, block = $iter || nil, self = this;
            if ($iter) $Date_downto$52.$$p = null;
            if ($iter) $Date_downto$52.$$p = null;
            return $send(self, 'step', [
                min33,
                -1
            ], block.$to_proc());
        }, $Date_downto$52.$$arity = 1);
        Opal.def(self196, '$wday', $Date_wday$53 = function $$wday() {
            var self = this;
            return self.date.getDay();
        }, $Date_wday$53.$$arity = 0);
        Opal.def(self196, '$wednesday?', $Date_wednesday$ques$54 = function() {
            var self = this;
            return self.$wday()['$=='](3);
        }, $Date_wednesday$ques$54.$$arity = 0);
        Opal.def(self196, '$year', $Date_year$55 = function $$year() {
            var self = this;
            return self.date.getFullYear();
        }, $Date_year$55.$$arity = 0);
        Opal.def(self196, '$cwday', $Date_cwday$56 = function $$cwday() {
            var self = this;
            return self.date.getDay() || 7;
        }, $Date_cwday$56.$$arity = 0);
        Opal.def(self196, '$cweek', $Date_cweek$57 = function $$cweek() {
            var self = this;
            var d = new Date(self.date);
            d.setHours(0, 0, 0);
            d.setDate(d.getDate() + 4 - (d.getDay() || 7));
            return Math.ceil(((d - new Date(d.getFullYear(), 0, 1)) / 8.64e7 + 1) / 7);
        }, $Date_cweek$57.$$arity = 0);
        function days_in_month(year, month) {
            var leap = year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
            return [
                31,
                leap ? 29 : 28,
                31,
                30,
                31,
                30,
                31,
                31,
                30,
                31,
                30,
                31
            ][month];
        }
    }($nesting48[0], null, $nesting48);
})(Opal);
(function(Opal) {
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    var self200 = Opal.top, $nesting50 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;
    Opal.add_stubs([
        '$raise',
        '$new',
        '$push',
        '$[]=',
        '$-',
        '$[]',
        '$create_id',
        '$json_create',
        '$const_get',
        '$attr_accessor',
        '$create_id=',
        '$===',
        '$parse',
        '$generate',
        '$from_object',
        '$merge',
        '$to_json',
        '$responds_to?',
        '$to_io',
        '$write',
        '$to_s',
        '$to_a',
        '$strftime'
    ]);
    (function($base10, $parent_nesting21) {
        var self201 = $module($base10, 'JSON');
        var $nesting = [
            self201
        ].concat($parent_nesting21), $JSON_$$$1, $JSON_parse$2, $JSON_parse$excl$3, $JSON_load$4, $JSON_from_object$5, $JSON_generate$6, $JSON_dump$7, $writer1 = nil;
        (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'JSONError');
            [
                self
            ].concat($parent_nesting);
            return nil;
        })($nesting[0], $$($nesting, 'StandardError'), $nesting);
        (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'ParserError');
            [
                self
            ].concat($parent_nesting);
            return nil;
        })($nesting[0], $$($nesting, 'JSONError'), $nesting);
        var $hasOwn = Opal.hasOwnProperty;
        function $parse(source) {
            try {
                return JSON.parse(source);
            } catch (e) {
                self201.$raise($$$($$($nesting, 'JSON'), 'ParserError'), e.message);
            }
        }
        function to_opal(value, options) {
            var klass, arr, hash, i309, ii, k;
            switch(typeof value){
                case 'string':
                    return value;
                case 'number':
                    return value;
                case 'boolean':
                    return !!value;
                case 'null':
                    return nil;
                case 'object':
                    if (!value) return nil;
                    if (value.$$is_array) {
                        arr = options.array_class.$new();
                        for(i309 = 0, ii = value.length; i309 < ii; i309++){
                            arr.$push(to_opal(value[i309], options));
                        }
                        return arr;
                    } else {
                        hash = options.object_class.$new();
                        for(k in value){
                            if ($hasOwn.call(value, k)) {
                                $writer1 = [
                                    k,
                                    to_opal(value[k], options)
                                ], $send(hash, '[]=', Opal.to_a($writer1)), $writer1[$rb_minus($writer1["length"], 1)];
                            }
                        }
                        if (!options.parse && (klass = hash['$[]']($$($nesting, 'JSON').$create_id())) != nil) {
                            return $$$('::', 'Object').$const_get(klass).$json_create(hash);
                        } else {
                            return hash;
                        }
                    }
            }
        }
        (function(self, $parent_nesting) {
            [
                self
            ].concat($parent_nesting);
            return self.$attr_accessor("create_id");
        })(Opal.get_singleton_class(self201), $nesting);
        $writer1 = [
            "json_class"
        ];
        $send(self201, 'create_id=', Opal.to_a($writer1));
        $writer1[$rb_minus($writer1["length"], 1)];
        Opal.defs(self201, '$[]', $JSON_$$$1 = function(value, options) {
            var self = this;
            if (options == null) {
                options = $hash2([], {});
            }
            if ($truthy($$($nesting, 'String')['$==='](value))) {
                return self.$parse(value, options);
            } else {
                return self.$generate(value, options);
            }
        }, $JSON_$$$1.$$arity = -2);
        Opal.defs(self201, '$parse', $JSON_parse$2 = function $$parse(source, options) {
            var self = this;
            if (options == null) {
                options = $hash2([], {});
            }
            return self.$from_object($parse(source), options.$merge($hash2([
                "parse"
            ], {
                "parse": true
            })));
        }, $JSON_parse$2.$$arity = -2);
        Opal.defs(self201, '$parse!', $JSON_parse$excl$3 = function(source, options) {
            var self = this;
            if (options == null) {
                options = $hash2([], {});
            }
            return self.$parse(source, options);
        }, $JSON_parse$excl$3.$$arity = -2);
        Opal.defs(self201, '$load', $JSON_load$4 = function $$load(source, options) {
            var self = this;
            if (options == null) {
                options = $hash2([], {});
            }
            return self.$from_object($parse(source), options);
        }, $JSON_load$4.$$arity = -2);
        Opal.defs(self201, '$from_object', $JSON_from_object$5 = function $$from_object(js_object, options) {
            var $ret_or_1 = nil, $writer = nil, $ret_or_2 = nil;
            if (options == null) {
                options = $hash2([], {});
            }
            if ($truthy($ret_or_1 = options['$[]']("object_class"))) {} else {
                $writer = [
                    "object_class",
                    $$($nesting, 'Hash')
                ];
                $send(options, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
            }
            if ($truthy($ret_or_2 = options['$[]']("array_class"))) {} else {
                $writer = [
                    "array_class",
                    $$($nesting, 'Array')
                ];
                $send(options, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
            }
            return to_opal(js_object, options.$$smap);
        }, $JSON_from_object$5.$$arity = -2);
        Opal.defs(self201, '$generate', $JSON_generate$6 = function $$generate(obj, options) {
            if (options == null) {
                options = $hash2([], {});
            }
            return obj.$to_json(options);
        }, $JSON_generate$6.$$arity = -2);
        return (Opal.defs(self201, '$dump', $JSON_dump$7 = function $$dump(obj, io, limit) {
            var self = this, string = nil;
            if (io == null) {
                io = nil;
            }
            if (limit == null) {
                limit = nil;
            }
            string = self.$generate(obj);
            if ($truthy(io)) {
                if ($truthy(io['$responds_to?']("to_io"))) {
                    io = io.$to_io();
                }
                io.$write(string);
                return io;
            } else {
                return string;
            }
        }, $JSON_dump$7.$$arity = -2), nil) && 'dump';
    })($nesting50[0], $nesting50);
    (function($base, $super, $parent_nesting) {
        var self202 = $klass($base, $super, 'Object');
        var $nesting = [
            self202
        ].concat($parent_nesting), $Object_to_json$8;
        return (Opal.def(self202, '$to_json', $Object_to_json$8 = function $$to_json() {
            var self = this;
            return self.$to_s().$to_json();
        }, $Object_to_json$8.$$arity = 0), nil) && 'to_json';
    })($nesting50[0], null, $nesting50);
    (function($base, $parent_nesting) {
        var self203 = $module($base, 'Enumerable');
        var $nesting = [
            self203
        ].concat($parent_nesting), $Enumerable_to_json$9;
        return (Opal.def(self203, '$to_json', $Enumerable_to_json$9 = function $$to_json() {
            var self = this;
            return self.$to_a().$to_json();
        }, $Enumerable_to_json$9.$$arity = 0), nil) && 'to_json';
    })($nesting50[0], $nesting50);
    (function($base, $super, $parent_nesting) {
        var self204 = $klass($base, $super, 'Array');
        var $nesting = [
            self204
        ].concat($parent_nesting), $Array_to_json$10;
        return (Opal.def(self204, '$to_json', $Array_to_json$10 = function $$to_json() {
            var self = this;
            var result = [];
            for(var i310 = 0, length = self.length; i310 < length; i310++){
                result.push(self[i310].$to_json());
            }
            return '[' + result.join(', ') + ']';
        }, $Array_to_json$10.$$arity = 0), nil) && 'to_json';
    })($nesting50[0], null, $nesting50);
    (function($base, $super, $parent_nesting) {
        var self205 = $klass($base, $super, 'Boolean');
        var $nesting = [
            self205
        ].concat($parent_nesting), $Boolean_to_json$11;
        return (Opal.def(self205, '$to_json', $Boolean_to_json$11 = function $$to_json() {
            var self = this;
            return self == true ? 'true' : 'false';
        }, $Boolean_to_json$11.$$arity = 0), nil) && 'to_json';
    })($nesting50[0], null, $nesting50);
    (function($base, $super, $parent_nesting) {
        var self206 = $klass($base, $super, 'Hash');
        var $nesting = [
            self206
        ].concat($parent_nesting), $Hash_to_json$12;
        return (Opal.def(self206, '$to_json', $Hash_to_json$12 = function $$to_json() {
            var self = this;
            var result = [];
            for(var i311 = 0, keys = self.$$keys, length = keys.length, key, value; i311 < length; i311++){
                key = keys[i311];
                if (key.$$is_string) {
                    value = self.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                result.push(key.$to_s().$to_json() + ':' + value.$to_json());
            }
            return '{' + result.join(', ') + '}';
        }, $Hash_to_json$12.$$arity = 0), nil) && 'to_json';
    })($nesting50[0], null, $nesting50);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'NilClass');
        var $nesting = [
            self
        ].concat($parent_nesting), $NilClass_to_json$13;
        return (Opal.def(self, '$to_json', $NilClass_to_json$13 = function $$to_json() {
            return "null";
        }, $NilClass_to_json$13.$$arity = 0), nil) && 'to_json';
    })($nesting50[0], null, $nesting50);
    (function($base, $super, $parent_nesting) {
        var self207 = $klass($base, $super, 'Numeric');
        var $nesting = [
            self207
        ].concat($parent_nesting), $Numeric_to_json$14;
        return (Opal.def(self207, '$to_json', $Numeric_to_json$14 = function $$to_json() {
            var self = this;
            return self.toString();
        }, $Numeric_to_json$14.$$arity = 0), nil) && 'to_json';
    })($nesting50[0], null, $nesting50);
    (function($base, $super, $parent_nesting) {
        var self208 = $klass($base, $super, 'String');
        var $nesting = [
            self208
        ].concat($parent_nesting), $String_to_json$15;
        return (Opal.def(self208, '$to_json', $String_to_json$15 = function $$to_json() {
            var self = this;
            return JSON.stringify(self);
        }, $String_to_json$15.$$arity = 0), nil) && 'to_json';
    })($nesting50[0], null, $nesting50);
    (function($base, $super, $parent_nesting) {
        var self209 = $klass($base, $super, 'Time');
        var $nesting = [
            self209
        ].concat($parent_nesting), $Time_to_json$16;
        return (Opal.def(self209, '$to_json', $Time_to_json$16 = function $$to_json() {
            var self = this;
            return self.$strftime("%FT%T%z").$to_json();
        }, $Time_to_json$16.$$arity = 0), nil) && 'to_json';
    })($nesting50[0], null, $nesting50);
    return function($base, $super, $parent_nesting) {
        var self210 = $klass($base, $super, 'Date');
        var $nesting = [
            self210
        ].concat($parent_nesting), $Date_to_json$17, $Date_as_json$18;
        Opal.def(self210, '$to_json', $Date_to_json$17 = function $$to_json() {
            var self = this;
            return self.$to_s().$to_json();
        }, $Date_to_json$17.$$arity = 0);
        return (Opal.def(self210, '$as_json', $Date_as_json$18 = function $$as_json() {
            var self = this;
            return self.$to_s();
        }, $Date_as_json$18.$$arity = 0), nil) && 'as_json';
    }($nesting50[0], null, $nesting50);
})(Opal);
Opal.modules["json"] = function(Opal) {
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    var self211 = Opal.top, $nesting51 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;
    Opal.add_stubs([
        '$raise',
        '$new',
        '$push',
        '$[]=',
        '$-',
        '$[]',
        '$create_id',
        '$json_create',
        '$const_get',
        '$attr_accessor',
        '$create_id=',
        '$===',
        '$parse',
        '$generate',
        '$from_object',
        '$merge',
        '$to_json',
        '$responds_to?',
        '$to_io',
        '$write',
        '$to_s',
        '$to_a',
        '$strftime'
    ]);
    (function($base11, $parent_nesting22) {
        var self212 = $module($base11, 'JSON');
        var $nesting = [
            self212
        ].concat($parent_nesting22), $JSON_$$$1, $JSON_parse$2, $JSON_parse$excl$3, $JSON_load$4, $JSON_from_object$5, $JSON_generate$6, $JSON_dump$7, $writer2 = nil;
        (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'JSONError');
            [
                self
            ].concat($parent_nesting);
            return nil;
        })($nesting[0], $$($nesting, 'StandardError'), $nesting);
        (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'ParserError');
            [
                self
            ].concat($parent_nesting);
            return nil;
        })($nesting[0], $$($nesting, 'JSONError'), $nesting);
        var $hasOwn = Opal.hasOwnProperty;
        function $parse(source) {
            try {
                return JSON.parse(source);
            } catch (e) {
                self212.$raise($$$($$($nesting, 'JSON'), 'ParserError'), e.message);
            }
        }
        function to_opal(value, options) {
            var klass, arr, hash, i312, ii, k;
            switch(typeof value){
                case 'string':
                    return value;
                case 'number':
                    return value;
                case 'boolean':
                    return !!value;
                case 'null':
                    return nil;
                case 'object':
                    if (!value) return nil;
                    if (value.$$is_array) {
                        arr = options.array_class.$new();
                        for(i312 = 0, ii = value.length; i312 < ii; i312++){
                            arr.$push(to_opal(value[i312], options));
                        }
                        return arr;
                    } else {
                        hash = options.object_class.$new();
                        for(k in value){
                            if ($hasOwn.call(value, k)) {
                                $writer2 = [
                                    k,
                                    to_opal(value[k], options)
                                ], $send(hash, '[]=', Opal.to_a($writer2)), $writer2[$rb_minus($writer2["length"], 1)];
                            }
                        }
                        if (!options.parse && (klass = hash['$[]']($$($nesting, 'JSON').$create_id())) != nil) {
                            return $$$('::', 'Object').$const_get(klass).$json_create(hash);
                        } else {
                            return hash;
                        }
                    }
            }
        }
        (function(self, $parent_nesting) {
            [
                self
            ].concat($parent_nesting);
            return self.$attr_accessor("create_id");
        })(Opal.get_singleton_class(self212), $nesting);
        $writer2 = [
            "json_class"
        ];
        $send(self212, 'create_id=', Opal.to_a($writer2));
        $writer2[$rb_minus($writer2["length"], 1)];
        Opal.defs(self212, '$[]', $JSON_$$$1 = function(value, options) {
            var self = this;
            if (options == null) {
                options = $hash2([], {});
            }
            if ($truthy($$($nesting, 'String')['$==='](value))) {
                return self.$parse(value, options);
            } else {
                return self.$generate(value, options);
            }
        }, $JSON_$$$1.$$arity = -2);
        Opal.defs(self212, '$parse', $JSON_parse$2 = function $$parse(source, options) {
            var self = this;
            if (options == null) {
                options = $hash2([], {});
            }
            return self.$from_object($parse(source), options.$merge($hash2([
                "parse"
            ], {
                "parse": true
            })));
        }, $JSON_parse$2.$$arity = -2);
        Opal.defs(self212, '$parse!', $JSON_parse$excl$3 = function(source, options) {
            var self = this;
            if (options == null) {
                options = $hash2([], {});
            }
            return self.$parse(source, options);
        }, $JSON_parse$excl$3.$$arity = -2);
        Opal.defs(self212, '$load', $JSON_load$4 = function $$load(source, options) {
            var self = this;
            if (options == null) {
                options = $hash2([], {});
            }
            return self.$from_object($parse(source), options);
        }, $JSON_load$4.$$arity = -2);
        Opal.defs(self212, '$from_object', $JSON_from_object$5 = function $$from_object(js_object, options) {
            var $ret_or_1 = nil, $writer = nil, $ret_or_2 = nil;
            if (options == null) {
                options = $hash2([], {});
            }
            if ($truthy($ret_or_1 = options['$[]']("object_class"))) {} else {
                $writer = [
                    "object_class",
                    $$($nesting, 'Hash')
                ];
                $send(options, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
            }
            if ($truthy($ret_or_2 = options['$[]']("array_class"))) {} else {
                $writer = [
                    "array_class",
                    $$($nesting, 'Array')
                ];
                $send(options, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
            }
            return to_opal(js_object, options.$$smap);
        }, $JSON_from_object$5.$$arity = -2);
        Opal.defs(self212, '$generate', $JSON_generate$6 = function $$generate(obj, options) {
            if (options == null) {
                options = $hash2([], {});
            }
            return obj.$to_json(options);
        }, $JSON_generate$6.$$arity = -2);
        return (Opal.defs(self212, '$dump', $JSON_dump$7 = function $$dump(obj, io, limit) {
            var self = this, string = nil;
            if (io == null) {
                io = nil;
            }
            if (limit == null) {
                limit = nil;
            }
            string = self.$generate(obj);
            if ($truthy(io)) {
                if ($truthy(io['$responds_to?']("to_io"))) {
                    io = io.$to_io();
                }
                io.$write(string);
                return io;
            } else {
                return string;
            }
        }, $JSON_dump$7.$$arity = -2), nil) && 'dump';
    })($nesting51[0], $nesting51);
    (function($base, $super, $parent_nesting) {
        var self213 = $klass($base, $super, 'Object');
        var $nesting = [
            self213
        ].concat($parent_nesting), $Object_to_json$8;
        return (Opal.def(self213, '$to_json', $Object_to_json$8 = function $$to_json() {
            var self = this;
            return self.$to_s().$to_json();
        }, $Object_to_json$8.$$arity = 0), nil) && 'to_json';
    })($nesting51[0], null, $nesting51);
    (function($base, $parent_nesting) {
        var self214 = $module($base, 'Enumerable');
        var $nesting = [
            self214
        ].concat($parent_nesting), $Enumerable_to_json$9;
        return (Opal.def(self214, '$to_json', $Enumerable_to_json$9 = function $$to_json() {
            var self = this;
            return self.$to_a().$to_json();
        }, $Enumerable_to_json$9.$$arity = 0), nil) && 'to_json';
    })($nesting51[0], $nesting51);
    (function($base, $super, $parent_nesting) {
        var self215 = $klass($base, $super, 'Array');
        var $nesting = [
            self215
        ].concat($parent_nesting), $Array_to_json$10;
        return (Opal.def(self215, '$to_json', $Array_to_json$10 = function $$to_json() {
            var self = this;
            var result = [];
            for(var i313 = 0, length = self.length; i313 < length; i313++){
                result.push(self[i313].$to_json());
            }
            return '[' + result.join(', ') + ']';
        }, $Array_to_json$10.$$arity = 0), nil) && 'to_json';
    })($nesting51[0], null, $nesting51);
    (function($base, $super, $parent_nesting) {
        var self216 = $klass($base, $super, 'Boolean');
        var $nesting = [
            self216
        ].concat($parent_nesting), $Boolean_to_json$11;
        return (Opal.def(self216, '$to_json', $Boolean_to_json$11 = function $$to_json() {
            var self = this;
            return self == true ? 'true' : 'false';
        }, $Boolean_to_json$11.$$arity = 0), nil) && 'to_json';
    })($nesting51[0], null, $nesting51);
    (function($base, $super, $parent_nesting) {
        var self217 = $klass($base, $super, 'Hash');
        var $nesting = [
            self217
        ].concat($parent_nesting), $Hash_to_json$12;
        return (Opal.def(self217, '$to_json', $Hash_to_json$12 = function $$to_json() {
            var self = this;
            var result = [];
            for(var i314 = 0, keys = self.$$keys, length = keys.length, key, value; i314 < length; i314++){
                key = keys[i314];
                if (key.$$is_string) {
                    value = self.$$smap[key];
                } else {
                    value = key.value;
                    key = key.key;
                }
                result.push(key.$to_s().$to_json() + ':' + value.$to_json());
            }
            return '{' + result.join(', ') + '}';
        }, $Hash_to_json$12.$$arity = 0), nil) && 'to_json';
    })($nesting51[0], null, $nesting51);
    (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'NilClass');
        var $nesting = [
            self
        ].concat($parent_nesting), $NilClass_to_json$13;
        return (Opal.def(self, '$to_json', $NilClass_to_json$13 = function $$to_json() {
            return "null";
        }, $NilClass_to_json$13.$$arity = 0), nil) && 'to_json';
    })($nesting51[0], null, $nesting51);
    (function($base, $super, $parent_nesting) {
        var self218 = $klass($base, $super, 'Numeric');
        var $nesting = [
            self218
        ].concat($parent_nesting), $Numeric_to_json$14;
        return (Opal.def(self218, '$to_json', $Numeric_to_json$14 = function $$to_json() {
            var self = this;
            return self.toString();
        }, $Numeric_to_json$14.$$arity = 0), nil) && 'to_json';
    })($nesting51[0], null, $nesting51);
    (function($base, $super, $parent_nesting) {
        var self219 = $klass($base, $super, 'String');
        var $nesting = [
            self219
        ].concat($parent_nesting), $String_to_json$15;
        return (Opal.def(self219, '$to_json', $String_to_json$15 = function $$to_json() {
            var self = this;
            return JSON.stringify(self);
        }, $String_to_json$15.$$arity = 0), nil) && 'to_json';
    })($nesting51[0], null, $nesting51);
    (function($base, $super, $parent_nesting) {
        var self220 = $klass($base, $super, 'Time');
        var $nesting = [
            self220
        ].concat($parent_nesting), $Time_to_json$16;
        return (Opal.def(self220, '$to_json', $Time_to_json$16 = function $$to_json() {
            var self = this;
            return self.$strftime("%FT%T%z").$to_json();
        }, $Time_to_json$16.$$arity = 0), nil) && 'to_json';
    })($nesting51[0], null, $nesting51);
    return function($base, $super, $parent_nesting) {
        var self221 = $klass($base, $super, 'Date');
        var $nesting = [
            self221
        ].concat($parent_nesting), $Date_to_json$17, $Date_as_json$18;
        Opal.def(self221, '$to_json', $Date_to_json$17 = function $$to_json() {
            var self = this;
            return self.$to_s().$to_json();
        }, $Date_to_json$17.$$arity = 0);
        return (Opal.def(self221, '$as_json', $Date_as_json$18 = function $$as_json() {
            var self = this;
            return self.$to_s();
        }, $Date_as_json$18.$$arity = 0), nil) && 'as_json';
    }($nesting51[0], null, $nesting51);
};
Opal.modules["date"] = function(Opal) {
    function $rb_gt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs > rhs : lhs['$>'](rhs);
    }
    function $rb_plus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
    }
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    function $rb_lt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs < rhs : lhs['$<'](rhs);
    }
    function $rb_times(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs * rhs : lhs['$*'](rhs);
    }
    var self222 = Opal.top, $nesting52 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send2 = Opal.send2, $truthy = Opal.truthy, $send = Opal.send;
    Opal.add_stubs([
        '$include',
        '$<=>',
        '$attr_reader',
        '$nonzero?',
        '$d',
        '$zero?',
        '$new',
        '$class',
        '$-@',
        '$+@',
        '$===',
        '$coerce',
        '$==',
        '$>',
        '$+',
        '$allocate',
        '$join',
        '$compact',
        '$map',
        '$to_proc',
        '$downcase',
        '$wrap',
        '$raise',
        '$clone',
        '$jd',
        '$>>',
        '$wday',
        '$year',
        '$month',
        '$day',
        '$-',
        '$to_s',
        '$to_i',
        '$<',
        '$*',
        '$reverse',
        '$step',
        '$abs',
        '$each'
    ]);
    return function($base12, $super6, $parent_nesting23) {
        var self223 = $klass($base12, $super6, 'Date');
        var $nesting53 = [
            self223
        ].concat($parent_nesting23), $Date_initialize$16, $Date_$minus$17, $Date_$plus$18, $Date_$lt$19, $Date_$lt_eq$20, $Date_$gt$21, $Date_$gt_eq$22, $Date_$lt_eq_gt$23, $Date_$gt$gt$24, $Date_$lt$lt$25, $Date_clone$26, $Date_day$27, $Date_friday$ques$28, $Date_jd$29, $Date_julian$ques$30, $Date_monday$ques$31, $Date_month$32, $Date_next$33, $Date_next_day$34, $Date_next_month$35, $Date_next_year$36, $Date_prev_day$37, $Date_prev_month$38, $Date_prev_year$39, $Date_saturday$ques$40, $Date_strftime$41, $Date_sunday$ques$42, $Date_thursday$ques$43, $Date_to_s$44, $Date_to_time$45, $Date_to_n$46, $Date_tuesday$ques$47, $Date_step$48, $Date_upto$51, $Date_downto$52, $Date_wday$53, $Date_wednesday$ques$54, $Date_year$55, $Date_cwday$56, $Date_cweek$57;
        self223.$$prototype.date = nil;
        self223.$include($$($nesting53, 'Comparable'));
        (function($base, $super, $parent_nesting) {
            var self224 = $klass($base, $super, 'Infinity');
            var $nesting = [
                self224
            ].concat($parent_nesting), $Infinity_initialize$1, $Infinity_zero$ques$2, $Infinity_finite$ques$3, $Infinity_infinite$ques$4, $Infinity_nan$ques$5, $Infinity_abs$6, $Infinity_$minus$$7, $Infinity_$plus$$8, $Infinity_$lt_eq_gt$9, $Infinity_coerce$10, $Infinity_to_f$11;
            self224.$$prototype.d = nil;
            self224.$include($$($nesting, 'Comparable'));
            Opal.def(self224, '$initialize', $Infinity_initialize$1 = function $$initialize(d) {
                var self = this;
                if (d == null) {
                    d = 1;
                }
                return self.d = d['$<=>'](0);
            }, $Infinity_initialize$1.$$arity = -1);
            self224.$attr_reader("d");
            Opal.def(self224, '$zero?', $Infinity_zero$ques$2 = function() {
                return false;
            }, $Infinity_zero$ques$2.$$arity = 0);
            Opal.def(self224, '$finite?', $Infinity_finite$ques$3 = function() {
                return false;
            }, $Infinity_finite$ques$3.$$arity = 0);
            Opal.def(self224, '$infinite?', $Infinity_infinite$ques$4 = function() {
                var self = this;
                return self.$d()['$nonzero?']();
            }, $Infinity_infinite$ques$4.$$arity = 0);
            Opal.def(self224, '$nan?', $Infinity_nan$ques$5 = function() {
                var self = this;
                return self.$d()['$zero?']();
            }, $Infinity_nan$ques$5.$$arity = 0);
            Opal.def(self224, '$abs', $Infinity_abs$6 = function $$abs() {
                var self = this;
                return self.$class().$new();
            }, $Infinity_abs$6.$$arity = 0);
            Opal.def(self224, '$-@', $Infinity_$minus$$7 = function() {
                var self = this;
                return self.$class().$new(self.$d()['$-@']());
            }, $Infinity_$minus$$7.$$arity = 0);
            Opal.def(self224, '$+@', $Infinity_$plus$$8 = function() {
                var self = this;
                return self.$class().$new(self.$d()['$+@']());
            }, $Infinity_$plus$$8.$$arity = 0);
            Opal.def(self224, '$<=>', $Infinity_$lt_eq_gt$9 = function(other) {
                var $a, $b, self = this, $case = nil, l = nil, r = nil;
                return function() {
                    $case = other;
                    if ($$($nesting, 'Infinity')['$===']($case)) {
                        return self.$d()['$<=>'](other.$d());
                    } else if ($$($nesting, 'Numeric')['$===']($case)) {
                        return self.$d();
                    } else {
                        try {
                            $b = other.$coerce(self), $a = Opal.to_ary($b), l = $a[0] == null ? nil : $a[0], r = $a[1] == null ? nil : $a[1], $b;
                            return l['$<=>'](r);
                        } catch ($err) {
                            if (Opal.rescue($err, [
                                $$($nesting, 'NoMethodError')
                            ])) {
                                try {
                                    return nil;
                                } finally{
                                    Opal.pop_exception();
                                }
                            } else {
                                throw $err;
                            }
                        }
                    }
                }();
            }, $Infinity_$lt_eq_gt$9.$$arity = 1);
            Opal.def(self224, '$coerce', $Infinity_coerce$10 = function $$coerce(other) {
                var $iter = $Infinity_coerce$10.$$p, self = this, $case = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
                if ($iter) $Infinity_coerce$10.$$p = null;
                for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++){
                    $zuper[$zuper_i] = arguments[$zuper_i];
                }
                return function() {
                    $case = other;
                    if ($$($nesting, 'Numeric')['$===']($case)) {
                        return [
                            self.$d()['$-@'](),
                            self.$d()
                        ];
                    } else {
                        return $send2(self, Opal.find_super_dispatcher(self, 'coerce', $Infinity_coerce$10, false, true), 'coerce', $zuper, $iter);
                    }
                }();
            }, $Infinity_coerce$10.$$arity = 1);
            return (Opal.def(self224, '$to_f', $Infinity_to_f$11 = function $$to_f() {
                var self = this;
                if (self.d['$=='](0)) {
                    return 0;
                }
                if ($truthy($rb_gt(self.d, 0))) {
                    return $$$($$($nesting, 'Float'), 'INFINITY');
                } else {
                    return $$$($$($nesting, 'Float'), 'INFINITY')['$-@']();
                }
            }, $Infinity_to_f$11.$$arity = 0), nil) && 'to_f';
        })($nesting53[0], $$($nesting53, 'Numeric'), $nesting53);
        Opal.const_set($nesting53[0], 'JULIAN', $$($nesting53, 'Infinity').$new());
        Opal.const_set($nesting53[0], 'GREGORIAN', $$($nesting53, 'Infinity').$new()['$-@']());
        Opal.const_set($nesting53[0], 'ITALY', 2299161);
        Opal.const_set($nesting53[0], 'ENGLAND', 2361222);
        Opal.const_set($nesting53[0], 'MONTHNAMES', $rb_plus([
            nil
        ], [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
        ]));
        Opal.const_set($nesting53[0], 'ABBR_MONTHNAMES', [
            "jan",
            "feb",
            "mar",
            "apr",
            "may",
            "jun",
            "jul",
            "aug",
            "sep",
            "oct",
            "nov",
            "dec"
        ]);
        Opal.const_set($nesting53[0], 'DAYNAMES', [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
        ]);
        Opal.const_set($nesting53[0], 'ABBR_DAYNAMES', [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
        ]);
        (function(self225, $parent_nesting) {
            var $nesting = [
                self225
            ].concat($parent_nesting), $wrap$12, $parse$13, $today$14, $gregorian_leap$ques$15;
            Opal.alias(self225, "civil", "new");
            Opal.def(self225, '$wrap', $wrap$12 = function $$wrap(native$) {
                var self = this, instance = nil;
                instance = self.$allocate();
                instance.date = native$;
                return instance;
            }, $wrap$12.$$arity = 1);
            Opal.def(self225, '$parse', $parse$13 = function $$parse(string, comp) {
                var self = this;
                if (comp == null) {
                    comp = true;
                }
                var current_date = new Date();
                var current_day = current_date.getDate(), current_month = current_date.getMonth(), current_year = current_date.getFullYear(), current_wday = current_date.getDay(), full_month_name_regexp = $$($nesting, 'MONTHNAMES').$compact().$join("|");
                function match1(match) {
                    return match[1];
                }
                function match2(match) {
                    return match[2];
                }
                function match3(match) {
                    return match[3];
                }
                function match4(match) {
                    return match[4];
                }
                function fromShortYear(fn) {
                    return function(match) {
                        var short_year = fn(match);
                        if (short_year >= 69) {
                            short_year += 1900;
                        } else {
                            short_year += 2000;
                        }
                        return short_year;
                    };
                }
                function fromMonthAbbr(fn) {
                    return function(match) {
                        var abbr = fn(match).toLowerCase();
                        return $$($nesting, 'ABBR_MONTHNAMES').indexOf(abbr) + 1;
                    };
                }
                function toInt(fn) {
                    return function(match) {
                        var value = fn(match);
                        return parseInt(value, 10);
                    };
                }
                function to2000(fn) {
                    return function(match) {
                        var value = fn(match);
                        if (comp) {
                            return value + 2000;
                        } else {
                            return value;
                        }
                    };
                }
                function fromDayName(fn) {
                    return function(match) {
                        var dayname = fn(match), wday = $send($$($nesting, 'DAYNAMES'), 'map', [], "downcase".$to_proc()).indexOf(dayname.$downcase());
                        return current_day - current_wday + wday;
                    };
                }
                function fromFullMonthName(fn) {
                    return function(match) {
                        var month_name = fn(match);
                        return $send($$($nesting, 'MONTHNAMES').$compact(), 'map', [], "downcase".$to_proc()).indexOf(month_name.$downcase()) + 1;
                    };
                }
                var rules = [
                    {
                        regexp: /^(\d{2})$/,
                        year: current_year,
                        month: current_month,
                        day: toInt(match1)
                    },
                    {
                        regexp: /^(\d{3})$/,
                        year: current_year,
                        month: 0,
                        day: toInt(match1)
                    },
                    {
                        regexp: /^(\d{2})(\d{2})$/,
                        year: current_year,
                        month: toInt(match1),
                        day: toInt(match2)
                    },
                    {
                        regexp: /^(\d{2})(\d{3})$/,
                        year: fromShortYear(toInt(match1)),
                        month: 0,
                        day: toInt(match2)
                    },
                    {
                        regexp: /^(\d{2})(\d{2})(\d{2})$/,
                        year: fromShortYear(toInt(match1)),
                        month: toInt(match2),
                        day: toInt(match3)
                    },
                    {
                        regexp: /^(\d{4})(\d{3})$/,
                        year: toInt(match1),
                        month: 0,
                        day: toInt(match2)
                    },
                    {
                        regexp: /^(\d{4})(\d{2})(\d{2})$/,
                        year: toInt(match1),
                        month: toInt(match2),
                        day: toInt(match3)
                    },
                    {
                        regexp: /^([a-z]{3})[\s\.\/\-](\d{3,4})$/,
                        year: toInt(match2),
                        month: fromMonthAbbr(match1),
                        day: 1
                    },
                    {
                        regexp: /^(\d{1,2})[\s\.\/\-]([a-z]{3})[\s\.\/\-](\d{3,4})$/i,
                        year: toInt(match3),
                        month: fromMonthAbbr(match2),
                        day: toInt(match1)
                    },
                    {
                        regexp: /^([a-z]{3})[\s\.\/\-](\d{1,2})[\s\.\/\-](\d{3,4})$/i,
                        year: toInt(match3),
                        month: fromMonthAbbr(match1),
                        day: toInt(match2)
                    },
                    {
                        regexp: /^(\d{3,4})[\s\.\/\-]([a-z]{3})[\s\.\/\-](\d{1,2})$/i,
                        year: toInt(match1),
                        month: fromMonthAbbr(match2),
                        day: toInt(match3)
                    },
                    {
                        regexp: /^(\-?\d{3,4})[\s\.\/\-](\d{1,2})[\s\.\/\-](\d{1,2})$/,
                        year: toInt(match1),
                        month: toInt(match2),
                        day: toInt(match3)
                    },
                    {
                        regexp: /^(\d{2})[\s\.\/\-](\d{1,2})[\s\.\/\-](\d{1,2})$/,
                        year: to2000(toInt(match1)),
                        month: toInt(match2),
                        day: toInt(match3)
                    },
                    {
                        regexp: /^(\d{1,2})[\s\.\/\-](\d{1,2})[\s\.\/\-](\-?\d{3,4})$/,
                        year: toInt(match3),
                        month: toInt(match2),
                        day: toInt(match1)
                    },
                    {
                        regexp: new RegExp("^(" + $$($nesting, 'DAYNAMES').$join("|") + ")$", 'i'),
                        year: current_year,
                        month: current_month,
                        day: fromDayName(match1)
                    },
                    {
                        regexp: new RegExp("^(" + full_month_name_regexp + ")[\\s\\.\\/\\-](\\d{1,2})(th|nd|rd)[\\s\\.\\/\\-](\\-?\\d{3,4})$", "i"),
                        year: toInt(match4),
                        month: fromFullMonthName(match1),
                        day: toInt(match2)
                    },
                    {
                        regexp: new RegExp("^(" + full_month_name_regexp + ")[\\s\\.\\/\\-](\\d{1,2})(th|nd|rd)", "i"),
                        year: current_year,
                        month: fromFullMonthName(match1),
                        day: toInt(match2)
                    },
                    {
                        regexp: new RegExp("^(\\d{1,2})(th|nd|rd)[\\s\\.\\/\\-](" + full_month_name_regexp + ")[\\s\\.\\/\\-](\\-?\\d{3,4})$", "i"),
                        year: toInt(match4),
                        month: fromFullMonthName(match3),
                        day: toInt(match1)
                    },
                    {
                        regexp: new RegExp("^(\\-?\\d{3,4})[\\s\\.\\/\\-](" + full_month_name_regexp + ")[\\s\\.\\/\\-](\\d{1,2})(th|nd|rd)$", "i"),
                        year: toInt(match1),
                        month: fromFullMonthName(match2),
                        day: toInt(match3)
                    }
                ];
                var rule, i315, match6;
                for(i315 = 0; i315 < rules.length; i315++){
                    rule = rules[i315];
                    match6 = rule.regexp.exec(string);
                    if (match6) {
                        var year = rule.year;
                        if (typeof year === 'function') {
                            year = year(match6);
                        }
                        var month = rule.month;
                        if (typeof month === 'function') {
                            month = month(match6) - 1;
                        }
                        var day = rule.day;
                        if (typeof day === 'function') {
                            day = day(match6);
                        }
                        var result = new Date(year, month, day);
                        if (year >= 0 && year <= 1970) {
                            result.setFullYear(year);
                        }
                        return self.$wrap(result);
                    }
                }
                return self.$raise($$($nesting, 'ArgumentError'), "invalid date");
            }, $parse$13.$$arity = -2);
            Opal.def(self225, '$today', $today$14 = function $$today() {
                var self = this;
                return self.$wrap(new Date());
            }, $today$14.$$arity = 0);
            return (Opal.def(self225, '$gregorian_leap?', $gregorian_leap$ques$15 = function(year) {
                return new Date(year, 1, 29).getMonth() - 1 === 0;
            }, $gregorian_leap$ques$15.$$arity = 1), nil) && 'gregorian_leap?';
        })(Opal.get_singleton_class(self223), $nesting53);
        Opal.def(self223, '$initialize', $Date_initialize$16 = function $$initialize(year, month, day, start) {
            var self = this;
            if (year == null) {
                year = -4712;
            }
            if (month == null) {
                month = 1;
            }
            if (day == null) {
                day = 1;
            }
            if (start == null) {
                start = $$($nesting53, 'ITALY');
            }
            if (year === 1582 && month === 10 && day > 4 && day < 15) {
                day = 4;
            }
            return self.date = new Date(year, month - 1, day);
        }, $Date_initialize$16.$$arity = -1);
        Opal.def(self223, '$-', $Date_$minus$17 = function(date) {
            var self = this;
            if (date.$$is_number) {
                var result = self.$clone();
                result.date.setDate(self.date.getDate() - date);
                return result;
            } else if (date.date) {
                return Math.round((self.date - date.date) / (1000 * 60 * 60 * 24));
            } else {
                self.$raise($$($nesting53, 'TypeError'));
            }
        }, $Date_$minus$17.$$arity = 1);
        Opal.def(self223, '$+', $Date_$plus$18 = function(date) {
            var self = this;
            if (date.$$is_number) {
                var result = self.$clone();
                result.date.setDate(self.date.getDate() + date);
                return result;
            } else {
                self.$raise($$($nesting53, 'TypeError'));
            }
        }, $Date_$plus$18.$$arity = 1);
        Opal.def(self223, '$<', $Date_$lt$19 = function(other) {
            var self = this;
            var a = self.date, b = other.date;
            a.setHours(0, 0, 0, 0);
            b.setHours(0, 0, 0, 0);
            return a < b;
        }, $Date_$lt$19.$$arity = 1);
        Opal.def(self223, '$<=', $Date_$lt_eq$20 = function(other) {
            var self = this;
            var a = self.date, b = other.date;
            a.setHours(0, 0, 0, 0);
            b.setHours(0, 0, 0, 0);
            return a <= b;
        }, $Date_$lt_eq$20.$$arity = 1);
        Opal.def(self223, '$>', $Date_$gt$21 = function(other) {
            var self = this;
            var a = self.date, b = other.date;
            a.setHours(0, 0, 0, 0);
            b.setHours(0, 0, 0, 0);
            return a > b;
        }, $Date_$gt$21.$$arity = 1);
        Opal.def(self223, '$>=', $Date_$gt_eq$22 = function(other) {
            var self = this;
            var a = self.date, b = other.date;
            a.setHours(0, 0, 0, 0);
            b.setHours(0, 0, 0, 0);
            return a >= b;
        }, $Date_$gt_eq$22.$$arity = 1);
        Opal.def(self223, '$<=>', $Date_$lt_eq_gt$23 = function(other) {
            var self = this;
            if (other.$$is_number) {
                return self.$jd()['$<=>'](other);
            }
            if ($$($nesting53, 'Date')['$==='](other)) {
                var a = self.date, b = other.date;
                a.setHours(0, 0, 0, 0);
                b.setHours(0, 0, 0, 0);
                if (a < b) {
                    return -1;
                } else if (a > b) {
                    return 1;
                } else {
                    return 0;
                }
            } else {
                return nil;
            }
        }, $Date_$lt_eq_gt$23.$$arity = 1);
        Opal.def(self223, '$>>', $Date_$gt$gt$24 = function(n) {
            var self = this;
            if (!n.$$is_number) {
                self.$raise($$($nesting53, 'TypeError'));
            }
            var result = self.$clone(), date = result.date, cur = date.getDate();
            date.setDate(1);
            date.setMonth(date.getMonth() + n);
            date.setDate(Math.min(cur, days_in_month(date.getFullYear(), date.getMonth())));
            return result;
        }, $Date_$gt$gt$24.$$arity = 1);
        Opal.def(self223, '$<<', $Date_$lt$lt$25 = function(n) {
            var self = this;
            if (!n.$$is_number) {
                self.$raise($$($nesting53, 'TypeError'));
            }
            return self['$>>'](-n);
        }, $Date_$lt$lt$25.$$arity = 1);
        Opal.alias(self223, "eql?", "==");
        Opal.def(self223, '$clone', $Date_clone$26 = function $$clone() {
            var self = this;
            return $$($nesting53, 'Date').$wrap(new Date(self.date.getTime()));
        }, $Date_clone$26.$$arity = 0);
        Opal.def(self223, '$day', $Date_day$27 = function $$day() {
            var self = this;
            return self.date.getDate();
        }, $Date_day$27.$$arity = 0);
        Opal.def(self223, '$friday?', $Date_friday$ques$28 = function() {
            var self = this;
            return self.$wday()['$=='](5);
        }, $Date_friday$ques$28.$$arity = 0);
        Opal.def(self223, '$jd', $Date_jd$29 = function $$jd() {
            var self = this;
            var mm = self.date.getMonth() + 1, dd = self.date.getDate(), yy = self.date.getFullYear(), hr = 12, mn = 0, sc = 0, ggg, s, a, j1, jd;
            hr = hr + mn / 60 + sc / 3600;
            ggg = 1;
            if (yy <= 1585) {
                ggg = 0;
            }
            jd = -1 * Math.floor(7 * (Math.floor((mm + 9) / 12) + yy) / 4);
            s = 1;
            if (mm - 9 < 0) {
                s = -1;
            }
            a = Math.abs(mm - 9);
            j1 = Math.floor(yy + s * Math.floor(a / 7));
            j1 = -1 * Math.floor((Math.floor(j1 / 100) + 1) * 3 / 4);
            jd = jd + Math.floor(275 * mm / 9) + dd + ggg * j1;
            jd = jd + 1721027 + 2 * ggg + 367 * yy - 0.5;
            jd = jd + hr / 24;
            return jd;
        }, $Date_jd$29.$$arity = 0);
        Opal.def(self223, '$julian?', $Date_julian$ques$30 = function() {
            var self = this;
            return self.date < new Date(1582, 10 - 1, 15, 12);
        }, $Date_julian$ques$30.$$arity = 0);
        Opal.def(self223, '$monday?', $Date_monday$ques$31 = function() {
            var self = this;
            return self.$wday()['$=='](1);
        }, $Date_monday$ques$31.$$arity = 0);
        Opal.def(self223, '$month', $Date_month$32 = function $$month() {
            var self = this;
            return self.date.getMonth() + 1;
        }, $Date_month$32.$$arity = 0);
        Opal.def(self223, '$next', $Date_next$33 = function $$next() {
            var self = this;
            return $rb_plus(self, 1);
        }, $Date_next$33.$$arity = 0);
        Opal.def(self223, '$next_day', $Date_next_day$34 = function $$next_day(n) {
            var self = this;
            if (n == null) {
                n = 1;
            }
            return $rb_plus(self, n);
        }, $Date_next_day$34.$$arity = -1);
        Opal.def(self223, '$next_month', $Date_next_month$35 = function $$next_month(n) {
            var self = this;
            if (n == null) {
                n = 1;
            }
            var result = self.$clone(), date = result.date, cur = date.getDate();
            date.setDate(1);
            date.setMonth(date.getMonth() + n);
            date.setDate(Math.min(cur, days_in_month(date.getFullYear(), date.getMonth())));
            return result;
        }, $Date_next_month$35.$$arity = -1);
        Opal.def(self223, '$next_year', $Date_next_year$36 = function $$next_year(years) {
            var self = this;
            if (years == null) {
                years = 1;
            }
            return self.$class().$new($rb_plus(self.$year(), years), self.$month(), self.$day());
        }, $Date_next_year$36.$$arity = -1);
        Opal.def(self223, '$prev_day', $Date_prev_day$37 = function $$prev_day(n) {
            var self = this;
            if (n == null) {
                n = 1;
            }
            return $rb_minus(self, n);
        }, $Date_prev_day$37.$$arity = -1);
        Opal.def(self223, '$prev_month', $Date_prev_month$38 = function $$prev_month(n) {
            var self = this;
            if (n == null) {
                n = 1;
            }
            var result = self.$clone(), date = result.date, cur = date.getDate();
            date.setDate(1);
            date.setMonth(date.getMonth() - n);
            date.setDate(Math.min(cur, days_in_month(date.getFullYear(), date.getMonth())));
            return result;
        }, $Date_prev_month$38.$$arity = -1);
        Opal.def(self223, '$prev_year', $Date_prev_year$39 = function $$prev_year(years) {
            var self = this;
            if (years == null) {
                years = 1;
            }
            return self.$class().$new($rb_minus(self.$year(), years), self.$month(), self.$day());
        }, $Date_prev_year$39.$$arity = -1);
        Opal.def(self223, '$saturday?', $Date_saturday$ques$40 = function() {
            var self = this;
            return self.$wday()['$=='](6);
        }, $Date_saturday$ques$40.$$arity = 0);
        Opal.def(self223, '$strftime', $Date_strftime$41 = function $$strftime(format11) {
            var self = this;
            if (format11 == null) {
                format11 = "";
            }
            if (format11 == '') {
                return self.$to_s();
            }
            return self.date.$strftime(format11);
        }, $Date_strftime$41.$$arity = -1);
        Opal.alias(self223, "succ", "next");
        Opal.def(self223, '$sunday?', $Date_sunday$ques$42 = function() {
            var self = this;
            return self.$wday()['$=='](0);
        }, $Date_sunday$ques$42.$$arity = 0);
        Opal.def(self223, '$thursday?', $Date_thursday$ques$43 = function() {
            var self = this;
            return self.$wday()['$=='](4);
        }, $Date_thursday$ques$43.$$arity = 0);
        Opal.def(self223, '$to_s', $Date_to_s$44 = function $$to_s() {
            var self = this;
            var d = self.date, year = d.getFullYear(), month = d.getMonth() + 1, day = d.getDate();
            if (month < 10) {
                month = '0' + month;
            }
            if (day < 10) {
                day = '0' + day;
            }
            return year + '-' + month + '-' + day;
        }, $Date_to_s$44.$$arity = 0);
        Opal.def(self223, '$to_time', $Date_to_time$45 = function $$to_time() {
            var self = this;
            return $$($nesting53, 'Time').$new(self.$year(), self.$month(), self.$day());
        }, $Date_to_time$45.$$arity = 0);
        Opal.def(self223, '$to_n', $Date_to_n$46 = function $$to_n() {
            var self = this;
            return self.date;
        }, $Date_to_n$46.$$arity = 0);
        Opal.def(self223, '$tuesday?', $Date_tuesday$ques$47 = function() {
            var self = this;
            return self.$wday()['$=='](2);
        }, $Date_tuesday$ques$47.$$arity = 0);
        Opal.def(self223, '$step', $Date_step$48 = function $$step(limit, step) {
            var $iter = $Date_step$48.$$p, block = $iter || nil, $$49, $$50, self226 = this, steps_count = nil, steps = nil, result = nil;
            if ($iter) $Date_step$48.$$p = null;
            if ($iter) $Date_step$48.$$p = null;
            if (step == null) {
                step = 1;
            }
            steps_count = $rb_minus(limit, self226).$to_i();
            steps = function() {
                if ($truthy($rb_lt($rb_times(steps_count, step), 0))) {
                    return [];
                } else if ($truthy($rb_lt(steps_count, 0))) {
                    return $send(Opal.Range.$new(0, steps_count['$-@'](), false).$step(step.$abs()), 'map', [], "-@".$to_proc()).$reverse();
                } else {
                    return Opal.Range.$new(0, steps_count, false).$step(step.$abs());
                }
                return nil;
            }();
            result = $send(steps, 'map', [], ($$49 = function(i316) {
                var self = $$49.$$s == null ? this : $$49.$$s;
                if (i316 == null) {
                    i316 = nil;
                }
                return $rb_plus(self, i316);
            }, $$49.$$s = self226, $$49.$$arity = 1, $$49));
            if (block !== nil) {
                $send(result, 'each', [], ($$50 = function(i317) {
                    $$50.$$s == null ? this : $$50.$$s;
                    if (i317 == null) {
                        i317 = nil;
                    }
                    return Opal.yield1(block, i317);
                }, $$50.$$s = self226, $$50.$$arity = 1, $$50));
                return self226;
            } else {
                return result;
            }
        }, $Date_step$48.$$arity = -2);
        Opal.def(self223, '$upto', $Date_upto$51 = function $$upto(max) {
            var $iter = $Date_upto$51.$$p, block = $iter || nil, self = this;
            if ($iter) $Date_upto$51.$$p = null;
            if ($iter) $Date_upto$51.$$p = null;
            return $send(self, 'step', [
                max,
                1
            ], block.$to_proc());
        }, $Date_upto$51.$$arity = 1);
        Opal.def(self223, '$downto', $Date_downto$52 = function $$downto(min34) {
            var $iter = $Date_downto$52.$$p, block = $iter || nil, self = this;
            if ($iter) $Date_downto$52.$$p = null;
            if ($iter) $Date_downto$52.$$p = null;
            return $send(self, 'step', [
                min34,
                -1
            ], block.$to_proc());
        }, $Date_downto$52.$$arity = 1);
        Opal.def(self223, '$wday', $Date_wday$53 = function $$wday() {
            var self = this;
            return self.date.getDay();
        }, $Date_wday$53.$$arity = 0);
        Opal.def(self223, '$wednesday?', $Date_wednesday$ques$54 = function() {
            var self = this;
            return self.$wday()['$=='](3);
        }, $Date_wednesday$ques$54.$$arity = 0);
        Opal.def(self223, '$year', $Date_year$55 = function $$year() {
            var self = this;
            return self.date.getFullYear();
        }, $Date_year$55.$$arity = 0);
        Opal.def(self223, '$cwday', $Date_cwday$56 = function $$cwday() {
            var self = this;
            return self.date.getDay() || 7;
        }, $Date_cwday$56.$$arity = 0);
        Opal.def(self223, '$cweek', $Date_cweek$57 = function $$cweek() {
            var self = this;
            var d = new Date(self.date);
            d.setHours(0, 0, 0);
            d.setDate(d.getDate() + 4 - (d.getDay() || 7));
            return Math.ceil(((d - new Date(d.getFullYear(), 0, 1)) / 8.64e7 + 1) / 7);
        }, $Date_cweek$57.$$arity = 0);
        function days_in_month(year, month) {
            var leap = year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
            return [
                31,
                leap ? 29 : 28,
                31,
                30,
                31,
                30,
                31,
                31,
                30,
                31,
                30,
                31
            ][month];
        }
    }($nesting52[0], null, $nesting52);
};
(function(Opal) {
    function $rb_plus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
    }
    function $rb_gt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs > rhs : lhs['$>'](rhs);
    }
    function $rb_lt(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs < rhs : lhs['$<'](rhs);
    }
    function $rb_minus(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
    }
    function $rb_le(lhs, rhs) {
        return typeof lhs === 'number' && typeof rhs === 'number' ? lhs <= rhs : lhs['$<='](rhs);
    }
    var self227 = Opal.top, $nesting54 = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range;
    Opal.add_stubs([
        '$require',
        '$setup',
        '$first',
        '$drop',
        '$===',
        '$empty?',
        '$raise',
        '$+',
        '$add',
        '$join',
        '$>',
        '$length',
        '$change_state',
        '$to_i',
        '$list',
        '$<',
        '$set_priority',
        '$due_date',
        '$append',
        '$rename',
        '$!=',
        '$delete',
        '$add_note',
        '$delete_note',
        '$[]',
        '$show',
        '$print',
        '$usage',
        '$cleanup',
        '$colorize',
        '$private',
        '$map',
        '$each_with_index',
        '$keys',
        '$==',
        '$select',
        '$parse',
        '$strftime',
        '$today',
        '$downcase',
        '$-',
        '$lambda',
        '$match',
        '$!',
        '$<=',
        '$each',
        '$split',
        '$strip',
        '$chomp',
        '$[]=',
        '$has_key?',
        '$sort',
        '$generate',
        '$gsub',
        '$convert_due_date',
        '$postprocess_tags',
        '$load_tasks',
        '$call',
        '$write_tasks',
        '$update_task',
        '$nil?',
        '$push',
        '$max',
        '$size',
        '$to_s',
        '$&',
        '$sort_by',
        '$filter_tasks',
        '$start_with?',
        '$abs',
        '$rjust',
        '$to_a',
        '$delete_at',
        '$is_a?',
        '$each_key',
        '$uniq',
        '$all?',
        '$index',
        '$execute',
        '$new'
    ]);
    self227.$require("json");
    self227.$require("date");
    (function($base, $super, $parent_nesting) {
        var self228 = $klass($base, $super, 'Todo');
        var $nesting = [
            self228
        ].concat($parent_nesting), $Todo_execute$1, $Todo_usage$2, $Todo_setup$6, $Todo_load_tasks$25, $Todo_write_tasks$27, $Todo_postprocess_tags$29, $Todo_add$30, $Todo_update_task$31, $Todo_append$32, $Todo_rename$34, $Todo_delete$36, $Todo_change_state$37, $Todo_set_priority$39, $Todo_due_date$41, $Todo_list$43, $Todo_add_note$47, $Todo_delete_note$49, $Todo_show$51, $Todo_cleanup$54, $Todo_filter_tasks$56, $Todo_colorize$59, $Todo_convert_due_date$60;
        self228.$$prototype.queries = self228.$$prototype.today = self228.$$prototype.due_date_days = nil;
        Opal.const_set($nesting[0], 'COLOR_CODES', $hash2([
            "black",
            "red",
            "green",
            "yellow",
            "blue",
            "magenta",
            "cyan",
            "white"
        ], {
            "black": 30,
            "red": 31,
            "green": 32,
            "yellow": 33,
            "blue": 34,
            "magenta": 35,
            "cyan": 36,
            "white": 37
        }));
        Opal.const_set($nesting[0], 'STATES', $hash2([
            "new",
            "done",
            "started",
            "blocked",
            "waiting",
            "default"
        ], {
            "new": "[ ]",
            "done": "[x]",
            "started": "[>]",
            "blocked": "[!]",
            "waiting": "[@]",
            "default": "[?]"
        }));
        Opal.const_set($nesting[0], 'ORDER', $hash2([
            "new",
            "done",
            "started",
            "blocked",
            "waiting",
            "default"
        ], {
            "new": 3,
            "done": 5,
            "started": 2,
            "blocked": 1,
            "waiting": 4,
            "default": 100
        }));
        Opal.const_set($nesting[0], 'COLORS', $hash2([
            "new",
            "done",
            "started",
            "blocked",
            "waiting",
            "default"
        ], {
            "new": "white",
            "done": "blue",
            "started": "green",
            "blocked": "yellow",
            "waiting": "cyan",
            "default": "magenta"
        }));
        Opal.const_set($nesting[0], 'DATE_FORMAT', "%Y-%m-%d");
        Opal.const_set($nesting[0], 'DATE_PATTERN', /^[1-9]\d{3}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$/);
        Opal.const_set($nesting[0], 'DUE_DATE_DAYS_SIMPLE', [
            "today",
            "tomorrow"
        ]);
        Opal.const_set($nesting[0], 'DUE_DATE_TAG_PATTERN', /(^| )due:([a-zA-Z0-9-]+)/);
        Opal.const_set($nesting[0], 'CONTEXT_TAG_PATTERN', /(^| )[@+][\w-]+/);
        Opal.const_set($nesting[0], 'PRIORITY_FLAG', "*");
        Opal.const_set($nesting[0], 'TODO_FILE', join3(homedir(), 'todo.jsonl'));
        Opal.def(self228, '$execute', $Todo_execute$1 = function $$execute(arguments$) {
            var self = this, action = nil, args85 = nil, $case = nil, $ret_or_1 = nil, error24 = nil;
            try {
                self.$setup();
                action = arguments$.$first();
                args85 = arguments$.$drop(1);
                $case = action;
                if ("add"['$===']($case)) {
                    if ($truthy(args85['$empty?']())) {
                        self.$raise($rb_plus(action, " command requires at least one parameter"));
                    }
                    self.$add(args85.$join(" "));
                } else if ("start"['$===']($case)) {
                    if ($truthy($rb_gt(args85.$length(), 0))) {
                        self.$change_state(args85.$first().$to_i(), "started", args85.$drop(1).$join(" "));
                    } else {
                        self.$list(nil, [
                            ":started"
                        ]);
                    }
                } else if ("done"['$===']($case)) {
                    if ($truthy($rb_gt(args85.$length(), 0))) {
                        self.$change_state(args85.$first().$to_i(), "done", args85.$drop(1).$join(" "));
                    } else {
                        self.$list(nil, [
                            ":done"
                        ]);
                    }
                } else if ("block"['$===']($case)) {
                    if ($truthy($rb_gt(args85.$length(), 0))) {
                        self.$change_state(args85.$first().$to_i(), "blocked", args85.$drop(1).$join(" "));
                    } else {
                        self.$list(nil, [
                            ":blocked"
                        ]);
                    }
                } else if ("wait"['$===']($case)) {
                    if ($truthy($rb_gt(args85.$length(), 0))) {
                        self.$change_state(args85.$first().$to_i(), "waiting", args85.$drop(1).$join(" "));
                    } else {
                        self.$list(nil, [
                            ":waiting"
                        ]);
                    }
                } else if ("reset"['$===']($case)) {
                    if ($truthy($rb_gt(args85.$length(), 0))) {
                        self.$change_state(args85.$first().$to_i(), "new", args85.$drop(1).$join(" "));
                    } else {
                        self.$list(nil, [
                            ":new"
                        ]);
                    }
                } else if ("prio"['$===']($case)) {
                    if ($truthy($rb_lt(args85.$length(), 1))) {
                        self.$raise($rb_plus(action, " command requires at least one parameter"));
                    }
                    self.$set_priority(args85.$first().$to_i(), args85.$drop(1).$join(" "));
                } else if ("due"['$===']($case)) {
                    if ($truthy($rb_lt(args85.$length(), 1))) {
                        self.$raise($rb_plus(action, " command requires at least one parameter"));
                    }
                    self.$due_date(args85.$first().$to_i(), args85.$drop(1).$join(" "));
                } else if ("append"['$===']($case)) {
                    if ($truthy($rb_lt(args85.$length(), 2))) {
                        self.$raise($rb_plus(action, " command requires at least two parameters"));
                    }
                    self.$append(args85.$first().$to_i(), args85.$drop(1).$join(" "));
                } else if ("rename"['$===']($case)) {
                    if ($truthy($rb_lt(args85.$length(), 2))) {
                        self.$raise($rb_plus(action, " command requires at least two parameters"));
                    }
                    self.$rename(args85.$first().$to_i(), args85.$drop(1).$join(" "));
                } else if ("del"['$===']($case)) {
                    if ($truthy(args85.$length()['$!='](1))) {
                        self.$raise($rb_plus(action, " command requires exactly one parameter"));
                    }
                    self.$delete(args85.$first().$to_i());
                } else if ("note"['$===']($case)) {
                    if ($truthy($rb_lt(args85.$length(), 2))) {
                        self.$raise($rb_plus(action, " command requires at least two parameters"));
                    }
                    self.$add_note(args85.$first().$to_i(), args85.$drop(1).$join(" "));
                } else if ("delnote"['$===']($case)) {
                    if ($truthy(function() {
                        if ($truthy($ret_or_1 = $rb_lt(args85.$length(), 1))) {
                            return $ret_or_1;
                        } else {
                            return $rb_gt(args85.$length(), 2);
                        }
                        return nil;
                    }())) {
                        self.$raise($rb_plus(action, " command requires one or two parameters"));
                    }
                    self.$delete_note(args85.$first().$to_i(), args85['$[]'](1));
                } else if ("list"['$===']($case)) {
                    self.$list(nil, args85);
                } else if ("show"['$===']($case)) {
                    if ($truthy(args85.$length()['$!='](1))) {
                        self.$raise($rb_plus(action, " command requires exactly one parameter"));
                    }
                    self.$show(args85.$first().$to_i());
                } else if ("help"['$===']($case)) {
                    if ($truthy($rb_gt(args85.$length(), 0))) {
                        self.$raise($rb_plus(action, " command has no parameters"));
                    }
                    self.$print(self.$usage());
                } else if ("cleanup"['$===']($case)) {
                    if ($truthy(args85['$empty?']())) {
                        self.$raise($rb_plus(action, " command requires at least one parameter"));
                    }
                    self.$cleanup(args85);
                } else {
                    self.$list(nil, arguments$);
                }
            } catch ($err) {
                if (Opal.rescue($err, [
                    $$$($$($nesting, 'JS'), 'Error'),
                    $$($nesting, 'StandardError')
                ])) {
                    error24 = $err;
                    try {
                        self.$print("" + self.$colorize("ERROR:", "red") + " " + error24);
                    } finally{
                        Opal.pop_exception();
                    }
                } else {
                    throw $err;
                }
            }
            return self;
        }, $Todo_execute$1.$$arity = 1);
        self228.$private();
        Opal.def(self228, '$usage', $Todo_usage$2 = function $$usage() {
            var $$3, $$4, $$5, self = this;
            return "" + "Usage: todo <command> <arguments>\n" + "\n" + "Commands:\n" + "* add <text>                     add new task\n" + "* start <tasknumber> [text]      mark task as started, with optional note\n" + "* done <tasknumber> [text]       mark task as completed, with optional note\n" + "* block <tasknumber> [text]      mark task as blocked, with optional note\n" + "* wait <tasknumber> [text]       mark task as waiting, with optional note\n" + "* reset <tasknumber> [text]      reset task to new state, with optional note\n" + "* prio <tasknumber> [text]       toggle high priority flag, with optional note\n" + "* due <tasknumber> [date]        set/unset due date (in YYYY-MM-DD format)\n" + "\n" + "* append <tasknumber> <text>     append text to task title\n" + "* rename <tasknumber> <text>     rename task\n" + "* del <tasknumber>               delete task\n" + "* note <tasknumber> <text>       add note to task\n" + "* delnote <tasknumber> [number]  delete a specific or all notes from task\n" + "\n" + "* list <regex> [regex...]        list tasks (only active tasks by default)\n" + "* show <tasknumber>              show all task details\n" + "* cleanup <regex> [regex...]     cleanup completed tasks by regex\n" + "* help                           this help screen\n" + "\n" + "With list command the following pre-defined queries can be also used:\n" + $send(self.queries.$keys().$each_with_index(), 'map', [], ($$3 = function(k, i318) {
                $$3.$$s == null ? this : $$3.$$s;
                if (k == null) {
                    k = nil;
                }
                if (i318 == null) {
                    i318 = nil;
                }
                return $rb_plus(function() {
                    if (i318['$=='](8)) {
                        return "\n";
                    } else {
                        return "";
                    }
                    return nil;
                }(), k);
            }, $$3.$$s = self, $$3.$$arity = 2, $$3)).$join(", ") + "\n" + "\n" + "Due dates can be also added via tags in task title: \"due:YYYY-MM-DD\"\n" + "In addition to formatted dates, you can use date synonyms:\n" + "\"due:today\", \"due:tomorrow\", and day names e.g. \"due:monday\" or \"due:tue\"\n" + "\n" + "Legend: " + $send($send($$($nesting, 'STATES'), 'select', [], ($$4 = function(k, v) {
                $$4.$$s == null ? this : $$4.$$s;
                if (k == null) {
                    k = nil;
                }
                if (v == null) {
                    v = nil;
                }
                return k['$!=']("default");
            }, $$4.$$s = self, $$4.$$arity = 2, $$4)), 'map', [], ($$5 = function(k, v) {
                $$5.$$s == null ? this : $$5.$$s;
                if (k == null) {
                    k = nil;
                }
                if (v == null) {
                    v = nil;
                }
                return "" + k + " " + v;
            }, $$5.$$s = self, $$5.$$arity = 2, $$5)).$join(", ") + ", priority " + $$($nesting, 'PRIORITY_FLAG') + "\n" + "\n" + "Todo file: " + $$($nesting, 'TODO_FILE') + "\n";
        }, $Todo_usage$2.$$arity = 0);
        Opal.def(self228, '$setup', $Todo_setup$6 = function $$setup() {
            var $$7, $$8, $$9, $$10, $$11, $$12, $$13, $$14, $$15, $$16, $$17, $$18, $$19, $$20, $$21, $$22, $$23, $$24, self229 = this, next_7_days = nil, due_dates_for_queries = nil, recent_date = nil;
            self229.today = $$($nesting, 'Date').$parse($$($nesting, 'Date').$today().$strftime($$($nesting, 'DATE_FORMAT')));
            next_7_days = $send($range(0, 6, false), 'map', [], ($$7 = function(day) {
                var self = $$7.$$s == null ? this : $$7.$$s;
                if (self.today == null) self.today = nil;
                if (day == null) {
                    day = nil;
                }
                return $rb_plus(self.today, day);
            }, $$7.$$s = self229, $$7.$$arity = 1, $$7));
            self229.due_date_days = $send(next_7_days, 'map', [], ($$8 = function(day) {
                $$8.$$s == null ? this : $$8.$$s;
                if (day == null) {
                    day = nil;
                }
                return day.$strftime("%A").$downcase();
            }, $$8.$$s = self229, $$8.$$arity = 1, $$8));
            due_dates_for_queries = $send(next_7_days, 'map', [], ($$9 = function(day) {
                $$9.$$s == null ? this : $$9.$$s;
                if (day == null) {
                    day = nil;
                }
                return day.$strftime($$($nesting, 'DATE_FORMAT'));
            }, $$9.$$s = self229, $$9.$$arity = 1, $$9));
            recent_date = $rb_minus(self229.today, 7).$strftime($$($nesting, 'DATE_FORMAT'));
            return self229.queries = $hash2([
                ":active",
                ":done",
                ":blocked",
                ":waiting",
                ":started",
                ":new",
                ":all",
                ":priority",
                ":note",
                ":today",
                ":tomorrow",
                ":next7days",
                ":overdue",
                ":due",
                ":recent"
            ], {
                ":active": $send(self229, 'lambda', [], ($$10 = function(task) {
                    $$10.$$s == null ? this : $$10.$$s;
                    if (task == null) {
                        task = nil;
                    }
                    return /(new|started|blocked|waiting)/.$match(task['$[]']("state"));
                }, $$10.$$s = self229, $$10.$$arity = 1, $$10)),
                ":done": $send(self229, 'lambda', [], ($$11 = function(task) {
                    $$11.$$s == null ? this : $$11.$$s;
                    if (task == null) {
                        task = nil;
                    }
                    return "done"['$=='](task['$[]']("state"));
                }, $$11.$$s = self229, $$11.$$arity = 1, $$11)),
                ":blocked": $send(self229, 'lambda', [], ($$12 = function(task) {
                    $$12.$$s == null ? this : $$12.$$s;
                    if (task == null) {
                        task = nil;
                    }
                    return "blocked"['$=='](task['$[]']("state"));
                }, $$12.$$s = self229, $$12.$$arity = 1, $$12)),
                ":waiting": $send(self229, 'lambda', [], ($$13 = function(task) {
                    $$13.$$s == null ? this : $$13.$$s;
                    if (task == null) {
                        task = nil;
                    }
                    return "waiting"['$=='](task['$[]']("state"));
                }, $$13.$$s = self229, $$13.$$arity = 1, $$13)),
                ":started": $send(self229, 'lambda', [], ($$14 = function(task) {
                    $$14.$$s == null ? this : $$14.$$s;
                    if (task == null) {
                        task = nil;
                    }
                    return "started"['$=='](task['$[]']("state"));
                }, $$14.$$s = self229, $$14.$$arity = 1, $$14)),
                ":new": $send(self229, 'lambda', [], ($$15 = function(task) {
                    $$15.$$s == null ? this : $$15.$$s;
                    if (task == null) {
                        task = nil;
                    }
                    return "new"['$=='](task['$[]']("state"));
                }, $$15.$$s = self229, $$15.$$arity = 1, $$15)),
                ":all": $send(self229, 'lambda', [], ($$16 = function(task) {
                    $$16.$$s == null ? this : $$16.$$s;
                    if (task == null) {
                        task = nil;
                    }
                    return /\w+/.$match(task['$[]']("state"));
                }, $$16.$$s = self229, $$16.$$arity = 1, $$16)),
                ":priority": $send(self229, 'lambda', [], ($$17 = function(task) {
                    $$17.$$s == null ? this : $$17.$$s;
                    if (task == null) {
                        task = nil;
                    }
                    return task['$[]']("priority");
                }, $$17.$$s = self229, $$17.$$arity = 1, $$17)),
                ":note": $send(self229, 'lambda', [], ($$18 = function(task) {
                    var self = $$18.$$s == null ? this : $$18.$$s, $ret_or_2 = nil;
                    if (task == null) {
                        task = nil;
                    }
                    if ($truthy($ret_or_2 = task['$[]']("note"))) {
                        return task['$[]']("note")['$empty?']()['$!']();
                    } else {
                        return $ret_or_2;
                    }
                }, $$18.$$s = self229, $$18.$$arity = 1, $$18)),
                ":today": $send(self229, 'lambda', [], ($$19 = function(task) {
                    $$19.$$s == null ? this : $$19.$$s;
                    if (task == null) {
                        task = nil;
                    }
                    return due_dates_for_queries['$[]'](0)['$=='](task['$[]']("due"));
                }, $$19.$$s = self229, $$19.$$arity = 1, $$19)),
                ":tomorrow": $send(self229, 'lambda', [], ($$20 = function(task) {
                    $$20.$$s == null ? this : $$20.$$s;
                    if (task == null) {
                        task = nil;
                    }
                    return due_dates_for_queries['$[]'](1)['$=='](task['$[]']("due"));
                }, $$20.$$s = self229, $$20.$$arity = 1, $$20)),
                ":next7days": $send(self229, 'lambda', [], ($$21 = function(task) {
                    $$21.$$s == null ? this : $$21.$$s;
                    if (task == null) {
                        task = nil;
                    }
                    return Opal.regexp([
                        "(",
                        due_dates_for_queries.$join("|"),
                        ")"
                    ]).$match(task['$[]']("due"));
                }, $$21.$$s = self229, $$21.$$arity = 1, $$21)),
                ":overdue": $send(self229, 'lambda', [], ($$22 = function(task) {
                    var self = $$22.$$s == null ? this : $$22.$$s, $ret_or_3 = nil;
                    if (task == null) {
                        task = nil;
                    }
                    if ($truthy($ret_or_3 = task['$[]']("due"))) {
                        return $rb_lt(task['$[]']("due"), due_dates_for_queries['$[]'](0));
                    } else {
                        return $ret_or_3;
                    }
                }, $$22.$$s = self229, $$22.$$arity = 1, $$22)),
                ":due": $send(self229, 'lambda', [], ($$23 = function(task) {
                    $$23.$$s == null ? this : $$23.$$s;
                    if (task == null) {
                        task = nil;
                    }
                    return task['$[]']("due");
                }, $$23.$$s = self229, $$23.$$arity = 1, $$23)),
                ":recent": $send(self229, 'lambda', [], ($$24 = function(task) {
                    $$24.$$s == null ? this : $$24.$$s;
                    if (task == null) {
                        task = nil;
                    }
                    return $rb_le(recent_date, task['$[]']("modified"));
                }, $$24.$$s = self229, $$24.$$arity = 1, $$24))
            });
        }, $Todo_setup$6.$$arity = 0);
        Opal.def(self228, '$load_tasks', $Todo_load_tasks$25 = function $$load_tasks(item_to_check) {
            var $$26, self = this, count = nil, tasks = nil, todo_jsonl = nil, $ret_or_4 = nil;
            if (item_to_check == null) {
                item_to_check = nil;
            }
            count = 0;
            tasks = $hash2([], {});
            todo_jsonl = existsSync($$($nesting, 'TODO_FILE')) ? readFileSync($$($nesting, 'TODO_FILE'), 'utf8') : '';
            if ($truthy(todo_jsonl['$empty?']()['$!']())) {
                $send(todo_jsonl.$split("\n"), 'each', [], ($$26 = function(line) {
                    var self = $$26.$$s == null ? this : $$26.$$s, $writer = nil;
                    if (line == null) {
                        line = nil;
                    }
                    if (line.$strip()['$==']("")) {
                        return nil;
                    }
                    count = $rb_plus(count, 1);
                    $writer = [
                        count,
                        $$($nesting, 'JSON').$parse(line.$chomp(), $hash2([
                            "symbolize_names"
                        ], {
                            "symbolize_names": true
                        }))
                    ];
                    $send(tasks, '[]=', Opal.to_a($writer));
                    return $writer[$rb_minus($writer["length"], 1)];
                }, $$26.$$s = self, $$26.$$arity = 1, $$26));
            }
            if ($truthy(function() {
                if ($truthy($ret_or_4 = item_to_check)) {
                    return tasks['$has_key?'](item_to_check)['$!']();
                } else {
                    return $ret_or_4;
                }
                return nil;
            }())) {
                self.$raise("" + item_to_check + ": No such todo");
            }
            return tasks;
        }, $Todo_load_tasks$25.$$arity = -1);
        Opal.def(self228, '$write_tasks', $Todo_write_tasks$27 = function $$write_tasks(tasks) {
            var $$28, self = this, todo_jsonl = nil;
            todo_jsonl = $rb_plus($send(tasks.$keys().$sort(), 'map', [], ($$28 = function(key) {
                $$28.$$s == null ? this : $$28.$$s;
                if (key == null) {
                    key = nil;
                }
                return $$($nesting, 'JSON').$generate(tasks['$[]'](key));
            }, $$28.$$s = self, $$28.$$arity = 1, $$28)).$join("\n"), "\n");
            return writeFileSync($$($nesting, 'TODO_FILE'), todo_jsonl, 'utf8');
        }, $Todo_write_tasks$27.$$arity = 1);
        Opal.def(self228, '$postprocess_tags', $Todo_postprocess_tags$29 = function $$postprocess_tags(task) {
            var self = this, match_data = nil, $writer = nil;
            match_data = task['$[]']("title").$match($$($nesting, 'DUE_DATE_TAG_PATTERN'));
            if ($truthy(match_data)) {
                $writer = [
                    "title",
                    task['$[]']("title").$gsub($$($nesting, 'DUE_DATE_TAG_PATTERN'), "")
                ];
                $send(task, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
                $writer = [
                    "due",
                    self.$convert_due_date(match_data['$[]'](2))
                ];
                $send(task, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
            }
            if ($truthy(task['$[]']("title")['$empty?']())) {
                return self.$raise("title must not be empty");
            } else {
                return nil;
            }
        }, $Todo_postprocess_tags$29.$$arity = 1);
        Opal.def(self228, '$add', $Todo_add$30 = function $$add(text) {
            var self = this, task = nil;
            task = $hash2([
                "state",
                "title",
                "modified"
            ], {
                "state": "new",
                "title": text,
                "modified": self.today.$strftime($$($nesting, 'DATE_FORMAT'))
            });
            self.$postprocess_tags(task);
            appendFileSync($$($nesting, 'TODO_FILE'), $rb_plus($$($nesting, 'JSON').$generate(task), "\n"), 'utf8');
            return self.$list();
        }, $Todo_add$30.$$arity = 1);
        Opal.def(self228, '$update_task', $Todo_update_task$31 = function $$update_task(item, post_action, update_function) {
            var self = this, tasks = nil, $writer = nil, $case = nil;
            tasks = self.$load_tasks(item);
            update_function.$call(tasks['$[]'](item));
            $writer = [
                "modified",
                self.today.$strftime($$($nesting, 'DATE_FORMAT'))
            ];
            $send(tasks['$[]'](item), '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
            self.$write_tasks(tasks);
            return function() {
                $case = post_action;
                if ("show"['$===']($case)) {
                    return self.$show(item, tasks);
                } else if ("list"['$===']($case)) {
                    return self.$list(tasks);
                } else {
                    return nil;
                }
            }();
        }, $Todo_update_task$31.$$arity = 3);
        Opal.def(self228, '$append', $Todo_append$32 = function $$append(item, text) {
            var $$33, self230 = this;
            return self230.$update_task(item, "list", $send(self230, 'lambda', [], ($$33 = function(task) {
                var self = $$33.$$s == null ? this : $$33.$$s, $writer = nil;
                if (task == null) {
                    task = nil;
                }
                $writer = [
                    "title",
                    [
                        task['$[]']("title"),
                        text
                    ].$join(" ")
                ];
                $send(task, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
                return self.$postprocess_tags(task);
            }, $$33.$$s = self230, $$33.$$arity = 1, $$33)));
        }, $Todo_append$32.$$arity = 2);
        Opal.def(self228, '$rename', $Todo_rename$34 = function $$rename(item, text) {
            var $$35, self231 = this;
            return self231.$update_task(item, "list", $send(self231, 'lambda', [], ($$35 = function(task) {
                var self = $$35.$$s == null ? this : $$35.$$s, $writer = nil;
                if (task == null) {
                    task = nil;
                }
                $writer = [
                    "title",
                    text
                ];
                $send(task, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
                return self.$postprocess_tags(task);
            }, $$35.$$s = self231, $$35.$$arity = 1, $$35)));
        }, $Todo_rename$34.$$arity = 2);
        Opal.def(self228, '$delete', $Todo_delete$36 = function(item) {
            var self = this, tasks = nil;
            tasks = self.$load_tasks(item);
            tasks.$delete(item);
            self.$write_tasks(tasks);
            return self.$list();
        }, $Todo_delete$36.$$arity = 1);
        Opal.def(self228, '$change_state', $Todo_change_state$37 = function $$change_state(item, state, note) {
            var $$38, self = this;
            if (note == null) {
                note = nil;
            }
            return self.$update_task(item, "list", $send(self, 'lambda', [], ($$38 = function(task) {
                var self = $$38.$$s == null ? this : $$38.$$s, $writer = nil, $ret_or_5 = nil, $ret_or_6 = nil;
                if (task == null) {
                    task = nil;
                }
                $writer = [
                    "state",
                    state
                ];
                $send(task, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
                if ($truthy(function() {
                    if ($truthy($ret_or_5 = note['$nil?']()['$!']())) {
                        return note['$empty?']()['$!']();
                    } else {
                        return $ret_or_5;
                    }
                    return nil;
                }())) {
                    if ($truthy($ret_or_6 = task['$[]']("note"))) {} else {
                        $writer = [
                            "note",
                            []
                        ];
                        $send(task, '[]=', Opal.to_a($writer));
                        $writer[$rb_minus($writer["length"], 1)];
                    }
                    return task['$[]']("note").$push(note);
                } else {
                    return nil;
                }
            }, $$38.$$s = self, $$38.$$arity = 1, $$38)));
        }, $Todo_change_state$37.$$arity = -3);
        Opal.def(self228, '$set_priority', $Todo_set_priority$39 = function $$set_priority(item, note) {
            var $$40, self = this;
            if (note == null) {
                note = nil;
            }
            return self.$update_task(item, "list", $send(self, 'lambda', [], ($$40 = function(task) {
                var self = $$40.$$s == null ? this : $$40.$$s, $writer = nil, $ret_or_7 = nil, $ret_or_8 = nil;
                if (task == null) {
                    task = nil;
                }
                $writer = [
                    "priority",
                    task['$[]']("priority")['$!']()
                ];
                $send(task, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
                if ($truthy(task['$[]']("priority")['$!']())) {
                    task.$delete("priority");
                }
                if ($truthy(function() {
                    if ($truthy($ret_or_7 = note['$nil?']()['$!']())) {
                        return note['$empty?']()['$!']();
                    } else {
                        return $ret_or_7;
                    }
                    return nil;
                }())) {
                    if ($truthy($ret_or_8 = task['$[]']("note"))) {} else {
                        $writer = [
                            "note",
                            []
                        ];
                        $send(task, '[]=', Opal.to_a($writer));
                        $writer[$rb_minus($writer["length"], 1)];
                    }
                    return task['$[]']("note").$push(note);
                } else {
                    return nil;
                }
            }, $$40.$$s = self, $$40.$$arity = 1, $$40)));
        }, $Todo_set_priority$39.$$arity = -2);
        Opal.def(self228, '$due_date', $Todo_due_date$41 = function $$due_date(item, date) {
            var $$42, self232 = this;
            if (date == null) {
                date = "";
            }
            return self232.$update_task(item, "list", $send(self232, 'lambda', [], ($$42 = function(task) {
                var self = $$42.$$s == null ? this : $$42.$$s, $writer = nil;
                if (task == null) {
                    task = nil;
                }
                $writer = [
                    "due",
                    self.$convert_due_date(date)
                ];
                $send(task, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
                if ($truthy(task['$[]']("due")['$nil?']())) {
                    return task.$delete("due");
                } else {
                    return nil;
                }
            }, $$42.$$s = self232, $$42.$$arity = 1, $$42)));
        }, $Todo_due_date$41.$$arity = -2);
        Opal.def(self228, '$list', $Todo_list$43 = function $$list(tasks, patterns) {
            var $$44, $$45, self233 = this, $ret_or_9 = nil, task_indent = nil, $ret_or_10 = nil, items = nil;
            if (tasks == null) {
                tasks = nil;
            }
            if (patterns == null) {
                patterns = nil;
            }
            tasks = function() {
                if ($truthy($ret_or_9 = tasks)) {
                    return $ret_or_9;
                } else {
                    return self233.$load_tasks();
                }
                return nil;
            }();
            task_indent = [
                tasks.$keys().$max().$to_s().$size(),
                4
            ].$max();
            patterns = function() {
                if ($truthy($ret_or_10 = patterns)) {
                    return $ret_or_10;
                } else {
                    return [];
                }
                return nil;
            }();
            if ($truthy(patterns['$&']([
                ":active",
                ":done",
                ":blocked",
                ":started",
                ":new",
                ":all",
                ":waiting"
            ])['$empty?']())) {
                patterns = $rb_plus(patterns, [
                    ":active"
                ]);
            }
            items = $send(self233.$filter_tasks(tasks, patterns), 'sort_by', [], ($$44 = function(num, task) {
                var self = $$44.$$s == null ? this : $$44.$$s, $ret_or_11 = nil, $ret_or_12 = nil, $ret_or_13 = nil, $ret_or_14 = nil;
                if (num == null) {
                    num = nil;
                }
                if (task == null) {
                    task = nil;
                }
                return [
                    function() {
                        if ($truthy(function() {
                            if ($truthy($ret_or_11 = task['$[]']("priority"))) {
                                return task['$[]']("state")['$!=']("done");
                            } else {
                                return $ret_or_11;
                            }
                            return nil;
                        }())) {
                            return 0;
                        } else {
                            return 1;
                        }
                        return nil;
                    }(),
                    function() {
                        if ($truthy($ret_or_12 = $$($nesting, 'ORDER')['$[]'](function() {
                            if ($truthy($ret_or_13 = task['$[]']("state"))) {
                                return $ret_or_13;
                            } else {
                                return "default";
                            }
                            return nil;
                        }()))) {
                            return $ret_or_12;
                        } else {
                            return $$($nesting, 'ORDER')['$[]']("default");
                        }
                        return nil;
                    }(),
                    function() {
                        if ($truthy(task['$[]']("state")['$!=']("done"))) {
                            if ($truthy($ret_or_14 = task['$[]']("due"))) {
                                return $ret_or_14;
                            } else {
                                return "n/a";
                            }
                        } else {
                            return task['$[]']("modified");
                        }
                        return nil;
                    }(),
                    num
                ];
            }, $$44.$$s = self233, $$44.$$arity = 2, $$44));
            $send(items, 'each', [], ($$45 = function(num, task) {
                var self234 = $$45.$$s == null ? this : $$45.$$s, $$46, state = nil, $ret_or_15 = nil, display_state = nil, title = nil, priority_flag = nil, $ret_or_16 = nil, due_date = nil, $ret_or_17 = nil, date_diff = nil, $ret_or_18 = nil, $ret_or_19 = nil;
                if (self234.today == null) self234.today = nil;
                if (self234.due_date_days == null) self234.due_date_days = nil;
                if (num == null) {
                    num = nil;
                }
                if (task == null) {
                    task = nil;
                }
                state = function() {
                    if ($truthy($ret_or_15 = task['$[]']("state"))) {
                        return $ret_or_15;
                    } else {
                        return "default";
                    }
                    return nil;
                }();
                display_state = self234.$colorize($$($nesting, 'STATES')['$[]'](state), $$($nesting, 'COLORS')['$[]'](state));
                title = $send(task['$[]']("title"), 'gsub', [
                    $$($nesting, 'CONTEXT_TAG_PATTERN')
                ], ($$46 = function(tag) {
                    var self = $$46.$$s == null ? this : $$46.$$s;
                    if (tag == null) {
                        tag = nil;
                    }
                    return $rb_plus(function() {
                        if ($truthy(tag['$start_with?'](" "))) {
                            return " ";
                        } else {
                            return "";
                        }
                        return nil;
                    }(), self.$colorize(tag.$strip(), "cyan"));
                }, $$46.$$s = self234, $$46.$$arity = 1, $$46));
                priority_flag = function() {
                    if ($truthy(function() {
                        if ($truthy($ret_or_16 = task['$[]']("priority"))) {
                            return state['$!=']("done");
                        } else {
                            return $ret_or_16;
                        }
                        return nil;
                    }())) {
                        return self234.$colorize($$($nesting, 'PRIORITY_FLAG'), "red");
                    } else {
                        return " ";
                    }
                    return nil;
                }();
                due_date = "";
                if ($truthy(function() {
                    if ($truthy($ret_or_17 = task['$[]']("due"))) {
                        return state['$!=']("done");
                    } else {
                        return $ret_or_17;
                    }
                    return nil;
                }())) {
                    date_diff = $rb_minus($$($nesting, 'Date').$parse(task['$[]']("due")), self234.today).$to_i();
                    if ($truthy($rb_lt(date_diff, 0))) {
                        due_date = self234.$colorize("" + "(" + date_diff.$abs() + "d overdue)", "red");
                    } else if ($truthy(function() {
                        if ($truthy($ret_or_18 = date_diff['$=='](0))) {
                            return $ret_or_18;
                        } else {
                            return date_diff['$=='](1);
                        }
                        return nil;
                    }())) {
                        due_date = self234.$colorize("" + "(" + $$($nesting, 'DUE_DATE_DAYS_SIMPLE')['$[]'](date_diff) + ")", "yellow");
                    } else if ($truthy($rb_gt(date_diff, 1))) {
                        due_date = self234.$colorize("" + "(" + function() {
                            if ($truthy($ret_or_19 = self234.due_date_days['$[]'](date_diff))) {
                                return $ret_or_19;
                            } else {
                                return task['$[]']("due");
                            }
                            return nil;
                        }() + ")", "magenta");
                    }
                    due_date = $rb_plus(" ", due_date);
                }
                return self234.$print("" + num.$to_s().$rjust(task_indent) + ":" + priority_flag + display_state + " " + title + due_date);
            }, $$45.$$s = self233, $$45.$$arity = 2, $$45));
            if ($truthy(items['$empty?']())) {
                return self233.$print("No todos found");
            } else {
                return nil;
            }
        }, $Todo_list$43.$$arity = -1);
        Opal.def(self228, '$add_note', $Todo_add_note$47 = function $$add_note(item, text) {
            var $$48, self = this;
            return self.$update_task(item, "show", $send(self, 'lambda', [], ($$48 = function(task) {
                var self = $$48.$$s == null ? this : $$48.$$s, $ret_or_20 = nil, $writer = nil;
                if (task == null) {
                    task = nil;
                }
                if ($truthy($ret_or_20 = task['$[]']("note"))) {} else {
                    $writer = [
                        "note",
                        []
                    ];
                    $send(task, '[]=', Opal.to_a($writer));
                    $writer[$rb_minus($writer["length"], 1)];
                }
                return task['$[]']("note").$push(text);
            }, $$48.$$s = self, $$48.$$arity = 1, $$48)));
        }, $Todo_add_note$47.$$arity = 2);
        Opal.def(self228, '$delete_note', $Todo_delete_note$49 = function $$delete_note(item, num) {
            var $$50, self235 = this;
            if (num == null) {
                num = nil;
            }
            return self235.$update_task(item, "show", $send(self235, 'lambda', [], ($$50 = function(task) {
                var self = $$50.$$s == null ? this : $$50.$$s, $ret_or_21 = nil;
                if (task == null) {
                    task = nil;
                }
                if ($truthy(num.$to_s()['$empty?']())) {
                    return task.$delete("note");
                } else {
                    if ($truthy(function() {
                        if ($truthy($ret_or_21 = $rb_le(num.$to_i(), 0))) {
                            return $ret_or_21;
                        } else {
                            return $rb_lt(task['$[]']("note").$to_a().$size(), num.$to_i());
                        }
                        return nil;
                    }())) {
                        self.$raise("" + num.$to_i() + ": Note does not exist");
                    }
                    task['$[]']("note").$delete_at($rb_minus(num.$to_i(), 1));
                    if ($truthy(task['$[]']("note")['$empty?']())) {
                        return task.$delete("note");
                    } else {
                        return nil;
                    }
                }
            }, $$50.$$s = self235, $$50.$$arity = 1, $$50)));
        }, $Todo_delete_note$49.$$arity = -2);
        Opal.def(self228, '$show', $Todo_show$51 = function $$show(item, tasks) {
            var $$52, self236 = this, $ret_or_22 = nil;
            if (tasks == null) {
                tasks = nil;
            }
            tasks = function() {
                if ($truthy($ret_or_22 = tasks)) {
                    return $ret_or_22;
                } else {
                    return self236.$load_tasks(item);
                }
                return nil;
            }();
            return $send(tasks['$[]'](item), 'each', [], ($$52 = function(k, v) {
                var self = $$52.$$s == null ? this : $$52.$$s, $$53;
                if (k == null) {
                    k = nil;
                }
                if (v == null) {
                    v = nil;
                }
                if ($truthy(v['$is_a?']($$($nesting, 'Array')))) {
                    v = $rb_plus("\n", $send(v.$each_with_index(), 'map', [], ($$53 = function(n, i319) {
                        $$53.$$s == null ? this : $$53.$$s;
                        if (n == null) {
                            n = nil;
                        }
                        if (i319 == null) {
                            i319 = nil;
                        }
                        if ($truthy($rb_gt(v.$size(), 1))) {
                            return "" + $rb_plus(i319, 1).$to_s().$rjust(v.$size().$to_s().$size()) + ": " + n;
                        } else {
                            return n;
                        }
                    }, $$53.$$s = self, $$53.$$arity = 2, $$53)).$join("\n"));
                }
                return self.$print("" + self.$colorize($rb_plus(k.$to_s().$rjust(10), ":"), "cyan") + " " + v);
            }, $$52.$$s = self236, $$52.$$arity = 2, $$52));
        }, $Todo_show$51.$$arity = -2);
        Opal.def(self228, '$cleanup', $Todo_cleanup$54 = function $$cleanup(patterns) {
            var $$55, self = this, tasks = nil, items = nil;
            tasks = self.$load_tasks();
            patterns = $rb_plus([
                ":done"
            ], patterns.$to_a());
            items = self.$filter_tasks(tasks, patterns);
            $send(items, 'each_key', [], ($$55 = function(num) {
                $$55.$$s == null ? this : $$55.$$s;
                if (num == null) {
                    num = nil;
                }
                return tasks.$delete(num);
            }, $$55.$$s = self, $$55.$$arity = 1, $$55));
            self.$write_tasks(tasks);
            return self.$print("" + "Deleted " + items.$size() + " todo(s)");
        }, $Todo_cleanup$54.$$arity = 1);
        Opal.def(self228, '$filter_tasks', $Todo_filter_tasks$56 = function $$filter_tasks(tasks, patterns) {
            var $$57, self237 = this;
            patterns = patterns.$uniq();
            return $send(tasks, 'select', [], ($$57 = function(num, task) {
                var self238 = $$57.$$s == null ? this : $$57.$$s, $$58;
                if (num == null) {
                    num = nil;
                }
                if (task == null) {
                    task = nil;
                }
                return $send(patterns, 'all?', [], ($$58 = function(pattern) {
                    var self = $$58.$$s == null ? this : $$58.$$s;
                    if (self.queries == null) self.queries = nil;
                    if (pattern == null) {
                        pattern = nil;
                    }
                    if ($truthy(self.queries['$[]'](pattern))) {
                        return self.queries['$[]'](pattern).$call(task);
                    } else {
                        return Opal.regexp([
                            pattern
                        ], 'i').$match(task['$[]']("title"));
                    }
                }, $$58.$$s = self238, $$58.$$arity = 1, $$58));
            }, $$57.$$s = self237, $$57.$$arity = 2, $$57));
        }, $Todo_filter_tasks$56.$$arity = 2);
        Opal.def(self228, '$colorize', $Todo_colorize$59 = function $$colorize(text, color) {
            var $ret_or_23 = nil;
            return '\u001b[' + function() {
                if ($truthy($ret_or_23 = $$($nesting, 'COLOR_CODES')['$[]'](color))) {
                    return $ret_or_23;
                } else {
                    return 37;
                }
                return nil;
            }() + 'm' + text + '\u001b[0m';
        }, $Todo_colorize$59.$$arity = 2);
        return (Opal.def(self228, '$convert_due_date', $Todo_convert_due_date$60 = function $$convert_due_date(date) {
            var $$61, self = this, day_index = nil, $ret_or_24 = nil, $ret_or_25 = nil, $ret_or_26 = nil;
            day_index = function() {
                if ($truthy($ret_or_24 = function() {
                    if ($truthy($ret_or_25 = self.due_date_days.$index(date.$to_s().$downcase()))) {
                        return $ret_or_25;
                    } else {
                        return $$($nesting, 'DUE_DATE_DAYS_SIMPLE').$index(date.$to_s().$downcase());
                    }
                    return nil;
                }())) {
                    return $ret_or_24;
                } else {
                    return $send(self.due_date_days, 'map', [], ($$61 = function(day) {
                        $$61.$$s == null ? this : $$61.$$s;
                        if (day == null) {
                            day = nil;
                        }
                        return day['$[]']($range(0, 2, false));
                    }, $$61.$$s = self, $$61.$$arity = 1, $$61)).$index(date.$to_s().$downcase());
                }
                return nil;
            }();
            if ($truthy(day_index)) {
                return $rb_plus(self.today, day_index).$strftime($$($nesting, 'DATE_FORMAT'));
            }
            if ($truthy(function() {
                if ($truthy($ret_or_26 = date['$nil?']())) {
                    return $ret_or_26;
                } else {
                    return date['$empty?']();
                }
                return nil;
            }())) {
                return nil;
            } else {
                return $$($nesting, 'Date').$parse($$($nesting, 'DATE_PATTERN').$match(date).$to_s()).$strftime($$($nesting, 'DATE_FORMAT'));
            }
        }, $Todo_convert_due_date$60.$$arity = 1), nil) && 'convert_due_date';
    })($nesting54[0], null, $nesting54);
    return $$($nesting54, 'Todo').$new().$execute(Deno.args);
})(Opal);
(function(Opal) {
    var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;
    Opal.add_stubs([
        '$exit'
    ]);
    return $$($nesting, 'Kernel').$exit();
})(Opal);
