(function() {

  // Object.assign polyfill
  if (typeof Object.assign !== 'function') {
    // Must be writable: true, enumerable: false, configurable: true
    Object.defineProperty(Object, "assign", {
      value: function assign(target, varArgs) { // .length of function is 2
        'use strict';
        if (target === null || target === undefined) {
          throw new TypeError('Cannot convert undefined or null to object');
        }

        var to = Object(target);

        for (var index = 1; index < arguments.length; index++) {
          var nextSource = arguments[index];

          if (nextSource !== null && nextSource !== undefined) {
            for (var nextKey in nextSource) {
              // Avoid bugs when hasOwnProperty is shadowed
              if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
        return to;
      },
      writable: true,
      configurable: true
    });
  }

  // Array.includes polyfill
  if (!Array.prototype.includes) {
    Object.defineProperty(Array.prototype, 'includes', {
      value: function (searchElement, fromIndex) {
        if (this == null) {
          throw new TypeError('"this" is null or not defined');
        }

        var o = Object(this);
        var len = o.length >>> 0;

        if (len === 0) {
          return false;
        }

        var n = fromIndex | 0;
        var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

        function sameValueZero(x, y) {
          return x === y || (typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y));
        }

        while (k < len) {
          if (sameValueZero(o[k], searchElement)) {
            return true;
          }
          k++;
        }

        return false;
      }
    });
  }

  var $jscomp = $jscomp || {};
  $jscomp.scope = {};
  $jscomp.createTemplateTagFirstArg = function(a) {
    return a.raw = a;
  };
  $jscomp.createTemplateTagFirstArgWithRaw = function(a, b) {
    a.raw = b;
    return a;
  };
  $jscomp.arrayIteratorImpl = function(a) {
    var b = 0;
    return function() {
      return b < a.length ? {done:!1, value:a[b++], } : {done:!0};
    };
  };
  $jscomp.arrayIterator = function(a) {
    return {next:$jscomp.arrayIteratorImpl(a)};
  };
  $jscomp.makeIterator = function(a) {
    var b = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];
    return b ? b.call(a) : $jscomp.arrayIterator(a);
  };
  $jscomp.arrayFromIterator = function(a) {
    for (var b, d = []; !(b = a.next()).done;) {
      d.push(b.value);
    }
    return d;
  };
  var KEY = "VanillaTerm", $jscomp$destructuring$var0 = window, addEventListener = $jscomp$destructuring$var0.addEventListener, cloneCommandNode = function(a) {
    a = a.cloneNode(!0);
    var b = a.querySelector(".input");
    b.autofocus = !1;
    b.readOnly = !0;
    b.insertAdjacentHTML("beforebegin", b.value);
    b.parentNode.removeChild(b);
    a.classList.add("line");
    return a;
  }, markup = function(a) {
    a = a.shell;
    return '\n<div class="container">\n<output></output>\n<div class="command">\n<div class="prompt">' + a.prompt + a.separator + '</div>\n<input class="input" spellcheck="false" autofocus />\n</table>\n</div>\n';
  }, COMMANDS = {clear:function(a) {
    return a.clear();
  }, commands:function(a) {
    a.output("These shell commands are defined internally:");
    a.output(Object.keys(a.commands).join(", "));
  }, }, Terminal = function(a) {
    var b = this, d = a = void 0 === a ? {} : a;
    a = void 0 === d.container ? "vanilla-terminal" : d.container;
    var q = void 0 === d.defaultCallback ? null : d.defaultCallback, l = void 0 === d.welcome ? 'Welcome to <a href="">Vanilla</a> terminal.' : d.welcome, r = void 0 === d.prompt ? "" : d.prompt, t = void 0 === d.separator ? "&gt;" : d.separator;
    this.commands = Object.assign({}, void 0 === d.commands ? {} : d.commands, COMMANDS);
    this.defaultCallback = q;
    this.history = [];
    this.historyCursor = this.history.length;
    this.welcome = l;
    this.shell = {prompt:r, separator:t};
    this.state = {prompt:void 0, idle:void 0, };
    this.cacheDOM = function(c) {
      c.classList.add(KEY);
      c.insertAdjacentHTML("beforeEnd", markup(b));
      c = c.querySelector(".container");
      b.DOM = {container:c, output:c.querySelector("output"), command:c.querySelector(".command"), input:c.querySelector(".command .input"), prompt:c.querySelector(".command .prompt"), };
    };
    this.addListeners = function() {
      var c = b.DOM;
      c.output.addEventListener("DOMSubtreeModified", function() {
        setTimeout(function() {
          return c.input.scrollIntoView();
        }, 10);
      }, !1);
      addEventListener("click", function() {
        return c.input.focus();
      }, !1);
      c.output.addEventListener("click", function(e) {
        return e.stopPropagation();
      }, !1);
      c.input.addEventListener("keyup", b.onKeyUp, !1);
      c.input.addEventListener("keydown", b.onKeyDown, !1);
      c.command.addEventListener("click", function() {
        return c.input.focus();
      }, !1);
      addEventListener("keyup", function(e) {
        c.input.focus();
        e.stopPropagation();
        e.preventDefault();
      }, !1);
    };
    this.onKeyUp = function(c) {
      var e = c.keyCode, g = b.DOM, f = void 0 === b.history ? [] : b.history, h = b.historyCursor;
      27 === e ? (g.input.value = "", c.stopPropagation(), c.preventDefault()) : [38, 40].includes(e) && (38 === e && 0 < h && --b.historyCursor, 40 === e && h < f.length - 1 && (b.historyCursor += 1), f[b.historyCursor] && (g.input.value = f[b.historyCursor]));
    };
    this.onKeyDown = function(c) {
      var e = c.keyCode, g = void 0 === b.commands ? {} : b.commands, f = b.DOM, h = b.history;
      c = b.onInputCallback;
      var n = b.defaultCallback, p = b.state, m = f.input.value.trim();
      if (13 === e && m) {
        var k = $jscomp.makeIterator(m.trim().split(/[\s|\u00A0]+/));
        e = k.next().value;
        k = $jscomp.arrayFromIterator(k);
        p.prompt ? (p.prompt = !1, b.onAskCallback(e), b.setPrompt(), b.resetCommand()) : (100 <= h.length && h.shift(), h.push(m), b.historyCursor = h.length, f.output.appendChild(cloneCommandNode(f.command)), f.command.classList.add("hidden"), f.input.value = "", Object.keys(g).includes(e) ? ((g = g[e]) && g(b, k), c && c(e, k)) : n ? n(b, e, k) : b.output("<u>" + e + "</u>: command not found."));
      }
    };
    this.resetCommand = function() {
      var c = b.DOM;
      c.input.value = "";
      c.command.classList.remove("input");
      c.command.classList.remove("hidden");
      c.input.scrollIntoView && c.input.scrollIntoView();
    };
    if (d = document.getElementById(a)) {
      this.cacheDOM(d), this.addListeners(), l && this.output(l);
    } else {
      throw Error("Container #" + a + " doesn't exists.");
    }
  };
  Terminal.prototype.clear = function() {
    this.DOM.output.innerHTML = "";
    this.resetCommand();
  };
  Terminal.prototype.idle = function() {
    var a = this.DOM;
    a.command.classList.add("idle");
    a.prompt.innerHTML = '<div class="spinner"></div>';
  };
  Terminal.prototype.prompt = function(a, b) {
    this.state.prompt = !0;
    this.onAskCallback = void 0 === b ? function() {
    } : b;
    this.DOM.prompt.innerHTML = a + ":";
    this.resetCommand();
    this.DOM.command.classList.add("input");
  };
  Terminal.prototype.onInput = function(a) {
    this.onInputCallback = a;
  };
  Terminal.prototype.output = function(a) {
    this.DOM.output.insertAdjacentHTML("beforeEnd", "<span>" + (void 0 === a ? "&nbsp;" : a) + "</span>");
    this.resetCommand();
  };
  Terminal.prototype.setPrompt = function(a) {
    a = void 0 === a ? this.shell.prompt : a;
    var b = this.DOM, d = this.shell.separator;
    this.shell = {prompt:a, separator:d};
    b.command.classList.remove("idle");
    b.prompt.innerHTML = "" + a + d;
    b.input.focus();
  };
  window && (window.VanillaTerminal = Terminal);
})();
(function(global_object) {
  "use strict";

  // @note
  //   A few conventions for the documentation of this file:
  //   1. Always use "//" (in contrast with "/**/")
  //   2. The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)
  //   3. `@param` and `@return` types should be preceded by `JS.` when referring to
  //      JavaScript constructors (e.g. `JS.Function`) otherwise Ruby is assumed.
  //   4. `nil` and `null` being unambiguous refer to the respective
  //      objects/values in Ruby and JavaScript
  //   5. This is still WIP :) so please give feedback and suggestions on how
  //      to improve or for alternative solutions
  //
  //   The way the code is digested before going through Yardoc is a secret kept
  //   in the docs repo (https://github.com/opal/docs/tree/master).

  var console;

  // Detect the global object
  if (typeof(globalThis) !== 'undefined') { global_object = globalThis; }
  else if (typeof(global) !== 'undefined') { global_object = global; }
  else if (typeof(window) !== 'undefined') { global_object = window; }

  // Setup a dummy console object if missing
  if (typeof(global_object.console) === 'object') {
    console = global_object.console;
  } else if (global_object.console == null) {
    console = global_object.console = {};
  } else {
    console = {};
  }

  if (!('log' in console)) { console.log = function () {}; }
  if (!('warn' in console)) { console.warn = console.log; }

  if (typeof(global_object.Opal) !== 'undefined') {
    console.warn('Opal already loaded. Loading twice can cause troubles, please fix your setup.');
    return global_object.Opal;
  }

  var nil;

  // The actual class for BasicObject
  var BasicObject;

  // The actual Object class.
  // The leading underscore is to avoid confusion with window.Object()
  var _Object;

  // The actual Module class
  var Module;

  // The actual Class class
  var Class;

  // The Opal object that is exposed globally
  var Opal = global_object.Opal = {};

  // This is a useful reference to global object inside ruby files
  Opal.global = global_object;
  global_object.Opal = Opal;

  // Configure runtime behavior with regards to require and unsupported features
  Opal.config = {
    missing_require_severity: 'error',        // error, warning, ignore
    unsupported_features_severity: 'warning', // error, warning, ignore
    enable_stack_trace: true                  // true, false
  };

  // Minify common function calls
  var $has_own   = Object.hasOwnProperty;
  var $bind      = Function.prototype.bind;
  var $set_proto = Object.setPrototypeOf;
  var $slice     = Array.prototype.slice;
  var $splice    = Array.prototype.splice;

  // Nil object id is always 4
  var nil_id = 4;

  // Generates even sequential numbers greater than 4
  // (nil_id) to serve as unique ids for ruby objects
  var unique_id = nil_id;

  // Return next unique id
  Opal.uid = function() {
    unique_id += 2;
    return unique_id;
  };

  // Retrieve or assign the id of an object
  Opal.id = function(obj) {
    if (obj.$$is_number) return (obj * 2)+1;
    if (obj.$$id != null) {
      return obj.$$id;
    }
    $defineProperty(obj, '$$id', Opal.uid());
    return obj.$$id;
  };

  // Globals table
  Opal.gvars = {};

  // Exit function, this should be replaced by platform specific implementation
  // (See nodejs and chrome for examples)
  Opal.exit = function(status) { if (Opal.gvars.DEBUG) console.log('Exited with status '+status); };

  // keeps track of exceptions for $!
  Opal.exceptions = [];

  // @private
  // Pops an exception from the stack and updates `$!`.
  Opal.pop_exception = function() {
    Opal.gvars["!"] = Opal.exceptions.pop() || nil;
  };

  // Inspect any kind of object, including non Ruby ones
  Opal.inspect = function(obj) {
    if (obj === undefined) {
      return "undefined";
    }
    else if (obj === null) {
      return "null";
    }
    else if (!obj.$$class) {
      return obj.toString();
    }
    else {
      return obj.$inspect();
    }
  };

  function $defineProperty(object, name, initialValue) {
    if (typeof(object) === "string") {
      // Special case for:
      //   s = "string"
      //   def s.m; end
      // String class is the only class that:
      // + compiles to JS primitive
      // + allows method definition directly on instances
      // numbers, true, false and null do not support it.
      object[name] = initialValue;
    } else {
      Object.defineProperty(object, name, {
        value: initialValue,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
  }

  Opal.defineProperty = $defineProperty;

  Opal.slice = $slice;


  // Helpers
  // -----

  Opal.truthy = function(val) {
    return (val !== nil && val != null && (!val.$$is_boolean || val == true));
  };

  Opal.falsy = function(val) {
    return (val === nil || val == null || (val.$$is_boolean && val == false))
  };

  Opal.type_error = function(object, type, method, coerced) {
    object = object.$$class;

    if (coerced && method) {
      coerced = coerced.$$class;
      return Opal.TypeError.$new(
        "can't convert " + object + " into " + type +
        " (" + object + "#" + method + " gives " + coerced + ")"
      )
    } else {
      return Opal.TypeError.$new(
        "no implicit conversion of " + object + " into " + type
      )
    }
  };

  Opal.coerce_to = function(object, type, method, args) {
    if (type['$==='](object)) return object;

    if (!object['$respond_to?'](method)) {
      throw Opal.type_error(object, type);
    }

    if (args == null) args = [];
    return Opal.send(object, method, args);
  }

  Opal.respond_to = function(obj, jsid, include_all) {
    if (obj == null || !obj.$$class) return false;
    include_all = !!include_all;
    var body = obj[jsid];

    if (obj['$respond_to?'].$$pristine) {
      if (obj['$respond_to_missing?'].$$pristine) {
        return typeof(body) === "function" && !body.$$stub;
      } else {
        return Opal.send(obj, obj['$respond_to_missing?'], [jsid.substr(1), include_all]);
      }
    } else {
      return Opal.send(obj, obj['$respond_to?'], [jsid.substr(1), include_all]);
    }
  }


  // Constants
  // ---------
  //
  // For future reference:
  // - The Rails autoloading guide (http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html)
  // - @ConradIrwin's 2012 post on “Everything you ever wanted to know about constant lookup in Ruby” (http://cirw.in/blog/constant-lookup.html)
  //
  // Legend of MRI concepts/names:
  // - constant reference (cref): the module/class that acts as a namespace
  // - nesting: the namespaces wrapping the current scope, e.g. nesting inside
  //            `module A; module B::C; end; end` is `[B::C, A]`

  // Get the constant in the scope of the current cref
  function const_get_name(cref, name) {
    if (cref) return cref.$$const[name];
  }

  // Walk up the nesting array looking for the constant
  function const_lookup_nesting(nesting, name) {
    var i, ii, constant;

    if (nesting.length === 0) return;

    // If the nesting is not empty the constant is looked up in its elements
    // and in order. The ancestors of those elements are ignored.
    for (i = 0, ii = nesting.length; i < ii; i++) {
      constant = nesting[i].$$const[name];
      if (constant != null) return constant;
    }
  }

  // Walk up the ancestors chain looking for the constant
  function const_lookup_ancestors(cref, name) {
    var i, ii, ancestors;

    if (cref == null) return;

    ancestors = Opal.ancestors(cref);

    for (i = 0, ii = ancestors.length; i < ii; i++) {
      if (ancestors[i].$$const && $has_own.call(ancestors[i].$$const, name)) {
        return ancestors[i].$$const[name];
      }
    }
  }

  // Walk up Object's ancestors chain looking for the constant,
  // but only if cref is missing or a module.
  function const_lookup_Object(cref, name) {
    if (cref == null || cref.$$is_module) {
      return const_lookup_ancestors(_Object, name);
    }
  }

  // Call const_missing if nothing else worked
  function const_missing(cref, name, skip_missing) {
    if (!skip_missing) {
      return (cref || _Object).$const_missing(name);
    }
  }

  // Look for the constant just in the current cref or call `#const_missing`
  Opal.const_get_local = function(cref, name, skip_missing) {
    var result;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    result = const_get_name(cref, name);              if (result != null) return result;
    result = const_missing(cref, name, skip_missing); if (result != null) return result;
  };

  // Look for the constant relative to a cref or call `#const_missing` (when the
  // constant is prefixed by `::`).
  Opal.const_get_qualified = function(cref, name, skip_missing) {
    var result, cache, cached, current_version = Opal.const_cache_version;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    if ((cache = cref.$$const_cache) == null) {
      $defineProperty(cref, '$$const_cache', Object.create(null));
      cache = cref.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null);
      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Initialize the top level constant cache generation counter
  Opal.const_cache_version = 1;

  // Look for the constant in the open using the current nesting and the nearest
  // cref ancestors or call `#const_missing` (when the constant has no :: prefix).
  Opal.const_get_relative = function(nesting, name, skip_missing) {
    var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;

    if ((cache = nesting.$$const_cache) == null) {
      $defineProperty(nesting, '$$const_cache', Object.create(null));
      cache = nesting.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_nesting(nesting, name))     != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null) ||
      ((result = const_lookup_Object(cref, name))         != null);

      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Register the constant on a cref and opportunistically set the name of
  // unnamed classes/modules.
  Opal.const_set = function(cref, name, value) {
    if (cref == null || cref === '::') cref = _Object;

    if (value.$$is_a_module) {
      if (value.$$name == null || value.$$name === nil) value.$$name = name;
      if (value.$$base_module == null) value.$$base_module = cref;
    }

    cref.$$const = (cref.$$const || Object.create(null));
    cref.$$const[name] = value;

    // Add a short helper to navigate constants manually.
    // @example
    //   Opal.$$.Regexp.$$.IGNORECASE
    cref.$$ = cref.$$const;

    Opal.const_cache_version++;

    // Expose top level constants onto the Opal object
    if (cref === _Object) Opal[name] = value;

    // Name new class directly onto current scope (Opal.Foo.Baz = klass)
    $defineProperty(cref, name, value);

    return value;
  };

  // Get all the constants reachable from a given cref, by default will include
  // inherited constants.
  Opal.constants = function(cref, inherit) {
    if (inherit == null) inherit = true;

    var module, modules = [cref], i, ii, constants = {}, constant;

    if (inherit) modules = modules.concat(Opal.ancestors(cref));
    if (inherit && cref.$$is_module) modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));

    for (i = 0, ii = modules.length; i < ii; i++) {
      module = modules[i];

      // Do not show Objects constants unless we're querying Object itself
      if (cref !== _Object && module == _Object) break;

      for (constant in module.$$const) {
        constants[constant] = true;
      }
    }

    return Object.keys(constants);
  };

  // Remove a constant from a cref.
  Opal.const_remove = function(cref, name) {
    Opal.const_cache_version++;

    if (cref.$$const[name] != null) {
      var old = cref.$$const[name];
      delete cref.$$const[name];
      return old;
    }

    if (cref.$$autoload != null && cref.$$autoload[name] != null) {
      delete cref.$$autoload[name];
      return nil;
    }

    throw Opal.NameError.$new("constant "+cref+"::"+cref.$name()+" not defined");
  };

  // Setup some shortcuts to reduce compiled size
  Opal.$$ = Opal.const_get_relative;
  Opal.$$$ = Opal.const_get_qualified;


  // Modules & Classes
  // -----------------

  // A `class Foo; end` expression in ruby is compiled to call this runtime
  // method which either returns an existing class of the given name, or creates
  // a new class in the given `base` scope.
  //
  // If a constant with the given name exists, then we check to make sure that
  // it is a class and also that the superclasses match. If either of these
  // fail, then we raise a `TypeError`. Note, `superclass` may be null if one
  // was not specified in the ruby code.
  //
  // We pass a constructor to this method of the form `function ClassName() {}`
  // simply so that classes show up with nicely formatted names inside debuggers
  // in the web browser (or node/sprockets).
  //
  // The `scope` is the current `self` value where the class is being created
  // from. We use this to get the scope for where the class should be created.
  // If `scope` is an object (not a class/module), we simple get its class and
  // use that as the scope instead.
  //
  // @param scope        [Object] where the class is being created
  // @param superclass  [Class,null] superclass of the new class (may be null)
  // @param id          [String] the name of the class to be created
  // @param constructor [JS.Function] function to use as constructor
  //
  // @return new [Class]  or existing ruby class
  //
  Opal.allocate_class = function(name, superclass) {
    var klass, constructor;

    if (superclass != null && superclass.$$bridge) {
      // Inheritance from bridged classes requires
      // calling original JS constructors
      constructor = function() {
        var args = $slice.call(arguments),
            self = new ($bind.apply(superclass.$$constructor, [null].concat(args)))();

        // and replacing a __proto__ manually
        $set_proto(self, klass.$$prototype);
        return self;
      }
    } else {
      constructor = function(){};
    }

    if (name) {
      $defineProperty(constructor, 'displayName', '::'+name);
    }

    klass = constructor;

    $defineProperty(klass, '$$name', name);
    $defineProperty(klass, '$$constructor', constructor);
    $defineProperty(klass, '$$prototype', constructor.prototype);
    $defineProperty(klass, '$$const', {});
    $defineProperty(klass, '$$is_class', true);
    $defineProperty(klass, '$$is_a_module', true);
    $defineProperty(klass, '$$super', superclass);
    $defineProperty(klass, '$$cvars', {});
    $defineProperty(klass, '$$own_included_modules', []);
    $defineProperty(klass, '$$own_prepended_modules', []);
    $defineProperty(klass, '$$ancestors', []);
    $defineProperty(klass, '$$ancestors_cache_version', null);

    $defineProperty(klass.$$prototype, '$$class', klass);

    // By default if there are no singleton class methods
    // __proto__ is Class.prototype
    // Later singleton methods generate a singleton_class
    // and inject it into ancestors chain
    if (Opal.Class) {
      $set_proto(klass, Opal.Class.prototype);
    }

    if (superclass != null) {
      $set_proto(klass.$$prototype, superclass.$$prototype);

      if (superclass.$$meta) {
        // If superclass has metaclass then we have explicitely inherit it.
        Opal.build_class_singleton_class(klass);
      }
    }

    return klass;
  };


  function find_existing_class(scope, name) {
    // Try to find the class in the current scope
    var klass = const_get_name(scope, name);

    // If the class exists in the scope, then we must use that
    if (klass) {
      // Make sure the existing constant is a class, or raise error
      if (!klass.$$is_class) {
        throw Opal.TypeError.$new(name + " is not a class");
      }

      return klass;
    }
  }

  function ensureSuperclassMatch(klass, superclass) {
    if (klass.$$super !== superclass) {
      throw Opal.TypeError.$new("superclass mismatch for class " + klass.$$name);
    }
  }

  Opal.klass = function(scope, superclass, name) {
    var bridged;

    if (scope == null) {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    // If the superclass is not an Opal-generated class then we're bridging a native JS class
    if (superclass != null && !superclass.hasOwnProperty('$$is_class')) {
      bridged = superclass;
      superclass = _Object;
    }

    var klass = find_existing_class(scope, name);

    if (klass) {
      if (superclass) {
        // Make sure existing class has same superclass
        ensureSuperclassMatch(klass, superclass);
      }
      return klass;
    }

    // Class doesn't exist, create a new one with given superclass...

    // Not specifying a superclass means we can assume it to be Object
    if (superclass == null) {
      superclass = _Object;
    }

    // Create the class object (instance of Class)
    klass = Opal.allocate_class(name, superclass);
    Opal.const_set(scope, name, klass);

    // Call .inherited() hook with new class on the superclass
    if (superclass.$inherited) {
      superclass.$inherited(klass);
    }

    if (bridged) {
      Opal.bridge(bridged, klass);
    }

    return klass;
  };

  // Define new module (or return existing module). The given `scope` is basically
  // the current `self` value the `module` statement was defined in. If this is
  // a ruby module or class, then it is used, otherwise if the scope is a ruby
  // object then that objects real ruby class is used (e.g. if the scope is the
  // main object, then the top level `Object` class is used as the scope).
  //
  // If a module of the given name is already defined in the scope, then that
  // instance is just returned.
  //
  // If there is a class of the given name in the scope, then an error is
  // generated instead (cannot have a class and module of same name in same scope).
  //
  // Otherwise, a new module is created in the scope with the given name, and that
  // new instance is returned back (to be referenced at runtime).
  //
  // @param  scope [Module, Class] class or module this definition is inside
  // @param  id   [String] the name of the new (or existing) module
  //
  // @return [Module]
  Opal.allocate_module = function(name) {
    var constructor = function(){};
    if (name) {
      $defineProperty(constructor, 'displayName', name+'.$$constructor');
    }

    var module = constructor;

    if (name)
      $defineProperty(constructor, 'displayName', name+'.constructor');

    $defineProperty(module, '$$name', name);
    $defineProperty(module, '$$prototype', constructor.prototype);
    $defineProperty(module, '$$const', {});
    $defineProperty(module, '$$is_module', true);
    $defineProperty(module, '$$is_a_module', true);
    $defineProperty(module, '$$cvars', {});
    $defineProperty(module, '$$iclasses', []);
    $defineProperty(module, '$$own_included_modules', []);
    $defineProperty(module, '$$own_prepended_modules', []);
    $defineProperty(module, '$$ancestors', [module]);
    $defineProperty(module, '$$ancestors_cache_version', null);

    $set_proto(module, Opal.Module.prototype);

    return module;
  };

  function find_existing_module(scope, name) {
    var module = const_get_name(scope, name);
    if (module == null && scope === _Object) module = const_lookup_ancestors(_Object, name);

    if (module) {
      if (!module.$$is_module && module !== _Object) {
        throw Opal.TypeError.$new(name + " is not a module");
      }
    }

    return module;
  }

  Opal.module = function(scope, name) {
    var module;

    if (scope == null) {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    module = find_existing_module(scope, name);

    if (module) {
      return module;
    }

    // Module doesnt exist, create a new one...
    module = Opal.allocate_module(name);
    Opal.const_set(scope, name, module);

    return module;
  };

  // Return the singleton class for the passed object.
  //
  // If the given object alredy has a singleton class, then it will be stored on
  // the object as the `$$meta` property. If this exists, then it is simply
  // returned back.
  //
  // Otherwise, a new singleton object for the class or object is created, set on
  // the object at `$$meta` for future use, and then returned.
  //
  // @param object [Object] the ruby object
  // @return [Class] the singleton class for object
  Opal.get_singleton_class = function(object) {
    if (object.$$meta) {
      return object.$$meta;
    }

    if (object.hasOwnProperty('$$is_class')) {
      return Opal.build_class_singleton_class(object);
    } else if (object.hasOwnProperty('$$is_module')) {
      return Opal.build_module_singleton_class(object);
    } else {
      return Opal.build_object_singleton_class(object);
    }
  };

  // Build the singleton class for an existing class. Class object are built
  // with their singleton class already in the prototype chain and inheriting
  // from their superclass object (up to `Class` itself).
  //
  // NOTE: Actually in MRI a class' singleton class inherits from its
  // superclass' singleton class which in turn inherits from Class.
  //
  // @param klass [Class]
  // @return [Class]
  Opal.build_class_singleton_class = function(klass) {
    var superclass, meta;

    if (klass.$$meta) {
      return klass.$$meta;
    }

    // The singleton_class superclass is the singleton_class of its superclass;
    // but BasicObject has no superclass (its `$$super` is null), thus we
    // fallback on `Class`.
    superclass = klass === BasicObject ? Class : Opal.get_singleton_class(klass.$$super);

    meta = Opal.allocate_class(null, superclass, function(){});

    $defineProperty(meta, '$$is_singleton', true);
    $defineProperty(meta, '$$singleton_of', klass);
    $defineProperty(klass, '$$meta', meta);
    $set_proto(klass, meta.$$prototype);
    // Restoring ClassName.class
    $defineProperty(klass, '$$class', Opal.Class);

    return meta;
  };

  Opal.build_module_singleton_class = function(mod) {
    if (mod.$$meta) {
      return mod.$$meta;
    }

    var meta = Opal.allocate_class(null, Opal.Module, function(){});

    $defineProperty(meta, '$$is_singleton', true);
    $defineProperty(meta, '$$singleton_of', mod);
    $defineProperty(mod, '$$meta', meta);
    $set_proto(mod, meta.$$prototype);
    // Restoring ModuleName.class
    $defineProperty(mod, '$$class', Opal.Module);

    return meta;
  };

  // Build the singleton class for a Ruby (non class) Object.
  //
  // @param object [Object]
  // @return [Class]
  Opal.build_object_singleton_class = function(object) {
    var superclass = object.$$class,
        klass = Opal.allocate_class(nil, superclass, function(){});

    $defineProperty(klass, '$$is_singleton', true);
    $defineProperty(klass, '$$singleton_of', object);

    delete klass.$$prototype.$$class;

    $defineProperty(object, '$$meta', klass);

    $set_proto(object, object.$$meta.$$prototype);

    return klass;
  };

  Opal.is_method = function(prop) {
    return (prop[0] === '$' && prop[1] !== '$');
  };

  Opal.instance_methods = function(mod) {
    var exclude = [], results = [], ancestors = Opal.ancestors(mod);

    for (var i = 0, l = ancestors.length; i < l; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      var props = Object.getOwnPropertyNames(proto);

      for (var j = 0, ll = props.length; j < ll; j++) {
        var prop = props[j];

        if (Opal.is_method(prop)) {
          var method_name = prop.slice(1),
              method = proto[prop];

          if (method.$$stub && exclude.indexOf(method_name) === -1) {
            exclude.push(method_name);
          }

          if (!method.$$stub && results.indexOf(method_name) === -1 && exclude.indexOf(method_name) === -1) {
            results.push(method_name);
          }
        }
      }
    }

    return results;
  };

  Opal.own_instance_methods = function(mod) {
    var results = [],
        proto = mod.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto);

    for (var i = 0, length = props.length; i < length; i++) {
      var prop = props[i];

      if (Opal.is_method(prop)) {
        var method = proto[prop];

        if (!method.$$stub) {
          var method_name = prop.slice(1);
          results.push(method_name);
        }
      }
    }

    return results;
  };

  Opal.methods = function(obj) {
    return Opal.instance_methods(Opal.get_singleton_class(obj));
  };

  Opal.own_methods = function(obj) {
    return Opal.own_instance_methods(Opal.get_singleton_class(obj));
  };

  Opal.receiver_methods = function(obj) {
    var mod = Opal.get_singleton_class(obj);
    var singleton_methods = Opal.own_instance_methods(mod);
    var instance_methods = Opal.own_instance_methods(mod.$$super);
    return singleton_methods.concat(instance_methods);
  };

  // Returns an object containing all pairs of names/values
  // for all class variables defined in provided +module+
  // and its ancestors.
  //
  // @param module [Module]
  // @return [Object]
  Opal.class_variables = function(module) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length,
        result = {};

    for (i = length - 1; i >= 0; i--) {
      var ancestor = ancestors[i];

      for (var cvar in ancestor.$$cvars) {
        result[cvar] = ancestor.$$cvars[cvar];
      }
    }

    return result;
  };

  // Sets class variable with specified +name+ to +value+
  // in provided +module+
  //
  // @param module [Module]
  // @param name [String]
  // @param value [Object]
  Opal.class_variable_set = function(module, name, value) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length;

    for (i = length - 2; i >= 0; i--) {
      var ancestor = ancestors[i];

      if ($has_own.call(ancestor.$$cvars, name)) {
        ancestor.$$cvars[name] = value;
        return value;
      }
    }

    module.$$cvars[name] = value;

    return value;
  };

  function isRoot(proto) {
    return proto.hasOwnProperty('$$iclass') && proto.hasOwnProperty('$$root');
  }

  function own_included_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    while (proto) {
      if (proto.hasOwnProperty('$$class')) {
        // superclass
        break;
      }
      mod = protoToModule(proto);
      if (mod) {
        result.push(mod);
      }
      proto = Object.getPrototypeOf(proto);
    }

    return result;
  }

  function own_prepended_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    if (module.$$prototype.hasOwnProperty('$$dummy')) {
      while (proto) {
        if (proto === module.$$prototype.$$define_methods_on) {
          break;
        }

        mod = protoToModule(proto);
        if (mod) {
          result.push(mod);
        }

        proto = Object.getPrototypeOf(proto);
      }
    }

    return result;
  }


  // The actual inclusion of a module into a class.
  //
  // ## Class `$$parent` and `iclass`
  //
  // To handle `super` calls, every class has a `$$parent`. This parent is
  // used to resolve the next class for a super call. A normal class would
  // have this point to its superclass. However, if a class includes a module
  // then this would need to take into account the module. The module would
  // also have to then point its `$$parent` to the actual superclass. We
  // cannot modify modules like this, because it might be included in more
  // then one class. To fix this, we actually insert an `iclass` as the class'
  // `$$parent` which can then point to the superclass. The `iclass` acts as
  // a proxy to the actual module, so the `super` chain can then search it for
  // the required method.
  //
  // @param module [Module] the module to include
  // @param includer [Module] the target class to include module into
  // @return [null]
  Opal.append_features = function(module, includer) {
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(includer) !== -1) {
      throw Opal.ArgumentError.$new('cyclic include detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $defineProperty(iclass, '$$included', true);
      iclasses.push(iclass);
    }
    var includer_ancestors = Opal.ancestors(includer),
        chain = chain_iclasses(iclasses),
        start_chain_after,
        end_chain_on;

    if (includer_ancestors.indexOf(module) === -1) {
      // first time include

      // includer -> chain.first -> ...chain... -> chain.last -> includer.parent
      start_chain_after = includer.$$prototype;
      end_chain_on = Object.getPrototypeOf(includer.$$prototype);
    } else {
      // The module has been already included,
      // we don't need to put it into the ancestors chain again,
      // but this module may have new included modules.
      // If it's true we need to copy them.
      //
      // The simplest way is to replace ancestors chain from
      //          parent
      //            |
      //   `module` iclass (has a $$root flag)
      //            |
      //   ...previos chain of module.included_modules ...
      //            |
      //  "next ancestor" (has a $$root flag or is a real class)
      //
      // to
      //          parent
      //            |
      //    `module` iclass (has a $$root flag)
      //            |
      //   ...regenerated chain of module.included_modules
      //            |
      //   "next ancestor" (has a $$root flag or is a real class)
      //
      // because there are no intermediate classes between `parent` and `next ancestor`.
      // It doesn't break any prototypes of other objects as we don't change class references.

      var proto = includer.$$prototype, parent = proto, module_iclass = Object.getPrototypeOf(parent);

      while (module_iclass != null) {
        if (isRoot(module_iclass) && module_iclass.$$module === module) {
          break;
        }

        parent = module_iclass;
        module_iclass = Object.getPrototypeOf(module_iclass);
      }

      var next_ancestor = Object.getPrototypeOf(module_iclass);

      // skip non-root iclasses (that were recursively included)
      while (next_ancestor.hasOwnProperty('$$iclass') && !isRoot(next_ancestor)) {
        next_ancestor = Object.getPrototypeOf(next_ancestor);
      }

      start_chain_after = parent;
      end_chain_on = next_ancestor;
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_included_modules cache
    includer.$$own_included_modules = own_included_modules(includer);

    Opal.const_cache_version++;
  };

  Opal.prepend_features = function(module, prepender) {
    // Here we change the ancestors chain from
    //
    //   prepender
    //      |
    //    parent
    //
    // to:
    //
    // dummy(prepender)
    //      |
    //  iclass(module)
    //      |
    // iclass(prepender)
    //      |
    //    parent
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(prepender) !== -1) {
      throw Opal.ArgumentError.$new('cyclic prepend detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $defineProperty(iclass, '$$prepended', true);
      iclasses.push(iclass);
    }

    var chain = chain_iclasses(iclasses),
        dummy_prepender = prepender.$$prototype,
        previous_parent = Object.getPrototypeOf(dummy_prepender),
        prepender_iclass,
        start_chain_after,
        end_chain_on;

    if (dummy_prepender.hasOwnProperty('$$dummy')) {
      // The module already has some prepended modules
      // which means that we don't need to make it "dummy"
      prepender_iclass = dummy_prepender.$$define_methods_on;
    } else {
      // Making the module "dummy"
      prepender_iclass = create_dummy_iclass(prepender);
      flush_methods_in(prepender);
      $defineProperty(dummy_prepender, '$$dummy', true);
      $defineProperty(dummy_prepender, '$$define_methods_on', prepender_iclass);

      // Converting
      //   dummy(prepender) -> previous_parent
      // to
      //   dummy(prepender) -> iclass(prepender) -> previous_parent
      $set_proto(dummy_prepender, prepender_iclass);
      $set_proto(prepender_iclass, previous_parent);
    }

    var prepender_ancestors = Opal.ancestors(prepender);

    if (prepender_ancestors.indexOf(module) === -1) {
      // first time prepend

      start_chain_after = dummy_prepender;

      // next $$root or prepender_iclass or non-$$iclass
      end_chain_on = Object.getPrototypeOf(dummy_prepender);
      while (end_chain_on != null) {
        if (
          end_chain_on.hasOwnProperty('$$root') ||
          end_chain_on === prepender_iclass ||
          !end_chain_on.hasOwnProperty('$$iclass')
        ) {
          break;
        }

        end_chain_on = Object.getPrototypeOf(end_chain_on);
      }
    } else {
      throw Opal.RuntimeError.$new("Prepending a module multiple times is not supported");
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_prepended_modules cache
    prepender.$$own_prepended_modules = own_prepended_modules(prepender);

    Opal.const_cache_version++;
  };

  function flush_methods_in(module) {
    var proto = module.$$prototype,
        props = Object.getOwnPropertyNames(proto);

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (Opal.is_method(prop)) {
        delete proto[prop];
      }
    }
  }

  function create_iclass(module) {
    var iclass = create_dummy_iclass(module);

    if (module.$$is_module) {
      module.$$iclasses.push(iclass);
    }

    return iclass;
  }

  // Dummy iclass doesn't receive updates when the module gets a new method.
  function create_dummy_iclass(module) {
    var iclass = {},
        proto = module.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto),
        length = props.length, i;

    for (i = 0; i < length; i++) {
      var prop = props[i];
      $defineProperty(iclass, prop, proto[prop]);
    }

    $defineProperty(iclass, '$$iclass', true);
    $defineProperty(iclass, '$$module', module);

    return iclass;
  }

  function chain_iclasses(iclasses) {
    var length = iclasses.length, first = iclasses[0];

    $defineProperty(first, '$$root', true);

    if (length === 1) {
      return { first: first, last: first };
    }

    var previous = first;

    for (var i = 1; i < length; i++) {
      var current = iclasses[i];
      $set_proto(previous, current);
      previous = current;
    }


    return { first: iclasses[0], last: iclasses[length - 1] };
  }

  // For performance, some core Ruby classes are toll-free bridged to their
  // native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).
  //
  // This method is used to setup a native constructor (e.g. Array), to have
  // its prototype act like a normal Ruby class. Firstly, a new Ruby class is
  // created using the native constructor so that its prototype is set as the
  // target for the new class. Note: all bridged classes are set to inherit
  // from Object.
  //
  // Example:
  //
  //    Opal.bridge(self, Function);
  //
  // @param klass       [Class] the Ruby class to bridge
  // @param constructor [JS.Function] native JavaScript constructor to use
  // @return [Class] returns the passed Ruby class
  //
  Opal.bridge = function(native_klass, klass) {
    if (native_klass.hasOwnProperty('$$bridge')) {
      throw Opal.ArgumentError.$new("already bridged");
    }

    // constructor is a JS function with a prototype chain like:
    // - constructor
    //   - super
    //
    // What we need to do is to inject our class (with its prototype chain)
    // between constructor and super. For example, after injecting ::Object
    // into JS String we get:
    //
    // - constructor (window.String)
    //   - Opal.Object
    //     - Opal.Kernel
    //       - Opal.BasicObject
    //         - super (window.Object)
    //           - null
    //
    $defineProperty(native_klass, '$$bridge', klass);
    $set_proto(native_klass.prototype, (klass.$$super || Opal.Object).$$prototype);
    $defineProperty(klass, '$$prototype', native_klass.prototype);

    $defineProperty(klass.$$prototype, '$$class', klass);
    $defineProperty(klass, '$$constructor', native_klass);
    $defineProperty(klass, '$$bridge', true);
  };

  function protoToModule(proto) {
    if (proto.hasOwnProperty('$$dummy')) {
      return;
    } else if (proto.hasOwnProperty('$$iclass')) {
      return proto.$$module;
    } else if (proto.hasOwnProperty('$$class')) {
      return proto.$$class;
    }
  }

  function own_ancestors(module) {
    return module.$$own_prepended_modules.concat([module]).concat(module.$$own_included_modules);
  }

  // The Array of ancestors for a given module/class
  Opal.ancestors = function(module) {
    if (!module) { return []; }

    if (module.$$ancestors_cache_version === Opal.const_cache_version) {
      return module.$$ancestors;
    }

    var result = [], i, mods, length;

    for (i = 0, mods = own_ancestors(module), length = mods.length; i < length; i++) {
      result.push(mods[i]);
    }

    if (module.$$super) {
      for (i = 0, mods = Opal.ancestors(module.$$super), length = mods.length; i < length; i++) {
        result.push(mods[i]);
      }
    }

    module.$$ancestors_cache_version = Opal.const_cache_version;
    module.$$ancestors = result;

    return result;
  };

  Opal.included_modules = function(module) {
    var result = [], mod = null, proto = Object.getPrototypeOf(module.$$prototype);

    for (; proto && Object.getPrototypeOf(proto); proto = Object.getPrototypeOf(proto)) {
      mod = protoToModule(proto);
      if (mod && mod.$$is_module && proto.$$iclass && proto.$$included) {
        result.push(mod);
      }
    }

    return result;
  };


  // Method Missing
  // --------------

  // Methods stubs are used to facilitate method_missing in opal. A stub is a
  // placeholder function which just calls `method_missing` on the receiver.
  // If no method with the given name is actually defined on an object, then it
  // is obvious to say that the stub will be called instead, and then in turn
  // method_missing will be called.
  //
  // When a file in ruby gets compiled to javascript, it includes a call to
  // this function which adds stubs for every method name in the compiled file.
  // It should then be safe to assume that method_missing will work for any
  // method call detected.
  //
  // Method stubs are added to the BasicObject prototype, which every other
  // ruby object inherits, so all objects should handle method missing. A stub
  // is only added if the given property name (method name) is not already
  // defined.
  //
  // Note: all ruby methods have a `$` prefix in javascript, so all stubs will
  // have this prefix as well (to make this method more performant).
  //
  //    Opal.add_stubs(["$foo", "$bar", "$baz="]);
  //
  // All stub functions will have a private `$$stub` property set to true so
  // that other internal methods can detect if a method is just a stub or not.
  // `Kernel#respond_to?` uses this property to detect a methods presence.
  //
  // @param stubs [Array] an array of method stubs to add
  // @return [undefined]
  Opal.add_stubs = function(stubs) {
    var proto = Opal.BasicObject.$$prototype;

    for (var i = 0, length = stubs.length; i < length; i++) {
      var stub = stubs[i], existing_method = proto[stub];

      if (existing_method == null || existing_method.$$stub) {
        Opal.add_stub_for(proto, stub);
      }
    }
  };

  // Add a method_missing stub function to the given prototype for the
  // given name.
  //
  // @param prototype [Prototype] the target prototype
  // @param stub [String] stub name to add (e.g. "$foo")
  // @return [undefined]
  Opal.add_stub_for = function(prototype, stub) {
    var method_missing_stub = Opal.stub_for(stub);
    $defineProperty(prototype, stub, method_missing_stub);
  };

  // Generate the method_missing stub for a given method name.
  //
  // @param method_name [String] The js-name of the method to stub (e.g. "$foo")
  // @return [undefined]
  Opal.stub_for = function(method_name) {

    function method_missing_stub() {
      /* jshint validthis: true */

      // Copy any given block onto the method_missing dispatcher
      this.$method_missing.$$p = method_missing_stub.$$p;

      // Set block property to null ready for the next call (stop false-positives)
      method_missing_stub.$$p = null;

      // call method missing with correct args (remove '$' prefix on method name)
      var args_ary = new Array(arguments.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = arguments[i]; }

      return this.$method_missing.apply(this, [method_name.slice(1)].concat(args_ary));
    }

    method_missing_stub.$$stub = true;

    return method_missing_stub;
  };


  // Methods
  // -------

  // Arity count error dispatcher for methods
  //
  // @param actual [Fixnum] number of arguments given to method
  // @param expected [Fixnum] expected number of arguments
  // @param object [Object] owner of the method +meth+
  // @param meth [String] method name that got wrong number of arguments
  // @raise [ArgumentError]
  Opal.ac = function(actual, expected, object, meth) {
    var inspect = '';
    if (object.$$is_a_module) {
      inspect += object.$$name + '.';
    }
    else {
      inspect += object.$$class.$$name + '#';
    }
    inspect += meth;

    throw Opal.ArgumentError.$new('[' + inspect + '] wrong number of arguments(' + actual + ' for ' + expected + ')');
  };

  // Arity count error dispatcher for blocks
  //
  // @param actual [Fixnum] number of arguments given to block
  // @param expected [Fixnum] expected number of arguments
  // @param context [Object] context of the block definition
  // @raise [ArgumentError]
  Opal.block_ac = function(actual, expected, context) {
    var inspect = "`block in " + context + "'";

    throw Opal.ArgumentError.$new(inspect + ': wrong number of arguments (' + actual + ' for ' + expected + ')');
  };

  // Super dispatcher
  Opal.find_super_dispatcher = function(obj, mid, current_func, defcheck, allow_stubs) {
    var jsid = '$' + mid, ancestors, super_method;

    if (obj.hasOwnProperty('$$meta')) {
      ancestors = Opal.ancestors(obj.$$meta);
    } else {
      ancestors = Opal.ancestors(obj.$$class);
    }

    var current_index = ancestors.indexOf(current_func.$$owner);

    for (var i = current_index + 1; i < ancestors.length; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      if (proto.hasOwnProperty(jsid)) {
        super_method = proto[jsid];
        break;
      }
    }

    if (!defcheck && super_method && super_method.$$stub && obj.$method_missing.$$pristine) {
      // method_missing hasn't been explicitly defined
      throw Opal.NoMethodError.$new('super: no superclass method `'+mid+"' for "+obj, mid);
    }

    return (super_method.$$stub && !allow_stubs) ? null : super_method;
  };

  // Iter dispatcher for super in a block
  Opal.find_iter_super_dispatcher = function(obj, jsid, current_func, defcheck, implicit) {
    var call_jsid = jsid;

    if (!current_func) {
      throw Opal.RuntimeError.$new("super called outside of method");
    }

    if (implicit && current_func.$$define_meth) {
      throw Opal.RuntimeError.$new("implicit argument passing of super from method defined by define_method() is not supported. Specify all arguments explicitly");
    }

    if (current_func.$$def) {
      call_jsid = current_func.$$jsid;
    }

    return Opal.find_super_dispatcher(obj, call_jsid, current_func, defcheck);
  };

  // Used to return as an expression. Sometimes, we can't simply return from
  // a javascript function as if we were a method, as the return is used as
  // an expression, or even inside a block which must "return" to the outer
  // method. This helper simply throws an error which is then caught by the
  // method. This approach is expensive, so it is only used when absolutely
  // needed.
  //
  Opal.ret = function(val) {
    Opal.returner.$v = val;
    throw Opal.returner;
  };

  // Used to break out of a block.
  Opal.brk = function(val, breaker) {
    breaker.$v = val;
    throw breaker;
  };

  // Builds a new unique breaker, this is to avoid multiple nested breaks to get
  // in the way of each other.
  Opal.new_brk = function() {
    return new Error('unexpected break');
  };

  // handles yield calls for 1 yielded arg
  Opal.yield1 = function(block, arg) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    var has_mlhs = block.$$has_top_level_mlhs_arg,
        has_trailing_comma = block.$$has_trailing_comma_in_args;

    if (block.length > 1 || ((has_mlhs || has_trailing_comma) && block.length === 1)) {
      arg = Opal.to_ary(arg);
    }

    if ((block.length > 1 || (has_trailing_comma && block.length === 1)) && arg.$$is_array) {
      return block.apply(null, arg);
    }
    else {
      return block(arg);
    }
  };

  // handles yield for > 1 yielded arg
  Opal.yieldX = function(block, args) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    if (block.length > 1 && args.length === 1) {
      if (args[0].$$is_array) {
        return block.apply(null, args[0]);
      }
    }

    if (!args.$$is_array) {
      var args_ary = new Array(args.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

      return block.apply(null, args_ary);
    }

    return block.apply(null, args);
  };

  // Finds the corresponding exception match in candidates.  Each candidate can
  // be a value, or an array of values.  Returns null if not found.
  Opal.rescue = function(exception, candidates) {
    for (var i = 0; i < candidates.length; i++) {
      var candidate = candidates[i];

      if (candidate.$$is_array) {
        var result = Opal.rescue(exception, candidate);

        if (result) {
          return result;
        }
      }
      else if (candidate === Opal.JS.Error) {
        return candidate;
      }
      else if (candidate['$==='](exception)) {
        return candidate;
      }
    }

    return null;
  };

  Opal.is_a = function(object, klass) {
    if (klass != null && object.$$meta === klass || object.$$class === klass) {
      return true;
    }

    if (object.$$is_number && klass.$$is_number_class) {
      return (klass.$$is_integer_class) ? (object % 1) === 0 : true;
    }

    var i, length, ancestors = Opal.ancestors(object.$$is_class ? Opal.get_singleton_class(object) : (object.$$meta || object.$$class));

    for (i = 0, length = ancestors.length; i < length; i++) {
      if (ancestors[i] === klass) {
        return true;
      }
    }

    return false;
  };

  // Helpers for extracting kwsplats
  // Used for: { **h }
  Opal.to_hash = function(value) {
    if (value.$$is_hash) {
      return value;
    }
    else if (value['$respond_to?']('to_hash', true)) {
      var hash = value.$to_hash();
      if (hash.$$is_hash) {
        return hash;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Hash (" + value.$$class + "#to_hash gives " + hash.$$class + ")");
      }
    }
    else {
      throw Opal.TypeError.$new("no implicit conversion of " + value.$$class + " into Hash");
    }
  };

  // Helpers for implementing multiple assignment
  // Our code for extracting the values and assigning them only works if the
  // return value is a JS array.
  // So if we get an Array subclass, extract the wrapped JS array from it

  // Used for: a, b = something (no splat)
  Opal.to_ary = function(value) {
    if (value.$$is_array) {
      return value;
    }
    else if (value['$respond_to?']('to_ary', true)) {
      var ary = value.$to_ary();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_ary gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for: a, b = *something (with splat)
  Opal.to_a = function(value) {
    if (value.$$is_array) {
      // A splatted array must be copied
      return value.slice();
    }
    else if (value['$respond_to?']('to_a', true)) {
      var ary = value.$to_a();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_a gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for extracting keyword arguments from arguments passed to
  // JS function. If provided +arguments+ list doesn't have a Hash
  // as a last item, returns a blank Hash.
  //
  // @param parameters [Array]
  // @return [Hash]
  //
  Opal.extract_kwargs = function(parameters) {
    var kwargs = parameters[parameters.length - 1];
    if (kwargs != null && Opal.respond_to(kwargs, '$to_hash', true)) {
      $splice.call(parameters, parameters.length - 1, 1);
      return kwargs.$to_hash();
    }
    else {
      return Opal.hash2([], {});
    }
  };

  // Used to get a list of rest keyword arguments. Method takes the given
  // keyword args, i.e. the hash literal passed to the method containing all
  // keyword arguemnts passed to method, as well as the used args which are
  // the names of required and optional arguments defined. This method then
  // just returns all key/value pairs which have not been used, in a new
  // hash literal.
  //
  // @param given_args [Hash] all kwargs given to method
  // @param used_args [Object<String: true>] all keys used as named kwargs
  // @return [Hash]
  //
  Opal.kwrestargs = function(given_args, used_args) {
    var keys      = [],
        map       = {},
        key           ,
        given_map = given_args.$$smap;

    for (key in given_map) {
      if (!used_args[key]) {
        keys.push(key);
        map[key] = given_map[key];
      }
    }

    return Opal.hash2(keys, map);
  };

  // Calls passed method on a ruby object with arguments and block:
  //
  // Can take a method or a method name.
  //
  // 1. When method name gets passed it invokes it by its name
  //    and calls 'method_missing' when object doesn't have this method.
  //    Used internally by Opal to invoke method that takes a block or a splat.
  // 2. When method (i.e. method body) gets passed, it doesn't trigger 'method_missing'
  //    because it doesn't know the name of the actual method.
  //    Used internally by Opal to invoke 'super'.
  //
  // @example
  //   var my_array = [1, 2, 3, 4]
  //   Opal.send(my_array, 'length')                    # => 4
  //   Opal.send(my_array, my_array.$length)            # => 4
  //
  //   Opal.send(my_array, 'reverse!')                  # => [4, 3, 2, 1]
  //   Opal.send(my_array, my_array['$reverse!']')      # => [4, 3, 2, 1]
  //
  // @param recv [Object] ruby object
  // @param method [Function, String] method body or name of the method
  // @param args [Array] arguments that will be passed to the method call
  // @param block [Function] ruby block
  // @return [Object] returning value of the method call
  Opal.send = function(recv, method, args, block) {
    var body;

    if (typeof(method) === 'function') {
      body = method;
      method = null;
    } else if (typeof(method) === 'string') {
      body = recv['$'+method];
    } else {
      throw Opal.NameError.$new("Passed method should be a string or a function");
    }

    return Opal.send2(recv, body, method, args, block);
  };

  Opal.send2 = function(recv, body, method, args, block) {
    if (body == null && method != null && recv.$method_missing) {
      body = recv.$method_missing;
      args = [method].concat(args);
    }

    if (typeof block === 'function') body.$$p = block;
    return body.apply(recv, args);
  };

  Opal.lambda = function(block) {
    block.$$is_lambda = true;
    return block;
  };

  // Used to define methods on an object. This is a helper method, used by the
  // compiled source to define methods on special case objects when the compiler
  // can not determine the destination object, or the object is a Module
  // instance. This can get called by `Module#define_method` as well.
  //
  // ## Modules
  //
  // Any method defined on a module will come through this runtime helper.
  // The method is added to the module body, and the owner of the method is
  // set to be the module itself. This is used later when choosing which
  // method should show on a class if more than 1 included modules define
  // the same method. Finally, if the module is in `module_function` mode,
  // then the method is also defined onto the module itself.
  //
  // ## Classes
  //
  // This helper will only be called for classes when a method is being
  // defined indirectly; either through `Module#define_method`, or by a
  // literal `def` method inside an `instance_eval` or `class_eval` body. In
  // either case, the method is simply added to the class' prototype. A special
  // exception exists for `BasicObject` and `Object`. These two classes are
  // special because they are used in toll-free bridged classes. In each of
  // these two cases, extra work is required to define the methods on toll-free
  // bridged class' prototypes as well.
  //
  // ## Objects
  //
  // If a simple ruby object is the object, then the method is simply just
  // defined on the object as a singleton method. This would be the case when
  // a method is defined inside an `instance_eval` block.
  //
  // @param obj  [Object, Class] the actual obj to define method for
  // @param jsid [String] the JavaScript friendly method name (e.g. '$foo')
  // @param body [JS.Function] the literal JavaScript function used as method
  // @return [null]
  //
  Opal.def = function(obj, jsid, body) {
    // Special case for a method definition in the
    // top-level namespace
    if (obj === Opal.top) {
      Opal.defn(Opal.Object, jsid, body)
    }
    // if instance_eval is invoked on a module/class, it sets inst_eval_mod
    else if (!obj.$$eval && obj.$$is_a_module) {
      Opal.defn(obj, jsid, body);
    }
    else {
      Opal.defs(obj, jsid, body);
    }
  };

  // Define method on a module or class (see Opal.def).
  Opal.defn = function(module, jsid, body) {
    body.displayName = jsid;
    body.$$owner = module;

    var proto = module.$$prototype;
    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }
    $defineProperty(proto, jsid, body);

    if (module.$$is_module) {
      if (module.$$module_function) {
        Opal.defs(module, jsid, body)
      }

      for (var i = 0, iclasses = module.$$iclasses, length = iclasses.length; i < length; i++) {
        var iclass = iclasses[i];
        $defineProperty(iclass, jsid, body);
      }
    }

    var singleton_of = module.$$singleton_of;
    if (module.$method_added && !module.$method_added.$$stub && !singleton_of) {
      module.$method_added(jsid.substr(1));
    }
    else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {
      singleton_of.$singleton_method_added(jsid.substr(1));
    }
  };

  // Define a singleton method on the given object (see Opal.def).
  Opal.defs = function(obj, jsid, body) {
    if (obj.$$is_string || obj.$$is_number) {
      throw Opal.TypeError.$new("can't define singleton");
    }
    Opal.defn(Opal.get_singleton_class(obj), jsid, body)
  };

  // Called from #remove_method.
  Opal.rdef = function(obj, jsid) {
    if (!$has_own.call(obj.$$prototype, jsid)) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    delete obj.$$prototype[jsid];

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_removed && !obj.$$prototype.$singleton_method_removed.$$stub) {
        obj.$$prototype.$singleton_method_removed(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_removed && !obj.$method_removed.$$stub) {
        obj.$method_removed(jsid.substr(1));
      }
    }
  };

  // Called from #undef_method.
  Opal.udef = function(obj, jsid) {
    if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    Opal.add_stub_for(obj.$$prototype, jsid);

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_undefined && !obj.$$prototype.$singleton_method_undefined.$$stub) {
        obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_undefined && !obj.$method_undefined.$$stub) {
        obj.$method_undefined(jsid.substr(1));
      }
    }
  };

  function is_method_body(body) {
    return (typeof(body) === "function" && !body.$$stub);
  }

  Opal.alias = function(obj, name, old) {
    var id     = '$' + name,
        old_id = '$' + old,
        body   = obj.$$prototype['$' + old],
        alias;

    // When running inside #instance_eval the alias refers to class methods.
    if (obj.$$eval) {
      return Opal.alias(Opal.get_singleton_class(obj), name, old);
    }

    if (!is_method_body(body)) {
      var ancestor = obj.$$super;

      while (typeof(body) !== "function" && ancestor) {
        body     = ancestor[old_id];
        ancestor = ancestor.$$super;
      }

      if (!is_method_body(body) && obj.$$is_module) {
        // try to look into Object
        body = Opal.Object.$$prototype[old_id]
      }

      if (!is_method_body(body)) {
        throw Opal.NameError.$new("undefined method `" + old + "' for class `" + obj.$name() + "'")
      }
    }

    // If the body is itself an alias use the original body
    // to keep the max depth at 1.
    if (body.$$alias_of) body = body.$$alias_of;

    // We need a wrapper because otherwise properties
    // would be overwritten on the original body.
    alias = function() {
      var block = alias.$$p, args, i, ii;

      args = new Array(arguments.length);
      for(i = 0, ii = arguments.length; i < ii; i++) {
        args[i] = arguments[i];
      }

      if (block != null) { alias.$$p = null }

      return Opal.send(this, body, args, block);
    };

    // Assign the 'length' value with defineProperty because
    // in strict mode the property is not writable.
    // It doesn't work in older browsers (like Chrome 38), where
    // an exception is thrown breaking Opal altogether.
    try {
      Object.defineProperty(alias, 'length', { value: body.length });
    } catch (e) {}

    // Try to make the browser pick the right name
    alias.displayName       = name;

    alias.$$arity           = body.$$arity;
    alias.$$parameters      = body.$$parameters;
    alias.$$source_location = body.$$source_location;
    alias.$$alias_of        = body;
    alias.$$alias_name      = name;

    Opal.defn(obj, id, alias);

    return obj;
  };

  Opal.alias_native = function(obj, name, native_name) {
    var id   = '$' + name,
        body = obj.$$prototype[native_name];

    if (typeof(body) !== "function" || body.$$stub) {
      throw Opal.NameError.$new("undefined native method `" + native_name + "' for class `" + obj.$name() + "'")
    }

    Opal.defn(obj, id, body);

    return obj;
  };


  // Hashes
  // ------

  Opal.hash_init = function(hash) {
    hash.$$smap = Object.create(null);
    hash.$$map  = Object.create(null);
    hash.$$keys = [];
  };

  Opal.hash_clone = function(from_hash, to_hash) {
    to_hash.$$none = from_hash.$$none;
    to_hash.$$proc = from_hash.$$proc;

    for (var i = 0, keys = from_hash.$$keys, smap = from_hash.$$smap, len = keys.length, key, value; i < len; i++) {
      key = keys[i];

      if (key.$$is_string) {
        value = smap[key];
      } else {
        value = key.value;
        key = key.key;
      }

      Opal.hash_put(to_hash, key, value);
    }
  };

  Opal.hash_put = function(hash, key, value) {
    if (key.$$is_string) {
      if (!$has_own.call(hash.$$smap, key)) {
        hash.$$keys.push(key);
      }
      hash.$$smap[key] = value;
      return;
    }

    var key_hash, bucket, last_bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if (!$has_own.call(hash.$$map, key_hash)) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      hash.$$map[key_hash] = bucket;
      return;
    }

    bucket = hash.$$map[key_hash];

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        last_bucket = undefined;
        bucket.value = value;
        break;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }

    if (last_bucket) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      last_bucket.next = bucket;
    }
  };

  Opal.hash_get = function(hash, key) {
    if (key.$$is_string) {
      if ($has_own.call(hash.$$smap, key)) {
        return hash.$$smap[key];
      }
      return;
    }

    var key_hash, bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if ($has_own.call(hash.$$map, key_hash)) {
      bucket = hash.$$map[key_hash];

      while (bucket) {
        if (key === bucket.key || key['$eql?'](bucket.key)) {
          return bucket.value;
        }
        bucket = bucket.next;
      }
    }
  };

  Opal.hash_delete = function(hash, key) {
    var i, keys = hash.$$keys, length = keys.length, value;

    if (key.$$is_string) {
      if (typeof key !== "string") key = key.valueOf();

      if (!$has_own.call(hash.$$smap, key)) {
        return;
      }

      for (i = 0; i < length; i++) {
        if (keys[i] === key) {
          keys.splice(i, 1);
          break;
        }
      }

      value = hash.$$smap[key];
      delete hash.$$smap[key];
      return value;
    }

    var key_hash = key.$hash();

    if (!$has_own.call(hash.$$map, key_hash)) {
      return;
    }

    var bucket = hash.$$map[key_hash], last_bucket;

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        value = bucket.value;

        for (i = 0; i < length; i++) {
          if (keys[i] === bucket) {
            keys.splice(i, 1);
            break;
          }
        }

        if (last_bucket && bucket.next) {
          last_bucket.next = bucket.next;
        }
        else if (last_bucket) {
          delete last_bucket.next;
        }
        else if (bucket.next) {
          hash.$$map[key_hash] = bucket.next;
        }
        else {
          delete hash.$$map[key_hash];
        }

        return value;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }
  };

  Opal.hash_rehash = function(hash) {
    for (var i = 0, length = hash.$$keys.length, key_hash, bucket, last_bucket; i < length; i++) {

      if (hash.$$keys[i].$$is_string) {
        continue;
      }

      key_hash = hash.$$keys[i].key.$hash();

      if (key_hash === hash.$$keys[i].key_hash) {
        continue;
      }

      bucket = hash.$$map[hash.$$keys[i].key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          if (last_bucket && bucket.next) {
            last_bucket.next = bucket.next;
          }
          else if (last_bucket) {
            delete last_bucket.next;
          }
          else if (bucket.next) {
            hash.$$map[hash.$$keys[i].key_hash] = bucket.next;
          }
          else {
            delete hash.$$map[hash.$$keys[i].key_hash];
          }
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      hash.$$keys[i].key_hash = key_hash;

      if (!$has_own.call(hash.$$map, key_hash)) {
        hash.$$map[key_hash] = hash.$$keys[i];
        continue;
      }

      bucket = hash.$$map[key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          last_bucket = undefined;
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      if (last_bucket) {
        last_bucket.next = hash.$$keys[i];
      }
    }
  };

  Opal.hash = function() {
    var arguments_length = arguments.length, args, hash, i, length, key, value;

    if (arguments_length === 1 && arguments[0].$$is_hash) {
      return arguments[0];
    }

    hash = new Opal.Hash();
    Opal.hash_init(hash);

    if (arguments_length === 1 && arguments[0].$$is_array) {
      args = arguments[0];
      length = args.length;

      for (i = 0; i < length; i++) {
        if (args[i].length !== 2) {
          throw Opal.ArgumentError.$new("value not of length 2: " + args[i].$inspect());
        }

        key = args[i][0];
        value = args[i][1];

        Opal.hash_put(hash, key, value);
      }

      return hash;
    }

    if (arguments_length === 1) {
      args = arguments[0];
      for (key in args) {
        if ($has_own.call(args, key)) {
          value = args[key];

          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    }

    if (arguments_length % 2 !== 0) {
      throw Opal.ArgumentError.$new("odd number of arguments for Hash");
    }

    for (i = 0; i < arguments_length; i += 2) {
      key = arguments[i];
      value = arguments[i + 1];

      Opal.hash_put(hash, key, value);
    }

    return hash;
  };

  // A faster Hash creator for hashes that just use symbols and
  // strings as keys. The map and keys array can be constructed at
  // compile time, so they are just added here by the constructor
  // function.
  //
  Opal.hash2 = function(keys, smap) {
    var hash = new Opal.Hash();

    hash.$$smap = smap;
    hash.$$map  = Object.create(null);
    hash.$$keys = keys;

    return hash;
  };

  // Create a new range instance with first and last values, and whether the
  // range excludes the last value.
  //
  Opal.range = function(first, last, exc) {
    var range         = new Opal.Range();
        range.begin   = first;
        range.end     = last;
        range.excl    = exc;

    return range;
  };

  // Get the ivar name for a given name.
  // Mostly adds a trailing $ to reserved names.
  //
  Opal.ivar = function(name) {
    if (
        // properties
        name === "constructor" ||
        name === "displayName" ||
        name === "__count__" ||
        name === "__noSuchMethod__" ||
        name === "__parent__" ||
        name === "__proto__" ||

        // methods
        name === "hasOwnProperty" ||
        name === "valueOf"
       )
    {
      return name + "$";
    }

    return name;
  };


  // Regexps
  // -------

  // Escape Regexp special chars letting the resulting string be used to build
  // a new Regexp.
  //
  Opal.escape_regexp = function(str) {
    return str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, '\\$1')
              .replace(/[\n]/g, '\\n')
              .replace(/[\r]/g, '\\r')
              .replace(/[\f]/g, '\\f')
              .replace(/[\t]/g, '\\t');
  };

  // Create a global Regexp from a RegExp object and cache the result
  // on the object itself ($$g attribute).
  //
  Opal.global_regexp = function(pattern) {
    if (pattern.global) {
      return pattern; // RegExp already has the global flag
    }
    if (pattern.$$g == null) {
      pattern.$$g = new RegExp(pattern.source, (pattern.multiline ? 'gm' : 'g') + (pattern.ignoreCase ? 'i' : ''));
    } else {
      pattern.$$g.lastIndex = null; // reset lastIndex property
    }
    return pattern.$$g;
  };

  // Create a global multiline Regexp from a RegExp object and cache the result
  // on the object itself ($$gm or $$g attribute).
  //
  Opal.global_multiline_regexp = function(pattern) {
    var result;
    if (pattern.multiline) {
      if (pattern.global) {
        return pattern; // RegExp already has the global and multiline flag
      }
      // we are using the $$g attribute because the Regexp is already multiline
      if (pattern.$$g != null) {
        result = pattern.$$g;
      } else {
        result = pattern.$$g = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
      }
    } else if (pattern.$$gm != null) {
      result = pattern.$$gm;
    } else {
      result = pattern.$$gm = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
    }
    result.lastIndex = null; // reset lastIndex property
    return result;
  };

  // Combine multiple regexp parts together
  Opal.regexp = function(parts, flags) {
    var part;
    var ignoreCase = typeof flags !== 'undefined' && flags && flags.indexOf('i') >= 0;

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part instanceof RegExp) {
        if (part.ignoreCase !== ignoreCase)
          Opal.Kernel.$warn(
            "ignore case doesn't match for " + part.source.$inspect(),
            Opal.hash({uplevel: 1})
          )

        part = part.source;
      }
      if (part === '') part = '(?:' + part + ')';
      parts[i] = part;
    }

    if (flags) {
      return new RegExp(parts.join(''), flags);
    } else {
      return new RegExp(parts.join(''));
    }
  };

  // Require system
  // --------------

  Opal.modules         = {};
  Opal.loaded_features = ['corelib/runtime'];
  Opal.current_dir     = '.';
  Opal.require_table   = {'corelib/runtime': true};

  Opal.normalize = function(path) {
    var parts, part, new_parts = [], SEPARATOR = '/';

    if (Opal.current_dir !== '.') {
      path = Opal.current_dir.replace(/\/*$/, '/') + path;
    }

    path = path.replace(/^\.\//, '');
    path = path.replace(/\.(rb|opal|js)$/, '');
    parts = path.split(SEPARATOR);

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part === '') continue;
      (part === '..') ? new_parts.pop() : new_parts.push(part)
    }

    return new_parts.join(SEPARATOR);
  };

  Opal.loaded = function(paths) {
    var i, l, path;

    for (i = 0, l = paths.length; i < l; i++) {
      path = Opal.normalize(paths[i]);

      if (Opal.require_table[path]) {
        continue;
      }

      Opal.loaded_features.push(path);
      Opal.require_table[path] = true;
    }
  };

  Opal.load = function(path) {
    path = Opal.normalize(path);

    Opal.loaded([path]);

    var module = Opal.modules[path];

    if (module) {
      module(Opal);
    }
    else {
      var severity = Opal.config.missing_require_severity;
      var message  = 'cannot load such file -- ' + path;

      if (severity === "error") {
        if (Opal.LoadError) {
          throw Opal.LoadError.$new(message)
        } else {
          throw message
        }
      }
      else if (severity === "warning") {
        console.warn('WARNING: LoadError: ' + message);
      }
    }

    return true;
  };

  Opal.require = function(path) {
    path = Opal.normalize(path);

    if (Opal.require_table[path]) {
      return false;
    }

    return Opal.load(path);
  };


  // Strings
  // -------

  Opal.encodings = Object.create(null);

  // Sets the encoding on a string, will treat string literals as frozen strings
  // raising a FrozenError.
  // @param str [String] the string on which the encoding should be set.
  // @param name [String] the canonical name of the encoding
  Opal.set_encoding = function(str, name) {
    if (typeof str === 'string')
      throw Opal.FrozenError.$new("can't modify frozen String");

    var encoding = Opal.encodings[name];

    if (encoding === str.encoding) { return str; }

    str.encoding = encoding;

    return str;
  };

  // @returns a String object with the encoding set from a string literal
  Opal.enc = function(str, name) {
    var dup = new String(str);
    Opal.set_encoding(dup, name);
    dup.internal_encoding = dup.encoding;
    return dup
  }


  // Initialization
  // --------------
  function $BasicObject() {}
  function $Object() {}
  function $Module() {}
  function $Class() {}

  Opal.BasicObject = BasicObject = Opal.allocate_class('BasicObject', null, $BasicObject);
  Opal.Object      = _Object     = Opal.allocate_class('Object', Opal.BasicObject, $Object);
  Opal.Module      = Module      = Opal.allocate_class('Module', Opal.Object, $Module);
  Opal.Class       = Class       = Opal.allocate_class('Class', Opal.Module, $Class);

  $set_proto(Opal.BasicObject, Opal.Class.$$prototype);
  $set_proto(Opal.Object, Opal.Class.$$prototype);
  $set_proto(Opal.Module, Opal.Class.$$prototype);
  $set_proto(Opal.Class, Opal.Class.$$prototype);

  // BasicObject can reach itself, avoid const_set to skip the $$base_module logic
  BasicObject.$$const["BasicObject"] = BasicObject;

  // Assign basic constants
  Opal.const_set(_Object, "BasicObject",  BasicObject);
  Opal.const_set(_Object, "Object",       _Object);
  Opal.const_set(_Object, "Module",       Module);
  Opal.const_set(_Object, "Class",        Class);

  // Fix booted classes to have correct .class value
  BasicObject.$$class = Class;
  _Object.$$class     = Class;
  Module.$$class      = Class;
  Class.$$class       = Class;

  // Forward .toString() to #to_s
  $defineProperty(_Object.$$prototype, 'toString', function() {
    var to_s = this.$to_s();
    if (to_s.$$is_string && typeof(to_s) === 'object') {
      // a string created using new String('string')
      return to_s.valueOf();
    } else {
      return to_s;
    }
  });

  // Make Kernel#require immediately available as it's needed to require all the
  // other corelib files.
  $defineProperty(_Object.$$prototype, '$require', Opal.require);

  // Instantiate the main object
  Opal.top = new _Object();
  Opal.top.$to_s = Opal.top.$inspect = function() { return 'main' };
  Opal.top.$define_method = top_define_method;

  // Foward calls to define_method on the top object to Object
  function top_define_method() {
    var args = Opal.slice.call(arguments, 0, arguments.length);
    var block = top_define_method.$$p;
    top_define_method.$$p = null;
    return Opal.send(_Object, 'define_method', args, block)
  };


  // Nil
  function $NilClass() {}
  Opal.NilClass = Opal.allocate_class('NilClass', Opal.Object, $NilClass);
  Opal.const_set(_Object, 'NilClass', Opal.NilClass);
  nil = Opal.nil = new Opal.NilClass();
  nil.$$id = nil_id;
  nil.call = nil.apply = function() { throw Opal.LocalJumpError.$new('no block given'); };

  // Errors
  Opal.breaker  = new Error('unexpected break (old)');
  Opal.returner = new Error('unexpected return');
  TypeError.$$super = Error;
}).call(this);
Opal.loaded(["corelib/runtime.js"]);
/* Generated by Opal 1.1.1 */
Opal.modules["corelib/helpers"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $type_error = Opal.type_error, $coerce_to = Opal.coerce_to, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$===', '$raise', '$respond_to?', '$nil?', '$__send__', '$<=>', '$class', '$coerce_to!', '$new', '$!=', '$[]', '$upcase']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $Opal_bridge$1, $Opal_coerce_to$excl$2, $Opal_coerce_to$ques$3, $Opal_try_convert$4, $Opal_compare$5, $Opal_destructure$6, $Opal_respond_to$ques$7, $Opal_instance_variable_name$excl$8, $Opal_class_variable_name$excl$9, $Opal_const_name$excl$10, $Opal_pristine$11;

    
    Opal.defs(self, '$bridge', $Opal_bridge$1 = function $$bridge(constructor, klass) {
      var self = this;

      return Opal.bridge(constructor, klass);
    }, $Opal_bridge$1.$$arity = 2);
    Opal.defs(self, '$coerce_to!', $Opal_coerce_to$excl$2 = function(object, type, method, $a) {
      var $post_args, args, self = this, coerced = nil;

      
      
      $post_args = Opal.slice.call(arguments, 3, arguments.length);
      
      args = $post_args;;
      coerced = $coerce_to(object, type, method, args);
      if ($truthy(type['$==='](coerced))) {
      } else {
        self.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, $Opal_coerce_to$excl$2.$$arity = -4);
    Opal.defs(self, '$coerce_to?', $Opal_coerce_to$ques$3 = function(object, type, method, $a) {
      var $post_args, args, self = this, coerced = nil;

      
      
      $post_args = Opal.slice.call(arguments, 3, arguments.length);
      
      args = $post_args;;
      if ($truthy(object['$respond_to?'](method))) {
      } else {
        return nil
      };
      coerced = $coerce_to(object, type, method, args);
      if ($truthy(coerced['$nil?']())) {
        return nil};
      if ($truthy(type['$==='](coerced))) {
      } else {
        self.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, $Opal_coerce_to$ques$3.$$arity = -4);
    Opal.defs(self, '$try_convert', $Opal_try_convert$4 = function $$try_convert(object, type, method) {
      var self = this;

      
      if ($truthy(type['$==='](object))) {
        return object};
      if ($truthy(object['$respond_to?'](method))) {
        return object.$__send__(method)
      } else {
        return nil
      };
    }, $Opal_try_convert$4.$$arity = 3);
    Opal.defs(self, '$compare', $Opal_compare$5 = function $$compare(a, b) {
      var self = this, compare = nil;

      
      compare = a['$<=>'](b);
      if ($truthy(compare === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (a.$class()) + " with " + (b.$class()) + " failed")};
      return compare;
    }, $Opal_compare$5.$$arity = 2);
    Opal.defs(self, '$destructure', $Opal_destructure$6 = function $$destructure(args) {
      var self = this;

      
      if (args.length == 1) {
        return args[0];
      }
      else if (args.$$is_array) {
        return args;
      }
      else {
        var args_ary = new Array(args.length);
        for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

        return args_ary;
      }
    
    }, $Opal_destructure$6.$$arity = 1);
    Opal.defs(self, '$respond_to?', $Opal_respond_to$ques$7 = function(obj, method, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      
      if (obj == null || !obj.$$class) {
        return false;
      }
    ;
      return obj['$respond_to?'](method, include_all);
    }, $Opal_respond_to$ques$7.$$arity = -3);
    Opal.defs(self, '$instance_variable_name!', $Opal_instance_variable_name$excl$8 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      if ($truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "'" + (name) + "' is not allowed as an instance variable name", name))
      };
      return name;
    }, $Opal_instance_variable_name$excl$8.$$arity = 1);
    Opal.defs(self, '$class_variable_name!', $Opal_class_variable_name$excl$9 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      if ($truthy(name.length < 3 || name.slice(0,2) !== '@@')) {
        self.$raise($$($nesting, 'NameError').$new("" + "`" + (name) + "' is not allowed as a class variable name", name))};
      return name;
    }, $Opal_class_variable_name$excl$9.$$arity = 1);
    Opal.defs(self, '$const_name!', $Opal_const_name$excl$10 = function(const_name) {
      var self = this;

      
      const_name = $$($nesting, 'Opal')['$coerce_to!'](const_name, $$($nesting, 'String'), "to_str");
      if ($truthy(const_name['$[]'](0)['$!='](const_name['$[]'](0).$upcase()))) {
        self.$raise($$($nesting, 'NameError'), "" + "wrong constant name " + (const_name))};
      return const_name;
    }, $Opal_const_name$excl$10.$$arity = 1);
    Opal.defs(self, '$pristine', $Opal_pristine$11 = function $$pristine(owner_class, $a) {
      var $post_args, method_names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      method_names = $post_args;;
      
      var method_name, method;
      for (var i = method_names.length - 1; i >= 0; i--) {
        method_name = method_names[i];
        method = owner_class.$$prototype['$'+method_name];

        if (method && !method.$$stub) {
          method.$$pristine = true;
        }
      }
    ;
      return nil;
    }, $Opal_pristine$11.$$arity = -2);
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/module"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $lambda = Opal.lambda, $range = Opal.range, $send2 = Opal.send2;

  Opal.add_stubs(['$module_eval', '$to_proc', '$===', '$raise', '$equal?', '$<', '$>', '$nil?', '$attr_reader', '$attr_writer', '$warn', '$attr_accessor', '$class_variable_name!', '$new', '$const_name!', '$=~', '$inject', '$split', '$const_get', '$==', '$!~', '$start_with?', '$bind', '$call', '$class', '$append_features', '$included', '$name', '$cover?', '$size', '$merge', '$compile', '$proc', '$any?', '$prepend_features', '$prepended', '$to_s', '$__id__', '$constants', '$include?', '$copy_class_variables', '$copy_constants']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $Module_allocate$1, $Module_initialize$2, $Module_$eq_eq_eq$3, $Module_$lt$4, $Module_$lt_eq$5, $Module_$gt$6, $Module_$gt_eq$7, $Module_$lt_eq_gt$8, $Module_alias_method$9, $Module_alias_native$10, $Module_ancestors$11, $Module_append_features$12, $Module_attr_accessor$13, $Module_attr$14, $Module_attr_reader$15, $Module_attr_writer$16, $Module_autoload$17, $Module_class_variables$18, $Module_class_variable_get$19, $Module_class_variable_set$20, $Module_class_variable_defined$ques$21, $Module_remove_class_variable$22, $Module_constants$23, $Module_constants$24, $Module_nesting$25, $Module_const_defined$ques$26, $Module_const_get$27, $Module_const_missing$29, $Module_const_set$30, $Module_public_constant$31, $Module_define_method$32, $Module_remove_method$34, $Module_singleton_class$ques$35, $Module_include$36, $Module_included_modules$37, $Module_include$ques$38, $Module_instance_method$39, $Module_instance_methods$40, $Module_included$41, $Module_extended$42, $Module_extend_object$43, $Module_method_added$44, $Module_method_removed$45, $Module_method_undefined$46, $Module_module_eval$47, $Module_module_exec$49, $Module_method_defined$ques$50, $Module_module_function$51, $Module_name$52, $Module_prepend$53, $Module_prepend_features$54, $Module_prepended$55, $Module_remove_const$56, $Module_to_s$57, $Module_undef_method$58, $Module_instance_variables$59, $Module_dup$60, $Module_copy_class_variables$61, $Module_copy_constants$62;

    
    Opal.defs(self, '$allocate', $Module_allocate$1 = function $$allocate() {
      var self = this;

      
      var module = Opal.allocate_module(nil, function(){});
      // Link the prototype of Module subclasses
      if (self !== Opal.Module) Object.setPrototypeOf(module, self.$$prototype);
      return module;
    
    }, $Module_allocate$1.$$arity = 0);
    
    Opal.def(self, '$initialize', $Module_initialize$2 = function $$initialize() {
      var $iter = $Module_initialize$2.$$p, block = $iter || nil, self = this;

      if ($iter) $Module_initialize$2.$$p = null;
      
      
      if ($iter) $Module_initialize$2.$$p = null;;
      if ((block !== nil)) {
        return $send(self, 'module_eval', [], block.$to_proc())
      } else {
        return nil
      };
    }, $Module_initialize$2.$$arity = 0);
    
    Opal.def(self, '$===', $Module_$eq_eq_eq$3 = function(object) {
      var self = this;

      
      if ($truthy(object == null)) {
        return false};
      return Opal.is_a(object, self);;
    }, $Module_$eq_eq_eq$3.$$arity = 1);
    
    Opal.def(self, '$<', $Module_$lt$4 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "compared with non class/module")
      };
      
      var working = self,
          ancestors,
          i, length;

      if (working === other) {
        return false;
      }

      for (i = 0, ancestors = Opal.ancestors(self), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === other) {
          return true;
        }
      }

      for (i = 0, ancestors = Opal.ancestors(other), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === self) {
          return false;
        }
      }

      return nil;
    ;
    }, $Module_$lt$4.$$arity = 1);
    
    Opal.def(self, '$<=', $Module_$lt_eq$5 = function(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$equal?'](other)))) {
        return $ret_or_1
      } else {
        return $rb_lt(self, other)
      }
    }, $Module_$lt_eq$5.$$arity = 1);
    
    Opal.def(self, '$>', $Module_$gt$6 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "compared with non class/module")
      };
      return $rb_lt(other, self);
    }, $Module_$gt$6.$$arity = 1);
    
    Opal.def(self, '$>=', $Module_$gt_eq$7 = function(other) {
      var self = this, $ret_or_2 = nil;

      if ($truthy(($ret_or_2 = self['$equal?'](other)))) {
        return $ret_or_2
      } else {
        return $rb_gt(self, other)
      }
    }, $Module_$gt_eq$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Module_$lt_eq_gt$8 = function(other) {
      var self = this, lt = nil;

      
      
      if (self === other) {
        return 0;
      }
    ;
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        return nil
      };
      lt = $rb_lt(self, other);
      if ($truthy(lt['$nil?']())) {
        return nil};
      if ($truthy(lt)) {
        return -1
      } else {
        return 1
      };
    }, $Module_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$alias_method', $Module_alias_method$9 = function $$alias_method(newname, oldname) {
      var self = this;

      
      newname = $coerce_to(newname, $$($nesting, 'String'), 'to_str');
      oldname = $coerce_to(oldname, $$($nesting, 'String'), 'to_str');
      Opal.alias(self, newname, oldname);
      return self;
    }, $Module_alias_method$9.$$arity = 2);
    
    Opal.def(self, '$alias_native', $Module_alias_native$10 = function $$alias_native(mid, jsid) {
      var self = this;

      
      
      if (jsid == null) {
        jsid = mid;
      };
      Opal.alias_native(self, mid, jsid);
      return self;
    }, $Module_alias_native$10.$$arity = -2);
    
    Opal.def(self, '$ancestors', $Module_ancestors$11 = function $$ancestors() {
      var self = this;

      return Opal.ancestors(self);
    }, $Module_ancestors$11.$$arity = 0);
    
    Opal.def(self, '$append_features', $Module_append_features$12 = function $$append_features(includer) {
      var self = this;

      
      Opal.append_features(self, includer);
      return self;
    }, $Module_append_features$12.$$arity = 1);
    
    Opal.def(self, '$attr_accessor', $Module_attr_accessor$13 = function $$attr_accessor($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      $send(self, 'attr_reader', Opal.to_a(names));
      return $send(self, 'attr_writer', Opal.to_a(names));
    }, $Module_attr_accessor$13.$$arity = -1);
    
    Opal.def(self, '$attr', $Module_attr$14 = function $$attr($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (args.length == 2 && (args[1] === true || args[1] === false)) {
        self.$warn("optional boolean argument is obsoleted", $hash2(["uplevel"], {"uplevel": 1}))

        args[1] ? self.$attr_accessor(args[0]) : self.$attr_reader(args[0]);
        return nil;
      }
    ;
      return $send(self, 'attr_reader', Opal.to_a(args));
    }, $Module_attr$14.$$arity = -1);
    
    Opal.def(self, '$attr_reader', $Module_attr_reader$15 = function $$attr_reader($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name,
            ivar = Opal.ivar(name);

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(ivar) {
          return function() {
            if (this[ivar] == null) {
              return nil;
            }
            else {
              return this[ivar];
            }
          };
        })(ivar);

        // initialize the instance variable as nil
        Opal.defineProperty(proto, ivar, nil);

        body.$$parameters = [];
        body.$$arity = 0;

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, $Module_attr_reader$15.$$arity = -1);
    
    Opal.def(self, '$attr_writer', $Module_attr_writer$16 = function $$attr_writer($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name + '=',
            ivar = Opal.ivar(name);

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(ivar){
          return function(value) {
            return this[ivar] = value;
          }
        })(ivar);

        body.$$parameters = [['req']];
        body.$$arity = 1;

        // initialize the instance variable as nil
        Opal.defineProperty(proto, ivar, nil);

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, $Module_attr_writer$16.$$arity = -1);
    
    Opal.def(self, '$autoload', $Module_autoload$17 = function $$autoload(const$, path) {
      var self = this;

      
      if (self.$$autoload == null) self.$$autoload = {};
      Opal.const_cache_version++;
      self.$$autoload[const$] = path;
      return nil;
    
    }, $Module_autoload$17.$$arity = 2);
    
    Opal.def(self, '$class_variables', $Module_class_variables$18 = function $$class_variables() {
      var self = this;

      return Object.keys(Opal.class_variables(self));
    }, $Module_class_variables$18.$$arity = 0);
    
    Opal.def(self, '$class_variable_get', $Module_class_variable_get$19 = function $$class_variable_get(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      
      var value = Opal.class_variables(self)[name];
      if (value == null) {
        self.$raise($$($nesting, 'NameError').$new("" + "uninitialized class variable " + (name) + " in " + (self), name))
      }
      return value;
    ;
    }, $Module_class_variable_get$19.$$arity = 1);
    
    Opal.def(self, '$class_variable_set', $Module_class_variable_set$20 = function $$class_variable_set(name, value) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variable_set(self, name, value);;
    }, $Module_class_variable_set$20.$$arity = 2);
    
    Opal.def(self, '$class_variable_defined?', $Module_class_variable_defined$ques$21 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variables(self).hasOwnProperty(name);;
    }, $Module_class_variable_defined$ques$21.$$arity = 1);
    
    Opal.def(self, '$remove_class_variable', $Module_remove_class_variable$22 = function $$remove_class_variable(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      
      if (Opal.hasOwnProperty.call(self.$$cvars, name)) {
        var value = self.$$cvars[name];
        delete self.$$cvars[name];
        return value;
      } else {
        self.$raise($$($nesting, 'NameError'), "" + "cannot remove " + (name) + " for " + (self))
      }
    ;
    }, $Module_remove_class_variable$22.$$arity = 1);
    
    Opal.def(self, '$constants', $Module_constants$23 = function $$constants(inherit) {
      var self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      return Opal.constants(self, inherit);;
    }, $Module_constants$23.$$arity = -1);
    Opal.defs(self, '$constants', $Module_constants$24 = function $$constants(inherit) {
      var self = this;

      
      ;
      
      if (inherit == null) {
        var nesting = (self.$$nesting || []).concat(Opal.Object),
            constant, constants = {},
            i, ii;

        for(i = 0, ii = nesting.length; i < ii; i++) {
          for (constant in nesting[i].$$const) {
            constants[constant] = true;
          }
        }
        return Object.keys(constants);
      } else {
        return Opal.constants(self, inherit)
      }
    ;
    }, $Module_constants$24.$$arity = -1);
    Opal.defs(self, '$nesting', $Module_nesting$25 = function $$nesting() {
      var self = this;

      return self.$$nesting || [];
    }, $Module_nesting$25.$$arity = 0);
    
    Opal.def(self, '$const_defined?', $Module_const_defined$ques$26 = function(name, inherit) {
      var self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      name = $$($nesting, 'Opal')['$const_name!'](name);
      if ($truthy(name['$=~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))
      };
      
      var module, modules = [self], module_constants, i, ii;

      // Add up ancestors if inherit is true
      if (inherit) {
        modules = modules.concat(Opal.ancestors(self));

        // Add Object's ancestors if it's a module – modules have no ancestors otherwise
        if (self.$$is_module) {
          modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));
        }
      }

      for (i = 0, ii = modules.length; i < ii; i++) {
        module = modules[i];
        if (module.$$const[name] != null) {
          return true;
        }
      }

      return false;
    ;
    }, $Module_const_defined$ques$26.$$arity = -2);
    
    Opal.def(self, '$const_get', $Module_const_get$27 = function $$const_get(name, inherit) {
      var $$28, self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      name = $$($nesting, 'Opal')['$const_name!'](name);
      
      if (name.indexOf('::') === 0 && name !== '::'){
        name = name.slice(2);
      }
    ;
      if ($truthy(name.indexOf('::') != -1 && name != '::')) {
        return $send(name.$split("::"), 'inject', [self], ($$28 = function(o, c){var self = $$28.$$s == null ? this : $$28.$$s;

        
          
          if (o == null) {
            o = nil;
          };
          
          if (c == null) {
            c = nil;
          };
          return o.$const_get(c);}, $$28.$$s = self, $$28.$$arity = 2, $$28))};
      if ($truthy(name['$=~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))
      };
      
      if (inherit) {
        return $$([self], name);
      } else {
        return Opal.const_get_local(self, name);
      }
    ;
    }, $Module_const_get$27.$$arity = -2);
    
    Opal.def(self, '$const_missing', $Module_const_missing$29 = function $$const_missing(name) {
      var self = this, full_const_name = nil;

      
      
      if (self.$$autoload) {
        var file = self.$$autoload[name];

        if (file) {
          self.$require(file);

          return self.$const_get(name);
        }
      }
    ;
      full_const_name = (function() {if (self['$==']($$($nesting, 'Object'))) {
        return name
      } else {
        return "" + (self) + "::" + (name)
      }; return nil; })();
      return self.$raise($$($nesting, 'NameError').$new("" + "uninitialized constant " + (full_const_name), name));
    }, $Module_const_missing$29.$$arity = 1);
    
    Opal.def(self, '$const_set', $Module_const_set$30 = function $$const_set(name, value) {
      var self = this, $ret_or_3 = nil;

      
      name = $$($nesting, 'Opal')['$const_name!'](name);
      if ($truthy((function() {if ($truthy(($ret_or_3 = name['$!~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP'))))) {
        return $ret_or_3
      } else {
        return name['$start_with?']("::")
      }; return nil; })())) {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))};
      Opal.const_set(self, name, value);
      return value;
    }, $Module_const_set$30.$$arity = 2);
    
    Opal.def(self, '$public_constant', $Module_public_constant$31 = function $$public_constant(const_name) {
      var self = this;

      return nil
    }, $Module_public_constant$31.$$arity = 1);
    
    Opal.def(self, '$define_method', $Module_define_method$32 = function $$define_method(name, method) {
      var $iter = $Module_define_method$32.$$p, block = $iter || nil, $$33, self = this, $ret_or_4 = nil, $case = nil;

      if ($iter) $Module_define_method$32.$$p = null;
      
      
      if ($iter) $Module_define_method$32.$$p = null;;
      ;
      if ($truthy(method === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create a Proc object without a block")};
      block = (function() {if ($truthy(($ret_or_4 = block))) {
        return $ret_or_4
      } else {
        return (function() {$case = method;
        if ($$($nesting, 'Proc')['$===']($case)) {return method}
        else if ($$($nesting, 'Method')['$===']($case)) {return method.$to_proc().$$unbound}
        else if ($$($nesting, 'UnboundMethod')['$===']($case)) {return $lambda(($$33 = function($a){var self = $$33.$$s == null ? this : $$33.$$s, $post_args, args, bound = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          bound = method.$bind(self);
          return $send(bound, 'call', Opal.to_a(args));}, $$33.$$s = self, $$33.$$arity = -1, $$33))}
        else {return self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (block.$class()) + " (expected Proc/Method)")}})()
      }; return nil; })();
      
      var id = '$' + name;

      block.$$jsid        = name;
      block.$$s           = null;
      block.$$def         = block;
      block.$$define_meth = true;

      Opal.defn(self, id, block);

      return name;
    ;
    }, $Module_define_method$32.$$arity = -2);
    
    Opal.def(self, '$remove_method', $Module_remove_method$34 = function $$remove_method($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.rdef(self, "$" + names[i]);
      }
    ;
      return self;
    }, $Module_remove_method$34.$$arity = -1);
    
    Opal.def(self, '$singleton_class?', $Module_singleton_class$ques$35 = function() {
      var self = this;

      return !!self.$$is_singleton;
    }, $Module_singleton_class$ques$35.$$arity = 0);
    
    Opal.def(self, '$include', $Module_include$36 = function $$include($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(self);
        (mod).$included(self);
      }
    ;
      return self;
    }, $Module_include$36.$$arity = -1);
    
    Opal.def(self, '$included_modules', $Module_included_modules$37 = function $$included_modules() {
      var self = this;

      return Opal.included_modules(self);
    }, $Module_included_modules$37.$$arity = 0);
    
    Opal.def(self, '$include?', $Module_include$ques$38 = function(mod) {
      var self = this;

      
      if (!mod.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
      }

      var i, ii, mod2, ancestors = Opal.ancestors(self);

      for (i = 0, ii = ancestors.length; i < ii; i++) {
        mod2 = ancestors[i];
        if (mod2 === mod && mod2 !== self) {
          return true;
        }
      }

      return false;
    
    }, $Module_include$ques$38.$$arity = 1);
    
    Opal.def(self, '$instance_method', $Module_instance_method$39 = function $$instance_method(name) {
      var self = this;

      
      var meth = self.$$prototype['$' + name];

      if (!meth || meth.$$stub) {
        self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + (name) + "' for class `" + (self.$name()) + "'", name));
      }

      return $$($nesting, 'UnboundMethod').$new(self, meth.$$owner || self, meth, name);
    
    }, $Module_instance_method$39.$$arity = 1);
    
    Opal.def(self, '$instance_methods', $Module_instance_methods$40 = function $$instance_methods(include_super) {
      var self = this;

      
      
      if (include_super == null) {
        include_super = true;
      };
      
      if ($truthy(include_super)) {
        return Opal.instance_methods(self);
      } else {
        return Opal.own_instance_methods(self);
      }
    ;
    }, $Module_instance_methods$40.$$arity = -1);
    
    Opal.def(self, '$included', $Module_included$41 = function $$included(mod) {
      var self = this;

      return nil
    }, $Module_included$41.$$arity = 1);
    
    Opal.def(self, '$extended', $Module_extended$42 = function $$extended(mod) {
      var self = this;

      return nil
    }, $Module_extended$42.$$arity = 1);
    
    Opal.def(self, '$extend_object', $Module_extend_object$43 = function $$extend_object(object) {
      var self = this;

      return nil
    }, $Module_extend_object$43.$$arity = 1);
    
    Opal.def(self, '$method_added', $Module_method_added$44 = function $$method_added($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_added$44.$$arity = -1);
    
    Opal.def(self, '$method_removed', $Module_method_removed$45 = function $$method_removed($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_removed$45.$$arity = -1);
    
    Opal.def(self, '$method_undefined', $Module_method_undefined$46 = function $$method_undefined($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_undefined$46.$$arity = -1);
    
    Opal.def(self, '$module_eval', $Module_module_eval$47 = function $$module_eval($a) {
      var $iter = $Module_module_eval$47.$$p, block = $iter || nil, $post_args, args, $b, $$48, self = this, $ret_or_5 = nil, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_6 = nil, compiling_options = nil, compiled = nil;

      if ($iter) $Module_module_eval$47.$$p = null;
      
      
      if ($iter) $Module_module_eval$47.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy((function() {if ($truthy(($ret_or_5 = block['$nil?']()))) {
        return !!Opal.compile;
      } else {
        return $ret_or_5
      }; return nil; })())) {
        
        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {
        } else {
          $$($nesting, 'Kernel').$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": (function() {if ($truthy(($ret_or_6 = file))) {
          return $ret_or_6
        } else {
          return "(eval)"
        }; return nil; })(), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $$($nesting, 'Opal').$compile(string, compiling_options);
        block = $send($$($nesting, 'Kernel'), 'proc', [], ($$48 = function(){var self = $$48.$$s == null ? this : $$48.$$s;

        
          return (function(self) {
            return eval(compiled);
          })(self)
        }, $$48.$$s = self, $$48.$$arity = 0, $$48));
      } else if ($truthy(args['$any?']())) {
        $$($nesting, 'Kernel').$raise($$($nesting, 'ArgumentError'), "" + ("" + "wrong number of arguments (" + (args.$size()) + " for 0)") + "\n\n  NOTE:If you want to enable passing a String argument please add \"require 'opal-parser'\" to your script\n")};
      
      var old = block.$$s,
          result;

      block.$$s = null;
      result = block.apply(self, [self]);
      block.$$s = old;

      return result;
    ;
    }, $Module_module_eval$47.$$arity = -1);
    Opal.alias(self, "class_eval", "module_eval");
    
    Opal.def(self, '$module_exec', $Module_module_exec$49 = function $$module_exec($a) {
      var $iter = $Module_module_exec$49.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Module_module_exec$49.$$p = null;
      
      
      if ($iter) $Module_module_exec$49.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (block === nil) {
        self.$raise($$($nesting, 'LocalJumpError'), "no block given")
      }

      var block_self = block.$$s, result;

      block.$$s = null;
      result = block.apply(self, args);
      block.$$s = block_self;

      return result;
    ;
    }, $Module_module_exec$49.$$arity = -1);
    Opal.alias(self, "class_exec", "module_exec");
    
    Opal.def(self, '$method_defined?', $Module_method_defined$ques$50 = function(method) {
      var self = this;

      
      var body = self.$$prototype['$' + method];
      return (!!body) && !body.$$stub;
    
    }, $Module_method_defined$ques$50.$$arity = 1);
    
    Opal.def(self, '$module_function', $Module_module_function$51 = function $$module_function($a) {
      var $post_args, methods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      methods = $post_args;;
      
      if (methods.length === 0) {
        self.$$module_function = true;
      }
      else {
        for (var i = 0, length = methods.length; i < length; i++) {
          var meth = methods[i],
              id   = '$' + meth,
              func = self.$$prototype[id];

          Opal.defs(self, id, func);
        }
      }

      return self;
    ;
    }, $Module_module_function$51.$$arity = -1);
    
    Opal.def(self, '$name', $Module_name$52 = function $$name() {
      var self = this;

      
      if (self.$$full_name) {
        return self.$$full_name;
      }

      var result = [], base = self;

      while (base) {
        // Give up if any of the ancestors is unnamed
        if (base.$$name === nil || base.$$name == null) return nil;

        result.unshift(base.$$name);

        base = base.$$base_module;

        if (base === Opal.Object) {
          break;
        }
      }

      if (result.length === 0) {
        return nil;
      }

      return self.$$full_name = result.join('::');
    
    }, $Module_name$52.$$arity = 0);
    
    Opal.def(self, '$prepend', $Module_prepend$53 = function $$prepend($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      if (mods.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$prepend_features(self);
        (mod).$prepended(self);
      }
    ;
      return self;
    }, $Module_prepend$53.$$arity = -1);
    
    Opal.def(self, '$prepend_features', $Module_prepend_features$54 = function $$prepend_features(prepender) {
      var self = this;

      
      
      if (!self.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (self.$class()) + " (expected Module)");
      }

      Opal.prepend_features(self, prepender)
    ;
      return self;
    }, $Module_prepend_features$54.$$arity = 1);
    
    Opal.def(self, '$prepended', $Module_prepended$55 = function $$prepended(mod) {
      var self = this;

      return nil
    }, $Module_prepended$55.$$arity = 1);
    
    Opal.def(self, '$remove_const', $Module_remove_const$56 = function $$remove_const(name) {
      var self = this;

      return Opal.const_remove(self, name);
    }, $Module_remove_const$56.$$arity = 1);
    
    Opal.def(self, '$to_s', $Module_to_s$57 = function $$to_s() {
      var self = this, $ret_or_7 = nil;

      if ($truthy(($ret_or_7 = Opal.Module.$name.call(self)))) {
        return $ret_or_7
      } else {
        return "" + "#<" + (self.$$is_module ? 'Module' : 'Class') + ":0x" + (self.$__id__().$to_s(16)) + ">"
      }
    }, $Module_to_s$57.$$arity = 0);
    
    Opal.def(self, '$undef_method', $Module_undef_method$58 = function $$undef_method($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.udef(self, "$" + names[i]);
      }
    ;
      return self;
    }, $Module_undef_method$58.$$arity = -1);
    
    Opal.def(self, '$instance_variables', $Module_instance_variables$59 = function $$instance_variables() {
      var self = this, consts = nil;

      
      consts = (Opal.Module.$$nesting = $nesting, self.$constants());
      
      var result = [];

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$' && name !== 'constructor' && !consts['$include?'](name)) {
          result.push('@' + name);
        }
      }

      return result;
    ;
    }, $Module_instance_variables$59.$$arity = 0);
    
    Opal.def(self, '$dup', $Module_dup$60 = function $$dup() {
      var $iter = $Module_dup$60.$$p, $yield = $iter || nil, self = this, copy = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Module_dup$60.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      copy = $send2(self, Opal.find_super_dispatcher(self, 'dup', $Module_dup$60, false, true), 'dup', $zuper, $iter);
      copy.$copy_class_variables(self);
      copy.$copy_constants(self);
      return copy;
    }, $Module_dup$60.$$arity = 0);
    
    Opal.def(self, '$copy_class_variables', $Module_copy_class_variables$61 = function $$copy_class_variables(other) {
      var self = this;

      
      for (var name in other.$$cvars) {
        self.$$cvars[name] = other.$$cvars[name];
      }
    
    }, $Module_copy_class_variables$61.$$arity = 1);
    return (Opal.def(self, '$copy_constants', $Module_copy_constants$62 = function $$copy_constants(other) {
      var self = this;

      
      var name, other_constants = other.$$const;

      for (name in other_constants) {
        Opal.const_set(self, name, other_constants[name]);
      }
    
    }, $Module_copy_constants$62.$$arity = 1), nil) && 'copy_constants';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/class"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, $send2 = Opal.send2;

  Opal.add_stubs(['$require', '$class_eval', '$to_proc', '$initialize_copy', '$allocate', '$name', '$to_s']);
  
  self.$require("corelib/module");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $Class_new$1, $Class_allocate$2, $Class_inherited$3, $Class_initialize_dup$4, $Class_new$5, $Class_superclass$6, $Class_to_s$7;

    
    Opal.defs(self, '$new', $Class_new$1 = function(superclass) {
      var $iter = $Class_new$1.$$p, block = $iter || nil, self = this;

      if ($iter) $Class_new$1.$$p = null;
      
      
      if ($iter) $Class_new$1.$$p = null;;
      
      if (superclass == null) {
        superclass = $$($nesting, 'Object');
      };
      
      if (!superclass.$$is_class) {
        throw Opal.TypeError.$new("superclass must be a Class");
      }

      var klass = Opal.allocate_class(nil, superclass);
      superclass.$inherited(klass);
      (function() {if ((block !== nil)) {
        return $send((klass), 'class_eval', [], block.$to_proc())
      } else {
        return nil
      }; return nil; })()
      return klass;
    ;
    }, $Class_new$1.$$arity = -1);
    
    Opal.def(self, '$allocate', $Class_allocate$2 = function $$allocate() {
      var self = this;

      
      var obj = new self.$$constructor();
      obj.$$id = Opal.uid();
      return obj;
    
    }, $Class_allocate$2.$$arity = 0);
    
    Opal.def(self, '$inherited', $Class_inherited$3 = function $$inherited(cls) {
      var self = this;

      return nil
    }, $Class_inherited$3.$$arity = 1);
    
    Opal.def(self, '$initialize_dup', $Class_initialize_dup$4 = function $$initialize_dup(original) {
      var self = this;

      
      self.$initialize_copy(original);
      
      self.$$name = null;
      self.$$full_name = null;
    ;
    }, $Class_initialize_dup$4.$$arity = 1);
    
    Opal.def(self, '$new', $Class_new$5 = function($a) {
      var $iter = $Class_new$5.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Class_new$5.$$p = null;
      
      
      if ($iter) $Class_new$5.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var object = self.$allocate();
      Opal.send(object, object.$initialize, args, block);
      return object;
    ;
    }, $Class_new$5.$$arity = -1);
    
    Opal.def(self, '$superclass', $Class_superclass$6 = function $$superclass() {
      var self = this;

      return self.$$super || nil;
    }, $Class_superclass$6.$$arity = 0);
    return (Opal.def(self, '$to_s', $Class_to_s$7 = function $$to_s() {
      var $iter = $Class_to_s$7.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Class_to_s$7.$$p = null;
      
      var singleton_of = self.$$singleton_of;

      if (singleton_of && singleton_of.$$is_a_module) {
        return "" + "#<Class:" + ((singleton_of).$name()) + ">";
      }
      else if (singleton_of) {
        // a singleton class created from an object
        return "" + "#<Class:#<" + ((singleton_of.$$class).$name()) + ":0x" + ((Opal.id(singleton_of)).$to_s(16)) + ">>";
      }

      return $send2(self, Opal.find_super_dispatcher(self, 'to_s', $Class_to_s$7, false, true), 'to_s', [], null);
    
    }, $Class_to_s$7.$$arity = 0), nil) && 'to_s';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/basic_object"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$==', '$!', '$nil?', '$cover?', '$size', '$raise', '$merge', '$compile', '$proc', '$any?', '$inspect', '$new']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'BasicObject');

    var $nesting = [self].concat($parent_nesting), $BasicObject_initialize$1, $BasicObject_$eq_eq$2, $BasicObject_eql$ques$3, $BasicObject___id__$4, $BasicObject___send__$5, $BasicObject_$excl$6, $BasicObject_$not_eq$7, $BasicObject_instance_eval$8, $BasicObject_instance_exec$10, $BasicObject_singleton_method_added$11, $BasicObject_singleton_method_removed$12, $BasicObject_singleton_method_undefined$13, $BasicObject_method_missing$14, $BasicObject_respond_to_missing$ques$15;

    
    
    Opal.def(self, '$initialize', $BasicObject_initialize$1 = function $$initialize($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_initialize$1.$$arity = -1);
    
    Opal.def(self, '$==', $BasicObject_$eq_eq$2 = function(other) {
      var self = this;

      return self === other;
    }, $BasicObject_$eq_eq$2.$$arity = 1);
    
    Opal.def(self, '$eql?', $BasicObject_eql$ques$3 = function(other) {
      var self = this;

      return self['$=='](other)
    }, $BasicObject_eql$ques$3.$$arity = 1);
    Opal.alias(self, "equal?", "==");
    
    Opal.def(self, '$__id__', $BasicObject___id__$4 = function $$__id__() {
      var self = this;

      
      if (self.$$id != null) {
        return self.$$id;
      }
      Opal.defineProperty(self, '$$id', Opal.uid());
      return self.$$id;
    
    }, $BasicObject___id__$4.$$arity = 0);
    
    Opal.def(self, '$__send__', $BasicObject___send__$5 = function $$__send__(symbol, $a) {
      var $iter = $BasicObject___send__$5.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $BasicObject___send__$5.$$p = null;
      
      
      if ($iter) $BasicObject___send__$5.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      
      var func = self['$' + symbol]

      if (func) {
        if (block !== nil) {
          func.$$p = block;
        }

        return func.apply(self, args);
      }

      if (block !== nil) {
        self.$method_missing.$$p = block;
      }

      return self.$method_missing.apply(self, [symbol].concat(args));
    ;
    }, $BasicObject___send__$5.$$arity = -2);
    
    Opal.def(self, '$!', $BasicObject_$excl$6 = function() {
      var self = this;

      return false
    }, $BasicObject_$excl$6.$$arity = 0);
    
    Opal.def(self, '$!=', $BasicObject_$not_eq$7 = function(other) {
      var self = this;

      return self['$=='](other)['$!']()
    }, $BasicObject_$not_eq$7.$$arity = 1);
    
    Opal.def(self, '$instance_eval', $BasicObject_instance_eval$8 = function $$instance_eval($a) {
      var $iter = $BasicObject_instance_eval$8.$$p, block = $iter || nil, $post_args, args, $b, $$9, self = this, $ret_or_1 = nil, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_2 = nil, compiling_options = nil, compiled = nil;

      if ($iter) $BasicObject_instance_eval$8.$$p = null;
      
      
      if ($iter) $BasicObject_instance_eval$8.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy((function() {if ($truthy(($ret_or_1 = block['$nil?']()))) {
        return !!Opal.compile;
      } else {
        return $ret_or_1
      }; return nil; })())) {
        
        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {
        } else {
          $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": (function() {if ($truthy(($ret_or_2 = file))) {
          return $ret_or_2
        } else {
          return "(eval)"
        }; return nil; })(), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $$$('::', 'Opal').$compile(string, compiling_options);
        block = $send($$$('::', 'Kernel'), 'proc', [], ($$9 = function(){var self = $$9.$$s == null ? this : $$9.$$s;

        
          return (function(self) {
            return eval(compiled);
          })(self)
        }, $$9.$$s = self, $$9.$$arity = 0, $$9));
      } else if ($truthy(args['$any?']())) {
        $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "" + "wrong number of arguments (" + (args.$size()) + " for 0)")};
      
      var old = block.$$s,
          result;

      block.$$s = null;

      // Need to pass $$eval so that method definitions know if this is
      // being done on a class/module. Cannot be compiler driven since
      // send(:instance_eval) needs to work.
      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.call(self, self);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.call(self, self);
      }

      block.$$s = old;

      return result;
    ;
    }, $BasicObject_instance_eval$8.$$arity = -1);
    
    Opal.def(self, '$instance_exec', $BasicObject_instance_exec$10 = function $$instance_exec($a) {
      var $iter = $BasicObject_instance_exec$10.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $BasicObject_instance_exec$10.$$p = null;
      
      
      if ($iter) $BasicObject_instance_exec$10.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(block)) {
      } else {
        $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "no block given")
      };
      
      var block_self = block.$$s,
          result;

      block.$$s = null;

      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.apply(self, args);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.apply(self, args);
      }

      block.$$s = block_self;

      return result;
    ;
    }, $BasicObject_instance_exec$10.$$arity = -1);
    
    Opal.def(self, '$singleton_method_added', $BasicObject_singleton_method_added$11 = function $$singleton_method_added($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_added$11.$$arity = -1);
    
    Opal.def(self, '$singleton_method_removed', $BasicObject_singleton_method_removed$12 = function $$singleton_method_removed($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_removed$12.$$arity = -1);
    
    Opal.def(self, '$singleton_method_undefined', $BasicObject_singleton_method_undefined$13 = function $$singleton_method_undefined($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_undefined$13.$$arity = -1);
    
    Opal.def(self, '$method_missing', $BasicObject_method_missing$14 = function $$method_missing(symbol, $a) {
      var $iter = $BasicObject_method_missing$14.$$p, block = $iter || nil, $post_args, args, self = this, message = nil;

      if ($iter) $BasicObject_method_missing$14.$$p = null;
      
      
      if ($iter) $BasicObject_method_missing$14.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      message = (function() {if ($truthy(self.$inspect && !self.$inspect.$$stub)) {
        return "" + "undefined method `" + (symbol) + "' for " + (self.$inspect()) + ":" + (self.$$class)
      } else {
        return "" + "undefined method `" + (symbol) + "' for " + (self.$$class)
      }; return nil; })();
      return $$$('::', 'Kernel').$raise($$$('::', 'NoMethodError').$new(message, symbol));
    }, $BasicObject_method_missing$14.$$arity = -2);
    return (Opal.def(self, '$respond_to_missing?', $BasicObject_respond_to_missing$ques$15 = function(method_name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return false;
    }, $BasicObject_respond_to_missing$ques$15.$$arity = -2), nil) && 'respond_to_missing?';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/kernel"] = function(Opal) {
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $module = Opal.module, $gvars = Opal.gvars, $hash2 = Opal.hash2, $send = Opal.send, $klass = Opal.klass;

  Opal.add_stubs(['$raise', '$new', '$inspect', '$!', '$=~', '$==', '$object_id', '$class', '$coerce_to?', '$<<', '$allocate', '$copy_instance_variables', '$copy_singleton_methods', '$initialize_clone', '$initialize_copy', '$define_method', '$singleton_class', '$to_proc', '$initialize_dup', '$for', '$empty?', '$pop', '$call', '$append_features', '$extend_object', '$extended', '$__id__', '$to_s', '$instance_variable_name!', '$respond_to?', '$to_int', '$coerce_to!', '$Integer', '$nil?', '$===', '$enum_for', '$result', '$any?', '$print', '$format', '$puts', '$each', '$<=', '$length', '$[]', '$<', '$first', '$caller', '$+', '$map', '$exception', '$is_a?', '$rand', '$respond_to_missing?', '$pristine', '$try_convert!', '$expand_path', '$join', '$start_with?', '$new_seed', '$srand', '$sym', '$arg', '$open', '$include']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_method_missing$1, $Kernel_$eq_tilde$2, $Kernel_$excl_tilde$3, $Kernel_$eq_eq_eq$4, $Kernel_$lt_eq_gt$5, $Kernel_method$6, $Kernel_methods$7, $Kernel_public_methods$8, $Kernel_Array$9, $Kernel_at_exit$10, $Kernel_caller$11, $Kernel_class$12, $Kernel_copy_instance_variables$13, $Kernel_copy_singleton_methods$14, $Kernel_clone$15, $Kernel_initialize_clone$16, $Kernel_define_singleton_method$17, $Kernel_dup$18, $Kernel_initialize_dup$19, $Kernel_enum_for$20, $Kernel_equal$ques$21, $Kernel_exit$22, $Kernel_extend$23, $Kernel_hash$24, $Kernel_initialize_copy$25, $Kernel_inspect$26, $Kernel_instance_of$ques$27, $Kernel_instance_variable_defined$ques$28, $Kernel_instance_variable_get$29, $Kernel_instance_variable_set$30, $Kernel_remove_instance_variable$31, $Kernel_instance_variables$32, $Kernel_Integer$33, $Kernel_Float$34, $Kernel_Hash$35, $Kernel_is_a$ques$36, $Kernel_itself$37, $Kernel_lambda$38, $Kernel_load$39, $Kernel_loop$40, $Kernel_nil$ques$42, $Kernel_printf$43, $Kernel_proc$44, $Kernel_puts$45, $Kernel_p$46, $Kernel_print$48, $Kernel_warn$49, $Kernel_raise$51, $Kernel_rand$52, $Kernel_respond_to$ques$53, $Kernel_respond_to_missing$ques$54, $Kernel_require$55, $Kernel_require_relative$56, $Kernel_require_tree$57, $Kernel_singleton_class$58, $Kernel_sleep$59, $Kernel_srand$60, $Kernel_String$61, $Kernel_tap$62, $Kernel_to_proc$63, $Kernel_to_s$64, $Kernel_catch$65, $Kernel_throw$66, $Kernel_open$67, $Kernel_yield_self$68;

    
    
    Opal.def(self, '$method_missing', $Kernel_method_missing$1 = function $$method_missing(symbol, $a) {
      var $iter = $Kernel_method_missing$1.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Kernel_method_missing$1.$$p = null;
      
      
      if ($iter) $Kernel_method_missing$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      return self.$raise($$($nesting, 'NoMethodError').$new("" + "undefined method `" + (symbol) + "' for " + (self.$inspect()), symbol, args));
    }, $Kernel_method_missing$1.$$arity = -2);
    
    Opal.def(self, '$=~', $Kernel_$eq_tilde$2 = function(obj) {
      var self = this;

      return false
    }, $Kernel_$eq_tilde$2.$$arity = 1);
    
    Opal.def(self, '$!~', $Kernel_$excl_tilde$3 = function(obj) {
      var self = this;

      return self['$=~'](obj)['$!']()
    }, $Kernel_$excl_tilde$3.$$arity = 1);
    
    Opal.def(self, '$===', $Kernel_$eq_eq_eq$4 = function(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.$object_id()['$=='](other.$object_id())))) {
        return $ret_or_1
      } else {
        return self['$=='](other)
      }
    }, $Kernel_$eq_eq_eq$4.$$arity = 1);
    
    Opal.def(self, '$<=>', $Kernel_$lt_eq_gt$5 = function(other) {
      var self = this;

      
      // set guard for infinite recursion
      self.$$comparable = true;

      var x = self['$=='](other);

      if (x && x !== nil) {
        return 0;
      }

      return nil;
    
    }, $Kernel_$lt_eq_gt$5.$$arity = 1);
    
    Opal.def(self, '$method', $Kernel_method$6 = function $$method(name) {
      var self = this;

      
      var meth = self['$' + name];

      if (!meth || meth.$$stub) {
        self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + (name) + "' for class `" + (self.$class()) + "'", name));
      }

      return $$($nesting, 'Method').$new(self, meth.$$owner || self.$class(), meth, name);
    
    }, $Kernel_method$6.$$arity = 1);
    
    Opal.def(self, '$methods', $Kernel_methods$7 = function $$methods(all) {
      var self = this;

      
      
      if (all == null) {
        all = true;
      };
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.own_methods(self);
      }
    ;
    }, $Kernel_methods$7.$$arity = -1);
    
    Opal.def(self, '$public_methods', $Kernel_public_methods$8 = function $$public_methods(all) {
      var self = this;

      
      
      if (all == null) {
        all = true;
      };
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.receiver_methods(self);
      }
    ;
    }, $Kernel_public_methods$8.$$arity = -1);
    
    Opal.def(self, '$Array', $Kernel_Array$9 = function $$Array(object) {
      var self = this;

      
      var coerced;

      if (object === nil) {
        return [];
      }

      if (object.$$is_array) {
        return object;
      }

      coerced = $$($nesting, 'Opal')['$coerce_to?'](object, $$($nesting, 'Array'), "to_ary");
      if (coerced !== nil) { return coerced; }

      coerced = $$($nesting, 'Opal')['$coerce_to?'](object, $$($nesting, 'Array'), "to_a");
      if (coerced !== nil) { return coerced; }

      return [object];
    
    }, $Kernel_Array$9.$$arity = 1);
    
    Opal.def(self, '$at_exit', $Kernel_at_exit$10 = function $$at_exit() {
      var $iter = $Kernel_at_exit$10.$$p, block = $iter || nil, self = this, $ret_or_2 = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      if ($iter) $Kernel_at_exit$10.$$p = null;
      
      
      if ($iter) $Kernel_at_exit$10.$$p = null;;
      $gvars.__at_exit__ = (function() {if ($truthy(($ret_or_2 = $gvars.__at_exit__))) {
        return $ret_or_2
      } else {
        return []
      }; return nil; })();
      $gvars.__at_exit__['$<<'](block);
      return block;
    }, $Kernel_at_exit$10.$$arity = 0);
    
    Opal.def(self, '$caller', $Kernel_caller$11 = function $$caller(start, length) {
      var self = this;

      
      
      if (start == null) {
        start = 1;
      };
      
      if (length == null) {
        length = nil;
      };
      
      var stack, result

      stack = (new Error().stack || "").split("\n")
      result = []

      // Skip the initial line ("Error:") and Kernel#caller with i=3
      for (var i = 3, ii = stack.length; i < ii; i++) {
        if (!stack[i].match("runtime.js")) {
          result.push(stack[i].replace(/^ *\w+ +/, ''))
          if (length && result.length == length) break
        }
      }
      return result
    ;
    }, $Kernel_caller$11.$$arity = -1);
    
    Opal.def(self, '$class', $Kernel_class$12 = function() {
      var self = this;

      return self.$$class;
    }, $Kernel_class$12.$$arity = 0);
    
    Opal.def(self, '$copy_instance_variables', $Kernel_copy_instance_variables$13 = function $$copy_instance_variables(other) {
      var self = this;

      
      var keys = Object.keys(other), i, ii, name;
      for (i = 0, ii = keys.length; i < ii; i++) {
        name = keys[i];
        if (name.charAt(0) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, $Kernel_copy_instance_variables$13.$$arity = 1);
    
    Opal.def(self, '$copy_singleton_methods', $Kernel_copy_singleton_methods$14 = function $$copy_singleton_methods(other) {
      var self = this;

      
      var i, name, names, length;

      if (other.hasOwnProperty('$$meta')) {
        var other_singleton_class = Opal.get_singleton_class(other);
        var self_singleton_class = Opal.get_singleton_class(self);
        names = Object.getOwnPropertyNames(other_singleton_class.$$prototype);

        for (i = 0, length = names.length; i < length; i++) {
          name = names[i];
          if (Opal.is_method(name)) {
            self_singleton_class.$$prototype[name] = other_singleton_class.$$prototype[name];
          }
        }

        self_singleton_class.$$const = Object.assign({}, other_singleton_class.$$const);
        Object.setPrototypeOf(
          self_singleton_class.$$prototype,
          Object.getPrototypeOf(other_singleton_class.$$prototype)
        );
      }

      for (i = 0, names = Object.getOwnPropertyNames(other), length = names.length; i < length; i++) {
        name = names[i];
        if (name.charAt(0) === '$' && name.charAt(1) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, $Kernel_copy_singleton_methods$14.$$arity = 1);
    
    Opal.def(self, '$clone', $Kernel_clone$15 = function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, $Kernel_clone$15.$$arity = -1);
    
    Opal.def(self, '$initialize_clone', $Kernel_initialize_clone$16 = function $$initialize_clone(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, $Kernel_initialize_clone$16.$$arity = 1);
    
    Opal.def(self, '$define_singleton_method', $Kernel_define_singleton_method$17 = function $$define_singleton_method(name, method) {
      var $iter = $Kernel_define_singleton_method$17.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_define_singleton_method$17.$$p = null;
      
      
      if ($iter) $Kernel_define_singleton_method$17.$$p = null;;
      ;
      return $send(self.$singleton_class(), 'define_method', [name, method], block.$to_proc());
    }, $Kernel_define_singleton_method$17.$$arity = -2);
    
    Opal.def(self, '$dup', $Kernel_dup$18 = function $$dup() {
      var self = this, copy = nil;

      
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, $Kernel_dup$18.$$arity = 0);
    
    Opal.def(self, '$initialize_dup', $Kernel_initialize_dup$19 = function $$initialize_dup(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, $Kernel_initialize_dup$19.$$arity = 1);
    
    Opal.def(self, '$enum_for', $Kernel_enum_for$20 = function $$enum_for($a, $b) {
      var $iter = $Kernel_enum_for$20.$$p, block = $iter || nil, $post_args, method, args, self = this;

      if ($iter) $Kernel_enum_for$20.$$p = null;
      
      
      if ($iter) $Kernel_enum_for$20.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      if ($post_args.length > 0) {
        method = $post_args[0];
        $post_args.splice(0, 1);
      }
      if (method == null) {
        method = "each";
      };
      
      args = $post_args;;
      return $send($$($nesting, 'Enumerator'), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc());
    }, $Kernel_enum_for$20.$$arity = -1);
    Opal.alias(self, "to_enum", "enum_for");
    
    Opal.def(self, '$equal?', $Kernel_equal$ques$21 = function(other) {
      var self = this;

      return self === other;
    }, $Kernel_equal$ques$21.$$arity = 1);
    
    Opal.def(self, '$exit', $Kernel_exit$22 = function $$exit(status) {
      var $a, self = this, $ret_or_3 = nil, block = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      
      
      if (status == null) {
        status = true;
      };
      $gvars.__at_exit__ = (function() {if ($truthy(($ret_or_3 = $gvars.__at_exit__))) {
        return $ret_or_3
      } else {
        return []
      }; return nil; })();
      while (!($truthy($gvars.__at_exit__['$empty?']()))) {
        
        block = $gvars.__at_exit__.$pop();
        block.$call();
      };
      
      if (status.$$is_boolean) {
        status = status ? 0 : 1;
      } else {
        status = $coerce_to(status, $$($nesting, 'Integer'), 'to_int')
      }

      Opal.exit(status);
    ;
      return nil;
    }, $Kernel_exit$22.$$arity = -1);
    
    Opal.def(self, '$extend', $Kernel_extend$23 = function $$extend($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      var singleton = self.$singleton_class();

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(singleton);
        (mod).$extend_object(self);
        (mod).$extended(self);
      }
    ;
      return self;
    }, $Kernel_extend$23.$$arity = -1);
    
    Opal.def(self, '$hash', $Kernel_hash$24 = function $$hash() {
      var self = this;

      return self.$__id__()
    }, $Kernel_hash$24.$$arity = 0);
    
    Opal.def(self, '$initialize_copy', $Kernel_initialize_copy$25 = function $$initialize_copy(other) {
      var self = this;

      return nil
    }, $Kernel_initialize_copy$25.$$arity = 1);
    
    Opal.def(self, '$inspect', $Kernel_inspect$26 = function $$inspect() {
      var self = this;

      return self.$to_s()
    }, $Kernel_inspect$26.$$arity = 0);
    
    Opal.def(self, '$instance_of?', $Kernel_instance_of$ques$27 = function(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "class or module required");
      }

      return self.$$class === klass;
    
    }, $Kernel_instance_of$ques$27.$$arity = 1);
    
    Opal.def(self, '$instance_variable_defined?', $Kernel_instance_variable_defined$ques$28 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      return Opal.hasOwnProperty.call(self, name.substr(1));;
    }, $Kernel_instance_variable_defined$ques$28.$$arity = 1);
    
    Opal.def(self, '$instance_variable_get', $Kernel_instance_variable_get$29 = function $$instance_variable_get(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      
      var ivar = self[Opal.ivar(name.substr(1))];

      return ivar == null ? nil : ivar;
    ;
    }, $Kernel_instance_variable_get$29.$$arity = 1);
    
    Opal.def(self, '$instance_variable_set', $Kernel_instance_variable_set$30 = function $$instance_variable_set(name, value) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      return self[Opal.ivar(name.substr(1))] = value;;
    }, $Kernel_instance_variable_set$30.$$arity = 2);
    
    Opal.def(self, '$remove_instance_variable', $Kernel_remove_instance_variable$31 = function $$remove_instance_variable(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      
      var key = Opal.ivar(name.substr(1)),
          val;
      if (self.hasOwnProperty(key)) {
        val = self[key];
        delete self[key];
        return val;
      }
    ;
      return self.$raise($$($nesting, 'NameError'), "" + "instance variable " + (name) + " not defined");
    }, $Kernel_remove_instance_variable$31.$$arity = 1);
    
    Opal.def(self, '$instance_variables', $Kernel_instance_variables$32 = function $$instance_variables() {
      var self = this;

      
      var result = [], ivar;

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$') {
          if (name.substr(-1) === '$') {
            ivar = name.slice(0, name.length - 1);
          } else {
            ivar = name;
          }
          result.push('@' + ivar);
        }
      }

      return result;
    
    }, $Kernel_instance_variables$32.$$arity = 0);
    
    Opal.def(self, '$Integer', $Kernel_Integer$33 = function $$Integer(value, base) {
      var self = this;

      
      ;
      
      var i, str, base_digits;

      if (!value.$$is_string) {
        if (base !== undefined) {
          self.$raise($$($nesting, 'ArgumentError'), "base specified for non string value")
        }
        if (value === nil) {
          self.$raise($$($nesting, 'TypeError'), "can't convert nil into Integer")
        }
        if (value.$$is_number) {
          if (value === Infinity || value === -Infinity || isNaN(value)) {
            self.$raise($$($nesting, 'FloatDomainError'), value)
          }
          return Math.floor(value);
        }
        if (value['$respond_to?']("to_int")) {
          i = value.$to_int();
          if (i !== nil) {
            return i;
          }
        }
        return $$($nesting, 'Opal')['$coerce_to!'](value, $$($nesting, 'Integer'), "to_i");
      }

      if (value === "0") {
        return 0;
      }

      if (base === undefined) {
        base = 0;
      } else {
        base = $coerce_to(base, $$($nesting, 'Integer'), 'to_int');
        if (base === 1 || base < 0 || base > 36) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))
        }
      }

      str = value.toLowerCase();

      str = str.replace(/(\d)_(?=\d)/g, '$1');

      str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {
        switch (flag) {
        case '0b':
          if (base === 0 || base === 2) {
            base = 2;
            return head;
          }
        case '0':
        case '0o':
          if (base === 0 || base === 8) {
            base = 8;
            return head;
          }
        case '0d':
          if (base === 0 || base === 10) {
            base = 10;
            return head;
          }
        case '0x':
          if (base === 0 || base === 16) {
            base = 16;
            return head;
          }
        }
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      });

      base = (base === 0 ? 10 : base);

      base_digits = '0-' + (base <= 10 ? base - 1 : '9a-' + String.fromCharCode(97 + (base - 11)));

      if (!(new RegExp('^\\s*[+-]?[' + base_digits + ']+\\s*$')).test(str)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      }

      i = parseInt(str, base);

      if (isNaN(i)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      }

      return i;
    ;
    }, $Kernel_Integer$33.$$arity = -2);
    
    Opal.def(self, '$Float', $Kernel_Float$34 = function $$Float(value) {
      var self = this;

      
      var str;

      if (value === nil) {
        self.$raise($$($nesting, 'TypeError'), "can't convert nil into Float")
      }

      if (value.$$is_string) {
        str = value.toString();

        str = str.replace(/(\d)_(?=\d)/g, '$1');

        //Special case for hex strings only:
        if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
          return self.$Integer(str);
        }

        if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Float(): \"" + (value) + "\"")
        }

        return parseFloat(str);
      }

      return $$($nesting, 'Opal')['$coerce_to!'](value, $$($nesting, 'Float'), "to_f");
    
    }, $Kernel_Float$34.$$arity = 1);
    
    Opal.def(self, '$Hash', $Kernel_Hash$35 = function $$Hash(arg) {
      var self = this, $ret_or_4 = nil;

      
      if ($truthy((function() {if ($truthy(($ret_or_4 = arg['$nil?']()))) {
        return $ret_or_4
      } else {
        return arg['$==']([])
      }; return nil; })())) {
        return $hash2([], {})};
      if ($truthy($$($nesting, 'Hash')['$==='](arg))) {
        return arg};
      return $$($nesting, 'Opal')['$coerce_to!'](arg, $$($nesting, 'Hash'), "to_hash");
    }, $Kernel_Hash$35.$$arity = 1);
    
    Opal.def(self, '$is_a?', $Kernel_is_a$ques$36 = function(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "class or module required");
      }

      return Opal.is_a(self, klass);
    
    }, $Kernel_is_a$ques$36.$$arity = 1);
    
    Opal.def(self, '$itself', $Kernel_itself$37 = function $$itself() {
      var self = this;

      return self
    }, $Kernel_itself$37.$$arity = 0);
    Opal.alias(self, "kind_of?", "is_a?");
    
    Opal.def(self, '$lambda', $Kernel_lambda$38 = function $$lambda() {
      var $iter = $Kernel_lambda$38.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_lambda$38.$$p = null;
      
      
      if ($iter) $Kernel_lambda$38.$$p = null;;
      return Opal.lambda(block);;
    }, $Kernel_lambda$38.$$arity = 0);
    
    Opal.def(self, '$load', $Kernel_load$39 = function $$load(file) {
      var self = this;

      
      file = $$($nesting, 'Opal')['$coerce_to!'](file, $$($nesting, 'String'), "to_str");
      return Opal.load(file);
    }, $Kernel_load$39.$$arity = 1);
    
    Opal.def(self, '$loop', $Kernel_loop$40 = function $$loop() {
      var $$41, $a, $iter = $Kernel_loop$40.$$p, $yield = $iter || nil, self = this, e = nil;

      if ($iter) $Kernel_loop$40.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["loop"], ($$41 = function(){var self = $$41.$$s == null ? this : $$41.$$s;

        return $$$($$($nesting, 'Float'), 'INFINITY')}, $$41.$$s = self, $$41.$$arity = 0, $$41))
      };
      while ($truthy(true)) {
        
        try {
          Opal.yieldX($yield, [])
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'StopIteration')])) {(e = $err)
            try {
              return e.$result()
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };
      };
      return self;
    }, $Kernel_loop$40.$$arity = 0);
    
    Opal.def(self, '$nil?', $Kernel_nil$ques$42 = function() {
      var self = this;

      return false
    }, $Kernel_nil$ques$42.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.def(self, '$printf', $Kernel_printf$43 = function $$printf($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(args['$any?']())) {
        self.$print($send(self, 'format', Opal.to_a(args)))};
      return nil;
    }, $Kernel_printf$43.$$arity = -1);
    
    Opal.def(self, '$proc', $Kernel_proc$44 = function $$proc() {
      var $iter = $Kernel_proc$44.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_proc$44.$$p = null;
      
      
      if ($iter) $Kernel_proc$44.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create Proc object without a block")
      };
      block.$$is_lambda = false;
      return block;
    }, $Kernel_proc$44.$$arity = 0);
    
    Opal.def(self, '$puts', $Kernel_puts$45 = function $$puts($a) {
      var $post_args, strs, self = this;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      strs = $post_args;;
      return $send($gvars.stdout, 'puts', Opal.to_a(strs));
    }, $Kernel_puts$45.$$arity = -1);
    
    Opal.def(self, '$p', $Kernel_p$46 = function $$p($a) {
      var $post_args, args, $$47, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      $send(args, 'each', [], ($$47 = function(obj){var self = $$47.$$s == null ? this : $$47.$$s;
        if ($gvars.stdout == null) $gvars.stdout = nil;

      
        
        if (obj == null) {
          obj = nil;
        };
        return $gvars.stdout.$puts(obj.$inspect());}, $$47.$$s = self, $$47.$$arity = 1, $$47));
      if ($truthy($rb_le(args.$length(), 1))) {
        return args['$[]'](0)
      } else {
        return args
      };
    }, $Kernel_p$46.$$arity = -1);
    
    Opal.def(self, '$print', $Kernel_print$48 = function $$print($a) {
      var $post_args, strs, self = this;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      strs = $post_args;;
      return $send($gvars.stdout, 'print', Opal.to_a(strs));
    }, $Kernel_print$48.$$arity = -1);
    
    Opal.def(self, '$warn', $Kernel_warn$49 = function $$warn($a, $b) {
      var $post_args, $kwargs, strs, uplevel, $$50, self = this, location = nil, $ret_or_5 = nil;
      if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      strs = $post_args;;
      
      uplevel = $kwargs.$$smap["uplevel"];
      if (uplevel == null) {
        uplevel = nil
      };
      if ($truthy(uplevel)) {
        
        uplevel = $$($nesting, 'Opal')['$coerce_to!'](uplevel, $$($nesting, 'Integer'), "to_str");
        if ($truthy($rb_lt(uplevel, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "negative level (" + (uplevel) + ")")};
        location = self.$caller($rb_plus(uplevel, 2), 1).$first();
        if ($truthy(location)) {
          location = "" + (location) + ": "};
        strs = $send(strs, 'map', [], ($$50 = function(s){var self = $$50.$$s == null ? this : $$50.$$s;

        
          
          if (s == null) {
            s = nil;
          };
          return "" + (location) + "warning: " + (s);}, $$50.$$s = self, $$50.$$arity = 1, $$50));};
      if ($truthy((function() {if ($truthy(($ret_or_5 = $gvars.VERBOSE['$nil?']()))) {
        return $ret_or_5
      } else {
        return strs['$empty?']()
      }; return nil; })())) {
        return nil
      } else {
        return $send($gvars.stderr, 'puts', Opal.to_a(strs))
      };
    }, $Kernel_warn$49.$$arity = -1);
    
    Opal.def(self, '$raise', $Kernel_raise$51 = function $$raise(exception, string, _backtrace) {
      var self = this;
      if ($gvars["!"] == null) $gvars["!"] = nil;

      
      ;
      
      if (string == null) {
        string = nil;
      };
      
      if (_backtrace == null) {
        _backtrace = nil;
      };
      
      if (exception == null && $gvars["!"] !== nil) {
        throw $gvars["!"];
      }
      if (exception == null) {
        exception = $$($nesting, 'RuntimeError').$new();
      }
      else if (exception.$$is_string) {
        exception = $$($nesting, 'RuntimeError').$new(exception);
      }
      // using respond_to? and not an undefined check to avoid method_missing matching as true
      else if (exception.$$is_class && exception['$respond_to?']("exception")) {
        exception = exception.$exception(string);
      }
      else if (exception['$is_a?']($$($nesting, 'Exception'))) {
        // exception is fine
      }
      else {
        exception = $$($nesting, 'TypeError').$new("exception class/object expected");
      }

      if ($gvars["!"] !== nil) {
        Opal.exceptions.push($gvars["!"]);
      }

      $gvars["!"] = exception;

      throw exception;
    ;
    }, $Kernel_raise$51.$$arity = -1);
    Opal.alias(self, "fail", "raise");
    
    Opal.def(self, '$rand', $Kernel_rand$52 = function $$rand(max) {
      var self = this;

      
      ;
      
      if (max === undefined) {
        return $$$($$($nesting, 'Random'), 'DEFAULT').$rand();
      }

      if (max.$$is_number) {
        if (max < 0) {
          max = Math.abs(max);
        }

        if (max % 1 !== 0) {
          max = max.$to_i();
        }

        if (max === 0) {
          max = undefined;
        }
      }
    ;
      return $$$($$($nesting, 'Random'), 'DEFAULT').$rand(max);
    }, $Kernel_rand$52.$$arity = -1);
    
    Opal.def(self, '$respond_to?', $Kernel_respond_to$ques$53 = function(name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      
      var body = self['$' + name];

      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }

      if (self['$respond_to_missing?'].$$pristine === true) {
        return false;
      } else {
        return self['$respond_to_missing?'](name, include_all);
      }
    ;
    }, $Kernel_respond_to$ques$53.$$arity = -2);
    
    Opal.def(self, '$respond_to_missing?', $Kernel_respond_to_missing$ques$54 = function(method_name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return false;
    }, $Kernel_respond_to_missing$ques$54.$$arity = -2);
    $$($nesting, 'Opal').$pristine(self, "respond_to?", "respond_to_missing?");
    
    Opal.def(self, '$require', $Kernel_require$55 = function $$require(file) {
      var self = this;

      
      file = $$($nesting, 'Opal')['$coerce_to!'](file, $$($nesting, 'String'), "to_str");
      return Opal.require(file);
    }, $Kernel_require$55.$$arity = 1);
    
    Opal.def(self, '$require_relative', $Kernel_require_relative$56 = function $$require_relative(file) {
      var self = this;

      
      $$($nesting, 'Opal')['$try_convert!'](file, $$($nesting, 'String'), "to_str");
      file = $$($nesting, 'File').$expand_path($$($nesting, 'File').$join(Opal.current_file, "..", file));
      return Opal.require(file);
    }, $Kernel_require_relative$56.$$arity = 1);
    
    Opal.def(self, '$require_tree', $Kernel_require_tree$57 = function $$require_tree(path) {
      var self = this;

      
      var result = [];

      path = $$($nesting, 'File').$expand_path(path)
      path = Opal.normalize(path);
      if (path === '.') path = '';
      for (var name in Opal.modules) {
        if ((name)['$start_with?'](path)) {
          result.push([name, Opal.require(name)]);
        }
      }

      return result;
    
    }, $Kernel_require_tree$57.$$arity = 1);
    Opal.alias(self, "send", "__send__");
    Opal.alias(self, "public_send", "__send__");
    
    Opal.def(self, '$singleton_class', $Kernel_singleton_class$58 = function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    }, $Kernel_singleton_class$58.$$arity = 0);
    
    Opal.def(self, '$sleep', $Kernel_sleep$59 = function $$sleep(seconds) {
      var self = this;

      
      
      if (seconds == null) {
        seconds = nil;
      };
      
      if (seconds === nil) {
        self.$raise($$($nesting, 'TypeError'), "can't convert NilClass into time interval")
      }
      if (!seconds.$$is_number) {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (seconds.$class()) + " into time interval")
      }
      if (seconds < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "time interval must be positive")
      }
      var get_time = Opal.global.performance ?
        function() {return performance.now()} :
        function() {return new Date()}

      var t = get_time();
      while (get_time() - t <= seconds * 1000);
      return Math.round(seconds);
    ;
    }, $Kernel_sleep$59.$$arity = -1);
    
    Opal.def(self, '$srand', $Kernel_srand$60 = function $$srand(seed) {
      var self = this;

      
      
      if (seed == null) {
        seed = $$($nesting, 'Random').$new_seed();
      };
      return $$($nesting, 'Random').$srand(seed);
    }, $Kernel_srand$60.$$arity = -1);
    
    Opal.def(self, '$String', $Kernel_String$61 = function $$String(str) {
      var self = this, $ret_or_6 = nil;

      if ($truthy(($ret_or_6 = $$($nesting, 'Opal')['$coerce_to?'](str, $$($nesting, 'String'), "to_str")))) {
        return $ret_or_6
      } else {
        return $$($nesting, 'Opal')['$coerce_to!'](str, $$($nesting, 'String'), "to_s")
      }
    }, $Kernel_String$61.$$arity = 1);
    
    Opal.def(self, '$tap', $Kernel_tap$62 = function $$tap() {
      var $iter = $Kernel_tap$62.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_tap$62.$$p = null;
      
      
      if ($iter) $Kernel_tap$62.$$p = null;;
      Opal.yield1(block, self);
      return self;
    }, $Kernel_tap$62.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Kernel_to_proc$63 = function $$to_proc() {
      var self = this;

      return self
    }, $Kernel_to_proc$63.$$arity = 0);
    
    Opal.def(self, '$to_s', $Kernel_to_s$64 = function $$to_s() {
      var self = this;

      return "" + "#<" + (self.$class()) + ":0x" + (self.$__id__().$to_s(16)) + ">"
    }, $Kernel_to_s$64.$$arity = 0);
    
    Opal.def(self, '$catch', $Kernel_catch$65 = function(sym) {
      var $iter = $Kernel_catch$65.$$p, $yield = $iter || nil, self = this, e = nil;

      if ($iter) $Kernel_catch$65.$$p = null;
      try {
        return Opal.yieldX($yield, []);
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'UncaughtThrowError')])) {(e = $err)
          try {
            
            if (e.$sym()['$=='](sym)) {
              return e.$arg()};
            return self.$raise();
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Kernel_catch$65.$$arity = 1);
    
    Opal.def(self, '$throw', $Kernel_throw$66 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.$raise($$($nesting, 'UncaughtThrowError'), args);
    }, $Kernel_throw$66.$$arity = -1);
    
    Opal.def(self, '$open', $Kernel_open$67 = function $$open($a) {
      var $iter = $Kernel_open$67.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Kernel_open$67.$$p = null;
      
      
      if ($iter) $Kernel_open$67.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send($$($nesting, 'File'), 'open', Opal.to_a(args), block.$to_proc());
    }, $Kernel_open$67.$$arity = -1);
    
    Opal.def(self, '$yield_self', $Kernel_yield_self$68 = function $$yield_self() {
      var $$69, $iter = $Kernel_yield_self$68.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Kernel_yield_self$68.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["yield_self"], ($$69 = function(){var self = $$69.$$s == null ? this : $$69.$$s;

        return 1}, $$69.$$s = self, $$69.$$arity = 0, $$69))
      };
      return Opal.yield1($yield, self);;
    }, $Kernel_yield_self$68.$$arity = 0);
    Opal.alias(self, "then", "yield_self");
    $$($nesting, 'Opal').$pristine(self, "method_missing");
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting);

    return self.$include($$($nesting, 'Kernel'))
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/error"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $module = Opal.module, $send2 = Opal.send2, $hash2 = Opal.hash2;

  Opal.add_stubs(['$new', '$clone', '$to_s', '$empty?', '$class', '$raise', '$+', '$attr_reader', '$[]', '$>', '$length', '$inspect']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Exception');

    var $nesting = [self].concat($parent_nesting), $Exception_new$1, $Exception_exception$2, $Exception_initialize$3, $Exception_backtrace$4, $Exception_exception$5, $Exception_message$6, $Exception_inspect$7, $Exception_set_backtrace$8, $Exception_to_s$9;

    self.$$prototype.message = nil;
    
    var stack_trace_limit;
    Opal.defs(self, '$new', $Exception_new$1 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var message   = (args.length > 0) ? args[0] : nil;
      var error     = new self.$$constructor(message);
      error.name    = self.$$name;
      error.message = message;
      Opal.send(error, error.$initialize, args);

      // Error.captureStackTrace() will use .name and .toString to build the
      // first line of the stack trace so it must be called after the error
      // has been initialized.
      // https://nodejs.org/dist/latest-v6.x/docs/api/errors.html
      if (Opal.config.enable_stack_trace && Error.captureStackTrace) {
        // Passing Kernel.raise will cut the stack trace from that point above
        Error.captureStackTrace(error, stack_trace_limit);
      }

      return error;
    ;
    }, $Exception_new$1.$$arity = -1);
    stack_trace_limit = self.$new;
    Opal.defs(self, '$exception', $Exception_exception$2 = function $$exception($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self, 'new', Opal.to_a(args));
    }, $Exception_exception$2.$$arity = -1);
    
    Opal.def(self, '$initialize', $Exception_initialize$3 = function $$initialize($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.message = (args.length > 0) ? args[0] : nil;;
    }, $Exception_initialize$3.$$arity = -1);
    
    Opal.def(self, '$backtrace', $Exception_backtrace$4 = function $$backtrace() {
      var self = this;

      
      if (self.backtrace) {
        // nil is a valid backtrace
        return self.backtrace;
      }

      var backtrace = self.stack;

      if (typeof(backtrace) === 'string') {
        return backtrace.split("\n").slice(0, 15);
      }
      else if (backtrace) {
        return backtrace.slice(0, 15);
      }

      return [];
    
    }, $Exception_backtrace$4.$$arity = 0);
    
    Opal.def(self, '$exception', $Exception_exception$5 = function $$exception(str) {
      var self = this;

      
      
      if (str == null) {
        str = nil;
      };
      
      if (str === nil || self === str) {
        return self;
      }

      var cloned = self.$clone();
      cloned.message = str;
      cloned.stack = self.stack;
      return cloned;
    ;
    }, $Exception_exception$5.$$arity = -1);
    
    Opal.def(self, '$message', $Exception_message$6 = function $$message() {
      var self = this;

      return self.$to_s()
    }, $Exception_message$6.$$arity = 0);
    
    Opal.def(self, '$inspect', $Exception_inspect$7 = function $$inspect() {
      var self = this, as_str = nil;

      
      as_str = self.$to_s();
      if ($truthy(as_str['$empty?']())) {
        return self.$class().$to_s()
      } else {
        return "" + "#<" + (self.$class().$to_s()) + ": " + (self.$to_s()) + ">"
      };
    }, $Exception_inspect$7.$$arity = 0);
    
    Opal.def(self, '$set_backtrace', $Exception_set_backtrace$8 = function $$set_backtrace(backtrace) {
      var self = this;

      
      var valid = true, i, ii;

      if (backtrace === nil) {
        self.backtrace = nil;
        self.stack = '';
      } else if (backtrace.$$is_string) {
        self.backtrace = [backtrace];
        self.stack = backtrace;
      } else {
        if (backtrace.$$is_array) {
          for (i = 0, ii = backtrace.length; i < ii; i++) {
            if (!backtrace[i].$$is_string) {
              valid = false;
              break;
            }
          }
        } else {
          valid = false;
        }

        if (valid === false) {
          self.$raise($$($nesting, 'TypeError'), "backtrace must be Array of String")
        }

        self.backtrace = backtrace;
        self.stack = backtrace.join('\n');
      }

      return backtrace;
    
    }, $Exception_set_backtrace$8.$$arity = 1);
    return (Opal.def(self, '$to_s', $Exception_to_s$9 = function $$to_s() {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($truthy(($ret_or_1 = (function() {if ($truthy(($ret_or_2 = self.message))) {
        return self.message.$to_s()
      } else {
        return $ret_or_2
      }; return nil; })()))) {
        return $ret_or_1
      } else {
        return self.$class().$to_s()
      }
    }, $Exception_to_s$9.$$arity = 0), nil) && 'to_s';
  })($nesting[0], Error, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ScriptError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SyntaxError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'LoadError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NotImplementedError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemExit');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMemoryError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SignalException');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Interrupt');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SecurityError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StandardError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'EncodingError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ZeroDivisionError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NameError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMethodError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'NameError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RuntimeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'FrozenError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'RuntimeError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'LocalJumpError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'TypeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ArgumentError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IndexError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StopIteration');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'IndexError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'KeyError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'IndexError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RangeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'FloatDomainError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'RangeError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IOError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemCallError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Errno');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'EINVAL');

      var $nesting = [self].concat($parent_nesting), $EINVAL_new$10;

      return (Opal.defs(self, '$new', $EINVAL_new$10 = function(name) {
        var $iter = $EINVAL_new$10.$$p, $yield = $iter || nil, self = this, message = nil;

        if ($iter) $EINVAL_new$10.$$p = null;
        
        
        if (name == null) {
          name = nil;
        };
        message = "Invalid argument";
        if ($truthy(name)) {
          message = $rb_plus(message, "" + " - " + (name))};
        return $send2(self, Opal.find_super_dispatcher(self, 'new', $EINVAL_new$10, false, true), 'new', [message], null);
      }, $EINVAL_new$10.$$arity = -1), nil) && 'new'
    })($nesting[0], $$($nesting, 'SystemCallError'), $nesting)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'UncaughtThrowError');

    var $nesting = [self].concat($parent_nesting), $UncaughtThrowError_initialize$11;

    self.$$prototype.sym = nil;
    
    self.$attr_reader("sym", "arg");
    return (Opal.def(self, '$initialize', $UncaughtThrowError_initialize$11 = function $$initialize(args) {
      var $iter = $UncaughtThrowError_initialize$11.$$p, $yield = $iter || nil, self = this;

      if ($iter) $UncaughtThrowError_initialize$11.$$p = null;
      
      self.sym = args['$[]'](0);
      if ($truthy($rb_gt(args.$length(), 1))) {
        self.arg = args['$[]'](1)};
      return $send2(self, Opal.find_super_dispatcher(self, 'initialize', $UncaughtThrowError_initialize$11, false, true), 'initialize', ["" + "uncaught throw " + (self.sym.$inspect())], null);
    }, $UncaughtThrowError_initialize$11.$$arity = 1), nil) && 'initialize';
  })($nesting[0], $$($nesting, 'ArgumentError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NameError');

    var $nesting = [self].concat($parent_nesting), $NameError_initialize$12;

    
    self.$attr_reader("name");
    return (Opal.def(self, '$initialize', $NameError_initialize$12 = function $$initialize(message, name) {
      var $iter = $NameError_initialize$12.$$p, $yield = $iter || nil, self = this;

      if ($iter) $NameError_initialize$12.$$p = null;
      
      
      if (name == null) {
        name = nil;
      };
      $send2(self, Opal.find_super_dispatcher(self, 'initialize', $NameError_initialize$12, false, true), 'initialize', [message], null);
      return (self.name = name);
    }, $NameError_initialize$12.$$arity = -2), nil) && 'initialize';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMethodError');

    var $nesting = [self].concat($parent_nesting), $NoMethodError_initialize$13;

    
    self.$attr_reader("args");
    return (Opal.def(self, '$initialize', $NoMethodError_initialize$13 = function $$initialize(message, name, args) {
      var $iter = $NoMethodError_initialize$13.$$p, $yield = $iter || nil, self = this;

      if ($iter) $NoMethodError_initialize$13.$$p = null;
      
      
      if (name == null) {
        name = nil;
      };
      
      if (args == null) {
        args = [];
      };
      $send2(self, Opal.find_super_dispatcher(self, 'initialize', $NoMethodError_initialize$13, false, true), 'initialize', [message, name], null);
      return (self.args = args);
    }, $NoMethodError_initialize$13.$$arity = -2), nil) && 'initialize';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StopIteration');

    var $nesting = [self].concat($parent_nesting);

    return self.$attr_reader("result")
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'KeyError');

    var $nesting = [self].concat($parent_nesting), $KeyError_initialize$14, $KeyError_receiver$15, $KeyError_key$16;

    self.$$prototype.receiver = self.$$prototype.key = nil;
    
    
    Opal.def(self, '$initialize', $KeyError_initialize$14 = function $$initialize(message, $kwargs) {
      var receiver, key, $iter = $KeyError_initialize$14.$$p, $yield = $iter || nil, self = this;

      if ($iter) $KeyError_initialize$14.$$p = null;
      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      receiver = $kwargs.$$smap["receiver"];
      if (receiver == null) {
        receiver = nil
      };
      
      key = $kwargs.$$smap["key"];
      if (key == null) {
        key = nil
      };
      $send2(self, Opal.find_super_dispatcher(self, 'initialize', $KeyError_initialize$14, false, true), 'initialize', [message], null);
      self.receiver = receiver;
      return (self.key = key);
    }, $KeyError_initialize$14.$$arity = -2);
    
    Opal.def(self, '$receiver', $KeyError_receiver$15 = function $$receiver() {
      var self = this, $ret_or_3 = nil;

      if ($truthy(($ret_or_3 = self.receiver))) {
        return $ret_or_3
      } else {
        return self.$raise($$($nesting, 'ArgumentError'), "no receiver is available")
      }
    }, $KeyError_receiver$15.$$arity = 0);
    return (Opal.def(self, '$key', $KeyError_key$16 = function $$key() {
      var self = this, $ret_or_4 = nil;

      if ($truthy(($ret_or_4 = self.key))) {
        return $ret_or_4
      } else {
        return self.$raise($$($nesting, 'ArgumentError'), "no key is available")
      }
    }, $KeyError_key$16.$$arity = 0), nil) && 'key';
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'JS');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Error');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/constants"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  
  Opal.const_set($nesting[0], 'RUBY_PLATFORM', "opal");
  Opal.const_set($nesting[0], 'RUBY_ENGINE', "opal");
  Opal.const_set($nesting[0], 'RUBY_VERSION', "3.0.0");
  Opal.const_set($nesting[0], 'RUBY_ENGINE_VERSION', "1.1.1");
  Opal.const_set($nesting[0], 'RUBY_RELEASE_DATE', "2021-02-23");
  Opal.const_set($nesting[0], 'RUBY_PATCHLEVEL', 0);
  Opal.const_set($nesting[0], 'RUBY_REVISION', "0");
  Opal.const_set($nesting[0], 'RUBY_COPYRIGHT', "opal - Copyright (C) 2013-2021 Adam Beynon and the Opal contributors");
  return Opal.const_set($nesting[0], 'RUBY_DESCRIPTION', "" + "opal " + ($$($nesting, 'RUBY_ENGINE_VERSION')) + " (" + ($$($nesting, 'RUBY_RELEASE_DATE')) + " revision " + ($$($nesting, 'RUBY_REVISION')) + ")");
};

/* Generated by Opal 1.1.1 */
Opal.modules["opal/base"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$require']);
  
  self.$require("corelib/runtime");
  self.$require("corelib/helpers");
  self.$require("corelib/module");
  self.$require("corelib/class");
  self.$require("corelib/basic_object");
  self.$require("corelib/kernel");
  self.$require("corelib/error");
  return self.$require("corelib/constants");
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/nil"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$name', '$new', '$>', '$length', '$Rational']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting), $NilClass_$excl$2, $NilClass_$$3, $NilClass_$$4, $NilClass_$$5, $NilClass_$eq_eq$6, $NilClass_dup$7, $NilClass_clone$8, $NilClass_inspect$9, $NilClass_nil$ques$10, $NilClass_singleton_class$11, $NilClass_to_a$12, $NilClass_to_h$13, $NilClass_to_i$14, $NilClass_to_s$15, $NilClass_to_c$16, $NilClass_rationalize$17, $NilClass_to_r$18, $NilClass_instance_variables$19;

    
    self.$$prototype.$$meta = self;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$!', $NilClass_$excl$2 = function() {
      var self = this;

      return true
    }, $NilClass_$excl$2.$$arity = 0);
    
    Opal.def(self, '$&', $NilClass_$$3 = function(other) {
      var self = this;

      return false
    }, $NilClass_$$3.$$arity = 1);
    
    Opal.def(self, '$|', $NilClass_$$4 = function(other) {
      var self = this;

      return other !== false && other !== nil;
    }, $NilClass_$$4.$$arity = 1);
    
    Opal.def(self, '$^', $NilClass_$$5 = function(other) {
      var self = this;

      return other !== false && other !== nil;
    }, $NilClass_$$5.$$arity = 1);
    
    Opal.def(self, '$==', $NilClass_$eq_eq$6 = function(other) {
      var self = this;

      return other === nil;
    }, $NilClass_$eq_eq$6.$$arity = 1);
    
    Opal.def(self, '$dup', $NilClass_dup$7 = function $$dup() {
      var self = this;

      return nil
    }, $NilClass_dup$7.$$arity = 0);
    
    Opal.def(self, '$clone', $NilClass_clone$8 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return nil;
    }, $NilClass_clone$8.$$arity = -1);
    
    Opal.def(self, '$inspect', $NilClass_inspect$9 = function $$inspect() {
      var self = this;

      return "nil"
    }, $NilClass_inspect$9.$$arity = 0);
    
    Opal.def(self, '$nil?', $NilClass_nil$ques$10 = function() {
      var self = this;

      return true
    }, $NilClass_nil$ques$10.$$arity = 0);
    
    Opal.def(self, '$singleton_class', $NilClass_singleton_class$11 = function $$singleton_class() {
      var self = this;

      return $$($nesting, 'NilClass')
    }, $NilClass_singleton_class$11.$$arity = 0);
    
    Opal.def(self, '$to_a', $NilClass_to_a$12 = function $$to_a() {
      var self = this;

      return []
    }, $NilClass_to_a$12.$$arity = 0);
    
    Opal.def(self, '$to_h', $NilClass_to_h$13 = function $$to_h() {
      var self = this;

      return Opal.hash();
    }, $NilClass_to_h$13.$$arity = 0);
    
    Opal.def(self, '$to_i', $NilClass_to_i$14 = function $$to_i() {
      var self = this;

      return 0
    }, $NilClass_to_i$14.$$arity = 0);
    Opal.alias(self, "to_f", "to_i");
    
    Opal.def(self, '$to_s', $NilClass_to_s$15 = function $$to_s() {
      var self = this;

      return ""
    }, $NilClass_to_s$15.$$arity = 0);
    
    Opal.def(self, '$to_c', $NilClass_to_c$16 = function $$to_c() {
      var self = this;

      return $$($nesting, 'Complex').$new(0, 0)
    }, $NilClass_to_c$16.$$arity = 0);
    
    Opal.def(self, '$rationalize', $NilClass_rationalize$17 = function $$rationalize($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy($rb_gt(args.$length(), 1))) {
        self.$raise($$($nesting, 'ArgumentError'))};
      return self.$Rational(0, 1);
    }, $NilClass_rationalize$17.$$arity = -1);
    
    Opal.def(self, '$to_r', $NilClass_to_r$18 = function $$to_r() {
      var self = this;

      return self.$Rational(0, 1)
    }, $NilClass_to_r$18.$$arity = 0);
    return (Opal.def(self, '$instance_variables', $NilClass_instance_variables$19 = function $$instance_variables() {
      var self = this;

      return []
    }, $NilClass_instance_variables$19.$$arity = 0), nil) && 'instance_variables';
  })($nesting[0], null, $nesting);
  return Opal.const_set($nesting[0], 'NIL', nil);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/boolean"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2;

  Opal.add_stubs(['$raise', '$name']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting), $Boolean___id__$2, $Boolean_$excl$3, $Boolean_$$4, $Boolean_$$5, $Boolean_$$6, $Boolean_$eq_eq$7, $Boolean_singleton_class$8, $Boolean_to_s$9, $Boolean_dup$10, $Boolean_clone$11;

    
    Opal.defineProperty(self.$$prototype, '$$is_boolean', true);
    Opal.defineProperty(self.$$prototype, '$$meta', self);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$__id__', $Boolean___id__$2 = function $$__id__() {
      var self = this;

      return self.valueOf() ? 2 : 0;
    }, $Boolean___id__$2.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.def(self, '$!', $Boolean_$excl$3 = function() {
      var self = this;

      return self != true;
    }, $Boolean_$excl$3.$$arity = 0);
    
    Opal.def(self, '$&', $Boolean_$$4 = function(other) {
      var self = this;

      return (self == true) ? (other !== false && other !== nil) : false;
    }, $Boolean_$$4.$$arity = 1);
    
    Opal.def(self, '$|', $Boolean_$$5 = function(other) {
      var self = this;

      return (self == true) ? true : (other !== false && other !== nil);
    }, $Boolean_$$5.$$arity = 1);
    
    Opal.def(self, '$^', $Boolean_$$6 = function(other) {
      var self = this;

      return (self == true) ? (other === false || other === nil) : (other !== false && other !== nil);
    }, $Boolean_$$6.$$arity = 1);
    
    Opal.def(self, '$==', $Boolean_$eq_eq$7 = function(other) {
      var self = this;

      return (self == true) === other.valueOf();
    }, $Boolean_$eq_eq$7.$$arity = 1);
    Opal.alias(self, "equal?", "==");
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$singleton_class', $Boolean_singleton_class$8 = function $$singleton_class() {
      var self = this;

      return $$($nesting, 'Boolean')
    }, $Boolean_singleton_class$8.$$arity = 0);
    
    Opal.def(self, '$to_s', $Boolean_to_s$9 = function $$to_s() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, $Boolean_to_s$9.$$arity = 0);
    
    Opal.def(self, '$dup', $Boolean_dup$10 = function $$dup() {
      var self = this;

      return self
    }, $Boolean_dup$10.$$arity = 0);
    return (Opal.def(self, '$clone', $Boolean_clone$11 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return self;
    }, $Boolean_clone$11.$$arity = -1), nil) && 'clone';
  })($nesting[0], Boolean, $nesting);
  Opal.const_set($nesting[0], 'TrueClass', $$($nesting, 'Boolean'));
  Opal.const_set($nesting[0], 'FalseClass', $$($nesting, 'Boolean'));
  Opal.const_set($nesting[0], 'TRUE', true);
  return Opal.const_set($nesting[0], 'FALSE', false);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/comparable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $falsy = Opal.falsy, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$>', '$<', '$===', '$raise', '$class', '$<=>', '$equal?']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Comparable');

    var $nesting = [self].concat($parent_nesting), $Comparable_$eq_eq$1, $Comparable_$gt$2, $Comparable_$gt_eq$3, $Comparable_$lt$4, $Comparable_$lt_eq$5, $Comparable_between$ques$6, $Comparable_clamp$7, $case = nil;

    
    
    function normalize(what) {
      if (Opal.is_a(what, Opal.Integer)) { return what; }

      if ($rb_gt(what, 0)) { return 1; }
      if ($rb_lt(what, 0)) { return -1; }
      return 0;
    }

    function fail_comparison(lhs, rhs) {
      var class_name;
      (function() {$case = rhs;
    if (nil['$===']($case) || true['$===']($case) || false['$===']($case) || $$($nesting, 'Integer')['$===']($case) || $$($nesting, 'Float')['$===']($case)) {return class_name = rhs.$inspect();}
    else {return class_name = rhs.$$class;}})()
      self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + ((lhs).$class()) + " with " + (class_name) + " failed")
    }

    function cmp_or_fail(lhs, rhs) {
      var cmp = (lhs)['$<=>'](rhs);
      if ($falsy(cmp)) fail_comparison(lhs, rhs);
      return normalize(cmp);
    }
  ;
    
    Opal.def(self, '$==', $Comparable_$eq_eq$1 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy(self['$equal?'](other))) {
        return true};
      
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        delete self.$$comparable;
        return false;
      }
    ;
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        return false
      };
      return normalize(cmp) == 0;;
    }, $Comparable_$eq_eq$1.$$arity = 1);
    
    Opal.def(self, '$>', $Comparable_$gt$2 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) > 0;
    }, $Comparable_$gt$2.$$arity = 1);
    
    Opal.def(self, '$>=', $Comparable_$gt_eq$3 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) >= 0;
    }, $Comparable_$gt_eq$3.$$arity = 1);
    
    Opal.def(self, '$<', $Comparable_$lt$4 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) < 0;
    }, $Comparable_$lt$4.$$arity = 1);
    
    Opal.def(self, '$<=', $Comparable_$lt_eq$5 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) <= 0;
    }, $Comparable_$lt_eq$5.$$arity = 1);
    
    Opal.def(self, '$between?', $Comparable_between$ques$6 = function(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false};
      if ($rb_gt(self, max)) {
        return false};
      return true;
    }, $Comparable_between$ques$6.$$arity = 2);
    
    Opal.def(self, '$clamp', $Comparable_clamp$7 = function $$clamp(min, max) {
      var self = this;

      
      
      if (max == null) {
        max = nil;
      };
      
      var c, excl;

      if (max === nil) {
        // We are dealing with a new Ruby 2.7 behaviour that we are able to
        // provide a single Range argument instead of 2 Comparables.

        if (!Opal.is_a(min, Opal.Range)) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (min.$class()) + " (expected Range)")
        }

        excl = min.excl;
        max = min.end;
        min = min.begin;

        if (max !== nil && excl) {
          self.$raise($$($nesting, 'ArgumentError'), "cannot clamp with an exclusive range")
        }
      }

      if (min !== nil && max !== nil && cmp_or_fail(min, max) > 0) {
        self.$raise($$($nesting, 'ArgumentError'), "min argument must be smaller than max argument")
      }

      if (min !== nil) {
        c = cmp_or_fail(self, min);

        if (c == 0) return self;
        if (c < 0) return min;
      }

      if (max !== nil) {
        c = cmp_or_fail(self, max);

        if (c > 0) return max;
      }

      return self;
    ;
    }, $Comparable_clamp$7.$$arity = -2);
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/regexp"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $send2 = Opal.send2, $truthy = Opal.truthy, $gvars = Opal.gvars, $send = Opal.send;

  Opal.add_stubs(['$nil?', '$[]', '$raise', '$escape', '$options', '$to_str', '$new', '$join', '$coerce_to!', '$!', '$match', '$coerce_to?', '$begin', '$=~', '$attr_reader', '$===', '$inspect', '$to_a']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RegexpError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Regexp');

    var $nesting = [self].concat($parent_nesting), $Regexp_$eq_eq$6, $Regexp_$eq_eq_eq$7, $Regexp_$eq_tilde$8, $Regexp_inspect$9, $Regexp_match$10, $Regexp_match$ques$11, $Regexp_$$12, $Regexp_source$13, $Regexp_options$14, $Regexp_casefold$ques$15;

    
    Opal.const_set($nesting[0], 'IGNORECASE', 1);
    Opal.const_set($nesting[0], 'EXTENDED', 2);
    Opal.const_set($nesting[0], 'MULTILINE', 4);
    Opal.defineProperty(self.$$prototype, '$$is_regexp', true);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1, $escape$2, $last_match$3, $union$4, $new$5;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var $iter = $allocate$1.$$p, $yield = $iter || nil, self = this, allocated = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $allocate$1.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        allocated = $send2(self, Opal.find_super_dispatcher(self, 'allocate', $allocate$1, false, true), 'allocate', $zuper, $iter);
        allocated.uninitialized = true;
        return allocated;
      }, $allocate$1.$$arity = 0);
      
      Opal.def(self, '$escape', $escape$2 = function $$escape(string) {
        var self = this;

        return Opal.escape_regexp(string);
      }, $escape$2.$$arity = 1);
      
      Opal.def(self, '$last_match', $last_match$3 = function $$last_match(n) {
        var self = this;
        if ($gvars["~"] == null) $gvars["~"] = nil;

        
        
        if (n == null) {
          n = nil;
        };
        if ($truthy(n['$nil?']())) {
          return $gvars["~"]
        } else {
          return $gvars["~"]['$[]'](n)
        };
      }, $last_match$3.$$arity = -1);
      Opal.alias(self, "quote", "escape");
      
      Opal.def(self, '$union', $union$4 = function $$union($a) {
        var $post_args, parts, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        parts = $post_args;;
        
        var is_first_part_array, quoted_validated, part, options, each_part_options;
        if (parts.length == 0) {
          return /(?!)/;
        }
        // return fast if there's only one element
        if (parts.length == 1 && parts[0].$$is_regexp) {
          return parts[0];
        }
        // cover the 2 arrays passed as arguments case
        is_first_part_array = parts[0].$$is_array;
        if (parts.length > 1 && is_first_part_array) {
          self.$raise($$($nesting, 'TypeError'), "no implicit conversion of Array into String")
        }
        // deal with splat issues (related to https://github.com/opal/opal/issues/858)
        if (is_first_part_array) {
          parts = parts[0];
        }
        options = undefined;
        quoted_validated = [];
        for (var i=0; i < parts.length; i++) {
          part = parts[i];
          if (part.$$is_string) {
            quoted_validated.push(self.$escape(part));
          }
          else if (part.$$is_regexp) {
            each_part_options = (part).$options();
            if (options != undefined && options != each_part_options) {
              self.$raise($$($nesting, 'TypeError'), "All expressions must use the same options")
            }
            options = each_part_options;
            quoted_validated.push('('+part.source+')');
          }
          else {
            quoted_validated.push(self.$escape((part).$to_str()));
          }
        }
      ;
        return self.$new((quoted_validated).$join("|"), options);
      }, $union$4.$$arity = -1);
      
      Opal.def(self, '$new', $new$5 = function(regexp, options) {
        var self = this;

        
        ;
        
        if (regexp.$$is_regexp) {
          return new RegExp(regexp);
        }

        regexp = $$($nesting, 'Opal')['$coerce_to!'](regexp, $$($nesting, 'String'), "to_str");

        if (regexp.charAt(regexp.length - 1) === '\\' && regexp.charAt(regexp.length - 2) !== '\\') {
          self.$raise($$($nesting, 'RegexpError'), "" + "too short escape sequence: /" + (regexp) + "/")
        }

        if (options === undefined || options['$!']()) {
          return new RegExp(regexp);
        }

        if (options.$$is_number) {
          var temp = '';
          if ($$($nesting, 'IGNORECASE') & options) { temp += 'i'; }
          if ($$($nesting, 'MULTILINE')  & options) { temp += 'm'; }
          options = temp;
        }
        else {
          options = 'i';
        }

        return new RegExp(regexp, options);
      ;
      }, $new$5.$$arity = -2);
      return Opal.alias(self, "compile", "new");
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$==', $Regexp_$eq_eq$6 = function(other) {
      var self = this;

      return other instanceof RegExp && self.toString() === other.toString();
    }, $Regexp_$eq_eq$6.$$arity = 1);
    
    Opal.def(self, '$===', $Regexp_$eq_eq_eq$7 = function(string) {
      var self = this;

      return self.$match($$($nesting, 'Opal')['$coerce_to?'](string, $$($nesting, 'String'), "to_str")) !== nil
    }, $Regexp_$eq_eq_eq$7.$$arity = 1);
    
    Opal.def(self, '$=~', $Regexp_$eq_tilde$8 = function(string) {
      var self = this, $ret_or_1 = nil;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($truthy(($ret_or_1 = self.$match(string)))) {
        return $gvars["~"].$begin(0)
      } else {
        return $ret_or_1
      }
    }, $Regexp_$eq_tilde$8.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$inspect', $Regexp_inspect$9 = function $$inspect() {
      var self = this;

      
      var regexp_format = /^\/(.*)\/([^\/]*)$/;
      var value = self.toString();
      var matches = regexp_format.exec(value);
      if (matches) {
        var regexp_pattern = matches[1];
        var regexp_flags = matches[2];
        var chars = regexp_pattern.split('');
        var chars_length = chars.length;
        var char_escaped = false;
        var regexp_pattern_escaped = '';
        for (var i = 0; i < chars_length; i++) {
          var current_char = chars[i];
          if (!char_escaped && current_char == '/') {
            regexp_pattern_escaped = regexp_pattern_escaped.concat('\\');
          }
          regexp_pattern_escaped = regexp_pattern_escaped.concat(current_char);
          if (current_char == '\\') {
            if (char_escaped) {
              // does not over escape
              char_escaped = false;
            } else {
              char_escaped = true;
            }
          } else {
            char_escaped = false;
          }
        }
        return '/' + regexp_pattern_escaped + '/' + regexp_flags;
      } else {
        return value;
      }
    
    }, $Regexp_inspect$9.$$arity = 0);
    
    Opal.def(self, '$match', $Regexp_match$10 = function $$match(string, pos) {
      var $iter = $Regexp_match$10.$$p, block = $iter || nil, self = this;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($iter) $Regexp_match$10.$$p = null;
      
      
      if ($iter) $Regexp_match$10.$$p = null;;
      ;
      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        if (string === nil) return ($gvars["~"] = nil);
        var m = self.exec($coerce_to(string, $$($nesting, 'String'), 'to_str'));
        if (m) {
          ($gvars["~"] = $$($nesting, 'MatchData').$new(self, m));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        } else {
          return ($gvars["~"] = nil);
        }
      }

      pos = $coerce_to(pos, $$($nesting, 'Integer'), 'to_int');

      if (string === nil) {
        return ($gvars["~"] = nil);
      }

      string = $coerce_to(string, $$($nesting, 'String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return ($gvars["~"] = nil);
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      while (true) {
        md = re.exec(string);
        if (md === null) {
          return ($gvars["~"] = nil);
        }
        if (md.index >= pos) {
          ($gvars["~"] = $$($nesting, 'MatchData').$new(re, md));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        }
        re.lastIndex = md.index + 1;
      }
    ;
    }, $Regexp_match$10.$$arity = -2);
    
    Opal.def(self, '$match?', $Regexp_match$ques$11 = function(string, pos) {
      var self = this;

      
      ;
      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        return string === nil ? false : self.test($coerce_to(string, $$($nesting, 'String'), 'to_str'));
      }

      pos = $coerce_to(pos, $$($nesting, 'Integer'), 'to_int');

      if (string === nil) {
        return false;
      }

      string = $coerce_to(string, $$($nesting, 'String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return false;
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      md = re.exec(string);
      if (md === null || md.index < pos) {
        return false;
      } else {
        return true;
      }
    ;
    }, $Regexp_match$ques$11.$$arity = -2);
    
    Opal.def(self, '$~', $Regexp_$$12 = function() {
      var self = this;
      if ($gvars._ == null) $gvars._ = nil;

      return self['$=~']($gvars._)
    }, $Regexp_$$12.$$arity = 0);
    
    Opal.def(self, '$source', $Regexp_source$13 = function $$source() {
      var self = this;

      return self.source;
    }, $Regexp_source$13.$$arity = 0);
    
    Opal.def(self, '$options', $Regexp_options$14 = function $$options() {
      var self = this;

      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }
      var result = 0;
      // should be supported in IE6 according to https://msdn.microsoft.com/en-us/library/7f5z26w4(v=vs.94).aspx
      if (self.multiline) {
        result |= $$($nesting, 'MULTILINE');
      }
      if (self.ignoreCase) {
        result |= $$($nesting, 'IGNORECASE');
      }
      return result;
    
    }, $Regexp_options$14.$$arity = 0);
    
    Opal.def(self, '$casefold?', $Regexp_casefold$ques$15 = function() {
      var self = this;

      return self.ignoreCase;
    }, $Regexp_casefold$ques$15.$$arity = 0);
    return Opal.alias(self, "to_s", "source");
  })($nesting[0], RegExp, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $MatchData_initialize$16, $MatchData_$$$17, $MatchData_offset$18, $MatchData_$eq_eq$19, $MatchData_begin$20, $MatchData_end$21, $MatchData_captures$22, $MatchData_inspect$23, $MatchData_length$24, $MatchData_to_a$25, $MatchData_to_s$26, $MatchData_values_at$27;

    self.$$prototype.matches = nil;
    
    self.$attr_reader("post_match", "pre_match", "regexp", "string");
    
    Opal.def(self, '$initialize', $MatchData_initialize$16 = function $$initialize(regexp, match_groups) {
      var self = this;

      
      $gvars["~"] = self;
      self.regexp = regexp;
      self.begin = match_groups.index;
      self.string = match_groups.input;
      self.pre_match = match_groups.input.slice(0, match_groups.index);
      self.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);
      self.matches = [];
      
      for (var i = 0, length = match_groups.length; i < length; i++) {
        var group = match_groups[i];

        if (group == null) {
          self.matches.push(nil);
        }
        else {
          self.matches.push(group);
        }
      }
    ;
    }, $MatchData_initialize$16.$$arity = 2);
    
    Opal.def(self, '$[]', $MatchData_$$$17 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self.matches, '[]', Opal.to_a(args));
    }, $MatchData_$$$17.$$arity = -1);
    
    Opal.def(self, '$offset', $MatchData_offset$18 = function $$offset(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#offset only supports 0th element")
      }
      return [self.begin, self.begin + self.matches[n].length];
    
    }, $MatchData_offset$18.$$arity = 1);
    
    Opal.def(self, '$==', $MatchData_$eq_eq$19 = function(other) {
      var self = this, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil, $ret_or_5 = nil;

      
      if ($truthy($$($nesting, 'MatchData')['$==='](other))) {
      } else {
        return false
      };
      if ($truthy(($ret_or_2 = (function() {if ($truthy(($ret_or_3 = (function() {if ($truthy(($ret_or_4 = (function() {if ($truthy(($ret_or_5 = self.string == other.string))) {
        return self.regexp.toString() == other.regexp.toString();
      } else {
        return $ret_or_5
      }; return nil; })()))) {
        return self.pre_match == other.pre_match;
      } else {
        return $ret_or_4
      }; return nil; })()))) {
        return self.post_match == other.post_match;
      } else {
        return $ret_or_3
      }; return nil; })()))) {
        return self.begin == other.begin;
      } else {
        return $ret_or_2
      };
    }, $MatchData_$eq_eq$19.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$begin', $MatchData_begin$20 = function $$begin(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#begin only supports 0th element")
      }
      return self.begin;
    
    }, $MatchData_begin$20.$$arity = 1);
    
    Opal.def(self, '$end', $MatchData_end$21 = function $$end(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#end only supports 0th element")
      }
      return self.begin + self.matches[n].length;
    
    }, $MatchData_end$21.$$arity = 1);
    
    Opal.def(self, '$captures', $MatchData_captures$22 = function $$captures() {
      var self = this;

      return self.matches.slice(1)
    }, $MatchData_captures$22.$$arity = 0);
    
    Opal.def(self, '$inspect', $MatchData_inspect$23 = function $$inspect() {
      var self = this;

      
      var str = "#<MatchData " + (self.matches[0]).$inspect();

      for (var i = 1, length = self.matches.length; i < length; i++) {
        str += " " + i + ":" + (self.matches[i]).$inspect();
      }

      return str + ">";
    
    }, $MatchData_inspect$23.$$arity = 0);
    
    Opal.def(self, '$length', $MatchData_length$24 = function $$length() {
      var self = this;

      return self.matches.length
    }, $MatchData_length$24.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$to_a', $MatchData_to_a$25 = function $$to_a() {
      var self = this;

      return self.matches
    }, $MatchData_to_a$25.$$arity = 0);
    
    Opal.def(self, '$to_s', $MatchData_to_s$26 = function $$to_s() {
      var self = this;

      return self.matches[0]
    }, $MatchData_to_s$26.$$arity = 0);
    return (Opal.def(self, '$values_at', $MatchData_values_at$27 = function $$values_at($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var i, a, index, values = [];

      for (i = 0; i < args.length; i++) {

        if (args[i].$$is_range) {
          a = (args[i]).$to_a();
          a.unshift(i, 1);
          Array.prototype.splice.apply(args, a);
        }

        index = $$($nesting, 'Opal')['$coerce_to!'](args[i], $$($nesting, 'Integer'), "to_int");

        if (index < 0) {
          index += self.matches.length;
          if (index < 0) {
            values.push(nil);
            continue;
          }
        }

        values.push(self.matches[index]);
      }

      return values;
    ;
    }, $MatchData_values_at$27.$$arity = -1), nil) && 'values_at';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/string"] = function(Opal) {
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars;

  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$raise', '$===', '$format', '$to_s', '$respond_to?', '$to_str', '$<=>', '$==', '$=~', '$new', '$force_encoding', '$casecmp', '$empty?', '$ljust', '$ceil', '$/', '$+', '$rjust', '$floor', '$to_a', '$each_char', '$to_proc', '$coerce_to!', '$copy_singleton_methods', '$initialize_clone', '$initialize_dup', '$enum_for', '$size', '$chomp', '$[]', '$to_i', '$each_line', '$encoding', '$class', '$match', '$match?', '$captures', '$proc', '$succ', '$escape', '$include?', '$upcase', '$unicode_normalize']);
  
  self.$require("corelib/comparable");
  self.$require("corelib/regexp");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String___id__$1, $String_try_convert$2, $String_new$3, $String_initialize$4, $String_$percent$5, $String_$$6, $String_$plus$7, $String_$lt_eq_gt$8, $String_$eq_eq$9, $String_$eq_tilde$10, $String_$$$11, $String_b$12, $String_capitalize$13, $String_casecmp$14, $String_casecmp$ques$15, $String_center$16, $String_chars$17, $String_chomp$18, $String_chop$19, $String_chr$20, $String_clone$21, $String_dup$22, $String_count$23, $String_delete$24, $String_delete_prefix$25, $String_delete_suffix$26, $String_downcase$27, $String_each_char$28, $String_each_line$30, $String_empty$ques$31, $String_end_with$ques$32, $String_gsub$33, $String_hash$34, $String_hex$35, $String_include$ques$36, $String_index$37, $String_inspect$38, $String_intern$39, $String_lines$40, $String_length$41, $String_ljust$42, $String_lstrip$43, $String_ascii_only$ques$44, $String_match$45, $String_match$ques$46, $String_next$47, $String_oct$48, $String_ord$49, $String_partition$50, $String_reverse$51, $String_rindex$52, $String_rjust$53, $String_rpartition$54, $String_rstrip$55, $String_scan$56, $String_split$57, $String_squeeze$58, $String_start_with$ques$59, $String_strip$60, $String_sub$61, $String_sum$62, $String_swapcase$63, $String_to_f$64, $String_to_i$65, $String_to_proc$66, $String_to_s$68, $String_tr$69, $String_tr_s$70, $String_upcase$71, $String_upto$72, $String_instance_variables$73, $String__load$74, $String_unicode_normalize$75, $String_unicode_normalized$ques$76, $String_unpack$77, $String_unpack1$78;

    
    self.$include($$($nesting, 'Comparable'));
    
    Opal.defineProperty(self.$$prototype, '$$is_string', true);

    Opal.defineProperty(self.$$prototype, '$$cast', function(string) {
      var klass = this.$$class;
      if (klass.$$constructor === String) {
        return string;
      } else {
        return new klass.$$constructor(string);
      }
    });
  ;
    
    Opal.def(self, '$__id__', $String___id__$1 = function $$__id__() {
      var self = this;

      return self.toString();
    }, $String___id__$1.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    Opal.defs(self, '$try_convert', $String_try_convert$2 = function $$try_convert(what) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](what, $$($nesting, 'String'), "to_str")
    }, $String_try_convert$2.$$arity = 1);
    Opal.defs(self, '$new', $String_new$3 = function(str) {
      var self = this;

      
      
      if (str == null) {
        str = "";
      };
      str = $coerce_to(str, $$($nesting, 'String'), 'to_str');
      return new self.$$constructor(str);;
    }, $String_new$3.$$arity = -1);
    
    Opal.def(self, '$initialize', $String_initialize$4 = function $$initialize(str) {
      var self = this;

      
      ;
      
      if (str === undefined) {
        return self;
      }
    ;
      return self.$raise($$($nesting, 'NotImplementedError'), "Mutable strings are not supported in Opal.");
    }, $String_initialize$4.$$arity = -1);
    
    Opal.def(self, '$%', $String_$percent$5 = function(data) {
      var self = this;

      if ($truthy($$($nesting, 'Array')['$==='](data))) {
        return $send(self, 'format', [self].concat(Opal.to_a(data)))
      } else {
        return self.$format(self, data)
      }
    }, $String_$percent$5.$$arity = 1);
    
    Opal.def(self, '$*', $String_$$6 = function(count) {
      var self = this;

      
      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative argument")
      }

      if (count === 0) {
        return self.$$cast('');
      }

      var result = '',
          string = self.toString();

      // All credit for the bit-twiddling magic code below goes to Mozilla
      // polyfill implementation of String.prototype.repeat() posted here:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

      if (string.length * count >= 1 << 28) {
        self.$raise($$($nesting, 'RangeError'), "multiply count must not overflow maximum string size")
      }

      for (;;) {
        if ((count & 1) === 1) {
          result += string;
        }
        count >>>= 1;
        if (count === 0) {
          break;
        }
        string += string;
      }

      return self.$$cast(result);
    
    }, $String_$$6.$$arity = 1);
    
    Opal.def(self, '$+', $String_$plus$7 = function(other) {
      var self = this;

      
      other = $coerce_to(other, $$($nesting, 'String'), 'to_str');
      return self + other.$to_s();
    }, $String_$plus$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $String_$lt_eq_gt$8 = function(other) {
      var self = this;

      if ($truthy(other['$respond_to?']("to_str"))) {
        
        other = other.$to_str().$to_s();
        return self > other ? 1 : (self < other ? -1 : 0);;
      } else {
        
        var cmp = other['$<=>'](self);

        if (cmp === nil) {
          return nil;
        }
        else {
          return cmp > 0 ? -1 : (cmp < 0 ? 1 : 0);
        }
      
      }
    }, $String_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$==', $String_$eq_eq$9 = function(other) {
      var self = this;

      
      if (other.$$is_string) {
        return self.toString() === other.toString();
      }
      if ($respond_to(other, '$to_str')) {
        return other['$=='](self);
      }
      return false;
    
    }, $String_$eq_eq$9.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    Opal.alias(self, "===", "==");
    
    Opal.def(self, '$=~', $String_$eq_tilde$10 = function(other) {
      var self = this;

      
      if (other.$$is_string) {
        self.$raise($$($nesting, 'TypeError'), "type mismatch: String given");
      }

      return other['$=~'](self);
    
    }, $String_$eq_tilde$10.$$arity = 1);
    
    Opal.def(self, '$[]', $String_$$$11 = function(index, length) {
      var self = this;

      
      ;
      
      var size = self.length, exclude;

      if (index.$$is_range) {
        exclude = index.excl;
        length  = $coerce_to(index.end, $$($nesting, 'Integer'), 'to_int');
        index   = $coerce_to(index.begin, $$($nesting, 'Integer'), 'to_int');

        if (Math.abs(index) > size) {
          return nil;
        }

        if (index < 0) {
          index += size;
        }

        if (length < 0) {
          length += size;
        }

        if (!exclude) {
          length += 1;
        }

        length = length - index;

        if (length < 0) {
          length = 0;
        }

        return self.$$cast(self.substr(index, length));
      }


      if (index.$$is_string) {
        if (length != null) {
          self.$raise($$($nesting, 'TypeError'))
        }
        return self.indexOf(index) !== -1 ? self.$$cast(index) : nil;
      }


      if (index.$$is_regexp) {
        var match = self.match(index);

        if (match === null) {
          ($gvars["~"] = nil)
          return nil;
        }

        ($gvars["~"] = $$($nesting, 'MatchData').$new(index, match))

        if (length == null) {
          return self.$$cast(match[0]);
        }

        length = $coerce_to(length, $$($nesting, 'Integer'), 'to_int');

        if (length < 0 && -length < match.length) {
          return self.$$cast(match[length += match.length]);
        }

        if (length >= 0 && length < match.length) {
          return self.$$cast(match[length]);
        }

        return nil;
      }


      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');

      if (index < 0) {
        index += size;
      }

      if (length == null) {
        if (index >= size || index < 0) {
          return nil;
        }
        return self.$$cast(self.substr(index, 1));
      }

      length = $coerce_to(length, $$($nesting, 'Integer'), 'to_int');

      if (length < 0) {
        return nil;
      }

      if (index > size || index < 0) {
        return nil;
      }

      return self.$$cast(self.substr(index, length));
    ;
    }, $String_$$$11.$$arity = -2);
    Opal.alias(self, "byteslice", "[]");
    
    Opal.def(self, '$b', $String_b$12 = function $$b() {
      var self = this;

      return self.$force_encoding("binary")
    }, $String_b$12.$$arity = 0);
    
    Opal.def(self, '$capitalize', $String_capitalize$13 = function $$capitalize() {
      var self = this;

      return self.$$cast(self.charAt(0).toUpperCase() + self.substr(1).toLowerCase());
    }, $String_capitalize$13.$$arity = 0);
    
    Opal.def(self, '$casecmp', $String_casecmp$14 = function $$casecmp(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
      } else {
        return nil
      };
      other = ($coerce_to(other, $$($nesting, 'String'), 'to_str')).$to_s();
      
      var ascii_only = /^[\x00-\x7F]*$/;
      if (ascii_only.test(self) && ascii_only.test(other)) {
        self = self.toLowerCase();
        other = other.toLowerCase();
      }
    ;
      return self['$<=>'](other);
    }, $String_casecmp$14.$$arity = 1);
    
    Opal.def(self, '$casecmp?', $String_casecmp$ques$15 = function(other) {
      var self = this;

      
      var cmp = self.$casecmp(other);
      if (cmp === nil) {
        return nil;
      } else {
        return cmp === 0;
      }
    
    }, $String_casecmp$ques$15.$$arity = 1);
    
    Opal.def(self, '$center', $String_center$16 = function $$center(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $coerce_to(width, $$($nesting, 'Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$($nesting, 'String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var ljustified = self.$ljust($rb_divide($rb_plus(width, self.length), 2).$ceil(), padstr),
          rjustified = self.$rjust($rb_divide($rb_plus(width, self.length), 2).$floor(), padstr);

      return self.$$cast(rjustified + ljustified.slice(self.length));
    ;
    }, $String_center$16.$$arity = -2);
    
    Opal.def(self, '$chars', $String_chars$17 = function $$chars() {
      var $iter = $String_chars$17.$$p, block = $iter || nil, self = this;

      if ($iter) $String_chars$17.$$p = null;
      
      
      if ($iter) $String_chars$17.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$each_char().$to_a()
      };
      return $send(self, 'each_char', [], block.$to_proc());
    }, $String_chars$17.$$arity = 0);
    
    Opal.def(self, '$chomp', $String_chomp$18 = function $$chomp(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if ($truthy(separator === nil || self.length === 0)) {
        return self};
      separator = $$($nesting, 'Opal')['$coerce_to!'](separator, $$($nesting, 'String'), "to_str").$to_s();
      
      var result;

      if (separator === "\n") {
        result = self.replace(/\r?\n?$/, '');
      }
      else if (separator === "") {
        result = self.replace(/(\r?\n)+$/, '');
      }
      else if (self.length >= separator.length) {
        var tail = self.substr(self.length - separator.length, separator.length);

        if (tail === separator) {
          result = self.substr(0, self.length - separator.length);
        }
      }

      if (result != null) {
        return self.$$cast(result);
      }
    ;
      return self;
    }, $String_chomp$18.$$arity = -1);
    
    Opal.def(self, '$chop', $String_chop$19 = function $$chop() {
      var self = this;

      
      var length = self.length, result;

      if (length <= 1) {
        result = "";
      } else if (self.charAt(length - 1) === "\n" && self.charAt(length - 2) === "\r") {
        result = self.substr(0, length - 2);
      } else {
        result = self.substr(0, length - 1);
      }

      return self.$$cast(result);
    
    }, $String_chop$19.$$arity = 0);
    
    Opal.def(self, '$chr', $String_chr$20 = function $$chr() {
      var self = this;

      return self.charAt(0);
    }, $String_chr$20.$$arity = 0);
    
    Opal.def(self, '$clone', $String_clone$21 = function $$clone() {
      var self = this, copy = nil;

      
      copy = new String(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, $String_clone$21.$$arity = 0);
    
    Opal.def(self, '$dup', $String_dup$22 = function $$dup() {
      var self = this, copy = nil;

      
      copy = new String(self);
      copy.$initialize_dup(self);
      return copy;
    }, $String_dup$22.$$arity = 0);
    
    Opal.def(self, '$count', $String_count$23 = function $$count($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return 0;
      }
      return self.length - self.replace(new RegExp(char_class, 'g'), '').length;
    ;
    }, $String_count$23.$$arity = -1);
    
    Opal.def(self, '$delete', $String_delete$24 = function($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.$$cast(self.replace(new RegExp(char_class, 'g'), ''));
    ;
    }, $String_delete$24.$$arity = -1);
    
    Opal.def(self, '$delete_prefix', $String_delete_prefix$25 = function $$delete_prefix(prefix) {
      var self = this;

      
      if (!prefix.$$is_string) {
        prefix = $coerce_to(prefix, $$($nesting, 'String'), 'to_str');
      }

      if (self.slice(0, prefix.length) === prefix) {
        return self.$$cast(self.slice(prefix.length));
      } else {
        return self;
      }
    
    }, $String_delete_prefix$25.$$arity = 1);
    
    Opal.def(self, '$delete_suffix', $String_delete_suffix$26 = function $$delete_suffix(suffix) {
      var self = this;

      
      if (!suffix.$$is_string) {
        suffix = $coerce_to(suffix, $$($nesting, 'String'), 'to_str');
      }

      if (self.slice(self.length - suffix.length) === suffix) {
        return self.$$cast(self.slice(0, self.length - suffix.length));
      } else {
        return self;
      }
    
    }, $String_delete_suffix$26.$$arity = 1);
    
    Opal.def(self, '$downcase', $String_downcase$27 = function $$downcase() {
      var self = this;

      return self.$$cast(self.toLowerCase());
    }, $String_downcase$27.$$arity = 0);
    
    Opal.def(self, '$each_char', $String_each_char$28 = function $$each_char() {
      var $iter = $String_each_char$28.$$p, block = $iter || nil, $$29, self = this;

      if ($iter) $String_each_char$28.$$p = null;
      
      
      if ($iter) $String_each_char$28.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_char"], ($$29 = function(){var self = $$29.$$s == null ? this : $$29.$$s;

        return self.$size()}, $$29.$$s = self, $$29.$$arity = 0, $$29))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        Opal.yield1(block, self.charAt(i));
      }
    ;
      return self;
    }, $String_each_char$28.$$arity = 0);
    
    Opal.def(self, '$each_line', $String_each_line$30 = function $$each_line(separator) {
      var $iter = $String_each_line$30.$$p, block = $iter || nil, self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $String_each_line$30.$$p = null;
      
      
      if ($iter) $String_each_line$30.$$p = null;;
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_line", separator)
      };
      
      if (separator === nil) {
        Opal.yield1(block, self);

        return self;
      }

      separator = $coerce_to(separator, $$($nesting, 'String'), 'to_str')

      var a, i, n, length, chomped, trailing, splitted;

      if (separator.length === 0) {
        for (a = self.split(/(\n{2,})/), i = 0, n = a.length; i < n; i += 2) {
          if (a[i] || a[i + 1]) {
            var value = (a[i] || "") + (a[i + 1] || "");
            Opal.yield1(block, self.$$cast(value));
          }
        }

        return self;
      }

      chomped  = self.$chomp(separator);
      trailing = self.length != chomped.length;
      splitted = chomped.split(separator);

      for (i = 0, length = splitted.length; i < length; i++) {
        if (i < length - 1 || trailing) {
          Opal.yield1(block, self.$$cast(splitted[i] + separator));
        }
        else {
          Opal.yield1(block, self.$$cast(splitted[i]));
        }
      }
    ;
      return self;
    }, $String_each_line$30.$$arity = -1);
    
    Opal.def(self, '$empty?', $String_empty$ques$31 = function() {
      var self = this;

      return self.length === 0;
    }, $String_empty$ques$31.$$arity = 0);
    
    Opal.def(self, '$end_with?', $String_end_with$ques$32 = function($a) {
      var $post_args, suffixes, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      suffixes = $post_args;;
      
      for (var i = 0, length = suffixes.length; i < length; i++) {
        var suffix = $coerce_to(suffixes[i], $$($nesting, 'String'), 'to_str').$to_s();

        if (self.length >= suffix.length &&
            self.substr(self.length - suffix.length, suffix.length) == suffix) {
          return true;
        }
      }
    ;
      return false;
    }, $String_end_with$ques$32.$$arity = -1);
    Opal.alias(self, "equal?", "===");
    
    Opal.def(self, '$gsub', $String_gsub$33 = function $$gsub(pattern, replacement) {
      var $iter = $String_gsub$33.$$p, block = $iter || nil, self = this;

      if ($iter) $String_gsub$33.$$p = null;
      
      
      if ($iter) $String_gsub$33.$$p = null;;
      ;
      
      if (replacement === undefined && block === nil) {
        return self.$enum_for("gsub", pattern);
      }

      var result = '', match_data = nil, index = 0, match, _replacement;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      var lastIndex;
      while (true) {
        match = pattern.exec(self);

        if (match === null) {
          ($gvars["~"] = nil)
          result += self.slice(index);
          break;
        }

        match_data = $$($nesting, 'MatchData').$new(pattern, match);

        if (replacement === undefined) {
          lastIndex = pattern.lastIndex;
          _replacement = block(match[0]);
          pattern.lastIndex = lastIndex; // save and restore lastIndex
        }
        else if (replacement.$$is_hash) {
          _replacement = (replacement)['$[]'](match[0]).$to_s();
        }
        else {
          if (!replacement.$$is_string) {
            replacement = $coerce_to(replacement, $$($nesting, 'String'), 'to_str');
          }
          _replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');
        }

        if (pattern.lastIndex === match.index) {
          result += (self.slice(index, match.index) + _replacement + (self[match.index] || ""));
          pattern.lastIndex += 1;
        }
        else {
          result += (self.slice(index, match.index) + _replacement)
        }
        index = pattern.lastIndex;
      }

      ($gvars["~"] = match_data)
      return self.$$cast(result);
    ;
    }, $String_gsub$33.$$arity = -2);
    
    Opal.def(self, '$hash', $String_hash$34 = function $$hash() {
      var self = this;

      return self.toString();
    }, $String_hash$34.$$arity = 0);
    
    Opal.def(self, '$hex', $String_hex$35 = function $$hex() {
      var self = this;

      return self.$to_i(16)
    }, $String_hex$35.$$arity = 0);
    
    Opal.def(self, '$include?', $String_include$ques$36 = function(other) {
      var self = this;

      
      if (!other.$$is_string) {
        other = $coerce_to(other, $$($nesting, 'String'), 'to_str');
      }
      return self.indexOf(other) !== -1;
    
    }, $String_include$ques$36.$$arity = 1);
    
    Opal.def(self, '$index', $String_index$37 = function $$index(search, offset) {
      var self = this;

      
      ;
      
      var index,
          match,
          regex;

      if (offset === undefined) {
        offset = 0;
      } else {
        offset = $coerce_to(offset, $$($nesting, 'Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        regex = Opal.global_multiline_regexp(search);
        while (true) {
          match = regex.exec(self);
          if (match === null) {
            ($gvars["~"] = nil);
            index = -1;
            break;
          }
          if (match.index >= offset) {
            ($gvars["~"] = $$($nesting, 'MatchData').$new(regex, match))
            index = match.index;
            break;
          }
          regex.lastIndex = match.index + 1;
        }
      } else {
        search = $coerce_to(search, $$($nesting, 'String'), 'to_str');
        if (search.length === 0 && offset > self.length) {
          index = -1;
        } else {
          index = self.indexOf(search, offset);
        }
      }

      return index === -1 ? nil : index;
    ;
    }, $String_index$37.$$arity = -2);
    
    Opal.def(self, '$inspect', $String_inspect$38 = function $$inspect() {
      var self = this;

      
      var escapable = /[\\\"\x00-\x1f\u007F-\u009F\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
          meta = {
            '\u0007': '\\a',
            '\u001b': '\\e',
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '\v': '\\v',
            '"' : '\\"',
            '\\': '\\\\'
          },
          escaped = self.replace(escapable, function (chr) {
            return meta[chr] || '\\u' + ('0000' + chr.charCodeAt(0).toString(16).toUpperCase()).slice(-4);
          });
      return '"' + escaped.replace(/\#[\$\@\{]/g, '\\$&') + '"';
    
    }, $String_inspect$38.$$arity = 0);
    
    Opal.def(self, '$intern', $String_intern$39 = function $$intern() {
      var self = this;

      return self.toString();
    }, $String_intern$39.$$arity = 0);
    
    Opal.def(self, '$lines', $String_lines$40 = function $$lines(separator) {
      var $iter = $String_lines$40.$$p, block = $iter || nil, self = this, e = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $String_lines$40.$$p = null;
      
      
      if ($iter) $String_lines$40.$$p = null;;
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      e = $send(self, 'each_line', [separator], block.$to_proc());
      if ($truthy(block)) {
        return self
      } else {
        return e.$to_a()
      };
    }, $String_lines$40.$$arity = -1);
    
    Opal.def(self, '$length', $String_length$41 = function $$length() {
      var self = this;

      return self.length;
    }, $String_length$41.$$arity = 0);
    
    Opal.def(self, '$ljust', $String_ljust$42 = function $$ljust(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $coerce_to(width, $$($nesting, 'Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$($nesting, 'String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var index  = -1,
          result = "";

      width -= self.length;

      while (++index < width) {
        result += padstr;
      }

      return self.$$cast(self + result.slice(0, width));
    ;
    }, $String_ljust$42.$$arity = -2);
    
    Opal.def(self, '$lstrip', $String_lstrip$43 = function $$lstrip() {
      var self = this;

      return self.replace(/^\s*/, '');
    }, $String_lstrip$43.$$arity = 0);
    
    Opal.def(self, '$ascii_only?', $String_ascii_only$ques$44 = function() {
      var self = this;

      
      if (self.$encoding()['$==']($$$($$($nesting, 'Encoding'), 'UTF_16BE'))) {
        return false};
      return /^[\x00-\x7F]*$/.test(self);;
    }, $String_ascii_only$ques$44.$$arity = 0);
    
    Opal.def(self, '$match', $String_match$45 = function $$match(pattern, pos) {
      var $iter = $String_match$45.$$p, block = $iter || nil, self = this, $ret_or_1 = nil;

      if ($iter) $String_match$45.$$p = null;
      
      
      if ($iter) $String_match$45.$$p = null;;
      ;
      if ($truthy((function() {if ($truthy(($ret_or_1 = $$($nesting, 'String')['$==='](pattern)))) {
        return $ret_or_1
      } else {
        return pattern['$respond_to?']("to_str")
      }; return nil; })())) {
        pattern = $$($nesting, 'Regexp').$new(pattern.$to_str())};
      if ($truthy($$($nesting, 'Regexp')['$==='](pattern))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return $send(pattern, 'match', [self, pos], block.$to_proc());
    }, $String_match$45.$$arity = -2);
    
    Opal.def(self, '$match?', $String_match$ques$46 = function(pattern, pos) {
      var self = this, $ret_or_2 = nil;

      
      ;
      if ($truthy((function() {if ($truthy(($ret_or_2 = $$($nesting, 'String')['$==='](pattern)))) {
        return $ret_or_2
      } else {
        return pattern['$respond_to?']("to_str")
      }; return nil; })())) {
        pattern = $$($nesting, 'Regexp').$new(pattern.$to_str())};
      if ($truthy($$($nesting, 'Regexp')['$==='](pattern))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return pattern['$match?'](self, pos);
    }, $String_match$ques$46.$$arity = -2);
    
    Opal.def(self, '$next', $String_next$47 = function $$next() {
      var self = this;

      
      var i = self.length;
      if (i === 0) {
        return self.$$cast('');
      }
      var result = self;
      var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);
      var carry = false;
      var code;
      while (i--) {
        code = self.charCodeAt(i);
        if ((code >= 48 && code <= 57) ||
          (code >= 65 && code <= 90) ||
          (code >= 97 && code <= 122)) {
          switch (code) {
          case 57:
            carry = true;
            code = 48;
            break;
          case 90:
            carry = true;
            code = 65;
            break;
          case 122:
            carry = true;
            code = 97;
            break;
          default:
            carry = false;
            code += 1;
          }
        } else {
          if (first_alphanum_char_index === -1) {
            if (code === 255) {
              carry = true;
              code = 0;
            } else {
              carry = false;
              code += 1;
            }
          } else {
            carry = true;
          }
        }
        result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i + 1);
        if (carry && (i === 0 || i === first_alphanum_char_index)) {
          switch (code) {
          case 65:
            break;
          case 97:
            break;
          default:
            code += 1;
          }
          if (i === 0) {
            result = String.fromCharCode(code) + result;
          } else {
            result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i);
          }
          carry = false;
        }
        if (!carry) {
          break;
        }
      }
      return self.$$cast(result);
    
    }, $String_next$47.$$arity = 0);
    
    Opal.def(self, '$oct', $String_oct$48 = function $$oct() {
      var self = this;

      
      var result,
          string = self,
          radix = 8;

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/i, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x') {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          radix = 2;
          break;
        case '0':
        case '0o':
          radix = 8;
          break;
        case '0d':
          radix = 10;
          break;
        case '0x':
          radix = 16;
          break;
        }
        return head + tail;
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    
    }, $String_oct$48.$$arity = 0);
    
    Opal.def(self, '$ord', $String_ord$49 = function $$ord() {
      var self = this;

      return self.charCodeAt(0);
    }, $String_ord$49.$$arity = 0);
    
    Opal.def(self, '$partition', $String_partition$50 = function $$partition(sep) {
      var self = this;

      
      var i, m;

      if (sep.$$is_regexp) {
        m = sep.exec(self);
        if (m === null) {
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(sep, m);
          sep = m[0];
          i = m.index;
        }
      } else {
        sep = $coerce_to(sep, $$($nesting, 'String'), 'to_str');
        i = self.indexOf(sep);
      }

      if (i === -1) {
        return [self, '', ''];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, $String_partition$50.$$arity = 1);
    
    Opal.def(self, '$reverse', $String_reverse$51 = function $$reverse() {
      var self = this;

      return self.split('').reverse().join('');
    }, $String_reverse$51.$$arity = 0);
    
    Opal.def(self, '$rindex', $String_rindex$52 = function $$rindex(search, offset) {
      var self = this;

      
      ;
      
      var i, m, r, _m;

      if (offset === undefined) {
        offset = self.length;
      } else {
        offset = $coerce_to(offset, $$($nesting, 'Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        m = null;
        r = Opal.global_multiline_regexp(search);
        while (true) {
          _m = r.exec(self);
          if (_m === null || _m.index > offset) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }
        if (m === null) {
          ($gvars["~"] = nil)
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(r, m);
          i = m.index;
        }
      } else {
        search = $coerce_to(search, $$($nesting, 'String'), 'to_str');
        i = self.lastIndexOf(search, offset);
      }

      return i === -1 ? nil : i;
    ;
    }, $String_rindex$52.$$arity = -2);
    
    Opal.def(self, '$rjust', $String_rjust$53 = function $$rjust(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $coerce_to(width, $$($nesting, 'Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$($nesting, 'String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var chars     = Math.floor(width - self.length),
          patterns  = Math.floor(chars / padstr.length),
          result    = Array(patterns + 1).join(padstr),
          remaining = chars - result.length;

      return self.$$cast(result + padstr.slice(0, remaining) + self);
    ;
    }, $String_rjust$53.$$arity = -2);
    
    Opal.def(self, '$rpartition', $String_rpartition$54 = function $$rpartition(sep) {
      var self = this;

      
      var i, m, r, _m;

      if (sep.$$is_regexp) {
        m = null;
        r = Opal.global_multiline_regexp(sep);

        while (true) {
          _m = r.exec(self);
          if (_m === null) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }

        if (m === null) {
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(r, m);
          sep = m[0];
          i = m.index;
        }

      } else {
        sep = $coerce_to(sep, $$($nesting, 'String'), 'to_str');
        i = self.lastIndexOf(sep);
      }

      if (i === -1) {
        return ['', '', self];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, $String_rpartition$54.$$arity = 1);
    
    Opal.def(self, '$rstrip', $String_rstrip$55 = function $$rstrip() {
      var self = this;

      return self.replace(/[\s\u0000]*$/, '');
    }, $String_rstrip$55.$$arity = 0);
    
    Opal.def(self, '$scan', $String_scan$56 = function $$scan(pattern) {
      var $iter = $String_scan$56.$$p, block = $iter || nil, self = this;

      if ($iter) $String_scan$56.$$p = null;
      
      
      if ($iter) $String_scan$56.$$p = null;;
      
      var result = [],
          match_data = nil,
          match;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      while ((match = pattern.exec(self)) != null) {
        match_data = $$($nesting, 'MatchData').$new(pattern, match);
        if (block === nil) {
          match.length == 1 ? result.push(match[0]) : result.push((match_data).$captures());
        } else {
          match.length == 1 ? block(match[0]) : block.call(self, (match_data).$captures());
        }
        if (pattern.lastIndex === match.index) {
          pattern.lastIndex += 1;
        }
      }

      ($gvars["~"] = match_data)

      return (block !== nil ? self : result);
    ;
    }, $String_scan$56.$$arity = 1);
    Opal.alias(self, "size", "length");
    Opal.alias(self, "slice", "[]");
    
    Opal.def(self, '$split', $String_split$57 = function $$split(pattern, limit) {
      var self = this, $ret_or_3 = nil;
      if ($gvars[";"] == null) $gvars[";"] = nil;

      
      ;
      ;
      
      if (self.length === 0) {
        return [];
      }

      if (limit === undefined) {
        limit = 0;
      } else {
        limit = $$($nesting, 'Opal')['$coerce_to!'](limit, $$($nesting, 'Integer'), "to_int");
        if (limit === 1) {
          return [self];
        }
      }

      if (pattern === undefined || pattern === nil) {
        pattern = (function() {if ($truthy(($ret_or_3 = $gvars[";"]))) {
        return $ret_or_3
      } else {
        return " "
      }; return nil; })();
      }

      var result = [],
          string = self.toString(),
          index = 0,
          match,
          i, ii;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str').$to_s();
        if (pattern === ' ') {
          pattern = /\s+/gm;
          string = string.replace(/^\s+/, '');
        } else {
          pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
        }
      }

      result = string.split(pattern);

      if (result.length === 1 && result[0] === string) {
        return [self.$$cast(result[0])];
      }

      while ((i = result.indexOf(undefined)) !== -1) {
        result.splice(i, 1);
      }

      function castResult() {
        for (i = 0; i < result.length; i++) {
          result[i] = self.$$cast(result[i]);
        }
      }

      if (limit === 0) {
        while (result[result.length - 1] === '') {
          result.length -= 1;
        }
        castResult();
        return result;
      }

      match = pattern.exec(string);

      if (limit < 0) {
        if (match !== null && match[0] === '' && pattern.source.indexOf('(?=') === -1) {
          for (i = 0, ii = match.length; i < ii; i++) {
            result.push('');
          }
        }
        castResult();
        return result;
      }

      if (match !== null && match[0] === '') {
        result.splice(limit - 1, result.length - 1, result.slice(limit - 1).join(''));
        castResult();
        return result;
      }

      if (limit >= result.length) {
        castResult();
        return result;
      }

      i = 0;
      while (match !== null) {
        i++;
        index = pattern.lastIndex;
        if (i + 1 === limit) {
          break;
        }
        match = pattern.exec(string);
      }
      result.splice(limit - 1, result.length - 1, string.slice(index));
      castResult();
      return result;
    ;
    }, $String_split$57.$$arity = -1);
    
    Opal.def(self, '$squeeze', $String_squeeze$58 = function $$squeeze($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        return self.$$cast(self.replace(/(.)\1+/g, '$1'));
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.$$cast(self.replace(new RegExp('(' + char_class + ')\\1+', 'g'), '$1'));
    ;
    }, $String_squeeze$58.$$arity = -1);
    
    Opal.def(self, '$start_with?', $String_start_with$ques$59 = function($a) {
      var $post_args, prefixes, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      prefixes = $post_args;;
      
      for (var i = 0, length = prefixes.length; i < length; i++) {
        var prefix = $coerce_to(prefixes[i], $$($nesting, 'String'), 'to_str').$to_s();

        if (self.indexOf(prefix) === 0) {
          return true;
        }
      }

      return false;
    ;
    }, $String_start_with$ques$59.$$arity = -1);
    
    Opal.def(self, '$strip', $String_strip$60 = function $$strip() {
      var self = this;

      return self.replace(/^\s*/, '').replace(/[\s\u0000]*$/, '');
    }, $String_strip$60.$$arity = 0);
    
    Opal.def(self, '$sub', $String_sub$61 = function $$sub(pattern, replacement) {
      var $iter = $String_sub$61.$$p, block = $iter || nil, self = this;

      if ($iter) $String_sub$61.$$p = null;
      
      
      if ($iter) $String_sub$61.$$p = null;;
      ;
      
      if (!pattern.$$is_regexp) {
        pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
      }

      var result, match = pattern.exec(self);

      if (match === null) {
        ($gvars["~"] = nil)
        result = self.toString();
      } else {
        $$($nesting, 'MatchData').$new(pattern, match)

        if (replacement === undefined) {

          if (block === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (1 for 2)")
          }
          result = self.slice(0, match.index) + block(match[0]) + self.slice(match.index + match[0].length);

        } else if (replacement.$$is_hash) {

          result = self.slice(0, match.index) + (replacement)['$[]'](match[0]).$to_s() + self.slice(match.index + match[0].length);

        } else {

          replacement = $coerce_to(replacement, $$($nesting, 'String'), 'to_str');

          replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');

          result = self.slice(0, match.index) + replacement + self.slice(match.index + match[0].length);
        }
      }

      return self.$$cast(result);
    ;
    }, $String_sub$61.$$arity = -2);
    Opal.alias(self, "succ", "next");
    
    Opal.def(self, '$sum', $String_sum$62 = function $$sum(n) {
      var self = this;

      
      
      if (n == null) {
        n = 16;
      };
      
      n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');

      var result = 0,
          length = self.length,
          i = 0;

      for (; i < length; i++) {
        result += self.charCodeAt(i);
      }

      if (n <= 0) {
        return result;
      }

      return result & (Math.pow(2, n) - 1);
    ;
    }, $String_sum$62.$$arity = -1);
    
    Opal.def(self, '$swapcase', $String_swapcase$63 = function $$swapcase() {
      var self = this;

      
      var str = self.replace(/([a-z]+)|([A-Z]+)/g, function($0,$1,$2) {
        return $1 ? $0.toUpperCase() : $0.toLowerCase();
      });

      if (self.constructor === String) {
        return str;
      }

      return self.$class().$new(str);
    
    }, $String_swapcase$63.$$arity = 0);
    
    Opal.def(self, '$to_f', $String_to_f$64 = function $$to_f() {
      var self = this;

      
      if (self.charAt(0) === '_') {
        return 0;
      }

      var result = parseFloat(self.replace(/_/g, ''));

      if (isNaN(result) || result == Infinity || result == -Infinity) {
        return 0;
      }
      else {
        return result;
      }
    
    }, $String_to_f$64.$$arity = 0);
    
    Opal.def(self, '$to_i', $String_to_i$65 = function $$to_i(base) {
      var self = this;

      
      
      if (base == null) {
        base = 10;
      };
      
      var result,
          string = self.toLowerCase(),
          radix = $coerce_to(base, $$($nesting, 'Integer'), 'to_int');

      if (radix === 1 || radix < 0 || radix > 36) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (radix))
      }

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x' && (radix === 0 || radix === 16)) {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          if (radix === 0 || radix === 2) {
            radix = 2;
            return head + tail;
          }
          break;
        case '0':
        case '0o':
          if (radix === 0 || radix === 8) {
            radix = 8;
            return head + tail;
          }
          break;
        case '0d':
          if (radix === 0 || radix === 10) {
            radix = 10;
            return head + tail;
          }
          break;
        case '0x':
          if (radix === 0 || radix === 16) {
            radix = 16;
            return head + tail;
          }
          break;
        }
        return original
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    ;
    }, $String_to_i$65.$$arity = -1);
    
    Opal.def(self, '$to_proc', $String_to_proc$66 = function $$to_proc() {
      var $$67, $iter = $String_to_proc$66.$$p, $yield = $iter || nil, self = this, method_name = nil;

      if ($iter) $String_to_proc$66.$$p = null;
      
      method_name = $rb_plus("$", self.valueOf());
      return $send(self, 'proc', [], ($$67 = function($a){var self = $$67.$$s == null ? this : $$67.$$s, $iter = $$67.$$p, block = $iter || nil, $post_args, args;

      
        
        if ($iter) $$67.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        
        if (args.length === 0) {
          self.$raise($$($nesting, 'ArgumentError'), "no receiver given")
        }

        var recv = args[0];

        if (recv == null) recv = nil;

        var body = recv[method_name];

        if (!body) {
          return recv.$method_missing.apply(recv, args);
        }

        if (typeof block === 'function') {
          body.$$p = block;
        }

        if (args.length === 1) {
          return body.call(recv);
        } else {
          return body.apply(recv, args.slice(1));
        }
      ;}, $$67.$$s = self, $$67.$$arity = -1, $$67));
    }, $String_to_proc$66.$$arity = 0);
    
    Opal.def(self, '$to_s', $String_to_s$68 = function $$to_s() {
      var self = this;

      return self.toString();
    }, $String_to_s$68.$$arity = 0);
    Opal.alias(self, "to_str", "to_s");
    Opal.alias(self, "to_sym", "intern");
    
    Opal.def(self, '$tr', $String_tr$69 = function $$tr(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$($nesting, 'String'), 'to_str').$to_s();
      to = $coerce_to(to, $$($nesting, 'String'), 'to_str').$to_s();

      if (from.length == 0 || from === to) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_to == null) {
              last_to = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_to.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_to = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }

      var new_str = ''
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch];
        if (inverse) {
          new_str += (sub == null ? global_sub : ch);
        }
        else {
          new_str += (sub != null ? sub : ch);
        }
      }
      return self.$$cast(new_str);
    
    }, $String_tr$69.$$arity = 2);
    
    Opal.def(self, '$tr_s', $String_tr_s$70 = function $$tr_s(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$($nesting, 'String'), 'to_str').$to_s();
      to = $coerce_to(to, $$($nesting, 'String'), 'to_str').$to_s();

      if (from.length == 0) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_from == null) {
              last_from = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_from.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_from = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }
      var new_str = ''
      var last_substitute = null
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch]
        if (inverse) {
          if (sub == null) {
            if (last_substitute == null) {
              new_str += global_sub;
              last_substitute = true;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
        else {
          if (sub != null) {
            if (last_substitute == null || last_substitute !== sub) {
              new_str += sub;
              last_substitute = sub;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
      }
      return self.$$cast(new_str);
    
    }, $String_tr_s$70.$$arity = 2);
    
    Opal.def(self, '$upcase', $String_upcase$71 = function $$upcase() {
      var self = this;

      return self.$$cast(self.toUpperCase());
    }, $String_upcase$71.$$arity = 0);
    
    Opal.def(self, '$upto', $String_upto$72 = function $$upto(stop, excl) {
      var $iter = $String_upto$72.$$p, block = $iter || nil, self = this;

      if ($iter) $String_upto$72.$$p = null;
      
      
      if ($iter) $String_upto$72.$$p = null;;
      
      if (excl == null) {
        excl = false;
      };
      if ((block !== nil)) {
      } else {
        return self.$enum_for("upto", stop, excl)
      };
      
      var a, b, s = self.toString();

      stop = $coerce_to(stop, $$($nesting, 'String'), 'to_str');

      if (s.length === 1 && stop.length === 1) {

        a = s.charCodeAt(0);
        b = stop.charCodeAt(0);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(String.fromCharCode(a));

          a += 1;
        }

      } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {

        a = parseInt(s, 10);
        b = parseInt(stop, 10);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(a.toString());

          a += 1;
        }

      } else {

        while (s.length <= stop.length && s <= stop) {
          if (excl && s === stop) {
            break;
          }

          block(s);

          s = (s).$succ();
        }

      }
      return self;
    ;
    }, $String_upto$72.$$arity = -2);
    
    function char_class_from_char_sets(sets) {
      function explode_sequences_in_character_set(set) {
        var result = '',
            i, len = set.length,
            curr_char,
            skip_next_dash,
            char_code_from,
            char_code_upto,
            char_code;
        for (i = 0; i < len; i++) {
          curr_char = set.charAt(i);
          if (curr_char === '-' && i > 0 && i < (len - 1) && !skip_next_dash) {
            char_code_from = set.charCodeAt(i - 1);
            char_code_upto = set.charCodeAt(i + 1);
            if (char_code_from > char_code_upto) {
              self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (char_code_from) + "-" + (char_code_upto) + "\" in string transliteration")
            }
            for (char_code = char_code_from + 1; char_code < char_code_upto + 1; char_code++) {
              result += String.fromCharCode(char_code);
            }
            skip_next_dash = true;
            i++;
          } else {
            skip_next_dash = (curr_char === '\\');
            result += curr_char;
          }
        }
        return result;
      }

      function intersection(setA, setB) {
        if (setA.length === 0) {
          return setB;
        }
        var result = '',
            i, len = setA.length,
            chr;
        for (i = 0; i < len; i++) {
          chr = setA.charAt(i);
          if (setB.indexOf(chr) !== -1) {
            result += chr;
          }
        }
        return result;
      }

      var i, len, set, neg, chr, tmp,
          pos_intersection = '',
          neg_intersection = '';

      for (i = 0, len = sets.length; i < len; i++) {
        set = $coerce_to(sets[i], $$($nesting, 'String'), 'to_str');
        neg = (set.charAt(0) === '^' && set.length > 1);
        set = explode_sequences_in_character_set(neg ? set.slice(1) : set);
        if (neg) {
          neg_intersection = intersection(neg_intersection, set);
        } else {
          pos_intersection = intersection(pos_intersection, set);
        }
      }

      if (pos_intersection.length > 0 && neg_intersection.length > 0) {
        tmp = '';
        for (i = 0, len = pos_intersection.length; i < len; i++) {
          chr = pos_intersection.charAt(i);
          if (neg_intersection.indexOf(chr) === -1) {
            tmp += chr;
          }
        }
        pos_intersection = tmp;
        neg_intersection = '';
      }

      if (pos_intersection.length > 0) {
        return '[' + $$($nesting, 'Regexp').$escape(pos_intersection) + ']';
      }

      if (neg_intersection.length > 0) {
        return '[^' + $$($nesting, 'Regexp').$escape(neg_intersection) + ']';
      }

      return null;
    }
  ;
    
    Opal.def(self, '$instance_variables', $String_instance_variables$73 = function $$instance_variables() {
      var self = this;

      return []
    }, $String_instance_variables$73.$$arity = 0);
    Opal.defs(self, '$_load', $String__load$74 = function $$_load($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self, 'new', Opal.to_a(args));
    }, $String__load$74.$$arity = -1);
    
    Opal.def(self, '$unicode_normalize', $String_unicode_normalize$75 = function $$unicode_normalize(form) {
      var self = this;

      
      
      if (form == null) {
        form = "nfc";
      };
      if ($truthy(["nfc", "nfd", "nfkc", "nfkd"]['$include?'](form))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "Invalid normalization form " + (form))
      };
      return self.normalize(form.$upcase());
    }, $String_unicode_normalize$75.$$arity = -1);
    
    Opal.def(self, '$unicode_normalized?', $String_unicode_normalized$ques$76 = function(form) {
      var self = this;

      
      
      if (form == null) {
        form = "nfc";
      };
      return self.$unicode_normalize(form)['$=='](self);
    }, $String_unicode_normalized$ques$76.$$arity = -1);
    
    Opal.def(self, '$unpack', $String_unpack$77 = function $$unpack(format) {
      var self = this;

      return self.$raise("To use String#unpack, you must first require 'corelib/string/unpack'.")
    }, $String_unpack$77.$$arity = 1);
    return (Opal.def(self, '$unpack1', $String_unpack1$78 = function $$unpack1(format) {
      var self = this;

      return self.$raise("To use String#unpack1, you must first require 'corelib/string/unpack'.")
    }, $String_unpack1$78.$$arity = 1), nil) && 'unpack1';
  })($nesting[0], String, $nesting);
  return Opal.const_set($nesting[0], 'Symbol', $$($nesting, 'String'));
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/enumerable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $falsy = Opal.falsy, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $module = Opal.module, $send = Opal.send, $hash2 = Opal.hash2, $lambda = Opal.lambda;

  Opal.add_stubs(['$each', '$public_send', '$destructure', '$to_enum', '$enumerator_size', '$new', '$yield', '$raise', '$slice_when', '$!', '$enum_for', '$flatten', '$map', '$warn', '$proc', '$==', '$nil?', '$respond_to?', '$coerce_to!', '$>', '$*', '$try_convert', '$<', '$+', '$-', '$ceil', '$/', '$size', '$select', '$to_proc', '$__send__', '$length', '$<=', '$[]', '$push', '$<<', '$[]=', '$===', '$inspect', '$<=>', '$first', '$reverse', '$sort', '$take', '$sort_by', '$compare', '$call', '$dup', '$to_a', '$sort!', '$map!', '$key?', '$values', '$transform_values', '$group_by', '$to_h', '$coerce_to?', '$class', '$zip']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Enumerable');

    var $nesting = [self].concat($parent_nesting), $Enumerable_all$ques$1, $Enumerable_any$ques$5, $Enumerable_chunk$9, $Enumerable_chunk_while$12, $Enumerable_collect$14, $Enumerable_collect_concat$16, $Enumerable_count$19, $Enumerable_cycle$23, $Enumerable_detect$25, $Enumerable_drop$27, $Enumerable_drop_while$28, $Enumerable_each_cons$29, $Enumerable_each_entry$31, $Enumerable_each_slice$33, $Enumerable_each_with_index$35, $Enumerable_each_with_object$37, $Enumerable_entries$39, $Enumerable_filter_map$40, $Enumerable_find_all$42, $Enumerable_find_index$44, $Enumerable_first$47, $Enumerable_grep$50, $Enumerable_grep_v$52, $Enumerable_group_by$54, $Enumerable_include$ques$56, $Enumerable_inject$58, $Enumerable_lazy$59, $Enumerable_enumerator_size$61, $Enumerable_max$62, $Enumerable_max_by$63, $Enumerable_min$65, $Enumerable_min_by$67, $Enumerable_minmax$69, $Enumerable_minmax_by$71, $Enumerable_none$ques$73, $Enumerable_one$ques$77, $Enumerable_partition$81, $Enumerable_reject$83, $Enumerable_reverse_each$85, $Enumerable_slice_before$87, $Enumerable_slice_after$89, $Enumerable_slice_when$92, $Enumerable_sort$94, $Enumerable_sort_by$96, $Enumerable_sum$101, $Enumerable_take$103, $Enumerable_take_while$104, $Enumerable_uniq$106, $Enumerable_tally$108, $Enumerable_to_h$109, $Enumerable_zip$110;

    
    
    function comparableForPattern(value) {
      if (value.length === 0) {
        value = [nil];
      }

      if (value.length > 1) {
        value = [value];
      }

      return value;
    }
  ;
    
    Opal.def(self, '$all?', $Enumerable_all$ques$1 = function(pattern) {try {

      var $iter = $Enumerable_all$ques$1.$$p, block = $iter || nil, $$2, $$3, $$4, self = this;

      if ($iter) $Enumerable_all$ques$1.$$p = null;
      
      
      if ($iter) $Enumerable_all$ques$1.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$2 = function($a){var self = $$2.$$s == null ? this : $$2.$$s, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$2.$$s = self, $$2.$$arity = -1, $$2))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$3 = function($a){var self = $$3.$$s == null ? this : $$3.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$3.$$s = self, $$3.$$arity = -1, $$3))
      } else {
        $send(self, 'each', [], ($$4 = function($a){var self = $$4.$$s == null ? this : $$4.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$4.$$s = self, $$4.$$arity = -1, $$4))
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_all$ques$1.$$arity = -1);
    
    Opal.def(self, '$any?', $Enumerable_any$ques$5 = function(pattern) {try {

      var $iter = $Enumerable_any$ques$5.$$p, block = $iter || nil, $$6, $$7, $$8, self = this;

      if ($iter) $Enumerable_any$ques$5.$$p = null;
      
      
      if ($iter) $Enumerable_any$ques$5.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$6 = function($a){var self = $$6.$$s == null ? this : $$6.$$s, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$6.$$s = self, $$6.$$arity = -1, $$6))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$7 = function($a){var self = $$7.$$s == null ? this : $$7.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$7.$$s = self, $$7.$$arity = -1, $$7))
      } else {
        $send(self, 'each', [], ($$8 = function($a){var self = $$8.$$s == null ? this : $$8.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$8.$$s = self, $$8.$$arity = -1, $$8))
      };
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_any$ques$5.$$arity = -1);
    
    Opal.def(self, '$chunk', $Enumerable_chunk$9 = function $$chunk() {
      var $iter = $Enumerable_chunk$9.$$p, block = $iter || nil, $$10, $$11, self = this;

      if ($iter) $Enumerable_chunk$9.$$p = null;
      
      
      if ($iter) $Enumerable_chunk$9.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'to_enum', ["chunk"], ($$10 = function(){var self = $$10.$$s == null ? this : $$10.$$s;

        return self.$enumerator_size()}, $$10.$$s = self, $$10.$$arity = 0, $$10))
      };
      return $send($$$('::', 'Enumerator'), 'new', [], ($$11 = function(yielder){var self = $$11.$$s == null ? this : $$11.$$s;

      
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var previous = nil, accumulate = [];

        function releaseAccumulate() {
          if (accumulate.length > 0) {
            yielder.$yield(previous, accumulate)
          }
        }

        self.$each.$$p = function(value) {
          var key = Opal.yield1(block, value);

          if (key === nil) {
            releaseAccumulate();
            accumulate = [];
            previous = nil;
          } else {
            if (previous === nil || previous === key) {
              accumulate.push(value);
            } else {
              releaseAccumulate();
              accumulate = [value];
            }

            previous = key;
          }
        }

        self.$each();

        releaseAccumulate();
      ;}, $$11.$$s = self, $$11.$$arity = 1, $$11));
    }, $Enumerable_chunk$9.$$arity = 0);
    
    Opal.def(self, '$chunk_while', $Enumerable_chunk_while$12 = function $$chunk_while() {
      var $iter = $Enumerable_chunk_while$12.$$p, block = $iter || nil, $$13, self = this;

      if ($iter) $Enumerable_chunk_while$12.$$p = null;
      
      
      if ($iter) $Enumerable_chunk_while$12.$$p = null;;
      if ((block !== nil)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "no block given")
      };
      return $send(self, 'slice_when', [], ($$13 = function(before, after){var self = $$13.$$s == null ? this : $$13.$$s;

      
        
        if (before == null) {
          before = nil;
        };
        
        if (after == null) {
          after = nil;
        };
        return Opal.yieldX(block, [before, after])['$!']();}, $$13.$$s = self, $$13.$$arity = 2, $$13));
    }, $Enumerable_chunk_while$12.$$arity = 0);
    
    Opal.def(self, '$collect', $Enumerable_collect$14 = function $$collect() {
      var $iter = $Enumerable_collect$14.$$p, block = $iter || nil, $$15, self = this;

      if ($iter) $Enumerable_collect$14.$$p = null;
      
      
      if ($iter) $Enumerable_collect$14.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect"], ($$15 = function(){var self = $$15.$$s == null ? this : $$15.$$s;

        return self.$enumerator_size()}, $$15.$$s = self, $$15.$$arity = 0, $$15))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var value = Opal.yieldX(block, arguments);

        result.push(value);
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_collect$14.$$arity = 0);
    
    Opal.def(self, '$collect_concat', $Enumerable_collect_concat$16 = function $$collect_concat() {
      var $iter = $Enumerable_collect_concat$16.$$p, block = $iter || nil, $$17, $$18, self = this;

      if ($iter) $Enumerable_collect_concat$16.$$p = null;
      
      
      if ($iter) $Enumerable_collect_concat$16.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect_concat"], ($$17 = function(){var self = $$17.$$s == null ? this : $$17.$$s;

        return self.$enumerator_size()}, $$17.$$s = self, $$17.$$arity = 0, $$17))
      };
      return $send(self, 'map', [], ($$18 = function(item){var self = $$18.$$s == null ? this : $$18.$$s;

      
        
        if (item == null) {
          item = nil;
        };
        return Opal.yield1(block, item);;}, $$18.$$s = self, $$18.$$arity = 1, $$18)).$flatten(1);
    }, $Enumerable_collect_concat$16.$$arity = 0);
    
    Opal.def(self, '$count', $Enumerable_count$19 = function $$count(object) {
      var $iter = $Enumerable_count$19.$$p, block = $iter || nil, $$20, $$21, $$22, self = this, result = nil;

      if ($iter) $Enumerable_count$19.$$p = null;
      
      
      if ($iter) $Enumerable_count$19.$$p = null;;
      ;
      result = 0;
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      if ($truthy(object != null)) {
        block = $send(self, 'proc', [], ($$20 = function($a){var self = $$20.$$s == null ? this : $$20.$$s, $post_args, args;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $$($nesting, 'Opal').$destructure(args)['$=='](object);}, $$20.$$s = self, $$20.$$arity = -1, $$20))
      } else if ($truthy(block['$nil?']())) {
        block = $send(self, 'proc', [], ($$21 = function(){var self = $$21.$$s == null ? this : $$21.$$s;

        return true}, $$21.$$s = self, $$21.$$arity = 0, $$21))};
      $send(self, 'each', [], ($$22 = function($a){var self = $$22.$$s == null ? this : $$22.$$s, $post_args, args;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        if ($truthy(Opal.yieldX(block, args))) {
          return result++;
        } else {
          return nil
        };}, $$22.$$s = self, $$22.$$arity = -1, $$22));
      return result;
    }, $Enumerable_count$19.$$arity = -1);
    
    Opal.def(self, '$cycle', $Enumerable_cycle$23 = function $$cycle(n) {
      var $iter = $Enumerable_cycle$23.$$p, block = $iter || nil, $$24, self = this;

      if ($iter) $Enumerable_cycle$23.$$p = null;
      
      
      if ($iter) $Enumerable_cycle$23.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["cycle", n], ($$24 = function(){var self = $$24.$$s == null ? this : $$24.$$s;

        if ($truthy(n['$nil?']())) {
            if ($truthy(self['$respond_to?']("size"))) {
              return $$$($$($nesting, 'Float'), 'INFINITY')
            } else {
              return nil
            }
          } else {
            
            n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, $$24.$$s = self, $$24.$$arity = 0, $$24))
      };
      if ($truthy(n['$nil?']())) {
      } else {
        
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        if ($truthy(n <= 0)) {
          return nil};
      };
      
      var all = [], i, length, value;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        all.push(param);
      }

      self.$each();

      if (all.length === 0) {
        return nil;
      }

      if (n === nil) {
        while (true) {
          for (i = 0, length = all.length; i < length; i++) {
            value = Opal.yield1(block, all[i]);
          }
        }
      }
      else {
        while (n > 1) {
          for (i = 0, length = all.length; i < length; i++) {
            value = Opal.yield1(block, all[i]);
          }

          n--;
        }
      }
    ;
    }, $Enumerable_cycle$23.$$arity = -1);
    
    Opal.def(self, '$detect', $Enumerable_detect$25 = function $$detect(ifnone) {try {

      var $iter = $Enumerable_detect$25.$$p, block = $iter || nil, $$26, self = this;

      if ($iter) $Enumerable_detect$25.$$p = null;
      
      
      if ($iter) $Enumerable_detect$25.$$p = null;;
      ;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("detect", ifnone)
      };
      $send(self, 'each', [], ($$26 = function($a){var self = $$26.$$s == null ? this : $$26.$$s, $post_args, args, value = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
          Opal.ret(value)
        } else {
          return nil
        };}, $$26.$$s = self, $$26.$$arity = -1, $$26));
      
      if (ifnone !== undefined) {
        if (typeof(ifnone) === 'function') {
          return ifnone();
        } else {
          return ifnone;
        }
      }
    ;
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_detect$25.$$arity = -1);
    
    Opal.def(self, '$drop', $Enumerable_drop$27 = function $$drop(number) {
      var self = this;

      
      number = $coerce_to(number, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(number < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "attempt to drop negative size")};
      
      var result  = [],
          current = 0;

      self.$each.$$p = function() {
        if (number <= current) {
          result.push($$($nesting, 'Opal').$destructure(arguments));
        }

        current++;
      };

      self.$each()

      return result;
    ;
    }, $Enumerable_drop$27.$$arity = 1);
    
    Opal.def(self, '$drop_while', $Enumerable_drop_while$28 = function $$drop_while() {
      var $iter = $Enumerable_drop_while$28.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_drop_while$28.$$p = null;
      
      
      if ($iter) $Enumerable_drop_while$28.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("drop_while")
      };
      
      var result   = [],
          dropping = true;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        if (dropping) {
          var value = Opal.yield1(block, param);

          if ($falsy(value)) {
            dropping = false;
            result.push(param);
          }
        }
        else {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_drop_while$28.$$arity = 0);
    
    Opal.def(self, '$each_cons', $Enumerable_each_cons$29 = function $$each_cons(n) {
      var $iter = $Enumerable_each_cons$29.$$p, block = $iter || nil, $$30, self = this;

      if ($iter) $Enumerable_each_cons$29.$$p = null;
      
      
      if ($iter) $Enumerable_each_cons$29.$$p = null;;
      if ($truthy(arguments.length != 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 1)")};
      n = $$($nesting, 'Opal').$try_convert(n, $$($nesting, 'Integer'), "to_int");
      if ($truthy(n <= 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "invalid size")};
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_cons", n], ($$30 = function(){var self = $$30.$$s == null ? this : $$30.$$s, enum_size = nil, $ret_or_1 = nil;

        
          enum_size = self.$enumerator_size();
          if ($truthy(enum_size['$nil?']())) {
            return nil
          } else if ($truthy((function() {if ($truthy(($ret_or_1 = enum_size['$=='](0)))) {
            return $ret_or_1
          } else {
            return $rb_lt(enum_size, n)
          }; return nil; })())) {
            return 0
          } else {
            return $rb_plus($rb_minus(enum_size, n), 1)
          };}, $$30.$$s = self, $$30.$$arity = 0, $$30))
      };
      
      var buffer = [];

      self.$each.$$p = function() {
        var element = $$($nesting, 'Opal').$destructure(arguments);
        buffer.push(element);
        if (buffer.length > n) {
          buffer.shift();
        }
        if (buffer.length == n) {
          Opal.yield1(block, buffer.slice(0, n));
        }
      }

      self.$each();

      return nil;
    ;
    }, $Enumerable_each_cons$29.$$arity = 1);
    
    Opal.def(self, '$each_entry', $Enumerable_each_entry$31 = function $$each_entry($a) {
      var $iter = $Enumerable_each_entry$31.$$p, block = $iter || nil, $post_args, data, $$32, self = this;

      if ($iter) $Enumerable_each_entry$31.$$p = null;
      
      
      if ($iter) $Enumerable_each_entry$31.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      data = $post_args;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'to_enum', ["each_entry"].concat(Opal.to_a(data)), ($$32 = function(){var self = $$32.$$s == null ? this : $$32.$$s;

        return self.$enumerator_size()}, $$32.$$s = self, $$32.$$arity = 0, $$32))
      };
      
      self.$each.$$p = function() {
        var item = $$($nesting, 'Opal').$destructure(arguments);

        Opal.yield1(block, item);
      }

      self.$each.apply(self, data);

      return self;
    ;
    }, $Enumerable_each_entry$31.$$arity = -1);
    
    Opal.def(self, '$each_slice', $Enumerable_each_slice$33 = function $$each_slice(n) {
      var $iter = $Enumerable_each_slice$33.$$p, block = $iter || nil, $$34, self = this;

      if ($iter) $Enumerable_each_slice$33.$$p = null;
      
      
      if ($iter) $Enumerable_each_slice$33.$$p = null;;
      n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(n <= 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "invalid slice size")};
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_slice", n], ($$34 = function(){var self = $$34.$$s == null ? this : $$34.$$s;

        if ($truthy(self['$respond_to?']("size"))) {
            return $rb_divide(self.$size(), n).$ceil()
          } else {
            return nil
          }}, $$34.$$s = self, $$34.$$arity = 0, $$34))
      };
      
      var slice = []

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        slice.push(param);

        if (slice.length === n) {
          Opal.yield1(block, slice);
          slice = [];
        }
      };

      self.$each();

      // our "last" group, if smaller than n then won't have been yielded
      if (slice.length > 0) {
        Opal.yield1(block, slice);
      }
    ;
      return nil;
    }, $Enumerable_each_slice$33.$$arity = 1);
    
    Opal.def(self, '$each_with_index', $Enumerable_each_with_index$35 = function $$each_with_index($a) {
      var $iter = $Enumerable_each_with_index$35.$$p, block = $iter || nil, $post_args, args, $$36, self = this;

      if ($iter) $Enumerable_each_with_index$35.$$p = null;
      
      
      if ($iter) $Enumerable_each_with_index$35.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_index"].concat(Opal.to_a(args)), ($$36 = function(){var self = $$36.$$s == null ? this : $$36.$$s;

        return self.$enumerator_size()}, $$36.$$s = self, $$36.$$arity = 0, $$36))
      };
      
      var index = 0;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        block(param, index);

        index++;
      };

      self.$each.apply(self, args);
    ;
      return self;
    }, $Enumerable_each_with_index$35.$$arity = -1);
    
    Opal.def(self, '$each_with_object', $Enumerable_each_with_object$37 = function $$each_with_object(object) {
      var $iter = $Enumerable_each_with_object$37.$$p, block = $iter || nil, $$38, self = this;

      if ($iter) $Enumerable_each_with_object$37.$$p = null;
      
      
      if ($iter) $Enumerable_each_with_object$37.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_object", object], ($$38 = function(){var self = $$38.$$s == null ? this : $$38.$$s;

        return self.$enumerator_size()}, $$38.$$s = self, $$38.$$arity = 0, $$38))
      };
      
      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        block(param, object);
      };

      self.$each();
    ;
      return object;
    }, $Enumerable_each_with_object$37.$$arity = 1);
    
    Opal.def(self, '$entries', $Enumerable_entries$39 = function $$entries($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = [];

      self.$each.$$p = function() {
        result.push($$($nesting, 'Opal').$destructure(arguments));
      };

      self.$each.apply(self, args);

      return result;
    ;
    }, $Enumerable_entries$39.$$arity = -1);
    
    Opal.def(self, '$filter_map', $Enumerable_filter_map$40 = function $$filter_map() {
      var $iter = $Enumerable_filter_map$40.$$p, block = $iter || nil, $$41, self = this;

      if ($iter) $Enumerable_filter_map$40.$$p = null;
      
      
      if ($iter) $Enumerable_filter_map$40.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["filter_map"], ($$41 = function(){var self = $$41.$$s == null ? this : $$41.$$s;

        return self.$enumerator_size()}, $$41.$$s = self, $$41.$$arity = 0, $$41))
      };
      return $send($send(self, 'map', [], block.$to_proc()), 'select', [], "itself".$to_proc());
    }, $Enumerable_filter_map$40.$$arity = 0);
    Opal.alias(self, "find", "detect");
    
    Opal.def(self, '$find_all', $Enumerable_find_all$42 = function $$find_all() {
      var $iter = $Enumerable_find_all$42.$$p, block = $iter || nil, $$43, self = this;

      if ($iter) $Enumerable_find_all$42.$$p = null;
      
      
      if ($iter) $Enumerable_find_all$42.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["find_all"], ($$43 = function(){var self = $$43.$$s == null ? this : $$43.$$s;

        return self.$enumerator_size()}, $$43.$$s = self, $$43.$$arity = 0, $$43))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_find_all$42.$$arity = 0);
    Opal.alias(self, "filter", "find_all");
    
    Opal.def(self, '$find_index', $Enumerable_find_index$44 = function $$find_index(object) {try {

      var $iter = $Enumerable_find_index$44.$$p, block = $iter || nil, $$45, $$46, self = this, index = nil;

      if ($iter) $Enumerable_find_index$44.$$p = null;
      
      
      if ($iter) $Enumerable_find_index$44.$$p = null;;
      ;
      if ($truthy(object === undefined && block === nil)) {
        return self.$enum_for("find_index")};
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      index = 0;
      if ($truthy(object != null)) {
        $send(self, 'each', [], ($$45 = function($a){var self = $$45.$$s == null ? this : $$45.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($$($nesting, 'Opal').$destructure(value)['$=='](object)) {
            Opal.ret(index)};
          return index += 1;;}, $$45.$$s = self, $$45.$$arity = -1, $$45))
      } else {
        $send(self, 'each', [], ($$46 = function($a){var self = $$46.$$s == null ? this : $$46.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(index)};
          return index += 1;;}, $$46.$$s = self, $$46.$$arity = -1, $$46))
      };
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_find_index$44.$$arity = -1);
    
    Opal.def(self, '$first', $Enumerable_first$47 = function $$first(number) {try {

      var $$48, $$49, self = this, result = nil, current = nil;

      
      ;
      if ($truthy(number === undefined)) {
        return $send(self, 'each', [], ($$48 = function(value){var self = $$48.$$s == null ? this : $$48.$$s;

        
          
          if (value == null) {
            value = nil;
          };
          Opal.ret(value);}, $$48.$$s = self, $$48.$$arity = 1, $$48))
      } else {
        
        result = [];
        number = $coerce_to(number, $$($nesting, 'Integer'), 'to_int');
        if ($truthy(number < 0)) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to take negative size")};
        if ($truthy(number == 0)) {
          return []};
        current = 0;
        $send(self, 'each', [], ($$49 = function($a){var self = $$49.$$s == null ? this : $$49.$$s, $post_args, args;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          result.push($$($nesting, 'Opal').$destructure(args));
          if ($truthy(number <= ++current)) {
            Opal.ret(result)
          } else {
            return nil
          };}, $$49.$$s = self, $$49.$$arity = -1, $$49));
        return result;
      };
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_first$47.$$arity = -1);
    Opal.alias(self, "flat_map", "collect_concat");
    
    Opal.def(self, '$grep', $Enumerable_grep$50 = function $$grep(pattern) {
      var $iter = $Enumerable_grep$50.$$p, block = $iter || nil, $$51, self = this, result = nil;

      if ($iter) $Enumerable_grep$50.$$p = null;
      
      
      if ($iter) $Enumerable_grep$50.$$p = null;;
      result = [];
      $send(self, 'each', [], ($$51 = function($a){var self = $$51.$$s == null ? this : $$51.$$s, $post_args, value, cmp = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        value = $post_args;;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat(Opal.to_a(cmp))))) {
        } else {
          return nil;
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]};
          value = Opal.yieldX(block, Opal.to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)};
        return result.$push(value);}, $$51.$$s = self, $$51.$$arity = -1, $$51));
      return result;
    }, $Enumerable_grep$50.$$arity = 1);
    
    Opal.def(self, '$grep_v', $Enumerable_grep_v$52 = function $$grep_v(pattern) {
      var $iter = $Enumerable_grep_v$52.$$p, block = $iter || nil, $$53, self = this, result = nil;

      if ($iter) $Enumerable_grep_v$52.$$p = null;
      
      
      if ($iter) $Enumerable_grep_v$52.$$p = null;;
      result = [];
      $send(self, 'each', [], ($$53 = function($a){var self = $$53.$$s == null ? this : $$53.$$s, $post_args, value, cmp = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        value = $post_args;;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat(Opal.to_a(cmp))))) {
          return nil;};
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]};
          value = Opal.yieldX(block, Opal.to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)};
        return result.$push(value);}, $$53.$$s = self, $$53.$$arity = -1, $$53));
      return result;
    }, $Enumerable_grep_v$52.$$arity = 1);
    
    Opal.def(self, '$group_by', $Enumerable_group_by$54 = function $$group_by() {
      var $iter = $Enumerable_group_by$54.$$p, block = $iter || nil, $$55, self = this, hash = nil, $ret_or_2 = nil, $writer = nil;

      if ($iter) $Enumerable_group_by$54.$$p = null;
      
      
      if ($iter) $Enumerable_group_by$54.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["group_by"], ($$55 = function(){var self = $$55.$$s == null ? this : $$55.$$s;

        return self.$enumerator_size()}, $$55.$$s = self, $$55.$$arity = 0, $$55))
      };
      hash = $hash2([], {});
      
      var result;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        (function() {if ($truthy(($ret_or_2 = hash['$[]'](value)))) {
        return $ret_or_2
      } else {
        
        $writer = [value, []];
        $send(hash, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
      }; return nil; })()['$<<'](param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return hash;
    }, $Enumerable_group_by$54.$$arity = 0);
    
    Opal.def(self, '$include?', $Enumerable_include$ques$56 = function(obj) {try {

      var $$57, self = this;

      
      $send(self, 'each', [], ($$57 = function($a){var self = $$57.$$s == null ? this : $$57.$$s, $post_args, args;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        if ($$($nesting, 'Opal').$destructure(args)['$=='](obj)) {
          Opal.ret(true)
        } else {
          return nil
        };}, $$57.$$s = self, $$57.$$arity = -1, $$57));
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_include$ques$56.$$arity = 1);
    
    Opal.def(self, '$inject', $Enumerable_inject$58 = function $$inject(object, sym) {
      var $iter = $Enumerable_inject$58.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_inject$58.$$p = null;
      
      
      if ($iter) $Enumerable_inject$58.$$p = null;;
      ;
      ;
      
      var result = object;

      if (block !== nil && sym === undefined) {
        self.$each.$$p = function() {
          var value = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          value = Opal.yieldX(block, [result, value]);

          result = value;
        };
      }
      else {
        if (sym === undefined) {
          if (!$$($nesting, 'Symbol')['$==='](object)) {
            self.$raise($$($nesting, 'TypeError'), "" + (object.$inspect()) + " is not a Symbol");
          }

          sym    = object;
          result = undefined;
        }

        self.$each.$$p = function() {
          var value = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          result = (result).$__send__(sym, value);
        };
      }

      self.$each();

      return result == undefined ? nil : result;
    ;
    }, $Enumerable_inject$58.$$arity = -1);
    
    Opal.def(self, '$lazy', $Enumerable_lazy$59 = function $$lazy() {
      var $$60, self = this;

      return $send($$$($$($nesting, 'Enumerator'), 'Lazy'), 'new', [self, self.$enumerator_size()], ($$60 = function(enum$, $a){var self = $$60.$$s == null ? this : $$60.$$s, $post_args, args;

      
        
        if (enum$ == null) {
          enum$ = nil;
        };
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        args = $post_args;;
        return $send(enum$, 'yield', Opal.to_a(args));}, $$60.$$s = self, $$60.$$arity = -2, $$60))
    }, $Enumerable_lazy$59.$$arity = 0);
    
    Opal.def(self, '$enumerator_size', $Enumerable_enumerator_size$61 = function $$enumerator_size() {
      var self = this;

      if ($truthy(self['$respond_to?']("size"))) {
        return self.$size()
      } else {
        return nil
      }
    }, $Enumerable_enumerator_size$61.$$arity = 0);
    Opal.alias(self, "map", "collect");
    
    Opal.def(self, '$max', $Enumerable_max$62 = function $$max(n) {
      var $iter = $Enumerable_max$62.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_max$62.$$p = null;
      
      
      if ($iter) $Enumerable_max$62.$$p = null;;
      ;
      
      if (n === undefined || n === nil) {
        var result, value;

        self.$each.$$p = function() {
          var item = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = item;
            return;
          }

          if (block !== nil) {
            value = Opal.yieldX(block, [item, result]);
          } else {
            value = (item)['$<=>'](result);
          }

          if (value === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed");
          }

          if (value > 0) {
            result = item;
          }
        }

        self.$each();

        if (result === undefined) {
          return nil;
        } else {
          return result;
        }
      }

      n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
    ;
      return $send(self, 'sort', [], block.$to_proc()).$reverse().$first(n);
    }, $Enumerable_max$62.$$arity = -1);
    
    Opal.def(self, '$max_by', $Enumerable_max_by$63 = function $$max_by(n) {
      var $iter = $Enumerable_max_by$63.$$p, block = $iter || nil, $$64, self = this;

      if ($iter) $Enumerable_max_by$63.$$p = null;
      
      
      if ($iter) $Enumerable_max_by$63.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["max_by", n], ($$64 = function(){var self = $$64.$$s == null ? this : $$64.$$s;

        return self.$enumerator_size()}, $$64.$$s = self, $$64.$$arity = 0, $$64))
      };
      if ($truthy(n['$nil?']())) {
      } else {
        return $send(self, 'sort_by', [], block.$to_proc()).$reverse().$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) > 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_max_by$63.$$arity = -1);
    Opal.alias(self, "member?", "include?");
    
    Opal.def(self, '$min', $Enumerable_min$65 = function $$min(n) {
      var $iter = $Enumerable_min$65.$$p, block = $iter || nil, $$66, self = this;

      if ($iter) $Enumerable_min$65.$$p = null;
      
      
      if ($iter) $Enumerable_min$65.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ($truthy(n['$nil?']())) {
      } else if ((block !== nil)) {
        return $send(self, 'sort', [], ($$66 = function(a, b){var self = $$66.$$s == null ? this : $$66.$$s;

        
          
          if (a == null) {
            a = nil;
          };
          
          if (b == null) {
            b = nil;
          };
          return Opal.yieldX(block, [a, b]);;}, $$66.$$s = self, $$66.$$arity = 2, $$66)).$take(n)
      } else {
        return self.$sort().$take(n)
      };
      
      var result;

      if (block !== nil) {
        self.$each.$$p = function() {
          var param = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          var value = block(param, result);

          if (value === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed");
          }

          if (value < 0) {
            result = param;
          }
        };
      }
      else {
        self.$each.$$p = function() {
          var param = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          if ($$($nesting, 'Opal').$compare(param, result) < 0) {
            result = param;
          }
        };
      }

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_min$65.$$arity = -1);
    
    Opal.def(self, '$min_by', $Enumerable_min_by$67 = function $$min_by(n) {
      var $iter = $Enumerable_min_by$67.$$p, block = $iter || nil, $$68, self = this;

      if ($iter) $Enumerable_min_by$67.$$p = null;
      
      
      if ($iter) $Enumerable_min_by$67.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["min_by", n], ($$68 = function(){var self = $$68.$$s == null ? this : $$68.$$s;

        return self.$enumerator_size()}, $$68.$$s = self, $$68.$$arity = 0, $$68))
      };
      if ($truthy(n['$nil?']())) {
      } else {
        return $send(self, 'sort_by', [], block.$to_proc()).$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) < 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_min_by$67.$$arity = -1);
    
    Opal.def(self, '$minmax', $Enumerable_minmax$69 = function $$minmax() {
      var $iter = $Enumerable_minmax$69.$$p, block = $iter || nil, $$70, self = this, $ret_or_3 = nil;

      if ($iter) $Enumerable_minmax$69.$$p = null;
      
      
      if ($iter) $Enumerable_minmax$69.$$p = null;;
      block = (function() {if ($truthy(($ret_or_3 = block))) {
        return $ret_or_3
      } else {
        return $send(self, 'proc', [], ($$70 = function(a, b){var self = $$70.$$s == null ? this : $$70.$$s;

        
          
          if (a == null) {
            a = nil;
          };
          
          if (b == null) {
            b = nil;
          };
          return a['$<=>'](b);}, $$70.$$s = self, $$70.$$arity = 2, $$70))
      }; return nil; })();
      
      var min = nil, max = nil, first_time = true;

      self.$each.$$p = function() {
        var element = $$($nesting, 'Opal').$destructure(arguments);
        if (first_time) {
          min = max = element;
          first_time = false;
        } else {
          var min_cmp = block.$call(min, element);

          if (min_cmp === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed")
          } else if (min_cmp > 0) {
            min = element;
          }

          var max_cmp = block.$call(max, element);

          if (max_cmp === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed")
          } else if (max_cmp < 0) {
            max = element;
          }
        }
      }

      self.$each();

      return [min, max];
    ;
    }, $Enumerable_minmax$69.$$arity = 0);
    
    Opal.def(self, '$minmax_by', $Enumerable_minmax_by$71 = function $$minmax_by() {
      var $iter = $Enumerable_minmax_by$71.$$p, block = $iter || nil, $$72, self = this;

      if ($iter) $Enumerable_minmax_by$71.$$p = null;
      
      
      if ($iter) $Enumerable_minmax_by$71.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["minmax_by"], ($$72 = function(){var self = $$72.$$s == null ? this : $$72.$$s;

        return self.$enumerator_size()}, $$72.$$s = self, $$72.$$arity = 0, $$72))
      };
      
      var min_result = nil,
          max_result = nil,
          min_by,
          max_by;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ((min_by === undefined) || (value)['$<=>'](min_by) < 0) {
          min_result = param;
          min_by     = value;
        }

        if ((max_by === undefined) || (value)['$<=>'](max_by) > 0) {
          max_result = param;
          max_by     = value;
        }
      };

      self.$each();

      return [min_result, max_result];
    ;
    }, $Enumerable_minmax_by$71.$$arity = 0);
    
    Opal.def(self, '$none?', $Enumerable_none$ques$73 = function(pattern) {try {

      var $iter = $Enumerable_none$ques$73.$$p, block = $iter || nil, $$74, $$75, $$76, self = this;

      if ($iter) $Enumerable_none$ques$73.$$p = null;
      
      
      if ($iter) $Enumerable_none$ques$73.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$74 = function($a){var self = $$74.$$s == null ? this : $$74.$$s, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$74.$$s = self, $$74.$$arity = -1, $$74))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$75 = function($a){var self = $$75.$$s == null ? this : $$75.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$75.$$s = self, $$75.$$arity = -1, $$75))
      } else {
        $send(self, 'each', [], ($$76 = function($a){var self = $$76.$$s == null ? this : $$76.$$s, $post_args, value, item = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          item = $$($nesting, 'Opal').$destructure(value);
          if ($truthy(item)) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$76.$$s = self, $$76.$$arity = -1, $$76))
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_none$ques$73.$$arity = -1);
    
    Opal.def(self, '$one?', $Enumerable_one$ques$77 = function(pattern) {try {

      var $iter = $Enumerable_one$ques$77.$$p, block = $iter || nil, $$78, $$79, $$80, self = this, count = nil;

      if ($iter) $Enumerable_one$ques$77.$$p = null;
      
      
      if ($iter) $Enumerable_one$ques$77.$$p = null;;
      ;
      count = 0;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$78 = function($a){var self = $$78.$$s == null ? this : $$78.$$s, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            
            count = $rb_plus(count, 1);
            if ($truthy($rb_gt(count, 1))) {
              Opal.ret(false)
            } else {
              return nil
            };
          } else {
            return nil
          };}, $$78.$$s = self, $$78.$$arity = -1, $$78))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$79 = function($a){var self = $$79.$$s == null ? this : $$79.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
          } else {
            return nil;
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$79.$$s = self, $$79.$$arity = -1, $$79))
      } else {
        $send(self, 'each', [], ($$80 = function($a){var self = $$80.$$s == null ? this : $$80.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
          } else {
            return nil;
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$80.$$s = self, $$80.$$arity = -1, $$80))
      };
      return count['$=='](1);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_one$ques$77.$$arity = -1);
    
    Opal.def(self, '$partition', $Enumerable_partition$81 = function $$partition() {
      var $iter = $Enumerable_partition$81.$$p, block = $iter || nil, $$82, self = this;

      if ($iter) $Enumerable_partition$81.$$p = null;
      
      
      if ($iter) $Enumerable_partition$81.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["partition"], ($$82 = function(){var self = $$82.$$s == null ? this : $$82.$$s;

        return self.$enumerator_size()}, $$82.$$s = self, $$82.$$arity = 0, $$82))
      };
      
      var truthy = [], falsy = [], result;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($truthy(value)) {
          truthy.push(param);
        }
        else {
          falsy.push(param);
        }
      };

      self.$each();

      return [truthy, falsy];
    ;
    }, $Enumerable_partition$81.$$arity = 0);
    Opal.alias(self, "reduce", "inject");
    
    Opal.def(self, '$reject', $Enumerable_reject$83 = function $$reject() {
      var $iter = $Enumerable_reject$83.$$p, block = $iter || nil, $$84, self = this;

      if ($iter) $Enumerable_reject$83.$$p = null;
      
      
      if ($iter) $Enumerable_reject$83.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$84 = function(){var self = $$84.$$s == null ? this : $$84.$$s;

        return self.$enumerator_size()}, $$84.$$s = self, $$84.$$arity = 0, $$84))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($falsy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_reject$83.$$arity = 0);
    
    Opal.def(self, '$reverse_each', $Enumerable_reverse_each$85 = function $$reverse_each() {
      var $iter = $Enumerable_reverse_each$85.$$p, block = $iter || nil, $$86, self = this;

      if ($iter) $Enumerable_reverse_each$85.$$p = null;
      
      
      if ($iter) $Enumerable_reverse_each$85.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reverse_each"], ($$86 = function(){var self = $$86.$$s == null ? this : $$86.$$s;

        return self.$enumerator_size()}, $$86.$$s = self, $$86.$$arity = 0, $$86))
      };
      
      var result = [];

      self.$each.$$p = function() {
        result.push(arguments);
      };

      self.$each();

      for (var i = result.length - 1; i >= 0; i--) {
        Opal.yieldX(block, result[i]);
      }

      return result;
    ;
    }, $Enumerable_reverse_each$85.$$arity = 0);
    Opal.alias(self, "select", "find_all");
    
    Opal.def(self, '$slice_before', $Enumerable_slice_before$87 = function $$slice_before(pattern) {
      var $iter = $Enumerable_slice_before$87.$$p, block = $iter || nil, $$88, self = this;

      if ($iter) $Enumerable_slice_before$87.$$p = null;
      
      
      if ($iter) $Enumerable_slice_before$87.$$p = null;;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "both pattern and block are given")};
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " expected 1)")};
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$88 = function(e){var self = $$88.$$s == null ? this : $$88.$$s;

      
        
        if (e == null) {
          e = nil;
        };
        
        var slice = [];

        if (block !== nil) {
          if (pattern === undefined) {
            self.$each.$$p = function() {
              var param = $$($nesting, 'Opal').$destructure(arguments),
                  value = Opal.yield1(block, param);

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
          else {
            self.$each.$$p = function() {
              var param = $$($nesting, 'Opal').$destructure(arguments),
                  value = block(param, pattern.$dup());

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
        }
        else {
          self.$each.$$p = function() {
            var param = $$($nesting, 'Opal').$destructure(arguments),
                value = pattern['$==='](param);

            if ($truthy(value) && slice.length > 0) {
              e['$<<'](slice);
              slice = [];
            }

            slice.push(param);
          };
        }

        self.$each();

        if (slice.length > 0) {
          e['$<<'](slice);
        }
      ;}, $$88.$$s = self, $$88.$$arity = 1, $$88));
    }, $Enumerable_slice_before$87.$$arity = -1);
    
    Opal.def(self, '$slice_after', $Enumerable_slice_after$89 = function $$slice_after(pattern) {
      var $iter = $Enumerable_slice_after$89.$$p, block = $iter || nil, $$90, $$91, self = this;

      if ($iter) $Enumerable_slice_after$89.$$p = null;
      
      
      if ($iter) $Enumerable_slice_after$89.$$p = null;;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "both pattern and block are given")};
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " expected 1)")};
      if ($truthy(pattern !== undefined)) {
        block = $send(self, 'proc', [], ($$90 = function(e){var self = $$90.$$s == null ? this : $$90.$$s;

        
          
          if (e == null) {
            e = nil;
          };
          return pattern['$==='](e);}, $$90.$$s = self, $$90.$$arity = 1, $$90))};
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$91 = function(yielder){var self = $$91.$$s == null ? this : $$91.$$s;

      
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var accumulate;

        self.$each.$$p = function() {
          var element = $$($nesting, 'Opal').$destructure(arguments),
              end_chunk = Opal.yield1(block, element);

          if (accumulate == null) {
            accumulate = [];
          }

          if ($truthy(end_chunk)) {
            accumulate.push(element);
            yielder.$yield(accumulate);
            accumulate = null;
          } else {
            accumulate.push(element)
          }
        }

        self.$each();

        if (accumulate != null) {
          yielder.$yield(accumulate);
        }
      ;}, $$91.$$s = self, $$91.$$arity = 1, $$91));
    }, $Enumerable_slice_after$89.$$arity = -1);
    
    Opal.def(self, '$slice_when', $Enumerable_slice_when$92 = function $$slice_when() {
      var $iter = $Enumerable_slice_when$92.$$p, block = $iter || nil, $$93, self = this;

      if ($iter) $Enumerable_slice_when$92.$$p = null;
      
      
      if ($iter) $Enumerable_slice_when$92.$$p = null;;
      if ((block !== nil)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1)")
      };
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$93 = function(yielder){var self = $$93.$$s == null ? this : $$93.$$s;

      
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var slice = nil, last_after = nil;

        self.$each_cons.$$p = function() {
          var params = $$($nesting, 'Opal').$destructure(arguments),
              before = params[0],
              after = params[1],
              match = Opal.yieldX(block, [before, after]);

          last_after = after;

          if (slice === nil) {
            slice = [];
          }

          if ($truthy(match)) {
            slice.push(before);
            yielder.$yield(slice);
            slice = [];
          } else {
            slice.push(before);
          }
        }

        self.$each_cons(2);

        if (slice !== nil) {
          slice.push(last_after);
          yielder.$yield(slice);
        }
      ;}, $$93.$$s = self, $$93.$$arity = 1, $$93));
    }, $Enumerable_slice_when$92.$$arity = 0);
    
    Opal.def(self, '$sort', $Enumerable_sort$94 = function $$sort() {
      var $iter = $Enumerable_sort$94.$$p, block = $iter || nil, $$95, self = this, ary = nil;

      if ($iter) $Enumerable_sort$94.$$p = null;
      
      
      if ($iter) $Enumerable_sort$94.$$p = null;;
      ary = self.$to_a();
      if ((block !== nil)) {
      } else {
        block = $lambda(($$95 = function(a, b){var self = $$95.$$s == null ? this : $$95.$$s;

        
          
          if (a == null) {
            a = nil;
          };
          
          if (b == null) {
            b = nil;
          };
          return a['$<=>'](b);}, $$95.$$s = self, $$95.$$arity = 2, $$95))
      };
      return $send(ary, 'sort', [], block.$to_proc());
    }, $Enumerable_sort$94.$$arity = 0);
    
    Opal.def(self, '$sort_by', $Enumerable_sort_by$96 = function $$sort_by() {
      var $iter = $Enumerable_sort_by$96.$$p, block = $iter || nil, $$97, $$98, $$99, $$100, self = this, dup = nil;

      if ($iter) $Enumerable_sort_by$96.$$p = null;
      
      
      if ($iter) $Enumerable_sort_by$96.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["sort_by"], ($$97 = function(){var self = $$97.$$s == null ? this : $$97.$$s;

        return self.$enumerator_size()}, $$97.$$s = self, $$97.$$arity = 0, $$97))
      };
      dup = $send(self, 'map', [], ($$98 = function(){var self = $$98.$$s == null ? this : $$98.$$s, arg = nil;

      
        arg = $$($nesting, 'Opal').$destructure(arguments);
        return [Opal.yield1(block, arg), arg];}, $$98.$$s = self, $$98.$$arity = 0, $$98));
      $send(dup, 'sort!', [], ($$99 = function(a, b){var self = $$99.$$s == null ? this : $$99.$$s;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return (a[0])['$<=>'](b[0]);}, $$99.$$s = self, $$99.$$arity = 2, $$99));
      return $send(dup, 'map!', [], ($$100 = function(i){var self = $$100.$$s == null ? this : $$100.$$s;

      
        
        if (i == null) {
          i = nil;
        };
        return i[1];;}, $$100.$$s = self, $$100.$$arity = 1, $$100));
    }, $Enumerable_sort_by$96.$$arity = 0);
    
    Opal.def(self, '$sum', $Enumerable_sum$101 = function $$sum(initial) {
      var $$102, $iter = $Enumerable_sum$101.$$p, $yield = $iter || nil, self = this, result = nil;

      if ($iter) $Enumerable_sum$101.$$p = null;
      
      
      if (initial == null) {
        initial = 0;
      };
      result = initial;
      $send(self, 'each', [], ($$102 = function($a){var self = $$102.$$s == null ? this : $$102.$$s, $post_args, args, item = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        item = (function() {if (($yield !== nil)) {
          return Opal.yieldX($yield, Opal.to_a(args));
        } else {
          return $$($nesting, 'Opal').$destructure(args)
        }; return nil; })();
        return (result = $rb_plus(result, item));}, $$102.$$s = self, $$102.$$arity = -1, $$102));
      return result;
    }, $Enumerable_sum$101.$$arity = -1);
    
    Opal.def(self, '$take', $Enumerable_take$103 = function $$take(num) {
      var self = this;

      return self.$first(num)
    }, $Enumerable_take$103.$$arity = 1);
    
    Opal.def(self, '$take_while', $Enumerable_take_while$104 = function $$take_while() {try {

      var $iter = $Enumerable_take_while$104.$$p, block = $iter || nil, $$105, self = this, result = nil;

      if ($iter) $Enumerable_take_while$104.$$p = null;
      
      
      if ($iter) $Enumerable_take_while$104.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$enum_for("take_while")
      };
      result = [];
      return $send(self, 'each', [], ($$105 = function($a){var self = $$105.$$s == null ? this : $$105.$$s, $post_args, args, value = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
        } else {
          Opal.ret(result)
        };
        return result.push(value);;}, $$105.$$s = self, $$105.$$arity = -1, $$105));
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_take_while$104.$$arity = 0);
    
    Opal.def(self, '$uniq', $Enumerable_uniq$106 = function $$uniq() {
      var $iter = $Enumerable_uniq$106.$$p, block = $iter || nil, $$107, self = this, hash = nil;

      if ($iter) $Enumerable_uniq$106.$$p = null;
      
      
      if ($iter) $Enumerable_uniq$106.$$p = null;;
      hash = $hash2([], {});
      $send(self, 'each', [], ($$107 = function($a){var self = $$107.$$s == null ? this : $$107.$$s, $post_args, args, value = nil, produced = nil, $writer = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        produced = (function() {if ((block !== nil)) {
          return Opal.yield1(block, value);
        } else {
          return value
        }; return nil; })();
        if ($truthy(hash['$key?'](produced))) {
          return nil
        } else {
          
          $writer = [produced, value];
          $send(hash, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        };}, $$107.$$s = self, $$107.$$arity = -1, $$107));
      return hash.$values();
    }, $Enumerable_uniq$106.$$arity = 0);
    
    Opal.def(self, '$tally', $Enumerable_tally$108 = function $$tally() {
      var self = this;

      return $send($send(self, 'group_by', [], "itself".$to_proc()), 'transform_values', [], "count".$to_proc())
    }, $Enumerable_tally$108.$$arity = 0);
    Opal.alias(self, "to_a", "entries");
    
    Opal.def(self, '$to_h', $Enumerable_to_h$109 = function $$to_h($a) {
      var $iter = $Enumerable_to_h$109.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Enumerable_to_h$109.$$p = null;
      
      
      if ($iter) $Enumerable_to_h$109.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', Opal.to_a(args))};
      
      var hash = $hash2([], {});

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);
        var ary = $$($nesting, 'Opal')['$coerce_to?'](param, $$($nesting, 'Array'), "to_ary"), key, val;
        if (!ary.$$is_array) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong element type " + ((ary).$class()) + " (expected array)")
        }
        if (ary.length !== 2) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong array length (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];

        Opal.hash_put(hash, key, val);
      };

      self.$each.apply(self, args);

      return hash;
    ;
    }, $Enumerable_to_h$109.$$arity = -1);
    
    Opal.def(self, '$zip', $Enumerable_zip$110 = function $$zip($a) {
      var $iter = $Enumerable_zip$110.$$p, block = $iter || nil, $post_args, others, self = this;

      if ($iter) $Enumerable_zip$110.$$p = null;
      
      
      if ($iter) $Enumerable_zip$110.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      return $send(self.$to_a(), 'zip', Opal.to_a(others));
    }, $Enumerable_zip$110.$$arity = -1);
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/enumerator"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $breaker = Opal.breaker, $slice = Opal.slice, $falsy = Opal.falsy, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $send = Opal.send, $send2 = Opal.send2;

  Opal.add_stubs(['$require', '$include', '$allocate', '$new', '$to_proc', '$!', '$respond_to?', '$nil?', '$empty?', '$+', '$class', '$__send__', '$call', '$enum_for', '$size', '$destructure', '$inspect', '$any?', '$[]', '$raise', '$yield', '$each', '$enumerator_size', '$try_convert', '$<', '$===', '$for']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting), $Enumerator_for$1, $Enumerator_initialize$2, $Enumerator_each$3, $Enumerator_size$4, $Enumerator_with_index$5, $Enumerator_each_with_index$7, $Enumerator_inspect$9;

    self.$$prototype.size = self.$$prototype.args = self.$$prototype.object = self.$$prototype.method = nil;
    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_enumerator = true;
    Opal.defs(self, '$for', $Enumerator_for$1 = function(object, $a, $b) {
      var $iter = $Enumerator_for$1.$$p, block = $iter || nil, $post_args, method, args, self = this;

      if ($iter) $Enumerator_for$1.$$p = null;
      
      
      if ($iter) $Enumerator_for$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      if ($post_args.length > 0) {
        method = $post_args[0];
        $post_args.splice(0, 1);
      }
      if (method == null) {
        method = "each";
      };
      
      args = $post_args;;
      
      var obj = self.$allocate();

      obj.object = object;
      obj.size   = block;
      obj.method = method;
      obj.args   = args;

      return obj;
    ;
    }, $Enumerator_for$1.$$arity = -2);
    
    Opal.def(self, '$initialize', $Enumerator_initialize$2 = function $$initialize($a) {
      var $iter = $Enumerator_initialize$2.$$p, block = $iter || nil, $post_args, self = this, $ret_or_1 = nil;

      if ($iter) $Enumerator_initialize$2.$$p = null;
      
      
      if ($iter) $Enumerator_initialize$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      if ($truthy(block)) {
        
        self.object = $send($$($nesting, 'Generator'), 'new', [], block.$to_proc());
        self.method = "each";
        self.args = [];
        self.size = arguments[0] || nil;
        if ($truthy((function() {if ($truthy(($ret_or_1 = self.size))) {
          return self.size['$respond_to?']("call")['$!']()
        } else {
          return $ret_or_1
        }; return nil; })())) {
          return (self.size = $coerce_to(self.size, $$($nesting, 'Integer'), 'to_int'))
        } else {
          return nil
        };
      } else {
        
        self.object = arguments[0];
        self.method = arguments[1] || "each";
        self.args = $slice.call(arguments, 2);
        return (self.size = nil);
      };
    }, $Enumerator_initialize$2.$$arity = -1);
    
    Opal.def(self, '$each', $Enumerator_each$3 = function $$each($a) {
      var $iter = $Enumerator_each$3.$$p, block = $iter || nil, $post_args, args, self = this, $ret_or_2 = nil;

      if ($iter) $Enumerator_each$3.$$p = null;
      
      
      if ($iter) $Enumerator_each$3.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy((function() {if ($truthy(($ret_or_2 = block['$nil?']()))) {
        return args['$empty?']()
      } else {
        return $ret_or_2
      }; return nil; })())) {
        return self};
      args = $rb_plus(self.args, args);
      if ($truthy(block['$nil?']())) {
        return $send(self.$class(), 'new', [self.object, self.method].concat(Opal.to_a(args)))};
      return $send(self.object, '__send__', [self.method].concat(Opal.to_a(args)), block.$to_proc());
    }, $Enumerator_each$3.$$arity = -1);
    
    Opal.def(self, '$size', $Enumerator_size$4 = function $$size() {
      var self = this;

      if ($truthy(self.size['$respond_to?']("call"))) {
        return $send(self.size, 'call', Opal.to_a(self.args))
      } else {
        return self.size
      }
    }, $Enumerator_size$4.$$arity = 0);
    
    Opal.def(self, '$with_index', $Enumerator_with_index$5 = function $$with_index(offset) {
      var $iter = $Enumerator_with_index$5.$$p, block = $iter || nil, $$6, self = this;

      if ($iter) $Enumerator_with_index$5.$$p = null;
      
      
      if ($iter) $Enumerator_with_index$5.$$p = null;;
      
      if (offset == null) {
        offset = 0;
      };
      offset = (function() {if ($truthy(offset)) {
        return $coerce_to(offset, $$($nesting, 'Integer'), 'to_int')
      } else {
        return 0
      }; return nil; })();
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["with_index", offset], ($$6 = function(){var self = $$6.$$s == null ? this : $$6.$$s;

        return self.$size()}, $$6.$$s = self, $$6.$$arity = 0, $$6))
      };
      
      var result, index = offset;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = block(param, index);

        index++;

        return value;
      }

      return self.$each();
    ;
    }, $Enumerator_with_index$5.$$arity = -1);
    Opal.alias(self, "with_object", "each_with_object");
    
    Opal.def(self, '$each_with_index', $Enumerator_each_with_index$7 = function $$each_with_index() {
      var $iter = $Enumerator_each_with_index$7.$$p, block = $iter || nil, $$8, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Enumerator_each_with_index$7.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Enumerator_each_with_index$7.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_index"], ($$8 = function(){var self = $$8.$$s == null ? this : $$8.$$s;

        return self.$size()}, $$8.$$s = self, $$8.$$arity = 0, $$8))
      };
      $send2(self, Opal.find_super_dispatcher(self, 'each_with_index', $Enumerator_each_with_index$7, false, true), 'each_with_index', $zuper, $iter);
      return self.object;
    }, $Enumerator_each_with_index$7.$$arity = 0);
    
    Opal.def(self, '$inspect', $Enumerator_inspect$9 = function $$inspect() {
      var self = this, result = nil;

      
      result = "" + "#<" + (self.$class()) + ": " + (self.object.$inspect()) + ":" + (self.method);
      if ($truthy(self.args['$any?']())) {
        result = $rb_plus(result, "" + "(" + (self.args.$inspect()['$[]']($$($nesting, 'Range').$new(1, -2))) + ")")};
      return $rb_plus(result, ">");
    }, $Enumerator_inspect$9.$$arity = 0);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Generator');

      var $nesting = [self].concat($parent_nesting), $Generator_initialize$10, $Generator_each$11;

      self.$$prototype.block = nil;
      
      self.$include($$($nesting, 'Enumerable'));
      
      Opal.def(self, '$initialize', $Generator_initialize$10 = function $$initialize() {
        var $iter = $Generator_initialize$10.$$p, block = $iter || nil, self = this;

        if ($iter) $Generator_initialize$10.$$p = null;
        
        
        if ($iter) $Generator_initialize$10.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'LocalJumpError'), "no block given")
        };
        return (self.block = block);
      }, $Generator_initialize$10.$$arity = 0);
      return (Opal.def(self, '$each', $Generator_each$11 = function $$each($a) {
        var $iter = $Generator_each$11.$$p, block = $iter || nil, $post_args, args, self = this, yielder = nil;

        if ($iter) $Generator_each$11.$$p = null;
        
        
        if ($iter) $Generator_each$11.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        yielder = $send($$($nesting, 'Yielder'), 'new', [], block.$to_proc());
        
        try {
          args.unshift(yielder);

          Opal.yieldX(self.block, args);
        }
        catch (e) {
          if (e === $breaker) {
            return $breaker.$v;
          }
          else {
            throw e;
          }
        }
      ;
        return self;
      }, $Generator_each$11.$$arity = -1), nil) && 'each';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Yielder');

      var $nesting = [self].concat($parent_nesting), $Yielder_initialize$12, $Yielder_yield$13, $Yielder_$lt$lt$14;

      self.$$prototype.block = nil;
      
      
      Opal.def(self, '$initialize', $Yielder_initialize$12 = function $$initialize() {
        var $iter = $Yielder_initialize$12.$$p, block = $iter || nil, self = this;

        if ($iter) $Yielder_initialize$12.$$p = null;
        
        
        if ($iter) $Yielder_initialize$12.$$p = null;;
        return (self.block = block);
      }, $Yielder_initialize$12.$$arity = 0);
      
      Opal.def(self, '$yield', $Yielder_yield$13 = function($a) {
        var $post_args, values, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        values = $post_args;;
        
        var value = Opal.yieldX(self.block, values);

        if (value === $breaker) {
          throw $breaker;
        }

        return value;
      ;
      }, $Yielder_yield$13.$$arity = -1);
      return (Opal.def(self, '$<<', $Yielder_$lt$lt$14 = function($a) {
        var $post_args, values, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        values = $post_args;;
        $send(self, 'yield', Opal.to_a(values));
        return self;
      }, $Yielder_$lt$lt$14.$$arity = -1), nil) && '<<';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Lazy');

      var $nesting = [self].concat($parent_nesting), $Lazy_initialize$15, $Lazy_lazy$18, $Lazy_collect$19, $Lazy_collect_concat$21, $Lazy_drop$25, $Lazy_drop_while$27, $Lazy_enum_for$29, $Lazy_find_all$30, $Lazy_grep$32, $Lazy_reject$35, $Lazy_take$37, $Lazy_take_while$39, $Lazy_inspect$41;

      self.$$prototype.enumerator = nil;
      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'StopLazyError');

        var $nesting = [self].concat($parent_nesting);

        return nil
      })($nesting[0], $$($nesting, 'Exception'), $nesting);
      
      Opal.def(self, '$initialize', $Lazy_initialize$15 = function $$initialize(object, size) {
        var $iter = $Lazy_initialize$15.$$p, block = $iter || nil, $$16, self = this;

        if ($iter) $Lazy_initialize$15.$$p = null;
        
        
        if ($iter) $Lazy_initialize$15.$$p = null;;
        
        if (size == null) {
          size = nil;
        };
        if ((block !== nil)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy new without a block")
        };
        self.enumerator = object;
        return $send2(self, Opal.find_super_dispatcher(self, 'initialize', $Lazy_initialize$15, false, true), 'initialize', [size], ($$16 = function(yielder, $a){var self = $$16.$$s == null ? this : $$16.$$s, $post_args, each_args, $$17;

        
          
          if (yielder == null) {
            yielder = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          each_args = $post_args;;
          try {
            return $send(object, 'each', Opal.to_a(each_args), ($$17 = function($b){var self = $$17.$$s == null ? this : $$17.$$s, $post_args, args;

            
              
              $post_args = Opal.slice.call(arguments, 0, arguments.length);
              
              args = $post_args;;
              
            args.unshift(yielder);

            Opal.yieldX(block, args);
          ;}, $$17.$$s = self, $$17.$$arity = -1, $$17))
          } catch ($err) {
            if (Opal.rescue($err, [$$($nesting, 'Exception')])) {
              try {
                return nil
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          };}, $$16.$$s = self, $$16.$$arity = -2, $$16));
      }, $Lazy_initialize$15.$$arity = -2);
      Opal.alias(self, "force", "to_a");
      
      Opal.def(self, '$lazy', $Lazy_lazy$18 = function $$lazy() {
        var self = this;

        return self
      }, $Lazy_lazy$18.$$arity = 0);
      
      Opal.def(self, '$collect', $Lazy_collect$19 = function $$collect() {
        var $iter = $Lazy_collect$19.$$p, block = $iter || nil, $$20, self = this;

        if ($iter) $Lazy_collect$19.$$p = null;
        
        
        if ($iter) $Lazy_collect$19.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, self.$enumerator_size()], ($$20 = function(enum$, $a){var self = $$20.$$s == null ? this : $$20.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          enum$.$yield(value);
        ;}, $$20.$$s = self, $$20.$$arity = -2, $$20));
      }, $Lazy_collect$19.$$arity = 0);
      
      Opal.def(self, '$collect_concat', $Lazy_collect_concat$21 = function $$collect_concat() {
        var $iter = $Lazy_collect_concat$21.$$p, block = $iter || nil, $$22, self = this;

        if ($iter) $Lazy_collect_concat$21.$$p = null;
        
        
        if ($iter) $Lazy_collect_concat$21.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$22 = function(enum$, $a){var self = $$22.$$s == null ? this : $$22.$$s, $post_args, args, $$23, $$24;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ((value)['$respond_to?']("force") && (value)['$respond_to?']("each")) {
            $send((value), 'each', [], ($$23 = function(v){var self = $$23.$$s == null ? this : $$23.$$s;

          
            
            if (v == null) {
              v = nil;
            };
            return enum$.$yield(v);}, $$23.$$s = self, $$23.$$arity = 1, $$23))
          }
          else {
            var array = $$($nesting, 'Opal').$try_convert(value, $$($nesting, 'Array'), "to_ary");

            if (array === nil) {
              enum$.$yield(value);
            }
            else {
              $send((value), 'each', [], ($$24 = function(v){var self = $$24.$$s == null ? this : $$24.$$s;

          
            
            if (v == null) {
              v = nil;
            };
            return enum$.$yield(v);}, $$24.$$s = self, $$24.$$arity = 1, $$24));
            }
          }
        ;}, $$22.$$s = self, $$22.$$arity = -2, $$22));
      }, $Lazy_collect_concat$21.$$arity = 0);
      
      Opal.def(self, '$drop', $Lazy_drop$25 = function $$drop(n) {
        var $$26, self = this, current_size = nil, set_size = nil, dropped = nil;

        
        n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to drop negative size")};
        current_size = self.$enumerator_size();
        set_size = (function() {if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {
          if ($truthy($rb_lt(n, current_size))) {
            return n
          } else {
            return current_size
          }
        } else {
          return current_size
        }; return nil; })();
        dropped = 0;
        return $send($$($nesting, 'Lazy'), 'new', [self, set_size], ($$26 = function(enum$, $a){var self = $$26.$$s == null ? this : $$26.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy($rb_lt(dropped, n))) {
            return (dropped = $rb_plus(dropped, 1))
          } else {
            return $send(enum$, 'yield', Opal.to_a(args))
          };}, $$26.$$s = self, $$26.$$arity = -2, $$26));
      }, $Lazy_drop$25.$$arity = 1);
      
      Opal.def(self, '$drop_while', $Lazy_drop_while$27 = function $$drop_while() {
        var $iter = $Lazy_drop_while$27.$$p, block = $iter || nil, $$28, self = this, succeeding = nil;

        if ($iter) $Lazy_drop_while$27.$$p = null;
        
        
        if ($iter) $Lazy_drop_while$27.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy drop_while without a block")
        };
        succeeding = true;
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$28 = function(enum$, $a){var self = $$28.$$s == null ? this : $$28.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy(succeeding)) {
            
            var value = Opal.yieldX(block, args);

            if ($falsy(value)) {
              succeeding = false;

              $send(enum$, 'yield', Opal.to_a(args));
            }
          
          } else {
            return $send(enum$, 'yield', Opal.to_a(args))
          };}, $$28.$$s = self, $$28.$$arity = -2, $$28));
      }, $Lazy_drop_while$27.$$arity = 0);
      
      Opal.def(self, '$enum_for', $Lazy_enum_for$29 = function $$enum_for($a, $b) {
        var $iter = $Lazy_enum_for$29.$$p, block = $iter || nil, $post_args, method, args, self = this;

        if ($iter) $Lazy_enum_for$29.$$p = null;
        
        
        if ($iter) $Lazy_enum_for$29.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        if ($post_args.length > 0) {
          method = $post_args[0];
          $post_args.splice(0, 1);
        }
        if (method == null) {
          method = "each";
        };
        
        args = $post_args;;
        return $send(self.$class(), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc());
      }, $Lazy_enum_for$29.$$arity = -1);
      Opal.alias(self, "filter", "find_all");
      
      Opal.def(self, '$find_all', $Lazy_find_all$30 = function $$find_all() {
        var $iter = $Lazy_find_all$30.$$p, block = $iter || nil, $$31, self = this;

        if ($iter) $Lazy_find_all$30.$$p = null;
        
        
        if ($iter) $Lazy_find_all$30.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy select without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$31 = function(enum$, $a){var self = $$31.$$s == null ? this : $$31.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
        ;}, $$31.$$s = self, $$31.$$arity = -2, $$31));
      }, $Lazy_find_all$30.$$arity = 0);
      Opal.alias(self, "flat_map", "collect_concat");
      
      Opal.def(self, '$grep', $Lazy_grep$32 = function $$grep(pattern) {
        var $iter = $Lazy_grep$32.$$p, block = $iter || nil, $$33, $$34, self = this;

        if ($iter) $Lazy_grep$32.$$p = null;
        
        
        if ($iter) $Lazy_grep$32.$$p = null;;
        if ($truthy(block)) {
          return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$33 = function(enum$, $a){var self = $$33.$$s == null ? this : $$33.$$s, $post_args, args;

          
            
            if (enum$ == null) {
              enum$ = nil;
            };
            
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            
            args = $post_args;;
            
            var param = $$($nesting, 'Opal').$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              value = Opal.yield1(block, param);

              enum$.$yield(Opal.yield1(block, param));
            }
          ;}, $$33.$$s = self, $$33.$$arity = -2, $$33))
        } else {
          return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$34 = function(enum$, $a){var self = $$34.$$s == null ? this : $$34.$$s, $post_args, args;

          
            
            if (enum$ == null) {
              enum$ = nil;
            };
            
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            
            args = $post_args;;
            
            var param = $$($nesting, 'Opal').$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              enum$.$yield(param);
            }
          ;}, $$34.$$s = self, $$34.$$arity = -2, $$34))
        };
      }, $Lazy_grep$32.$$arity = 1);
      Opal.alias(self, "map", "collect");
      Opal.alias(self, "select", "find_all");
      
      Opal.def(self, '$reject', $Lazy_reject$35 = function $$reject() {
        var $iter = $Lazy_reject$35.$$p, block = $iter || nil, $$36, self = this;

        if ($iter) $Lazy_reject$35.$$p = null;
        
        
        if ($iter) $Lazy_reject$35.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy reject without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$36 = function(enum$, $a){var self = $$36.$$s == null ? this : $$36.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($falsy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
        ;}, $$36.$$s = self, $$36.$$arity = -2, $$36));
      }, $Lazy_reject$35.$$arity = 0);
      
      Opal.def(self, '$take', $Lazy_take$37 = function $$take(n) {
        var $$38, self = this, current_size = nil, set_size = nil, taken = nil;

        
        n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to take negative size")};
        current_size = self.$enumerator_size();
        set_size = (function() {if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {
          if ($truthy($rb_lt(n, current_size))) {
            return n
          } else {
            return current_size
          }
        } else {
          return current_size
        }; return nil; })();
        taken = 0;
        return $send($$($nesting, 'Lazy'), 'new', [self, set_size], ($$38 = function(enum$, $a){var self = $$38.$$s == null ? this : $$38.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy($rb_lt(taken, n))) {
            
            $send(enum$, 'yield', Opal.to_a(args));
            return (taken = $rb_plus(taken, 1));
          } else {
            return self.$raise($$($nesting, 'StopLazyError'))
          };}, $$38.$$s = self, $$38.$$arity = -2, $$38));
      }, $Lazy_take$37.$$arity = 1);
      
      Opal.def(self, '$take_while', $Lazy_take_while$39 = function $$take_while() {
        var $iter = $Lazy_take_while$39.$$p, block = $iter || nil, $$40, self = this;

        if ($iter) $Lazy_take_while$39.$$p = null;
        
        
        if ($iter) $Lazy_take_while$39.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy take_while without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$40 = function(enum$, $a){var self = $$40.$$s == null ? this : $$40.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
          else {
            self.$raise($$($nesting, 'StopLazyError'));
          }
        ;}, $$40.$$s = self, $$40.$$arity = -2, $$40));
      }, $Lazy_take_while$39.$$arity = 0);
      Opal.alias(self, "to_enum", "enum_for");
      return (Opal.def(self, '$inspect', $Lazy_inspect$41 = function $$inspect() {
        var self = this;

        return "" + "#<" + (self.$class()) + ": " + (self.enumerator.$inspect()) + ">"
      }, $Lazy_inspect$41.$$arity = 0), nil) && 'inspect';
    })($nesting[0], self, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ArithmeticSequence');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], self, $nesting);
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/numeric"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$include', '$instance_of?', '$class', '$Float', '$respond_to?', '$coerce', '$__send__', '$===', '$raise', '$equal?', '$-', '$*', '$div', '$<', '$-@', '$ceil', '$to_f', '$denominator', '$to_r', '$==', '$floor', '$/', '$%', '$Complex', '$zero?', '$numerator', '$abs', '$arg', '$coerce_to!', '$round', '$to_i', '$truncate', '$>']);
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Numeric');

    var $nesting = [self].concat($parent_nesting), $Numeric_coerce$1, $Numeric___coerced__$2, $Numeric_$lt_eq_gt$3, $Numeric_$plus$$4, $Numeric_$minus$$5, $Numeric_$percent$6, $Numeric_abs$7, $Numeric_abs2$8, $Numeric_angle$9, $Numeric_ceil$10, $Numeric_conj$11, $Numeric_denominator$12, $Numeric_div$13, $Numeric_divmod$14, $Numeric_fdiv$15, $Numeric_floor$16, $Numeric_i$17, $Numeric_imag$18, $Numeric_integer$ques$19, $Numeric_nonzero$ques$20, $Numeric_numerator$21, $Numeric_polar$22, $Numeric_quo$23, $Numeric_real$24, $Numeric_real$ques$25, $Numeric_rect$26, $Numeric_round$27, $Numeric_to_c$28, $Numeric_to_int$29, $Numeric_truncate$30, $Numeric_zero$ques$31, $Numeric_positive$ques$32, $Numeric_negative$ques$33, $Numeric_dup$34, $Numeric_clone$35, $Numeric_finite$ques$36, $Numeric_infinite$ques$37;

    
    self.$include($$($nesting, 'Comparable'));
    
    Opal.def(self, '$coerce', $Numeric_coerce$1 = function $$coerce(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
        return [other, self]};
      return [self.$Float(other), self.$Float(self)];
    }, $Numeric_coerce$1.$$arity = 1);
    
    Opal.def(self, '$__coerced__', $Numeric___coerced__$2 = function $$__coerced__(method, other) {
      var $a, $b, self = this, a = nil, b = nil, $case = nil;

      if ($truthy(other['$respond_to?']("coerce"))) {
        
        $b = other.$coerce(self), $a = Opal.to_ary($b), (a = ($a[0] == null ? nil : $a[0])), (b = ($a[1] == null ? nil : $a[1])), $b;
        return a.$__send__(method, b);
      } else {
        return (function() {$case = method;
        if ("+"['$===']($case) || "-"['$===']($case) || "*"['$===']($case) || "/"['$===']($case) || "%"['$===']($case) || "&"['$===']($case) || "|"['$===']($case) || "^"['$===']($case) || "**"['$===']($case)) {return self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Numeric")}
        else if (">"['$===']($case) || ">="['$===']($case) || "<"['$===']($case) || "<="['$===']($case) || "<=>"['$===']($case)) {return self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")}
        else { return nil }})()
      }
    }, $Numeric___coerced__$2.$$arity = 2);
    
    Opal.def(self, '$<=>', $Numeric_$lt_eq_gt$3 = function(other) {
      var self = this;

      
      if ($truthy(self['$equal?'](other))) {
        return 0};
      return nil;
    }, $Numeric_$lt_eq_gt$3.$$arity = 1);
    
    Opal.def(self, '$+@', $Numeric_$plus$$4 = function() {
      var self = this;

      return self
    }, $Numeric_$plus$$4.$$arity = 0);
    
    Opal.def(self, '$-@', $Numeric_$minus$$5 = function() {
      var self = this;

      return $rb_minus(0, self)
    }, $Numeric_$minus$$5.$$arity = 0);
    
    Opal.def(self, '$%', $Numeric_$percent$6 = function(other) {
      var self = this;

      return $rb_minus(self, $rb_times(other, self.$div(other)))
    }, $Numeric_$percent$6.$$arity = 1);
    
    Opal.def(self, '$abs', $Numeric_abs$7 = function $$abs() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return self['$-@']()
      } else {
        return self
      }
    }, $Numeric_abs$7.$$arity = 0);
    
    Opal.def(self, '$abs2', $Numeric_abs2$8 = function $$abs2() {
      var self = this;

      return $rb_times(self, self)
    }, $Numeric_abs2$8.$$arity = 0);
    
    Opal.def(self, '$angle', $Numeric_angle$9 = function $$angle() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return $$$($$($nesting, 'Math'), 'PI')
      } else {
        return 0
      }
    }, $Numeric_angle$9.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    
    Opal.def(self, '$ceil', $Numeric_ceil$10 = function $$ceil(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$ceil(ndigits);
    }, $Numeric_ceil$10.$$arity = -1);
    
    Opal.def(self, '$conj', $Numeric_conj$11 = function $$conj() {
      var self = this;

      return self
    }, $Numeric_conj$11.$$arity = 0);
    Opal.alias(self, "conjugate", "conj");
    
    Opal.def(self, '$denominator', $Numeric_denominator$12 = function $$denominator() {
      var self = this;

      return self.$to_r().$denominator()
    }, $Numeric_denominator$12.$$arity = 0);
    
    Opal.def(self, '$div', $Numeric_div$13 = function $$div(other) {
      var self = this;

      
      if (other['$=='](0)) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by o")};
      return $rb_divide(self, other).$floor();
    }, $Numeric_div$13.$$arity = 1);
    
    Opal.def(self, '$divmod', $Numeric_divmod$14 = function $$divmod(other) {
      var self = this;

      return [self.$div(other), self['$%'](other)]
    }, $Numeric_divmod$14.$$arity = 1);
    
    Opal.def(self, '$fdiv', $Numeric_fdiv$15 = function $$fdiv(other) {
      var self = this;

      return $rb_divide(self.$to_f(), other)
    }, $Numeric_fdiv$15.$$arity = 1);
    
    Opal.def(self, '$floor', $Numeric_floor$16 = function $$floor(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$floor(ndigits);
    }, $Numeric_floor$16.$$arity = -1);
    
    Opal.def(self, '$i', $Numeric_i$17 = function $$i() {
      var self = this;

      return self.$Complex(0, self)
    }, $Numeric_i$17.$$arity = 0);
    
    Opal.def(self, '$imag', $Numeric_imag$18 = function $$imag() {
      var self = this;

      return 0
    }, $Numeric_imag$18.$$arity = 0);
    Opal.alias(self, "imaginary", "imag");
    
    Opal.def(self, '$integer?', $Numeric_integer$ques$19 = function() {
      var self = this;

      return false
    }, $Numeric_integer$ques$19.$$arity = 0);
    Opal.alias(self, "magnitude", "abs");
    Opal.alias(self, "modulo", "%");
    
    Opal.def(self, '$nonzero?', $Numeric_nonzero$ques$20 = function() {
      var self = this;

      if ($truthy(self['$zero?']())) {
        return nil
      } else {
        return self
      }
    }, $Numeric_nonzero$ques$20.$$arity = 0);
    
    Opal.def(self, '$numerator', $Numeric_numerator$21 = function $$numerator() {
      var self = this;

      return self.$to_r().$numerator()
    }, $Numeric_numerator$21.$$arity = 0);
    Opal.alias(self, "phase", "arg");
    
    Opal.def(self, '$polar', $Numeric_polar$22 = function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, $Numeric_polar$22.$$arity = 0);
    
    Opal.def(self, '$quo', $Numeric_quo$23 = function $$quo(other) {
      var self = this;

      return $rb_divide($$($nesting, 'Opal')['$coerce_to!'](self, $$($nesting, 'Rational'), "to_r"), other)
    }, $Numeric_quo$23.$$arity = 1);
    
    Opal.def(self, '$real', $Numeric_real$24 = function $$real() {
      var self = this;

      return self
    }, $Numeric_real$24.$$arity = 0);
    
    Opal.def(self, '$real?', $Numeric_real$ques$25 = function() {
      var self = this;

      return true
    }, $Numeric_real$ques$25.$$arity = 0);
    
    Opal.def(self, '$rect', $Numeric_rect$26 = function $$rect() {
      var self = this;

      return [self, 0]
    }, $Numeric_rect$26.$$arity = 0);
    Opal.alias(self, "rectangular", "rect");
    
    Opal.def(self, '$round', $Numeric_round$27 = function $$round(digits) {
      var self = this;

      
      ;
      return self.$to_f().$round(digits);
    }, $Numeric_round$27.$$arity = -1);
    
    Opal.def(self, '$to_c', $Numeric_to_c$28 = function $$to_c() {
      var self = this;

      return self.$Complex(self, 0)
    }, $Numeric_to_c$28.$$arity = 0);
    
    Opal.def(self, '$to_int', $Numeric_to_int$29 = function $$to_int() {
      var self = this;

      return self.$to_i()
    }, $Numeric_to_int$29.$$arity = 0);
    
    Opal.def(self, '$truncate', $Numeric_truncate$30 = function $$truncate(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$truncate(ndigits);
    }, $Numeric_truncate$30.$$arity = -1);
    
    Opal.def(self, '$zero?', $Numeric_zero$ques$31 = function() {
      var self = this;

      return self['$=='](0)
    }, $Numeric_zero$ques$31.$$arity = 0);
    
    Opal.def(self, '$positive?', $Numeric_positive$ques$32 = function() {
      var self = this;

      return $rb_gt(self, 0)
    }, $Numeric_positive$ques$32.$$arity = 0);
    
    Opal.def(self, '$negative?', $Numeric_negative$ques$33 = function() {
      var self = this;

      return $rb_lt(self, 0)
    }, $Numeric_negative$ques$33.$$arity = 0);
    
    Opal.def(self, '$dup', $Numeric_dup$34 = function $$dup() {
      var self = this;

      return self
    }, $Numeric_dup$34.$$arity = 0);
    
    Opal.def(self, '$clone', $Numeric_clone$35 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return self;
    }, $Numeric_clone$35.$$arity = -1);
    
    Opal.def(self, '$finite?', $Numeric_finite$ques$36 = function() {
      var self = this;

      return true
    }, $Numeric_finite$ques$36.$$arity = 0);
    return (Opal.def(self, '$infinite?', $Numeric_infinite$ques$37 = function() {
      var self = this;

      return nil
    }, $Numeric_infinite$ques$37.$$arity = 0), nil) && 'infinite?';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/array"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $falsy = Opal.falsy, $hash_ids = Opal.hash_ids, $yield1 = Opal.yield1, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $hash_delete = Opal.hash_delete, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $klass = Opal.klass, $hash2 = Opal.hash2, $send2 = Opal.send2, $send = Opal.send, $gvars = Opal.gvars;

  Opal.add_stubs(['$require', '$include', '$to_a', '$warn', '$raise', '$replace', '$respond_to?', '$to_ary', '$coerce_to?', '$===', '$join', '$to_str', '$class', '$hash', '$<=>', '$==', '$object_id', '$inspect', '$enum_for', '$bsearch_index', '$to_proc', '$nil?', '$coerce_to!', '$>', '$*', '$enumerator_size', '$empty?', '$size', '$map', '$equal?', '$dup', '$each', '$[]', '$dig', '$eql?', '$length', '$exclude_end?', '$flatten', '$__id__', '$to_s', '$new', '$max', '$min', '$!', '$>=', '$**', '$delete_if', '$reverse', '$rotate', '$rand', '$at', '$keep_if', '$shuffle!', '$<', '$sort', '$sort_by', '$!=', '$times', '$[]=', '$-', '$<<', '$values', '$is_a?', '$last', '$first', '$upto', '$reject', '$pristine', '$singleton_class']);
  
  self.$require("corelib/enumerable");
  self.$require("corelib/numeric");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_$$$1, $Array_initialize$2, $Array_try_convert$3, $Array_$$4, $Array_$$5, $Array_$$6, $Array_$plus$7, $Array_$minus$8, $Array_$lt$lt$9, $Array_$lt_eq_gt$10, $Array_$eq_eq$11, $Array_$$$12, $Array_$$$eq$13, $Array_any$ques$14, $Array_assoc$15, $Array_at$16, $Array_bsearch_index$17, $Array_bsearch$18, $Array_cycle$19, $Array_clear$21, $Array_count$22, $Array_initialize_copy$23, $Array_collect$24, $Array_collect$excl$26, $Array_combination$28, $Array_repeated_combination$30, $Array_compact$32, $Array_compact$excl$33, $Array_concat$34, $Array_delete$37, $Array_delete_at$38, $Array_delete_if$39, $Array_dig$41, $Array_drop$42, $Array_dup$43, $Array_each$44, $Array_each_index$46, $Array_empty$ques$48, $Array_eql$ques$49, $Array_fetch$50, $Array_fill$51, $Array_first$52, $Array_flatten$53, $Array_flatten$excl$54, $Array_hash$55, $Array_include$ques$56, $Array_index$57, $Array_insert$58, $Array_inspect$59, $Array_join$60, $Array_keep_if$61, $Array_last$63, $Array_length$64, $Array_max$65, $Array_min$66, $Array_permutation$67, $Array_repeated_permutation$69, $Array_pop$71, $Array_product$72, $Array_push$73, $Array_rassoc$74, $Array_reject$75, $Array_reject$excl$77, $Array_replace$79, $Array_reverse$80, $Array_reverse$excl$81, $Array_reverse_each$82, $Array_rindex$84, $Array_rotate$85, $Array_rotate$excl$86, $Array_sample$89, $Array_select$90, $Array_select$excl$92, $Array_shift$94, $Array_shuffle$95, $Array_shuffle$excl$96, $Array_slice$excl$97, $Array_sort$98, $Array_sort$excl$99, $Array_sort_by$excl$100, $Array_take$102, $Array_take_while$103, $Array_to_a$104, $Array_to_h$105, $Array_transpose$106, $Array_uniq$109, $Array_uniq$excl$110, $Array_unshift$111, $Array_values_at$112, $Array_zip$115, $Array_inherited$116, $Array_instance_variables$117, $Array_pack$119;

    
    self.$include($$($nesting, 'Enumerable'));
    Opal.defineProperty(self.$$prototype, '$$is_array', true);
    
    // Recent versions of V8 (> 7.1) only use an optimized implementation when Array.prototype is unmodified.
    // For instance, "array-splice.tq" has a "fast path" (ExtractFastJSArray, defined in "src/codegen/code-stub-assembler.cc")
    // but it's only enabled when "IsPrototypeInitialArrayPrototype()" is true.
    //
    // Older versions of V8 were using relatively fast JS-with-extensions code even when Array.prototype is modified:
    // https://github.com/v8/v8/blob/7.0.1/src/js/array.js#L599-L642
    //
    // In short, Array operations are slow in recent versions of V8 when the Array.prototype has been tampered.
    // So, when possible, we are using faster open-coded version to boost the performance.

    // As of V8 8.4, depending on the size of the array, this is up to ~25x times faster than Array#shift()
    // Implementation is heavily inspired by: https://github.com/nodejs/node/blob/ba684805b6c0eded76e5cd89ee00328ac7a59365/lib/internal/util.js#L341-L347
    function shiftNoArg(list) {
      var r = list[0];
      var index = 1;
      var length = list.length;
      for (; index < length; index++) {
        list[index - 1] = list[index];
      }
      list.pop();
      return r;
    }

    function toArraySubclass(obj, klass) {
      if (klass.$$name === Opal.Array) {
        return obj;
      } else {
        return klass.$allocate().$replace((obj).$to_a());
      }
    }

    // A helper for keep_if and delete_if, filter is either Opal.truthy
    // or Opal.falsy.
    function filterIf(self, filter, block) {
      var value, raised = null, updated = new Array(self.length);

      for (var i = 0, i2 = 0, length = self.length; i < length; i++) {
        if (!raised) {
          try {
            value = $yield1(block, self[i])
          } catch(error) {
            raised = error;
          }
        }

        if (raised || filter(value)) {
          updated[i2] = self[i]
          i2 += 1;
        }
      }

      if (i2 !== i) {
        self.splice.apply(self, [0, updated.length].concat(updated));
        self.splice(i2, updated.length);
      }

      if (raised) throw raised;
    }
  ;
    Opal.defs(self, '$[]', $Array_$$$1 = function($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      return toArraySubclass(objects, self);;
    }, $Array_$$$1.$$arity = -1);
    
    Opal.def(self, '$initialize', $Array_initialize$2 = function $$initialize(size, obj) {
      var $iter = $Array_initialize$2.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_initialize$2.$$p = null;
      
      
      if ($iter) $Array_initialize$2.$$p = null;;
      
      if (size == null) {
        size = nil;
      };
      
      if (obj == null) {
        obj = nil;
      };
      
      if (obj !== nil && block !== nil) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (size > $$$($$($nesting, 'Integer'), 'MAX')) {
        self.$raise($$($nesting, 'ArgumentError'), "array size too big")
      }

      if (arguments.length > 2) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..2)")
      }

      if (arguments.length === 0) {
        self.splice(0, self.length);
        return self;
      }

      if (arguments.length === 1) {
        if (size.$$is_array) {
          self.$replace(size.$to_a())
          return self;
        } else if (size['$respond_to?']("to_ary")) {
          self.$replace(size.$to_ary())
          return self;
        }
      }

      size = $coerce_to(size, $$($nesting, 'Integer'), 'to_int');

      if (size < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")
      }

      self.splice(0, self.length);
      var i, value;

      if (block === nil) {
        for (i = 0; i < size; i++) {
          self.push(obj);
        }
      }
      else {
        for (i = 0, value; i < size; i++) {
          value = block(i);
          self[i] = value;
        }
      }

      return self;
    ;
    }, $Array_initialize$2.$$arity = -1);
    Opal.defs(self, '$try_convert', $Array_try_convert$3 = function $$try_convert(obj) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](obj, $$($nesting, 'Array'), "to_ary")
    }, $Array_try_convert$3.$$arity = 1);
    
    Opal.def(self, '$&', $Array_$$4 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_delete(hash, item) !== undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_$$4.$$arity = 1);
    
    Opal.def(self, '$|', $Array_$$5 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      
      var hash = $hash2([], {}), i, length, item;

      for (i = 0, length = self.length; i < length; i++) {
        $hash_put(hash, self[i], true);
      }

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      return hash.$keys();
    ;
    }, $Array_$$5.$$arity = 1);
    
    Opal.def(self, '$*', $Array_$$6 = function(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
        return self.$join(other.$to_str())};
      other = $coerce_to(other, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(other < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative argument")};
      
      var result = [],
          converted = self.$to_a();

      for (var i = 0; i < other; i++) {
        result = result.concat(converted);
      }

      return toArraySubclass(result, self.$class());
    ;
    }, $Array_$$6.$$arity = 1);
    
    Opal.def(self, '$+', $Array_$plus$7 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      return self.concat(other);;
    }, $Array_$plus$7.$$arity = 1);
    
    Opal.def(self, '$-', $Array_$minus$8 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      if ($truthy(self.length === 0)) {
        return []};
      if ($truthy(other.length === 0)) {
        return self.slice()};
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_get(hash, item) === undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_$minus$8.$$arity = 1);
    
    Opal.def(self, '$<<', $Array_$lt$lt$9 = function(object) {
      var self = this;

      
      self.push(object);
      return self;
    }, $Array_$lt$lt$9.$$arity = 1);
    
    Opal.def(self, '$<=>', $Array_$lt_eq_gt$10 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Array')['$==='](other))) {
        other = other.$to_a()
      } else if ($truthy(other['$respond_to?']("to_ary"))) {
        other = other.$to_ary().$to_a()
      } else {
        return nil
      };
      
      if (self.$hash() === other.$hash()) {
        return 0;
      }

      var count = Math.min(self.length, other.length);

      for (var i = 0; i < count; i++) {
        var tmp = (self[i])['$<=>'](other[i]);

        if (tmp !== 0) {
          return tmp;
        }
      }

      return (self.length)['$<=>'](other.length);
    ;
    }, $Array_$lt_eq_gt$10.$$arity = 1);
    
    Opal.def(self, '$==', $Array_$eq_eq$11 = function(other) {
      var self = this;

      
      var recursed = {};

      function _eqeq(array, other) {
        var i, length, a, b;

        if (array === other)
          return true;

        if (!other.$$is_array) {
          if ($respond_to(other, '$to_ary')) {
            return (other)['$=='](array);
          } else {
            return false;
          }
        }

        if (array.$$constructor !== Array)
          array = (array).$to_a();
        if (other.$$constructor !== Array)
          other = (other).$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    
    }, $Array_$eq_eq$11.$$arity = 1);
    
    function $array_slice_range(self, index) {
      var size = self.length,
          exclude, from, to, result;

      exclude = index.excl;
      from    = $coerce_to(index.begin, Opal.Integer, 'to_int');
      to      = $coerce_to(index.end, Opal.Integer, 'to_int');

      if (from < 0) {
        from += size;

        if (from < 0) {
          return nil;
        }
      }

      if (from > size) {
        return nil;
      }

      if (to < 0) {
        to += size;

        if (to < 0) {
          return [];
        }
      }

      if (!exclude) {
        to += 1;
      }

      result = self.slice(from, to);
      return toArraySubclass(result, self.$class());
    }

    function $array_slice_index_length(self, index, length) {
      var size = self.length,
          exclude, from, to, result;

      index = $coerce_to(index, Opal.Integer, 'to_int');

      if (index < 0) {
        index += size;

        if (index < 0) {
          return nil;
        }
      }

      if (length === undefined) {
        if (index >= size || index < 0) {
          return nil;
        }

        return self[index];
      }
      else {
        length = $coerce_to(length, Opal.Integer, 'to_int');

        if (length < 0 || index > size || index < 0) {
          return nil;
        }

        result = self.slice(index, index + length);
      }
      return toArraySubclass(result, self.$class());
    }
  ;
    
    Opal.def(self, '$[]', $Array_$$$12 = function(index, length) {
      var self = this;

      
      ;
      
      if (index.$$is_range) {
        return $array_slice_range(self, index);
      }
      else {
        return $array_slice_index_length(self, index, length);
      }
    ;
    }, $Array_$$$12.$$arity = -2);
    
    Opal.def(self, '$[]=', $Array_$$$eq$13 = function(index, value, extra) {
      var self = this, data = nil, length = nil;

      
      ;
            var i, size = self.length;;
      if ($truthy($$($nesting, 'Range')['$==='](index))) {
        
        data = (function() {if ($truthy($$($nesting, 'Array')['$==='](value))) {
          return value.$to_a()
        } else if ($truthy(value['$respond_to?']("to_ary"))) {
          return value.$to_ary().$to_a()
        } else {
          return [value]
        }; return nil; })();
        
        var exclude = index.excl,
            from    = $coerce_to(index.begin, $$($nesting, 'Integer'), 'to_int'),
            to      = $coerce_to(index.end, $$($nesting, 'Integer'), 'to_int');

        if (from < 0) {
          from += size;

          if (from < 0) {
            self.$raise($$($nesting, 'RangeError'), "" + (index.$inspect()) + " out of range");
          }
        }

        if (to < 0) {
          to += size;
        }

        if (!exclude) {
          to += 1;
        }

        if (from > size) {
          for (i = size; i < from; i++) {
            self[i] = nil;
          }
        }

        if (to < 0) {
          self.splice.apply(self, [from, 0].concat(data));
        }
        else {
          self.splice.apply(self, [from, to - from].concat(data));
        }

        return value;
      ;
      } else {
        
        if ($truthy(extra === undefined)) {
          length = 1
        } else {
          
          length = value;
          value = extra;
          data = (function() {if ($truthy($$($nesting, 'Array')['$==='](value))) {
            return value.$to_a()
          } else if ($truthy(value['$respond_to?']("to_ary"))) {
            return value.$to_ary().$to_a()
          } else {
            return [value]
          }; return nil; })();
        };
        
        var old;

        index  = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');
        length = $coerce_to(length, $$($nesting, 'Integer'), 'to_int');

        if (index < 0) {
          old    = index;
          index += size;

          if (index < 0) {
            self.$raise($$($nesting, 'IndexError'), "" + "index " + (old) + " too small for array; minimum " + (-self.length));
          }
        }

        if (length < 0) {
          self.$raise($$($nesting, 'IndexError'), "" + "negative length (" + (length) + ")")
        }

        if (index > size) {
          for (i = size; i < index; i++) {
            self[i] = nil;
          }
        }

        if (extra === undefined) {
          self[index] = value;
        }
        else {
          self.splice.apply(self, [index, length].concat(data));
        }

        return value;
      ;
      };
    }, $Array_$$$eq$13.$$arity = -3);
    
    Opal.def(self, '$any?', $Array_any$ques$14 = function(pattern) {
      var $iter = $Array_any$ques$14.$$p, block = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_any$ques$14.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Array_any$ques$14.$$p = null;;
      ;
      if (self.length === 0) return false;
      return $send2(self, Opal.find_super_dispatcher(self, 'any?', $Array_any$ques$14, false, true), 'any?', $zuper, $iter);
    }, $Array_any$ques$14.$$arity = -1);
    
    Opal.def(self, '$assoc', $Array_assoc$15 = function $$assoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        if (item = self[i], item.length && (item[0])['$=='](object)) {
          return item;
        }
      }

      return nil;
    
    }, $Array_assoc$15.$$arity = 1);
    
    Opal.def(self, '$at', $Array_at$16 = function $$at(index) {
      var self = this;

      
      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int')

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      return self[index];
    
    }, $Array_at$16.$$arity = 1);
    
    Opal.def(self, '$bsearch_index', $Array_bsearch_index$17 = function $$bsearch_index() {
      var $iter = $Array_bsearch_index$17.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_bsearch_index$17.$$p = null;
      
      
      if ($iter) $Array_bsearch_index$17.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch_index")
      };
      
      var min = 0,
          max = self.length,
          mid,
          val,
          ret,
          smaller = false,
          satisfied = nil;

      while (min < max) {
        mid = min + Math.floor((max - min) / 2);
        val = self[mid];
        ret = $yield1(block, val);

        if (ret === true) {
          satisfied = mid;
          smaller = true;
        }
        else if (ret === false || ret === nil) {
          smaller = false;
        }
        else if (ret.$$is_number) {
          if (ret === 0) { return mid; }
          smaller = (ret < 0);
        }
        else {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((ret).$class()) + " (must be numeric, true, false or nil)")
        }

        if (smaller) { max = mid; } else { min = mid + 1; }
      }

      return satisfied;
    ;
    }, $Array_bsearch_index$17.$$arity = 0);
    
    Opal.def(self, '$bsearch', $Array_bsearch$18 = function $$bsearch() {
      var $iter = $Array_bsearch$18.$$p, block = $iter || nil, self = this, index = nil;

      if ($iter) $Array_bsearch$18.$$p = null;
      
      
      if ($iter) $Array_bsearch$18.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch")
      };
      index = $send(self, 'bsearch_index', [], block.$to_proc());
      
      if (index != null && index.$$is_number) {
        return self[index];
      } else {
        return index;
      }
    ;
    }, $Array_bsearch$18.$$arity = 0);
    
    Opal.def(self, '$cycle', $Array_cycle$19 = function $$cycle(n) {
      var $iter = $Array_cycle$19.$$p, block = $iter || nil, $$20, self = this, $ret_or_1 = nil;

      if ($iter) $Array_cycle$19.$$p = null;
      
      
      if ($iter) $Array_cycle$19.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["cycle", n], ($$20 = function(){var self = $$20.$$s == null ? this : $$20.$$s;

        if ($truthy(n['$nil?']())) {
            return $$$($$($nesting, 'Float'), 'INFINITY')
          } else {
            
            n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, $$20.$$s = self, $$20.$$arity = 0, $$20))
      };
      if ($truthy((function() {if ($truthy(($ret_or_1 = self['$empty?']()))) {
        return $ret_or_1
      } else {
        return n['$=='](0)
      }; return nil; })())) {
        return nil};
      
      var i, length, value;

      if (n === nil) {
        while (true) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }
        }
      }
      else {
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        if (n <= 0) {
          return self;
        }

        while (n > 0) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }

          n--;
        }
      }
    ;
      return self;
    }, $Array_cycle$19.$$arity = -1);
    
    Opal.def(self, '$clear', $Array_clear$21 = function $$clear() {
      var self = this;

      
      self.splice(0, self.length);
      return self;
    }, $Array_clear$21.$$arity = 0);
    
    Opal.def(self, '$count', $Array_count$22 = function $$count(object) {
      var $iter = $Array_count$22.$$p, block = $iter || nil, self = this, $ret_or_2 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_count$22.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Array_count$22.$$p = null;;
      
      if (object == null) {
        object = nil;
      };
      if ($truthy((function() {if ($truthy(($ret_or_2 = object))) {
        return $ret_or_2
      } else {
        return block
      }; return nil; })())) {
        return $send2(self, Opal.find_super_dispatcher(self, 'count', $Array_count$22, false, true), 'count', $zuper, $iter)
      } else {
        return self.$size()
      };
    }, $Array_count$22.$$arity = -1);
    
    Opal.def(self, '$initialize_copy', $Array_initialize_copy$23 = function $$initialize_copy(other) {
      var self = this;

      return self.$replace(other)
    }, $Array_initialize_copy$23.$$arity = 1);
    
    Opal.def(self, '$collect', $Array_collect$24 = function $$collect() {
      var $iter = $Array_collect$24.$$p, block = $iter || nil, $$25, self = this;

      if ($iter) $Array_collect$24.$$p = null;
      
      
      if ($iter) $Array_collect$24.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect"], ($$25 = function(){var self = $$25.$$s == null ? this : $$25.$$s;

        return self.$size()}, $$25.$$s = self, $$25.$$arity = 0, $$25))
      };
      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
        result.push(value);
      }

      return result;
    ;
    }, $Array_collect$24.$$arity = 0);
    
    Opal.def(self, '$collect!', $Array_collect$excl$26 = function() {
      var $iter = $Array_collect$excl$26.$$p, block = $iter || nil, $$27, self = this;

      if ($iter) $Array_collect$excl$26.$$p = null;
      
      
      if ($iter) $Array_collect$excl$26.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect!"], ($$27 = function(){var self = $$27.$$s == null ? this : $$27.$$s;

        return self.$size()}, $$27.$$s = self, $$27.$$arity = 0, $$27))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
        self[i] = value;
      }
    ;
      return self;
    }, $Array_collect$excl$26.$$arity = 0);
    
    function binomial_coefficient(n, k) {
      if (n === k || k === 0) {
        return 1;
      }

      if (k > 0 && n > k) {
        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);
      }

      return 0;
    }
  ;
    
    Opal.def(self, '$combination', $Array_combination$28 = function $$combination(n) {
      var $$29, $iter = $Array_combination$28.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_combination$28.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["combination", num], ($$29 = function(){var self = $$29.$$s == null ? this : $$29.$$s;

        return binomial_coefficient(self.length, num)}, $$29.$$s = self, $$29.$$arity = 0, $$29))
      };
      
      var i, length, stack, chosen, lev, done, next;

      if (num === 0) {
        Opal.yield1($yield, [])
      } else if (num === 1) {
        for (i = 0, length = self.length; i < length; i++) {
          Opal.yield1($yield, [self[i]])
        }
      }
      else if (num === self.length) {
        Opal.yield1($yield, self.slice())
      }
      else if (num >= 0 && num < self.length) {
        stack = [];
        for (i = 0; i <= num + 1; i++) {
          stack.push(0);
        }

        chosen = [];
        lev = 0;
        done = false;
        stack[0] = -1;

        while (!done) {
          chosen[lev] = self[stack[lev+1]];
          while (lev < num - 1) {
            lev++;
            next = stack[lev+1] = stack[lev] + 1;
            chosen[lev] = self[next];
          }
          Opal.yield1($yield, chosen.slice())
          lev++;
          do {
            done = (lev === 0);
            stack[lev]++;
            lev--;
          } while ( stack[lev+1] + num === self.length + lev + 1 );
        }
      }
    ;
      return self;
    }, $Array_combination$28.$$arity = 1);
    
    Opal.def(self, '$repeated_combination', $Array_repeated_combination$30 = function $$repeated_combination(n) {
      var $$31, $iter = $Array_repeated_combination$30.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_repeated_combination$30.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["repeated_combination", num], ($$31 = function(){var self = $$31.$$s == null ? this : $$31.$$s;

        return binomial_coefficient(self.length + num - 1, num);}, $$31.$$s = self, $$31.$$arity = 0, $$31))
      };
      
      function iterate(max, from, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = from; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, i, buffer, self);
          buffer.pop();
        }
      }

      if (num >= 0) {
        iterate(num, 0, [], self);
      }
    ;
      return self;
    }, $Array_repeated_combination$30.$$arity = 1);
    
    Opal.def(self, '$compact', $Array_compact$32 = function $$compact() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length, item; i < length; i++) {
        if ((item = self[i]) !== nil) {
          result.push(item);
        }
      }

      return result;
    
    }, $Array_compact$32.$$arity = 0);
    
    Opal.def(self, '$compact!', $Array_compact$excl$33 = function() {
      var self = this;

      
      var original = self.length;

      for (var i = 0, length = self.length; i < length; i++) {
        if (self[i] === nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      return self.length === original ? nil : self;
    
    }, $Array_compact$excl$33.$$arity = 0);
    
    Opal.def(self, '$concat', $Array_concat$34 = function $$concat($a) {
      var $post_args, others, $$35, $$36, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      others = $send(others, 'map', [], ($$35 = function(other){var self = $$35.$$s == null ? this : $$35.$$s;

      
        
        if (other == null) {
          other = nil;
        };
        other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
          return other.$to_a()
        } else {
          return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
        }; return nil; })();
        if ($truthy(other['$equal?'](self))) {
          other = other.$dup()};
        return other;}, $$35.$$s = self, $$35.$$arity = 1, $$35));
      $send(others, 'each', [], ($$36 = function(other){var self = $$36.$$s == null ? this : $$36.$$s;

      
        
        if (other == null) {
          other = nil;
        };
        
        for (var i = 0, length = other.length; i < length; i++) {
          self.push(other[i]);
        }
      ;}, $$36.$$s = self, $$36.$$arity = 1, $$36));
      return self;
    }, $Array_concat$34.$$arity = -1);
    
    Opal.def(self, '$delete', $Array_delete$37 = function(object) {
      var $iter = $Array_delete$37.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Array_delete$37.$$p = null;
      
      var original = self.length;

      for (var i = 0, length = original; i < length; i++) {
        if ((self[i])['$=='](object)) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      if (self.length === original) {
        if (($yield !== nil)) {
          return Opal.yieldX($yield, []);
        }
        return nil;
      }
      return object;
    
    }, $Array_delete$37.$$arity = 1);
    
    Opal.def(self, '$delete_at', $Array_delete_at$38 = function $$delete_at(index) {
      var self = this;

      
      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      var result = self[index];

      self.splice(index, 1);

      return result;
    
    }, $Array_delete_at$38.$$arity = 1);
    
    Opal.def(self, '$delete_if', $Array_delete_if$39 = function $$delete_if() {
      var $iter = $Array_delete_if$39.$$p, block = $iter || nil, $$40, self = this;

      if ($iter) $Array_delete_if$39.$$p = null;
      
      
      if ($iter) $Array_delete_if$39.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["delete_if"], ($$40 = function(){var self = $$40.$$s == null ? this : $$40.$$s;

        return self.$size()}, $$40.$$s = self, $$40.$$arity = 0, $$40))
      };
      filterIf(self, $falsy, block);
      return self;
    }, $Array_delete_if$39.$$arity = 0);
    Opal.alias(self, "difference", "-");
    
    Opal.def(self, '$dig', $Array_dig$41 = function $$dig(idx, $a) {
      var $post_args, idxs, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      idxs = $post_args;;
      item = self['$[]'](idx);
      
      if (item === nil || idxs.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(idxs));
    }, $Array_dig$41.$$arity = -2);
    
    Opal.def(self, '$drop', $Array_drop$42 = function $$drop(number) {
      var self = this;

      
      if (number < 0) {
        self.$raise($$($nesting, 'ArgumentError'))
      }

      return self.slice(number);
    
    }, $Array_drop$42.$$arity = 1);
    
    Opal.def(self, '$dup', $Array_dup$43 = function $$dup() {
      var $iter = $Array_dup$43.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_dup$43.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if (self.$$class === Opal.Array &&
          self.$$class.$allocate.$$pristine &&
          self.$copy_instance_variables.$$pristine &&
          self.$initialize_dup.$$pristine) {
        return self.slice(0);
      }
    ;
      return $send2(self, Opal.find_super_dispatcher(self, 'dup', $Array_dup$43, false, true), 'dup', $zuper, $iter);
    }, $Array_dup$43.$$arity = 0);
    
    Opal.def(self, '$each', $Array_each$44 = function $$each() {
      var $iter = $Array_each$44.$$p, block = $iter || nil, $$45, self = this;

      if ($iter) $Array_each$44.$$p = null;
      
      
      if ($iter) $Array_each$44.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$45 = function(){var self = $$45.$$s == null ? this : $$45.$$s;

        return self.$size()}, $$45.$$s = self, $$45.$$arity = 0, $$45))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
      }
    ;
      return self;
    }, $Array_each$44.$$arity = 0);
    
    Opal.def(self, '$each_index', $Array_each_index$46 = function $$each_index() {
      var $iter = $Array_each_index$46.$$p, block = $iter || nil, $$47, self = this;

      if ($iter) $Array_each_index$46.$$p = null;
      
      
      if ($iter) $Array_each_index$46.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_index"], ($$47 = function(){var self = $$47.$$s == null ? this : $$47.$$s;

        return self.$size()}, $$47.$$s = self, $$47.$$arity = 0, $$47))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, i);
      }
    ;
      return self;
    }, $Array_each_index$46.$$arity = 0);
    
    Opal.def(self, '$empty?', $Array_empty$ques$48 = function() {
      var self = this;

      return self.length === 0;
    }, $Array_empty$ques$48.$$arity = 0);
    
    Opal.def(self, '$eql?', $Array_eql$ques$49 = function(other) {
      var self = this;

      
      var recursed = {};

      function _eql(array, other) {
        var i, length, a, b;

        if (!other.$$is_array) {
          return false;
        }

        other = other.$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eql(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eql(self, other);
    
    }, $Array_eql$ques$49.$$arity = 1);
    
    Opal.def(self, '$fetch', $Array_fetch$50 = function $$fetch(index, defaults) {
      var $iter = $Array_fetch$50.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_fetch$50.$$p = null;
      
      
      if ($iter) $Array_fetch$50.$$p = null;;
      ;
      
      var original = index;

      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index >= 0 && index < self.length) {
        return self[index];
      }

      if (block !== nil && defaults != null) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (block !== nil) {
        return block(original);
      }

      if (defaults != null) {
        return defaults;
      }

      if (self.length === 0) {
        self.$raise($$($nesting, 'IndexError'), "" + "index " + (original) + " outside of array bounds: 0...0")
      }
      else {
        self.$raise($$($nesting, 'IndexError'), "" + "index " + (original) + " outside of array bounds: -" + (self.length) + "..." + (self.length));
      }
    ;
    }, $Array_fetch$50.$$arity = -2);
    
    Opal.def(self, '$fill', $Array_fill$51 = function $$fill($a) {
      var $iter = $Array_fill$51.$$p, block = $iter || nil, $post_args, args, $b, $c, self = this, one = nil, two = nil, obj = nil, left = nil, right = nil;

      if ($iter) $Array_fill$51.$$p = null;
      
      
      if ($iter) $Array_fill$51.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
            var i, length, value;;
      if ($truthy(block)) {
        
        if ($truthy(args.length > 2)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (args.$length()) + " for 0..2)")};
        $c = args, $b = Opal.to_ary($c), (one = ($b[0] == null ? nil : $b[0])), (two = ($b[1] == null ? nil : $b[1])), $c;
      } else {
        
        if ($truthy(args.length == 0)) {
          self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        } else if ($truthy(args.length > 3)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (args.$length()) + " for 1..3)")};
        $c = args, $b = Opal.to_ary($c), (obj = ($b[0] == null ? nil : $b[0])), (one = ($b[1] == null ? nil : $b[1])), (two = ($b[2] == null ? nil : $b[2])), $c;
      };
      if ($truthy($$($nesting, 'Range')['$==='](one))) {
        
        if ($truthy(two)) {
          self.$raise($$($nesting, 'TypeError'), "length invalid with range")};
        left = $coerce_to(one.begin, $$($nesting, 'Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length};
        if ($truthy(left < 0)) {
          self.$raise($$($nesting, 'RangeError'), "" + (one.$inspect()) + " out of range")};
        right = $coerce_to(one.end, $$($nesting, 'Integer'), 'to_int');
        if ($truthy(right < 0)) {
          right += this.length};
        if ($truthy(one['$exclude_end?']())) {
        } else {
          right += 1
        };
        if ($truthy(right <= left)) {
          return self};
      } else if ($truthy(one)) {
        
        left = $coerce_to(one, $$($nesting, 'Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length};
        if ($truthy(left < 0)) {
          left = 0};
        if ($truthy(two)) {
          
          right = $coerce_to(two, $$($nesting, 'Integer'), 'to_int');
          if ($truthy(right == 0)) {
            return self};
          right += left;
        } else {
          right = this.length
        };
      } else {
        
        left = 0;
        right = this.length;
      };
      if ($truthy(left > this.length)) {
        
        for (i = this.length; i < right; i++) {
          self[i] = nil;
        }
      };
      if ($truthy(right > this.length)) {
        this.length = right};
      if ($truthy(block)) {
        
        for (length = this.length; left < right; left++) {
          value = block(left);
          self[left] = value;
        }
      
      } else {
        
        for (length = this.length; left < right; left++) {
          self[left] = obj;
        }
      
      };
      return self;
    }, $Array_fill$51.$$arity = -1);
    
    Opal.def(self, '$first', $Array_first$52 = function $$first(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[0];
      }

      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size");
      }

      return self.slice(0, count);
    ;
    }, $Array_first$52.$$arity = -1);
    
    Opal.def(self, '$flatten', $Array_flatten$53 = function $$flatten(level) {
      var self = this;

      
      ;
      
      function _flatten(array, level) {
        var result = [],
            i, length,
            item, ary;

        array = (array).$to_a();

        for (i = 0, length = array.length; i < length; i++) {
          item = array[i];

          if (!$respond_to(item, '$to_ary', true)) {
            result.push(item);
            continue;
          }

          ary = (item).$to_ary();

          if (ary === nil) {
            result.push(item);
            continue;
          }

          if (!ary.$$is_array) {
            self.$raise($$($nesting, 'TypeError'));
          }

          if (ary === self) {
            self.$raise($$($nesting, 'ArgumentError'));
          }

          switch (level) {
          case undefined:
            result = result.concat(_flatten(ary));
            break;
          case 0:
            result.push(ary);
            break;
          default:
            result.push.apply(result, _flatten(ary, level - 1));
          }
        }
        return result;
      }

      if (level !== undefined) {
        level = $coerce_to(level, $$($nesting, 'Integer'), 'to_int');
      }

      return toArraySubclass(_flatten(self, level), self.$class());
    ;
    }, $Array_flatten$53.$$arity = -1);
    
    Opal.def(self, '$flatten!', $Array_flatten$excl$54 = function(level) {
      var self = this;

      
      ;
      
      var flattened = self.$flatten(level);

      if (self.length == flattened.length) {
        for (var i = 0, length = self.length; i < length; i++) {
          if (self[i] !== flattened[i]) {
            break;
          }
        }

        if (i == length) {
          return nil;
        }
      }

      self.$replace(flattened);
    ;
      return self;
    }, $Array_flatten$excl$54.$$arity = -1);
    
    Opal.def(self, '$hash', $Array_hash$55 = function $$hash() {
      var self = this;

      
      var top = ($hash_ids === undefined),
          result = ['A'],
          hash_id = self.$object_id(),
          item, i, key;

      try {
        if (top) {
          $hash_ids = Object.create(null);
        }

        // return early for recursive structures
        if ($hash_ids[hash_id]) {
          return 'self';
        }

        for (key in $hash_ids) {
          item = $hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        $hash_ids[hash_id] = self;

        for (i = 0; i < self.length; i++) {
          item = self[i];
          result.push(item.$hash());
        }

        return result.join(',');
      } finally {
        if (top) {
          $hash_ids = undefined;
        }
      }
    
    }, $Array_hash$55.$$arity = 0);
    
    Opal.def(self, '$include?', $Array_include$ques$56 = function(member) {
      var self = this;

      
      for (var i = 0, length = self.length; i < length; i++) {
        if ((self[i])['$=='](member)) {
          return true;
        }
      }

      return false;
    
    }, $Array_include$ques$56.$$arity = 1);
    
    Opal.def(self, '$index', $Array_index$57 = function $$index(object) {
      var $iter = $Array_index$57.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_index$57.$$p = null;
      
      
      if ($iter) $Array_index$57.$$p = null;;
      ;
      
      var i, length, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = 0, length = self.length; i < length; i++) {
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = 0, length = self.length; i < length; i++) {
          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else {
        return self.$enum_for("index");
      }

      return nil;
    ;
    }, $Array_index$57.$$arity = -1);
    
    Opal.def(self, '$insert', $Array_insert$58 = function $$insert(index, $a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      objects = $post_args;;
      
      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');

      if (objects.length > 0) {
        if (index < 0) {
          index += self.length + 1;

          if (index < 0) {
            self.$raise($$($nesting, 'IndexError'), "" + (index) + " is out of bounds");
          }
        }
        if (index > self.length) {
          for (var i = self.length; i < index; i++) {
            self.push(nil);
          }
        }

        self.splice.apply(self, [index, 0].concat(objects));
      }
    ;
      return self;
    }, $Array_insert$58.$$arity = -2);
    
    Opal.def(self, '$inspect', $Array_inspect$59 = function $$inspect() {
      var self = this;

      
      var result = [],
          id     = self.$__id__();

      for (var i = 0, length = self.length; i < length; i++) {
        var item = self['$[]'](i);

        if ((item).$__id__() === id) {
          result.push('[...]');
        }
        else {
          result.push((item).$inspect());
        }
      }

      return '[' + result.join(', ') + ']';
    
    }, $Array_inspect$59.$$arity = 0);
    Opal.alias(self, "intersection", "&");
    
    Opal.def(self, '$join', $Array_join$60 = function $$join(sep) {
      var self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      
      if (sep == null) {
        sep = nil;
      };
      if ($truthy(self.length === 0)) {
        return ""};
      if ($truthy(sep === nil)) {
        sep = $gvars[","]};
      
      var result = [];
      var i, length, item, tmp;

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];

        if ($respond_to(item, '$to_str')) {
          tmp = (item).$to_str();

          if (tmp !== nil) {
            result.push((tmp).$to_s());

            continue;
          }
        }

        if ($respond_to(item, '$to_ary')) {
          tmp = (item).$to_ary();

          if (tmp === self) {
            self.$raise($$($nesting, 'ArgumentError'));
          }

          if (tmp !== nil) {
            result.push((tmp).$join(sep));

            continue;
          }
        }

        if ($respond_to(item, '$to_s')) {
          tmp = (item).$to_s();

          if (tmp !== nil) {
            result.push(tmp);

            continue;
          }
        }

        self.$raise($$($nesting, 'NoMethodError').$new("" + (Opal.inspect(item)) + " doesn't respond to #to_str, #to_ary or #to_s", "to_str"));
      }

      if (sep === nil) {
        return result.join('');
      }
      else {
        return result.join($$($nesting, 'Opal')['$coerce_to!'](sep, $$($nesting, 'String'), "to_str").$to_s());
      }
    ;
    }, $Array_join$60.$$arity = -1);
    
    Opal.def(self, '$keep_if', $Array_keep_if$61 = function $$keep_if() {
      var $iter = $Array_keep_if$61.$$p, block = $iter || nil, $$62, self = this;

      if ($iter) $Array_keep_if$61.$$p = null;
      
      
      if ($iter) $Array_keep_if$61.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["keep_if"], ($$62 = function(){var self = $$62.$$s == null ? this : $$62.$$s;

        return self.$size()}, $$62.$$s = self, $$62.$$arity = 0, $$62))
      };
      filterIf(self, $truthy, block);
      return self;
    }, $Array_keep_if$61.$$arity = 0);
    
    Opal.def(self, '$last', $Array_last$63 = function $$last(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[self.length - 1];
      }

      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size");
      }

      if (count > self.length) {
        count = self.length;
      }

      return self.slice(self.length - count, self.length);
    ;
    }, $Array_last$63.$$arity = -1);
    
    Opal.def(self, '$length', $Array_length$64 = function $$length() {
      var self = this;

      return self.length;
    }, $Array_length$64.$$arity = 0);
    Opal.alias(self, "map", "collect");
    Opal.alias(self, "map!", "collect!");
    
    Opal.def(self, '$max', $Array_max$65 = function $$max(n) {
      var $iter = $Array_max$65.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_max$65.$$p = null;
      
      
      if ($iter) $Array_max$65.$$p = null;;
      ;
      return $send(self.$each(), 'max', [n], block.$to_proc());
    }, $Array_max$65.$$arity = -1);
    
    Opal.def(self, '$min', $Array_min$66 = function $$min() {
      var $iter = $Array_min$66.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_min$66.$$p = null;
      
      
      if ($iter) $Array_min$66.$$p = null;;
      return $send(self.$each(), 'min', [], block.$to_proc());
    }, $Array_min$66.$$arity = 0);
    
    // Returns the product of from, from-1, ..., from - how_many + 1.
    function descending_factorial(from, how_many) {
      var count = how_many >= 0 ? 1 : 0;
      while (how_many) {
        count *= from;
        from--;
        how_many--;
      }
      return count;
    }
  ;
    
    Opal.def(self, '$permutation', $Array_permutation$67 = function $$permutation(num) {
      var $iter = $Array_permutation$67.$$p, block = $iter || nil, $$68, self = this, perm = nil, used = nil;

      if ($iter) $Array_permutation$67.$$p = null;
      
      
      if ($iter) $Array_permutation$67.$$p = null;;
      ;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["permutation", num], ($$68 = function(){var self = $$68.$$s == null ? this : $$68.$$s;

        return descending_factorial(self.length, num === undefined ? self.length : num);}, $$68.$$s = self, $$68.$$arity = 0, $$68))
      };
      
      var permute, offensive, output;

      if (num === undefined) {
        num = self.length;
      }
      else {
        num = $coerce_to(num, $$($nesting, 'Integer'), 'to_int');
      }

      if (num < 0 || self.length < num) {
        // no permutations, yield nothing
      }
      else if (num === 0) {
        // exactly one permutation: the zero-length array
        Opal.yield1(block, [])
      }
      else if (num === 1) {
        // this is a special, easy case
        for (var i = 0; i < self.length; i++) {
          Opal.yield1(block, [self[i]])
        }
      }
      else {
        // this is the general case
        (perm = $$($nesting, 'Array').$new(num));
        (used = $$($nesting, 'Array').$new(self.length, false));

        permute = function(num, perm, index, used, blk) {
          self = this;
          for(var i = 0; i < self.length; i++){
            if(used['$[]'](i)['$!']()) {
              perm[index] = i;
              if(index < num - 1) {
                used[i] = true;
                permute.call(self, num, perm, index + 1, used, blk);
                used[i] = false;
              }
              else {
                output = [];
                for (var j = 0; j < perm.length; j++) {
                  output.push(self[perm[j]]);
                }
                $yield1(blk, output);
              }
            }
          }
        }

        if ((block !== nil)) {
          // offensive (both definitions) copy.
          offensive = self.slice();
          permute.call(offensive, num, perm, 0, used, block);
        }
        else {
          permute.call(self, num, perm, 0, used, block);
        }
      }
    ;
      return self;
    }, $Array_permutation$67.$$arity = -1);
    
    Opal.def(self, '$repeated_permutation', $Array_repeated_permutation$69 = function $$repeated_permutation(n) {
      var $$70, $iter = $Array_repeated_permutation$69.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_repeated_permutation$69.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["repeated_permutation", num], ($$70 = function(){var self = $$70.$$s == null ? this : $$70.$$s;

        if ($truthy($rb_ge(num, 0))) {
            return self.$size()['$**'](num)
          } else {
            return 0
          }}, $$70.$$s = self, $$70.$$arity = 0, $$70))
      };
      
      function iterate(max, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = 0; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, buffer, self);
          buffer.pop();
        }
      }

      iterate(num, [], self.slice());
    ;
      return self;
    }, $Array_repeated_permutation$69.$$arity = 1);
    
    Opal.def(self, '$pop', $Array_pop$71 = function $$pop(count) {
      var self = this;

      
      ;
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil};
        return self.pop();};
      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(count < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")};
      if ($truthy(self.length === 0)) {
        return []};
      if ($truthy(count === 1)) {
        return [self.pop()];
      } else if ($truthy(count > self.length)) {
        return self.splice(0, self.length);
      } else {
        return self.splice(self.length - count, self.length);
      };
    }, $Array_pop$71.$$arity = -1);
    
    Opal.def(self, '$product', $Array_product$72 = function $$product($a) {
      var $iter = $Array_product$72.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Array_product$72.$$p = null;
      
      
      if ($iter) $Array_product$72.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = (block !== nil) ? null : [],
          n = args.length + 1,
          counters = new Array(n),
          lengths  = new Array(n),
          arrays   = new Array(n),
          i, m, subarray, len, resultlen = 1;

      arrays[0] = self;
      for (i = 1; i < n; i++) {
        arrays[i] = $coerce_to(args[i - 1], $$($nesting, 'Array'), 'to_ary');
      }

      for (i = 0; i < n; i++) {
        len = arrays[i].length;
        if (len === 0) {
          return result || self;
        }
        resultlen *= len;
        if (resultlen > 2147483647) {
          self.$raise($$($nesting, 'RangeError'), "too big to product")
        }
        lengths[i] = len;
        counters[i] = 0;
      }

      outer_loop: for (;;) {
        subarray = [];
        for (i = 0; i < n; i++) {
          subarray.push(arrays[i][counters[i]]);
        }
        if (result) {
          result.push(subarray);
        } else {
          Opal.yield1(block, subarray)
        }
        m = n - 1;
        counters[m]++;
        while (counters[m] === lengths[m]) {
          counters[m] = 0;
          if (--m < 0) break outer_loop;
          counters[m]++;
        }
      }

      return result || self;
    ;
    }, $Array_product$72.$$arity = -1);
    
    Opal.def(self, '$push', $Array_push$73 = function $$push($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      
      for (var i = 0, length = objects.length; i < length; i++) {
        self.push(objects[i]);
      }
    ;
      return self;
    }, $Array_push$73.$$arity = -1);
    Opal.alias(self, "append", "push");
    
    Opal.def(self, '$rassoc', $Array_rassoc$74 = function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        item = self[i];

        if (item.length && item[1] !== undefined) {
          if ((item[1])['$=='](object)) {
            return item;
          }
        }
      }

      return nil;
    
    }, $Array_rassoc$74.$$arity = 1);
    
    Opal.def(self, '$reject', $Array_reject$75 = function $$reject() {
      var $iter = $Array_reject$75.$$p, block = $iter || nil, $$76, self = this;

      if ($iter) $Array_reject$75.$$p = null;
      
      
      if ($iter) $Array_reject$75.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$76 = function(){var self = $$76.$$s == null ? this : $$76.$$s;

        return self.$size()}, $$76.$$s = self, $$76.$$arity = 0, $$76))
      };
      
      var result = [];

      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          result.push(self[i]);
        }
      }
      return result;
    ;
    }, $Array_reject$75.$$arity = 0);
    
    Opal.def(self, '$reject!', $Array_reject$excl$77 = function() {
      var $iter = $Array_reject$excl$77.$$p, block = $iter || nil, $$78, self = this, original = nil;

      if ($iter) $Array_reject$excl$77.$$p = null;
      
      
      if ($iter) $Array_reject$excl$77.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject!"], ($$78 = function(){var self = $$78.$$s == null ? this : $$78.$$s;

        return self.$size()}, $$78.$$s = self, $$78.$$arity = 0, $$78))
      };
      original = self.$length();
      $send(self, 'delete_if', [], block.$to_proc());
      if (self.$length()['$=='](original)) {
        return nil
      } else {
        return self
      };
    }, $Array_reject$excl$77.$$arity = 0);
    
    Opal.def(self, '$replace', $Array_replace$79 = function $$replace(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      
      self.splice(0, self.length);
      self.push.apply(self, other);
    ;
      return self;
    }, $Array_replace$79.$$arity = 1);
    
    Opal.def(self, '$reverse', $Array_reverse$80 = function $$reverse() {
      var self = this;

      return self.slice(0).reverse();
    }, $Array_reverse$80.$$arity = 0);
    
    Opal.def(self, '$reverse!', $Array_reverse$excl$81 = function() {
      var self = this;

      return self.reverse();
    }, $Array_reverse$excl$81.$$arity = 0);
    
    Opal.def(self, '$reverse_each', $Array_reverse_each$82 = function $$reverse_each() {
      var $iter = $Array_reverse_each$82.$$p, block = $iter || nil, $$83, self = this;

      if ($iter) $Array_reverse_each$82.$$p = null;
      
      
      if ($iter) $Array_reverse_each$82.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reverse_each"], ($$83 = function(){var self = $$83.$$s == null ? this : $$83.$$s;

        return self.$size()}, $$83.$$s = self, $$83.$$arity = 0, $$83))
      };
      $send(self.$reverse(), 'each', [], block.$to_proc());
      return self;
    }, $Array_reverse_each$82.$$arity = 0);
    
    Opal.def(self, '$rindex', $Array_rindex$84 = function $$rindex(object) {
      var $iter = $Array_rindex$84.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_rindex$84.$$p = null;
      
      
      if ($iter) $Array_rindex$84.$$p = null;;
      ;
      
      var i, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }

          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else if (object == null) {
        return self.$enum_for("rindex");
      }

      return nil;
    ;
    }, $Array_rindex$84.$$arity = -1);
    
    Opal.def(self, '$rotate', $Array_rotate$85 = function $$rotate(n) {
      var self = this;

      
      
      if (n == null) {
        n = 1;
      };
      
      var ary, idx, firstPart, lastPart;

      n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int')

      if (self.length === 1) {
        return self.slice();
      }
      if (self.length === 0) {
        return [];
      }

      ary = self.slice();
      idx = n % ary.length;

      firstPart = ary.slice(idx);
      lastPart = ary.slice(0, idx);
      return firstPart.concat(lastPart);
    ;
    }, $Array_rotate$85.$$arity = -1);
    
    Opal.def(self, '$rotate!', $Array_rotate$excl$86 = function(cnt) {
      var self = this, ary = nil;

      
      
      if (cnt == null) {
        cnt = 1;
      };
      
      if (self.length === 0 || self.length === 1) {
        return self;
      }
      cnt = $coerce_to(cnt, $$($nesting, 'Integer'), 'to_int');
    ;
      ary = self.$rotate(cnt);
      return self.$replace(ary);
    }, $Array_rotate$excl$86.$$arity = -1);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'SampleRandom');

      var $nesting = [self].concat($parent_nesting), $SampleRandom_initialize$87, $SampleRandom_rand$88;

      self.$$prototype.rng = nil;
      
      
      Opal.def(self, '$initialize', $SampleRandom_initialize$87 = function $$initialize(rng) {
        var self = this;

        return (self.rng = rng)
      }, $SampleRandom_initialize$87.$$arity = 1);
      return (Opal.def(self, '$rand', $SampleRandom_rand$88 = function $$rand(size) {
        var self = this, random = nil;

        
        random = $coerce_to(self.rng.$rand(size), $$($nesting, 'Integer'), 'to_int');
        if ($truthy(random < 0)) {
          self.$raise($$($nesting, 'RangeError'), "random value must be >= 0")};
        if ($truthy(random < size)) {
        } else {
          self.$raise($$($nesting, 'RangeError'), "random value must be less than Array size")
        };
        return random;
      }, $SampleRandom_rand$88.$$arity = 1), nil) && 'rand';
    })($nesting[0], null, $nesting);
    
    Opal.def(self, '$sample', $Array_sample$89 = function $$sample(count, options) {
      var self = this, o = nil, $ret_or_3 = nil, rng = nil, $ret_or_4 = nil;

      
      ;
      ;
      if ($truthy(count === undefined)) {
        return self.$at($$($nesting, 'Kernel').$rand(self.length))};
      if ($truthy(options === undefined)) {
        if ($truthy((o = $$($nesting, 'Opal')['$coerce_to?'](count, $$($nesting, 'Hash'), "to_hash")))) {
          
          options = o;
          count = nil;
        } else {
          
          options = nil;
          count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');
        }
      } else {
        
        count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');
        options = $coerce_to(options, $$($nesting, 'Hash'), 'to_hash');
      };
      if ($truthy((function() {if ($truthy(($ret_or_3 = count))) {
        return count < 0;
      } else {
        return $ret_or_3
      }; return nil; })())) {
        self.$raise($$($nesting, 'ArgumentError'), "count must be greater than 0")};
      if ($truthy(options)) {
        rng = options['$[]']("random")};
      rng = (function() {if ($truthy((function() {if ($truthy(($ret_or_4 = rng))) {
        return rng['$respond_to?']("rand")
      } else {
        return $ret_or_4
      }; return nil; })())) {
        return $$($nesting, 'SampleRandom').$new(rng)
      } else {
        return $$($nesting, 'Kernel')
      }; return nil; })();
      if ($truthy(count)) {
      } else {
        return self[rng.$rand(self.length)]
      };
      

      var abandon, spin, result, i, j, k, targetIndex, oldValue;

      if (count > self.length) {
        count = self.length;
      }

      switch (count) {
        case 0:
          return [];
          break;
        case 1:
          return [self[rng.$rand(self.length)]];
          break;
        case 2:
          i = rng.$rand(self.length);
          j = rng.$rand(self.length);
          if (i === j) {
            j = i === 0 ? i + 1 : i - 1;
          }
          return [self[i], self[j]];
          break;
        default:
          if (self.length / count > 3) {
            abandon = false;
            spin = 0;

            result = $$($nesting, 'Array').$new(count);
            i = 1;

            result[0] = rng.$rand(self.length);
            while (i < count) {
              k = rng.$rand(self.length);
              j = 0;

              while (j < i) {
                while (k === result[j]) {
                  spin++;
                  if (spin > 100) {
                    abandon = true;
                    break;
                  }
                  k = rng.$rand(self.length);
                }
                if (abandon) { break; }

                j++;
              }

              if (abandon) { break; }

              result[i] = k;

              i++;
            }

            if (!abandon) {
              i = 0;
              while (i < count) {
                result[i] = self[result[i]];
                i++;
              }

              return result;
            }
          }

          result = self.slice();

          for (var c = 0; c < count; c++) {
            targetIndex = rng.$rand(self.length);
            oldValue = result[c];
            result[c] = result[targetIndex];
            result[targetIndex] = oldValue;
          }

          return count === self.length ? result : (result)['$[]'](0, count);
      }
    ;
    }, $Array_sample$89.$$arity = -1);
    
    Opal.def(self, '$select', $Array_select$90 = function $$select() {
      var $iter = $Array_select$90.$$p, block = $iter || nil, $$91, self = this;

      if ($iter) $Array_select$90.$$p = null;
      
      
      if ($iter) $Array_select$90.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["select"], ($$91 = function(){var self = $$91.$$s == null ? this : $$91.$$s;

        return self.$size()}, $$91.$$s = self, $$91.$$arity = 0, $$91))
      };
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = $yield1(block, item);

        if ($truthy(value)) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_select$90.$$arity = 0);
    
    Opal.def(self, '$select!', $Array_select$excl$92 = function() {
      var $iter = $Array_select$excl$92.$$p, block = $iter || nil, $$93, self = this;

      if ($iter) $Array_select$excl$92.$$p = null;
      
      
      if ($iter) $Array_select$excl$92.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["select!"], ($$93 = function(){var self = $$93.$$s == null ? this : $$93.$$s;

        return self.$size()}, $$93.$$s = self, $$93.$$arity = 0, $$93))
      };
      
      var original = self.length;
      $send(self, 'keep_if', [], block.$to_proc());
      return self.length === original ? nil : self;
    ;
    }, $Array_select$excl$92.$$arity = 0);
    Opal.alias(self, "filter", "select");
    Opal.alias(self, "filter!", "select!");
    
    Opal.def(self, '$shift', $Array_shift$94 = function $$shift(count) {
      var self = this;

      
      ;
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil};
        return shiftNoArg(self);};
      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(count < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")};
      if ($truthy(self.length === 0)) {
        return []};
      return self.splice(0, count);;
    }, $Array_shift$94.$$arity = -1);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$shuffle', $Array_shuffle$95 = function $$shuffle(rng) {
      var self = this;

      
      ;
      return self.$dup().$to_a()['$shuffle!'](rng);
    }, $Array_shuffle$95.$$arity = -1);
    
    Opal.def(self, '$shuffle!', $Array_shuffle$excl$96 = function(rng) {
      var self = this;

      
      ;
      
      var randgen, i = self.length, j, tmp;

      if (rng !== undefined) {
        rng = $$($nesting, 'Opal')['$coerce_to?'](rng, $$($nesting, 'Hash'), "to_hash");

        if (rng !== nil) {
          rng = rng['$[]']("random");

          if (rng !== nil && rng['$respond_to?']("rand")) {
            randgen = rng;
          }
        }
      }

      while (i) {
        if (randgen) {
          j = randgen.$rand(i).$to_int();

          if (j < 0) {
            self.$raise($$($nesting, 'RangeError'), "" + "random number too small " + (j))
          }

          if (j >= i) {
            self.$raise($$($nesting, 'RangeError'), "" + "random number too big " + (j))
          }
        }
        else {
          j = self.$rand(i);
        }

        tmp = self[--i];
        self[i] = self[j];
        self[j] = tmp;
      }

      return self;
    ;
    }, $Array_shuffle$excl$96.$$arity = -1);
    Opal.alias(self, "slice", "[]");
    
    Opal.def(self, '$slice!', $Array_slice$excl$97 = function(index, length) {
      var self = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;

      
      ;
      result = nil;
      if ($truthy(length === undefined)) {
        if ($truthy($$($nesting, 'Range')['$==='](index))) {
          
          range = index;
          result = self['$[]'](range);
          range_start = $coerce_to(range.begin, $$($nesting, 'Integer'), 'to_int');
          range_end = $coerce_to(range.end, $$($nesting, 'Integer'), 'to_int');
          
          if (range_start < 0) {
            range_start += self.length;
          }

          if (range_end < 0) {
            range_end += self.length;
          } else if (range_end >= self.length) {
            range_end = self.length - 1;
            if (range.excl) {
              range_end += 1;
            }
          }

          var range_length = range_end - range_start;
          if (range.excl) {
            range_end -= 1;
          } else {
            range_length += 1;
          }

          if (range_start < self.length && range_start >= 0 && range_end < self.length && range_end >= 0 && range_length > 0) {
            self.splice(range_start, range_length);
          }
        ;
        } else {
          
          start = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');
          
          if (start < 0) {
            start += self.length;
          }

          if (start < 0 || start >= self.length) {
            return nil;
          }

          result = self[start];

          if (start === 0) {
            self.shift();
          } else {
            self.splice(start, 1);
          }
        ;
        }
      } else {
        
        start = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');
        length = $coerce_to(length, $$($nesting, 'Integer'), 'to_int');
        
        if (length < 0) {
          return nil;
        }

        var end = start + length;

        result = self['$[]'](start, length);

        if (start < 0) {
          start += self.length;
        }

        if (start + length > self.length) {
          length = self.length - start;
        }

        if (start < self.length && start >= 0) {
          self.splice(start, length);
        }
      ;
      };
      return result;
    }, $Array_slice$excl$97.$$arity = -2);
    
    Opal.def(self, '$sort', $Array_sort$98 = function $$sort() {
      var $iter = $Array_sort$98.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_sort$98.$$p = null;
      
      
      if ($iter) $Array_sort$98.$$p = null;;
      if ($truthy(self.length > 1)) {
      } else {
        return self
      };
      
      if (block === nil) {
        block = function(a, b) {
          return (a)['$<=>'](b);
        };
      }

      return self.slice().sort(function(x, y) {
        var ret = block(x, y);

        if (ret === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + ((x).$inspect()) + " with " + ((y).$inspect()) + " failed");
        }

        return $rb_gt(ret, 0) ? 1 : ($rb_lt(ret, 0) ? -1 : 0);
      });
    ;
    }, $Array_sort$98.$$arity = 0);
    
    Opal.def(self, '$sort!', $Array_sort$excl$99 = function() {
      var $iter = $Array_sort$excl$99.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_sort$excl$99.$$p = null;
      
      
      if ($iter) $Array_sort$excl$99.$$p = null;;
      
      var result;

      if ((block !== nil)) {
        result = $send((self.slice()), 'sort', [], block.$to_proc());
      }
      else {
        result = (self.slice()).$sort();
      }

      self.length = 0;
      for(var i = 0, length = result.length; i < length; i++) {
        self.push(result[i]);
      }

      return self;
    ;
    }, $Array_sort$excl$99.$$arity = 0);
    
    Opal.def(self, '$sort_by!', $Array_sort_by$excl$100 = function() {
      var $iter = $Array_sort_by$excl$100.$$p, block = $iter || nil, $$101, self = this;

      if ($iter) $Array_sort_by$excl$100.$$p = null;
      
      
      if ($iter) $Array_sort_by$excl$100.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["sort_by!"], ($$101 = function(){var self = $$101.$$s == null ? this : $$101.$$s;

        return self.$size()}, $$101.$$s = self, $$101.$$arity = 0, $$101))
      };
      return self.$replace($send(self, 'sort_by', [], block.$to_proc()));
    }, $Array_sort_by$excl$100.$$arity = 0);
    
    Opal.def(self, '$take', $Array_take$102 = function $$take(count) {
      var self = this;

      
      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'));
      }

      return self.slice(0, count);
    
    }, $Array_take$102.$$arity = 1);
    
    Opal.def(self, '$take_while', $Array_take_while$103 = function $$take_while() {
      var $iter = $Array_take_while$103.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_take_while$103.$$p = null;
      
      
      if ($iter) $Array_take_while$103.$$p = null;;
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = block(item);

        if (value === false || value === nil) {
          return result;
        }

        result.push(item);
      }

      return result;
    ;
    }, $Array_take_while$103.$$arity = 0);
    
    Opal.def(self, '$to_a', $Array_to_a$104 = function $$to_a() {
      var self = this;

      return self
    }, $Array_to_a$104.$$arity = 0);
    Opal.alias(self, "to_ary", "to_a");
    
    Opal.def(self, '$to_h', $Array_to_h$105 = function $$to_h() {
      var $iter = $Array_to_h$105.$$p, block = $iter || nil, self = this, array = nil;

      if ($iter) $Array_to_h$105.$$p = null;
      
      
      if ($iter) $Array_to_h$105.$$p = null;;
      array = self;
      if ((block !== nil)) {
        array = $send(array, 'map', [], block.$to_proc())};
      
      var i, len = array.length, ary, key, val, hash = $hash2([], {});

      for (i = 0; i < len; i++) {
        ary = $$($nesting, 'Opal')['$coerce_to?'](array[i], $$($nesting, 'Array'), "to_ary");
        if (!ary.$$is_array) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong element type " + ((ary).$class()) + " at " + (i) + " (expected array)")
        }
        if (ary.length !== 2) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong array length at " + (i) + " (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];
        $hash_put(hash, key, val);
      }

      return hash;
    ;
    }, $Array_to_h$105.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$transpose', $Array_transpose$106 = function $$transpose() {
      var $$107, self = this, result = nil, max = nil;

      
      if ($truthy(self['$empty?']())) {
        return []};
      result = [];
      max = nil;
      $send(self, 'each', [], ($$107 = function(row){var self = $$107.$$s == null ? this : $$107.$$s, $$108, $ret_or_5 = nil;

      
        
        if (row == null) {
          row = nil;
        };
        row = (function() {if ($truthy($$($nesting, 'Array')['$==='](row))) {
          return row.$to_a()
        } else {
          return ($coerce_to(row, $$($nesting, 'Array'), 'to_ary')).$to_a()
        }; return nil; })();
        max = (function() {if ($truthy(($ret_or_5 = max))) {
          return $ret_or_5
        } else {
          return row.length;
        }; return nil; })();
        if ($truthy((row.length)['$!='](max))) {
          self.$raise($$($nesting, 'IndexError'), "" + "element size differs (" + (row.length) + " should be " + (max) + ")")};
        return $send((row.length), 'times', [], ($$108 = function(i){var self = $$108.$$s == null ? this : $$108.$$s, entry = nil, $ret_or_6 = nil, $writer = nil;

        
          
          if (i == null) {
            i = nil;
          };
          entry = (function() {if ($truthy(($ret_or_6 = result['$[]'](i)))) {
            return $ret_or_6
          } else {
            
            $writer = [i, []];
            $send(result, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          }; return nil; })();
          return entry['$<<'](row.$at(i));}, $$108.$$s = self, $$108.$$arity = 1, $$108));}, $$107.$$s = self, $$107.$$arity = 1, $$107));
      return result;
    }, $Array_transpose$106.$$arity = 0);
    Opal.alias(self, "union", "|");
    
    Opal.def(self, '$uniq', $Array_uniq$109 = function $$uniq() {
      var $iter = $Array_uniq$109.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_uniq$109.$$p = null;
      
      
      if ($iter) $Array_uniq$109.$$p = null;;
      
      var hash = $hash2([], {}), i, length, item, key;

      if (block === nil) {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          if ($hash_get(hash, item) === undefined) {
            $hash_put(hash, item, item);
          }
        }
      }
      else {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          key = $yield1(block, item);
          if ($hash_get(hash, key) === undefined) {
            $hash_put(hash, key, item);
          }
        }
      }

      return toArraySubclass((hash).$values(), self.$class());
    ;
    }, $Array_uniq$109.$$arity = 0);
    
    Opal.def(self, '$uniq!', $Array_uniq$excl$110 = function() {
      var $iter = $Array_uniq$excl$110.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_uniq$excl$110.$$p = null;
      
      
      if ($iter) $Array_uniq$excl$110.$$p = null;;
      
      var original_length = self.length, hash = $hash2([], {}), i, length, item, key;

      for (i = 0, length = original_length; i < length; i++) {
        item = self[i];
        key = (block === nil ? item : $yield1(block, item));

        if ($hash_get(hash, key) === undefined) {
          $hash_put(hash, key, item);
          continue;
        }

        self.splice(i, 1);
        length--;
        i--;
      }

      return self.length === original_length ? nil : self;
    ;
    }, $Array_uniq$excl$110.$$arity = 0);
    
    Opal.def(self, '$unshift', $Array_unshift$111 = function $$unshift($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      
      for (var i = objects.length - 1; i >= 0; i--) {
        self.unshift(objects[i]);
      }
    ;
      return self;
    }, $Array_unshift$111.$$arity = -1);
    Opal.alias(self, "prepend", "unshift");
    
    Opal.def(self, '$values_at', $Array_values_at$112 = function $$values_at($a) {
      var $post_args, args, $$113, self = this, out = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      out = [];
      $send(args, 'each', [], ($$113 = function(elem){var self = $$113.$$s == null ? this : $$113.$$s, $$114, finish = nil, start = nil, i = nil;

      
        
        if (elem == null) {
          elem = nil;
        };
        if ($truthy(elem['$is_a?']($$($nesting, 'Range')))) {
          
          finish = $coerce_to(elem.$last(), $$($nesting, 'Integer'), 'to_int');
          start = $coerce_to(elem.$first(), $$($nesting, 'Integer'), 'to_int');
          
          if (start < 0) {
            start = start + self.length;
            return nil;;
          }
        ;
          
          if (finish < 0) {
            finish = finish + self.length;
          }
          if (elem['$exclude_end?']()) {
            finish--;
          }
          if (finish < start) {
            return nil;;
          }
        ;
          return $send(start, 'upto', [finish], ($$114 = function(i){var self = $$114.$$s == null ? this : $$114.$$s;

          
            
            if (i == null) {
              i = nil;
            };
            return out['$<<'](self.$at(i));}, $$114.$$s = self, $$114.$$arity = 1, $$114));
        } else {
          
          i = $coerce_to(elem, $$($nesting, 'Integer'), 'to_int');
          return out['$<<'](self.$at(i));
        };}, $$113.$$s = self, $$113.$$arity = 1, $$113));
      return out;
    }, $Array_values_at$112.$$arity = -1);
    
    Opal.def(self, '$zip', $Array_zip$115 = function $$zip($a) {
      var $iter = $Array_zip$115.$$p, block = $iter || nil, $post_args, others, self = this, $ret_or_7 = nil;

      if ($iter) $Array_zip$115.$$p = null;
      
      
      if ($iter) $Array_zip$115.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      
      var result = [], size = self.length, part, o, i, j, jj;

      for (j = 0, jj = others.length; j < jj; j++) {
        o = others[j];
        if (o.$$is_array) {
          continue;
        }
        if (o.$$is_enumerator) {
          if (o.$size() === Infinity) {
            others[j] = o.$take(size);
          } else {
            others[j] = o.$to_a();
          }
          continue;
        }
        others[j] = (function() {if ($truthy(($ret_or_7 = $$($nesting, 'Opal')['$coerce_to?'](o, $$($nesting, 'Array'), "to_ary")))) {
        return $ret_or_7
      } else {
        return $$($nesting, 'Opal')['$coerce_to!'](o, $$($nesting, 'Enumerator'), "to_enum", "each")
      }; return nil; })().$to_a();
      }

      for (i = 0; i < size; i++) {
        part = [self[i]];

        for (j = 0, jj = others.length; j < jj; j++) {
          o = others[j][i];

          if (o == null) {
            o = nil;
          }

          part[j + 1] = o;
        }

        result[i] = part;
      }

      if (block !== nil) {
        for (i = 0; i < size; i++) {
          block(result[i]);
        }

        return nil;
      }

      return result;
    ;
    }, $Array_zip$115.$$arity = -1);
    Opal.defs(self, '$inherited', $Array_inherited$116 = function $$inherited(klass) {
      var self = this;

      
      klass.$$prototype.$to_a = function() {
        return this.slice(0, this.length);
      }
    
    }, $Array_inherited$116.$$arity = 1);
    
    Opal.def(self, '$instance_variables', $Array_instance_variables$117 = function $$instance_variables() {
      var $$118, $iter = $Array_instance_variables$117.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_instance_variables$117.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      return $send($send2(self, Opal.find_super_dispatcher(self, 'instance_variables', $Array_instance_variables$117, false, true), 'instance_variables', $zuper, $iter), 'reject', [], ($$118 = function(ivar){var self = $$118.$$s == null ? this : $$118.$$s, $ret_or_8 = nil;

      
        
        if (ivar == null) {
          ivar = nil;
        };
        if ($truthy(($ret_or_8 = /^@\d+$/.test(ivar)))) {
          return $ret_or_8
        } else {
          return ivar['$==']("@length")
        };}, $$118.$$s = self, $$118.$$arity = 1, $$118))
    }, $Array_instance_variables$117.$$arity = 0);
    $$($nesting, 'Opal').$pristine(self.$singleton_class(), "allocate");
    $$($nesting, 'Opal').$pristine(self, "copy_instance_variables", "initialize_dup");
    return (Opal.def(self, '$pack', $Array_pack$119 = function $$pack($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.$raise("To use Array#pack, you must first require 'corelib/array/pack'.");
    }, $Array_pack$119.$$arity = -1), nil) && 'pack';
  })($nesting[0], Array, $nesting);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/hash"] = function(Opal) {
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$[]', '$merge!', '$allocate', '$raise', '$coerce_to!', '$each', '$fetch', '$>=', '$>', '$==', '$compare_by_identity', '$lambda?', '$abs', '$arity', '$enum_for', '$size', '$respond_to?', '$class', '$dig', '$new', '$inspect', '$map', '$to_proc', '$flatten', '$eql?', '$default', '$dup', '$default_proc', '$default_proc=', '$-', '$default=', '$to_h', '$proc']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $Hash_$$$1, $Hash_allocate$2, $Hash_try_convert$3, $Hash_initialize$4, $Hash_$eq_eq$5, $Hash_$gt_eq$6, $Hash_$gt$8, $Hash_$lt$9, $Hash_$lt_eq$10, $Hash_$$$11, $Hash_$$$eq$12, $Hash_assoc$13, $Hash_clear$14, $Hash_clone$15, $Hash_compact$16, $Hash_compact$excl$17, $Hash_compare_by_identity$18, $Hash_compare_by_identity$ques$19, $Hash_default$20, $Hash_default$eq$21, $Hash_default_proc$22, $Hash_default_proc$eq$23, $Hash_delete$24, $Hash_delete_if$25, $Hash_dig$27, $Hash_each$28, $Hash_each_key$30, $Hash_each_value$32, $Hash_empty$ques$34, $Hash_fetch$35, $Hash_fetch_values$36, $Hash_flatten$38, $Hash_has_key$ques$39, $Hash_has_value$ques$40, $Hash_hash$41, $Hash_index$42, $Hash_indexes$43, $Hash_inspect$44, $Hash_invert$45, $Hash_keep_if$46, $Hash_keys$48, $Hash_length$49, $Hash_merge$50, $Hash_merge$excl$51, $Hash_rassoc$52, $Hash_rehash$53, $Hash_reject$54, $Hash_reject$excl$56, $Hash_replace$58, $Hash_select$59, $Hash_select$excl$61, $Hash_shift$63, $Hash_slice$64, $Hash_to_a$65, $Hash_to_h$66, $Hash_to_hash$67, $Hash_to_proc$68, $Hash_transform_keys$70, $Hash_transform_keys$excl$72, $Hash_transform_values$74, $Hash_transform_values$excl$76, $Hash_values$78;

    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_hash = true;
    Opal.defs(self, '$[]', $Hash_$$$1 = function($a) {
      var $post_args, argv, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      argv = $post_args;;
      
      var hash, argc = argv.length, i;

      if (argc === 1) {
        hash = $$($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), $$($nesting, 'Hash'), "to_hash");
        if (hash !== nil) {
          return self.$allocate()['$merge!'](hash);
        }

        argv = $$($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), $$($nesting, 'Array'), "to_ary");
        if (argv === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "odd number of arguments for Hash")
        }

        argc = argv.length;
        hash = self.$allocate();

        for (i = 0; i < argc; i++) {
          if (!argv[i].$$is_array) continue;
          switch(argv[i].length) {
          case 1:
            hash.$store(argv[i][0], nil);
            break;
          case 2:
            hash.$store(argv[i][0], argv[i][1]);
            break;
          default:
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid number of elements (" + (argv[i].length) + " for 1..2)")
          }
        }

        return hash;
      }

      if (argc % 2 !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "odd number of arguments for Hash")
      }

      hash = self.$allocate();

      for (i = 0; i < argc; i += 2) {
        hash.$store(argv[i], argv[i + 1]);
      }

      return hash;
    ;
    }, $Hash_$$$1.$$arity = -1);
    Opal.defs(self, '$allocate', $Hash_allocate$2 = function $$allocate() {
      var self = this;

      
      var hash = new self.$$constructor();

      Opal.hash_init(hash);

      hash.$$none = nil;
      hash.$$proc = nil;

      return hash;
    
    }, $Hash_allocate$2.$$arity = 0);
    Opal.defs(self, '$try_convert', $Hash_try_convert$3 = function $$try_convert(obj) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](obj, $$($nesting, 'Hash'), "to_hash")
    }, $Hash_try_convert$3.$$arity = 1);
    
    Opal.def(self, '$initialize', $Hash_initialize$4 = function $$initialize(defaults) {
      var $iter = $Hash_initialize$4.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_initialize$4.$$p = null;
      
      
      if ($iter) $Hash_initialize$4.$$p = null;;
      ;
      
      if (defaults !== undefined && block !== nil) {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (1 for 0)")
      }
      self.$$none = (defaults === undefined ? nil : defaults);
      self.$$proc = block;

      return self;
    ;
    }, $Hash_initialize$4.$$arity = -1);
    
    Opal.def(self, '$==', $Hash_$eq_eq$5 = function(other) {
      var self = this;

      
      if (self === other) {
        return true;
      }

      if (!other.$$is_hash) {
        return false;
      }

      if (self.$$keys.length !== other.$$keys.length) {
        return false;
      }

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, other_value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
          other_value = other.$$smap[key];
        } else {
          value = key.value;
          other_value = Opal.hash_get(other, key.key);
        }

        if (other_value === undefined || !value['$eql?'](other_value)) {
          return false;
        }
      }

      return true;
    
    }, $Hash_$eq_eq$5.$$arity = 1);
    
    Opal.def(self, '$>=', $Hash_$gt_eq$6 = function(other) {
      var $$7, self = this, result = nil;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      if (self.$$keys.length < other.$$keys.length) {
        return false
      }
    ;
      result = true;
      $send(other, 'each', [], ($$7 = function(other_key, other_val){var self = $$7.$$s == null ? this : $$7.$$s, val = nil;

      
        
        if (other_key == null) {
          other_key = nil;
        };
        
        if (other_val == null) {
          other_val = nil;
        };
        val = self.$fetch(other_key, null);
        
        if (val == null || val !== other_val) {
          result = false;
          return;
        }
      ;}, $$7.$$s = self, $$7.$$arity = 2, $$7));
      return result;
    }, $Hash_$gt_eq$6.$$arity = 1);
    
    Opal.def(self, '$>', $Hash_$gt$8 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      if (self.$$keys.length <= other.$$keys.length) {
        return false
      }
    ;
      return $rb_ge(self, other);
    }, $Hash_$gt$8.$$arity = 1);
    
    Opal.def(self, '$<', $Hash_$lt$9 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      return $rb_gt(other, self);
    }, $Hash_$lt$9.$$arity = 1);
    
    Opal.def(self, '$<=', $Hash_$lt_eq$10 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      return $rb_ge(other, self);
    }, $Hash_$lt_eq$10.$$arity = 1);
    
    Opal.def(self, '$[]', $Hash_$$$11 = function(key) {
      var self = this;

      
      var value = Opal.hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      return self.$default(key);
    
    }, $Hash_$$$11.$$arity = 1);
    
    Opal.def(self, '$[]=', $Hash_$$$eq$12 = function(key, value) {
      var self = this;

      
      Opal.hash_put(self, key, value);
      return value;
    
    }, $Hash_$$$eq$12.$$arity = 2);
    
    Opal.def(self, '$assoc', $Hash_assoc$13 = function $$assoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          if ((key)['$=='](object)) {
            return [key, self.$$smap[key]];
          }
        } else {
          if ((key.key)['$=='](object)) {
            return [key.key, key.value];
          }
        }
      }

      return nil;
    
    }, $Hash_assoc$13.$$arity = 1);
    
    Opal.def(self, '$clear', $Hash_clear$14 = function $$clear() {
      var self = this;

      
      Opal.hash_init(self);
      return self;
    
    }, $Hash_clear$14.$$arity = 0);
    
    Opal.def(self, '$clone', $Hash_clone$15 = function $$clone() {
      var self = this;

      
      var hash = new self.$$class();

      Opal.hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    
    }, $Hash_clone$15.$$arity = 0);
    
    Opal.def(self, '$compact', $Hash_compact$16 = function $$compact() {
      var self = this;

      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value !== nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    
    }, $Hash_compact$16.$$arity = 0);
    
    Opal.def(self, '$compact!', $Hash_compact$excl$17 = function() {
      var self = this;

      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    
    }, $Hash_compact$excl$17.$$arity = 0);
    
    Opal.def(self, '$compare_by_identity', $Hash_compare_by_identity$18 = function $$compare_by_identity() {
      var self = this;

      
      var i, ii, key, keys = self.$$keys, identity_hash;

      if (self.$$by_identity) return self;
      if (self.$$keys.length === 0) {
        self.$$by_identity = true
        return self;
      }

      identity_hash = $hash2([], {}).$compare_by_identity();
      for(i = 0, ii = keys.length; i < ii; i++) {
        key = keys[i];
        if (!key.$$is_string) key = key.key;
        Opal.hash_put(identity_hash, key, Opal.hash_get(self, key));
      }

      self.$$by_identity = true;
      self.$$map = identity_hash.$$map;
      self.$$smap = identity_hash.$$smap;
      return self;
    
    }, $Hash_compare_by_identity$18.$$arity = 0);
    
    Opal.def(self, '$compare_by_identity?', $Hash_compare_by_identity$ques$19 = function() {
      var self = this;

      return self.$$by_identity === true;
    }, $Hash_compare_by_identity$ques$19.$$arity = 0);
    
    Opal.def(self, '$default', $Hash_default$20 = function(key) {
      var self = this;

      
      ;
      
      if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {
        return self.$$proc.$call(self, key);
      }
      if (self.$$none === undefined) {
        return nil;
      }
      return self.$$none;
    ;
    }, $Hash_default$20.$$arity = -1);
    
    Opal.def(self, '$default=', $Hash_default$eq$21 = function(object) {
      var self = this;

      
      self.$$proc = nil;
      self.$$none = object;

      return object;
    
    }, $Hash_default$eq$21.$$arity = 1);
    
    Opal.def(self, '$default_proc', $Hash_default_proc$22 = function $$default_proc() {
      var self = this;

      
      if (self.$$proc !== undefined) {
        return self.$$proc;
      }
      return nil;
    
    }, $Hash_default_proc$22.$$arity = 0);
    
    Opal.def(self, '$default_proc=', $Hash_default_proc$eq$23 = function(default_proc) {
      var self = this;

      
      var proc = default_proc;

      if (proc !== nil) {
        proc = $$($nesting, 'Opal')['$coerce_to!'](proc, $$($nesting, 'Proc'), "to_proc");

        if ((proc)['$lambda?']() && (proc).$arity().$abs() !== 2) {
          self.$raise($$($nesting, 'TypeError'), "default_proc takes two arguments");
        }
      }

      self.$$none = nil;
      self.$$proc = proc;

      return default_proc;
    
    }, $Hash_default_proc$eq$23.$$arity = 1);
    
    Opal.def(self, '$delete', $Hash_delete$24 = function(key) {
      var $iter = $Hash_delete$24.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_delete$24.$$p = null;
      
      
      if ($iter) $Hash_delete$24.$$p = null;;
      
      var value = Opal.hash_delete(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return Opal.yield1(block, key);
      }

      return nil;
    ;
    }, $Hash_delete$24.$$arity = 1);
    
    Opal.def(self, '$delete_if', $Hash_delete_if$25 = function $$delete_if() {
      var $iter = $Hash_delete_if$25.$$p, block = $iter || nil, $$26, self = this;

      if ($iter) $Hash_delete_if$25.$$p = null;
      
      
      if ($iter) $Hash_delete_if$25.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["delete_if"], ($$26 = function(){var self = $$26.$$s == null ? this : $$26.$$s;

        return self.$size()}, $$26.$$s = self, $$26.$$arity = 0, $$26))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, $Hash_delete_if$25.$$arity = 0);
    Opal.alias(self, "dup", "clone");
    
    Opal.def(self, '$dig', $Hash_dig$27 = function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      keys = $post_args;;
      item = self['$[]'](key);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(keys));
    }, $Hash_dig$27.$$arity = -2);
    
    Opal.def(self, '$each', $Hash_each$28 = function $$each() {
      var $iter = $Hash_each$28.$$p, block = $iter || nil, $$29, self = this;

      if ($iter) $Hash_each$28.$$p = null;
      
      
      if ($iter) $Hash_each$28.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$29 = function(){var self = $$29.$$s == null ? this : $$29.$$s;

        return self.$size()}, $$29.$$s = self, $$29.$$arity = 0, $$29))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        Opal.yield1(block, [key, value]);
      }

      return self;
    ;
    }, $Hash_each$28.$$arity = 0);
    
    Opal.def(self, '$each_key', $Hash_each_key$30 = function $$each_key() {
      var $iter = $Hash_each_key$30.$$p, block = $iter || nil, $$31, self = this;

      if ($iter) $Hash_each_key$30.$$p = null;
      
      
      if ($iter) $Hash_each_key$30.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each_key"], ($$31 = function(){var self = $$31.$$s == null ? this : $$31.$$s;

        return self.$size()}, $$31.$$s = self, $$31.$$arity = 0, $$31))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? key : key.key);
      }

      return self;
    ;
    }, $Hash_each_key$30.$$arity = 0);
    Opal.alias(self, "each_pair", "each");
    
    Opal.def(self, '$each_value', $Hash_each_value$32 = function $$each_value() {
      var $iter = $Hash_each_value$32.$$p, block = $iter || nil, $$33, self = this;

      if ($iter) $Hash_each_value$32.$$p = null;
      
      
      if ($iter) $Hash_each_value$32.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each_value"], ($$33 = function(){var self = $$33.$$s == null ? this : $$33.$$s;

        return self.$size()}, $$33.$$s = self, $$33.$$arity = 0, $$33))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? self.$$smap[key] : key.value);
      }

      return self;
    ;
    }, $Hash_each_value$32.$$arity = 0);
    
    Opal.def(self, '$empty?', $Hash_empty$ques$34 = function() {
      var self = this;

      return self.$$keys.length === 0;
    }, $Hash_empty$ques$34.$$arity = 0);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$fetch', $Hash_fetch$35 = function $$fetch(key, defaults) {
      var $iter = $Hash_fetch$35.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_fetch$35.$$p = null;
      
      
      if ($iter) $Hash_fetch$35.$$p = null;;
      ;
      
      var value = Opal.hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return block(key);
      }

      if (defaults !== undefined) {
        return defaults;
      }
    ;
      return self.$raise($$($nesting, 'KeyError').$new("" + "key not found: " + (key.$inspect()), $hash2(["key", "receiver"], {"key": key, "receiver": self})));
    }, $Hash_fetch$35.$$arity = -2);
    
    Opal.def(self, '$fetch_values', $Hash_fetch_values$36 = function $$fetch_values($a) {
      var $iter = $Hash_fetch_values$36.$$p, block = $iter || nil, $post_args, keys, $$37, self = this;

      if ($iter) $Hash_fetch_values$36.$$p = null;
      
      
      if ($iter) $Hash_fetch_values$36.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      return $send(keys, 'map', [], ($$37 = function(key){var self = $$37.$$s == null ? this : $$37.$$s;

      
        
        if (key == null) {
          key = nil;
        };
        return $send(self, 'fetch', [key], block.$to_proc());}, $$37.$$s = self, $$37.$$arity = 1, $$37));
    }, $Hash_fetch_values$36.$$arity = -1);
    
    Opal.def(self, '$flatten', $Hash_flatten$38 = function $$flatten(level) {
      var self = this;

      
      
      if (level == null) {
        level = 1;
      };
      level = $$($nesting, 'Opal')['$coerce_to!'](level, $$($nesting, 'Integer'), "to_int");
      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push(key);

        if (value.$$is_array) {
          if (level === 1) {
            result.push(value);
            continue;
          }

          result = result.concat((value).$flatten(level - 2));
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, $Hash_flatten$38.$$arity = -1);
    
    Opal.def(self, '$has_key?', $Hash_has_key$ques$39 = function(key) {
      var self = this;

      return Opal.hash_get(self, key) !== undefined;
    }, $Hash_has_key$ques$39.$$arity = 1);
    
    Opal.def(self, '$has_value?', $Hash_has_value$ques$40 = function(value) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (((key.$$is_string ? self.$$smap[key] : key.value))['$=='](value)) {
          return true;
        }
      }

      return false;
    
    }, $Hash_has_value$ques$40.$$arity = 1);
    
    Opal.def(self, '$hash', $Hash_hash$41 = function $$hash() {
      var self = this;

      
      var top = (Opal.hash_ids === undefined),
          hash_id = self.$object_id(),
          result = ['Hash'],
          key, item;

      try {
        if (top) {
          Opal.hash_ids = Object.create(null);
        }

        if (Opal[hash_id]) {
          return 'self';
        }

        for (key in Opal.hash_ids) {
          item = Opal.hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        Opal.hash_ids[hash_id] = self;

        for (var i = 0, keys = self.$$keys, length = keys.length; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            result.push([key, self.$$smap[key].$hash()]);
          } else {
            result.push([key.key_hash, key.value.$hash()]);
          }
        }

        return result.sort().join();

      } finally {
        if (top) {
          Opal.hash_ids = undefined;
        }
      }
    
    }, $Hash_hash$41.$$arity = 0);
    Opal.alias(self, "include?", "has_key?");
    
    Opal.def(self, '$index', $Hash_index$42 = function $$index(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return key;
        }
      }

      return nil;
    
    }, $Hash_index$42.$$arity = 1);
    
    Opal.def(self, '$indexes', $Hash_indexes$43 = function $$indexes($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = [];

      for (var i = 0, length = args.length, key, value; i < length; i++) {
        key = args[i];
        value = Opal.hash_get(self, key);

        if (value === undefined) {
          result.push(self.$default());
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, $Hash_indexes$43.$$arity = -1);
    Opal.alias(self, "indices", "indexes");
    var inspect_ids;
    
    Opal.def(self, '$inspect', $Hash_inspect$44 = function $$inspect() {
      var self = this;

      
      var top = (inspect_ids === undefined),
          hash_id = self.$object_id(),
          result = [];

      try {
        if (top) {
          inspect_ids = {};
        }

        if (inspect_ids.hasOwnProperty(hash_id)) {
          return '{...}';
        }

        inspect_ids[hash_id] = true;

        for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          result.push(key.$inspect() + '=>' + value.$inspect());
        }

        return '{' + result.join(', ') + '}';

      } finally {
        if (top) {
          inspect_ids = undefined;
        }
      }
    
    }, $Hash_inspect$44.$$arity = 0);
    
    Opal.def(self, '$invert', $Hash_invert$45 = function $$invert() {
      var self = this;

      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        Opal.hash_put(hash, value, key);
      }

      return hash;
    
    }, $Hash_invert$45.$$arity = 0);
    
    Opal.def(self, '$keep_if', $Hash_keep_if$46 = function $$keep_if() {
      var $iter = $Hash_keep_if$46.$$p, block = $iter || nil, $$47, self = this;

      if ($iter) $Hash_keep_if$46.$$p = null;
      
      
      if ($iter) $Hash_keep_if$46.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["keep_if"], ($$47 = function(){var self = $$47.$$s == null ? this : $$47.$$s;

        return self.$size()}, $$47.$$s = self, $$47.$$arity = 0, $$47))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, $Hash_keep_if$46.$$arity = 0);
    Opal.alias(self, "key", "index");
    Opal.alias(self, "key?", "has_key?");
    
    Opal.def(self, '$keys', $Hash_keys$48 = function $$keys() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(key);
        } else {
          result.push(key.key);
        }
      }

      return result;
    
    }, $Hash_keys$48.$$arity = 0);
    
    Opal.def(self, '$length', $Hash_length$49 = function $$length() {
      var self = this;

      return self.$$keys.length;
    }, $Hash_length$49.$$arity = 0);
    Opal.alias(self, "member?", "has_key?");
    
    Opal.def(self, '$merge', $Hash_merge$50 = function $$merge(other) {
      var $iter = $Hash_merge$50.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_merge$50.$$p = null;
      
      
      if ($iter) $Hash_merge$50.$$p = null;;
      return $send(self.$dup(), 'merge!', [other], block.$to_proc());
    }, $Hash_merge$50.$$arity = 1);
    
    Opal.def(self, '$merge!', $Hash_merge$excl$51 = function(other) {
      var $iter = $Hash_merge$excl$51.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_merge$excl$51.$$p = null;
      
      
      if ($iter) $Hash_merge$excl$51.$$p = null;;
      
      if (!other.$$is_hash) {
        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      }

      var i, other_keys = other.$$keys, length = other_keys.length, key, value, other_value;

      if (block === nil) {
        for (i = 0; i < length; i++) {
          key = other_keys[i];

          if (key.$$is_string) {
            other_value = other.$$smap[key];
          } else {
            other_value = key.value;
            key = key.key;
          }

          Opal.hash_put(self, key, other_value);
        }

        return self;
      }

      for (i = 0; i < length; i++) {
        key = other_keys[i];

        if (key.$$is_string) {
          other_value = other.$$smap[key];
        } else {
          other_value = key.value;
          key = key.key;
        }

        value = Opal.hash_get(self, key);

        if (value === undefined) {
          Opal.hash_put(self, key, other_value);
          continue;
        }

        Opal.hash_put(self, key, block(key, value, other_value));
      }

      return self;
    ;
    }, $Hash_merge$excl$51.$$arity = 1);
    
    Opal.def(self, '$rassoc', $Hash_rassoc$52 = function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return [key, value];
        }
      }

      return nil;
    
    }, $Hash_rassoc$52.$$arity = 1);
    
    Opal.def(self, '$rehash', $Hash_rehash$53 = function $$rehash() {
      var self = this;

      
      Opal.hash_rehash(self);
      return self;
    
    }, $Hash_rehash$53.$$arity = 0);
    
    Opal.def(self, '$reject', $Hash_reject$54 = function $$reject() {
      var $iter = $Hash_reject$54.$$p, block = $iter || nil, $$55, self = this;

      if ($iter) $Hash_reject$54.$$p = null;
      
      
      if ($iter) $Hash_reject$54.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$55 = function(){var self = $$55.$$s == null ? this : $$55.$$s;

        return self.$size()}, $$55.$$s = self, $$55.$$arity = 0, $$55))
      };
      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, $Hash_reject$54.$$arity = 0);
    
    Opal.def(self, '$reject!', $Hash_reject$excl$56 = function() {
      var $iter = $Hash_reject$excl$56.$$p, block = $iter || nil, $$57, self = this;

      if ($iter) $Hash_reject$excl$56.$$p = null;
      
      
      if ($iter) $Hash_reject$excl$56.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["reject!"], ($$57 = function(){var self = $$57.$$s == null ? this : $$57.$$s;

        return self.$size()}, $$57.$$s = self, $$57.$$arity = 0, $$57))
      };
      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    ;
    }, $Hash_reject$excl$56.$$arity = 0);
    
    Opal.def(self, '$replace', $Hash_replace$58 = function $$replace(other) {
      var self = this, $writer = nil;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      Opal.hash_init(self);

      for (var i = 0, other_keys = other.$$keys, length = other_keys.length, key, value, other_value; i < length; i++) {
        key = other_keys[i];

        if (key.$$is_string) {
          other_value = other.$$smap[key];
        } else {
          other_value = key.value;
          key = key.key;
        }

        Opal.hash_put(self, key, other_value);
      }
    ;
      if ($truthy(other.$default_proc())) {
        
        $writer = [other.$default_proc()];
        $send(self, 'default_proc=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      } else {
        
        $writer = [other.$default()];
        $send(self, 'default=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };
      return self;
    }, $Hash_replace$58.$$arity = 1);
    
    Opal.def(self, '$select', $Hash_select$59 = function $$select() {
      var $iter = $Hash_select$59.$$p, block = $iter || nil, $$60, self = this;

      if ($iter) $Hash_select$59.$$p = null;
      
      
      if ($iter) $Hash_select$59.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["select"], ($$60 = function(){var self = $$60.$$s == null ? this : $$60.$$s;

        return self.$size()}, $$60.$$s = self, $$60.$$arity = 0, $$60))
      };
      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, $Hash_select$59.$$arity = 0);
    
    Opal.def(self, '$select!', $Hash_select$excl$61 = function() {
      var $iter = $Hash_select$excl$61.$$p, block = $iter || nil, $$62, self = this;

      if ($iter) $Hash_select$excl$61.$$p = null;
      
      
      if ($iter) $Hash_select$excl$61.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["select!"], ($$62 = function(){var self = $$62.$$s == null ? this : $$62.$$s;

        return self.$size()}, $$62.$$s = self, $$62.$$arity = 0, $$62))
      };
      
      var result = nil;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
          result = self;
        }
      }

      return result;
    ;
    }, $Hash_select$excl$61.$$arity = 0);
    Opal.alias(self, "filter", "select");
    Opal.alias(self, "filter!", "select!");
    
    Opal.def(self, '$shift', $Hash_shift$63 = function $$shift() {
      var self = this;

      
      var keys = self.$$keys,
          key;

      if (keys.length > 0) {
        key = keys[0];

        key = key.$$is_string ? key : key.key;

        return [key, Opal.hash_delete(self, key)];
      }

      return self.$default(nil);
    
    }, $Hash_shift$63.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$slice', $Hash_slice$64 = function $$slice($a) {
      var $post_args, keys, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      
      var result = Opal.hash();

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i], value = Opal.hash_get(self, key);

        if (value !== undefined) {
          Opal.hash_put(result, key, value);
        }
      }

      return result;
    ;
    }, $Hash_slice$64.$$arity = -1);
    Opal.alias(self, "store", "[]=");
    
    Opal.def(self, '$to_a', $Hash_to_a$65 = function $$to_a() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push([key, value]);
      }

      return result;
    
    }, $Hash_to_a$65.$$arity = 0);
    
    Opal.def(self, '$to_h', $Hash_to_h$66 = function $$to_h() {
      var $iter = $Hash_to_h$66.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_to_h$66.$$p = null;
      
      
      if ($iter) $Hash_to_h$66.$$p = null;;
      if ((block !== nil)) {
        return $send(self, 'map', [], block.$to_proc()).$to_h()};
      
      if (self.$$class === Opal.Hash) {
        return self;
      }

      var hash = new Opal.Hash();

      Opal.hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    ;
    }, $Hash_to_h$66.$$arity = 0);
    
    Opal.def(self, '$to_hash', $Hash_to_hash$67 = function $$to_hash() {
      var self = this;

      return self
    }, $Hash_to_hash$67.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Hash_to_proc$68 = function $$to_proc() {
      var $$69, self = this;

      return $send(self, 'proc', [], ($$69 = function(key){var self = $$69.$$s == null ? this : $$69.$$s;

      
        ;
        
        if (key == null) {
          self.$raise($$($nesting, 'ArgumentError'), "no key given")
        }
      ;
        return self['$[]'](key);}, $$69.$$s = self, $$69.$$arity = -1, $$69))
    }, $Hash_to_proc$68.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$transform_keys', $Hash_transform_keys$70 = function $$transform_keys() {
      var $iter = $Hash_transform_keys$70.$$p, block = $iter || nil, $$71, self = this;

      if ($iter) $Hash_transform_keys$70.$$p = null;
      
      
      if ($iter) $Hash_transform_keys$70.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_keys"], ($$71 = function(){var self = $$71.$$s == null ? this : $$71.$$s;

        return self.$size()}, $$71.$$s = self, $$71.$$arity = 0, $$71))
      };
      
      var result = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        key = Opal.yield1(block, key);

        Opal.hash_put(result, key, value);
      }

      return result;
    ;
    }, $Hash_transform_keys$70.$$arity = 0);
    
    Opal.def(self, '$transform_keys!', $Hash_transform_keys$excl$72 = function() {
      var $iter = $Hash_transform_keys$excl$72.$$p, block = $iter || nil, $$73, self = this;

      if ($iter) $Hash_transform_keys$excl$72.$$p = null;
      
      
      if ($iter) $Hash_transform_keys$excl$72.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_keys!"], ($$73 = function(){var self = $$73.$$s == null ? this : $$73.$$s;

        return self.$size()}, $$73.$$s = self, $$73.$$arity = 0, $$73))
      };
      
      var keys = Opal.slice.call(self.$$keys),
          i, length = keys.length, key, value, new_key;

      for (i = 0; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        new_key = Opal.yield1(block, key);

        Opal.hash_delete(self, key);
        Opal.hash_put(self, new_key, value);
      }

      return self;
    ;
    }, $Hash_transform_keys$excl$72.$$arity = 0);
    
    Opal.def(self, '$transform_values', $Hash_transform_values$74 = function $$transform_values() {
      var $iter = $Hash_transform_values$74.$$p, block = $iter || nil, $$75, self = this;

      if ($iter) $Hash_transform_values$74.$$p = null;
      
      
      if ($iter) $Hash_transform_values$74.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_values"], ($$75 = function(){var self = $$75.$$s == null ? this : $$75.$$s;

        return self.$size()}, $$75.$$s = self, $$75.$$arity = 0, $$75))
      };
      
      var result = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = Opal.yield1(block, value);

        Opal.hash_put(result, key, value);
      }

      return result;
    ;
    }, $Hash_transform_values$74.$$arity = 0);
    
    Opal.def(self, '$transform_values!', $Hash_transform_values$excl$76 = function() {
      var $iter = $Hash_transform_values$excl$76.$$p, block = $iter || nil, $$77, self = this;

      if ($iter) $Hash_transform_values$excl$76.$$p = null;
      
      
      if ($iter) $Hash_transform_values$excl$76.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_values!"], ($$77 = function(){var self = $$77.$$s == null ? this : $$77.$$s;

        return self.$size()}, $$77.$$s = self, $$77.$$arity = 0, $$77))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = Opal.yield1(block, value);

        Opal.hash_put(self, key, value);
      }

      return self;
    ;
    }, $Hash_transform_values$excl$76.$$arity = 0);
    Opal.alias(self, "update", "merge!");
    Opal.alias(self, "value?", "has_value?");
    Opal.alias(self, "values_at", "indexes");
    return (Opal.def(self, '$values', $Hash_values$78 = function $$values() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(self.$$smap[key]);
        } else {
          result.push(key.value);
        }
      }

      return result;
    
    }, $Hash_values$78.$$arity = 0), nil) && 'values';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/number"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $send2 = Opal.send2, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$bridge', '$raise', '$name', '$class', '$Float', '$respond_to?', '$coerce_to!', '$__coerced__', '$===', '$!', '$>', '$**', '$new', '$<', '$to_f', '$==', '$nan?', '$infinite?', '$enum_for', '$+', '$-', '$gcd', '$lcm', '$%', '$/', '$frexp', '$to_i', '$ldexp', '$rationalize', '$*', '$<<', '$to_r', '$truncate', '$-@', '$size', '$<=', '$>=', '$<=>', '$compare', '$any?']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Number');

    var $nesting = [self].concat($parent_nesting), $Number_coerce$2, $Number___id__$3, $Number_$plus$4, $Number_$minus$5, $Number_$$6, $Number_$slash$7, $Number_$percent$8, $Number_$$9, $Number_$$10, $Number_$$11, $Number_$lt$12, $Number_$lt_eq$13, $Number_$gt$14, $Number_$gt_eq$15, $Number_$lt_eq_gt$16, $Number_$lt$lt$17, $Number_$gt$gt$18, $Number_$$$19, $Number_$plus$$20, $Number_$minus$$21, $Number_$$22, $Number_$$$23, $Number_$eq_eq_eq$24, $Number_$eq_eq$25, $Number_abs$26, $Number_abs2$27, $Number_allbits$ques$28, $Number_anybits$ques$29, $Number_angle$30, $Number_bit_length$31, $Number_ceil$32, $Number_chr$33, $Number_denominator$34, $Number_downto$35, $Number_equal$ques$37, $Number_even$ques$38, $Number_floor$39, $Number_gcd$40, $Number_gcdlcm$41, $Number_integer$ques$42, $Number_is_a$ques$43, $Number_instance_of$ques$44, $Number_lcm$45, $Number_next$46, $Number_nobits$ques$47, $Number_nonzero$ques$48, $Number_numerator$49, $Number_odd$ques$50, $Number_ord$51, $Number_pow$52, $Number_pred$53, $Number_quo$54, $Number_rationalize$55, $Number_remainder$56, $Number_round$57, $Number_step$58, $Number_times$60, $Number_to_f$62, $Number_to_i$63, $Number_to_r$64, $Number_to_s$65, $Number_truncate$66, $Number_digits$67, $Number_divmod$68, $Number_upto$69, $Number_zero$ques$71, $Number_size$72, $Number_nan$ques$73, $Number_finite$ques$74, $Number_infinite$ques$75, $Number_positive$ques$76, $Number_negative$ques$77;

    
    $$($nesting, 'Opal').$bridge(Number, self);
    Opal.defineProperty(self.$$prototype, '$$is_number', true);
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$coerce', $Number_coerce$2 = function $$coerce(other) {
      var self = this;

      
      if (other === nil) {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (other.$class()) + " into Float");
      }
      else if (other.$$is_string) {
        return [self.$Float(other), self];
      }
      else if (other['$respond_to?']("to_f")) {
        return [$$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Float'), "to_f"), self];
      }
      else if (other.$$is_number) {
        return [other, self];
      }
      else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (other.$class()) + " into Float");
      }
    
    }, $Number_coerce$2.$$arity = 1);
    
    Opal.def(self, '$__id__', $Number___id__$3 = function $$__id__() {
      var self = this;

      return (self * 2) + 1;
    }, $Number___id__$3.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.def(self, '$+', $Number_$plus$4 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self + other;
      }
      else {
        return self.$__coerced__("+", other);
      }
    
    }, $Number_$plus$4.$$arity = 1);
    
    Opal.def(self, '$-', $Number_$minus$5 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self - other;
      }
      else {
        return self.$__coerced__("-", other);
      }
    
    }, $Number_$minus$5.$$arity = 1);
    
    Opal.def(self, '$*', $Number_$$6 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self * other;
      }
      else {
        return self.$__coerced__("*", other);
      }
    
    }, $Number_$$6.$$arity = 1);
    
    Opal.def(self, '$/', $Number_$slash$7 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self / other;
      }
      else {
        return self.$__coerced__("/", other);
      }
    
    }, $Number_$slash$7.$$arity = 1);
    Opal.alias(self, "fdiv", "/");
    
    Opal.def(self, '$%', $Number_$percent$8 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        if (other == -Infinity) {
          return other;
        }
        else if (other == 0) {
          self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0");
        }
        else if (other < 0 || self < 0) {
          return (self % other + other) % other;
        }
        else {
          return self % other;
        }
      }
      else {
        return self.$__coerced__("%", other);
      }
    
    }, $Number_$percent$8.$$arity = 1);
    
    Opal.def(self, '$&', $Number_$$9 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self & other;
      }
      else {
        return self.$__coerced__("&", other);
      }
    
    }, $Number_$$9.$$arity = 1);
    
    Opal.def(self, '$|', $Number_$$10 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self | other;
      }
      else {
        return self.$__coerced__("|", other);
      }
    
    }, $Number_$$10.$$arity = 1);
    
    Opal.def(self, '$^', $Number_$$11 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self ^ other;
      }
      else {
        return self.$__coerced__("^", other);
      }
    
    }, $Number_$$11.$$arity = 1);
    
    Opal.def(self, '$<', $Number_$lt$12 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self < other;
      }
      else {
        return self.$__coerced__("<", other);
      }
    
    }, $Number_$lt$12.$$arity = 1);
    
    Opal.def(self, '$<=', $Number_$lt_eq$13 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self <= other;
      }
      else {
        return self.$__coerced__("<=", other);
      }
    
    }, $Number_$lt_eq$13.$$arity = 1);
    
    Opal.def(self, '$>', $Number_$gt$14 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self > other;
      }
      else {
        return self.$__coerced__(">", other);
      }
    
    }, $Number_$gt$14.$$arity = 1);
    
    Opal.def(self, '$>=', $Number_$gt_eq$15 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self >= other;
      }
      else {
        return self.$__coerced__(">=", other);
      }
    
    }, $Number_$gt_eq$15.$$arity = 1);
    
    var spaceship_operator = function(self, other) {
      if (other.$$is_number) {
        if (isNaN(self) || isNaN(other)) {
          return nil;
        }

        if (self > other) {
          return 1;
        } else if (self < other) {
          return -1;
        } else {
          return 0;
        }
      }
      else {
        return self.$__coerced__("<=>", other);
      }
    }
  ;
    
    Opal.def(self, '$<=>', $Number_$lt_eq_gt$16 = function(other) {
      var self = this;

      try {
        return spaceship_operator(self, other);
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return nil
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Number_$lt_eq_gt$16.$$arity = 1);
    
    Opal.def(self, '$<<', $Number_$lt$lt$17 = function(count) {
      var self = this;

      
      count = $$($nesting, 'Opal')['$coerce_to!'](count, $$($nesting, 'Integer'), "to_int");
      return count > 0 ? self << count : self >> -count;
    }, $Number_$lt$lt$17.$$arity = 1);
    
    Opal.def(self, '$>>', $Number_$gt$gt$18 = function(count) {
      var self = this;

      
      count = $$($nesting, 'Opal')['$coerce_to!'](count, $$($nesting, 'Integer'), "to_int");
      return count > 0 ? self >> count : self << -count;
    }, $Number_$gt$gt$18.$$arity = 1);
    
    Opal.def(self, '$[]', $Number_$$$19 = function(bit) {
      var self = this;

      
      bit = $$($nesting, 'Opal')['$coerce_to!'](bit, $$($nesting, 'Integer'), "to_int");
      
      if (bit < 0) {
        return 0;
      }
      if (bit >= 32) {
        return self < 0 ? 1 : 0;
      }
      return (self >> bit) & 1;
    ;
    }, $Number_$$$19.$$arity = 1);
    
    Opal.def(self, '$+@', $Number_$plus$$20 = function() {
      var self = this;

      return +self;
    }, $Number_$plus$$20.$$arity = 0);
    
    Opal.def(self, '$-@', $Number_$minus$$21 = function() {
      var self = this;

      return -self;
    }, $Number_$minus$$21.$$arity = 0);
    
    Opal.def(self, '$~', $Number_$$22 = function() {
      var self = this;

      return ~self;
    }, $Number_$$22.$$arity = 0);
    
    Opal.def(self, '$**', $Number_$$$23 = function(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
        if ($truthy((function() {if ($truthy(($ret_or_1 = $$($nesting, 'Integer')['$==='](self)['$!']()))) {
          return $ret_or_1
        } else {
          return $rb_gt(other, 0)
        }; return nil; })())) {
          return Math.pow(self, other);
        } else {
          return $$($nesting, 'Rational').$new(self, 1)['$**'](other)
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_2 = $rb_lt(self, 0)))) {
        
        if ($truthy(($ret_or_3 = $$($nesting, 'Float')['$==='](other)))) {
          return $ret_or_3
        } else {
          return $$($nesting, 'Rational')['$==='](other)
        };
      } else {
        return $ret_or_2
      }; return nil; })())) {
        return $$($nesting, 'Complex').$new(self, 0)['$**'](other.$to_f())
      } else if ($truthy(other.$$is_number != null)) {
        return Math.pow(self, other);
      } else {
        return self.$__coerced__("**", other)
      }
    }, $Number_$$$23.$$arity = 1);
    
    Opal.def(self, '$===', $Number_$eq_eq_eq$24 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, $Number_$eq_eq_eq$24.$$arity = 1);
    
    Opal.def(self, '$==', $Number_$eq_eq$25 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, $Number_$eq_eq$25.$$arity = 1);
    
    Opal.def(self, '$abs', $Number_abs$26 = function $$abs() {
      var self = this;

      return Math.abs(self);
    }, $Number_abs$26.$$arity = 0);
    
    Opal.def(self, '$abs2', $Number_abs2$27 = function $$abs2() {
      var self = this;

      return Math.abs(self * self);
    }, $Number_abs2$27.$$arity = 0);
    
    Opal.def(self, '$allbits?', $Number_allbits$ques$28 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) == mask;;
    }, $Number_allbits$ques$28.$$arity = 1);
    
    Opal.def(self, '$anybits?', $Number_anybits$ques$29 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) !== 0;;
    }, $Number_anybits$ques$29.$$arity = 1);
    
    Opal.def(self, '$angle', $Number_angle$30 = function $$angle() {
      var self = this;

      
      if ($truthy(self['$nan?']())) {
        return self};
      
      if (self == 0) {
        if (1 / self > 0) {
          return 0;
        }
        else {
          return Math.PI;
        }
      }
      else if (self < 0) {
        return Math.PI;
      }
      else {
        return 0;
      }
    ;
    }, $Number_angle$30.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    Opal.alias(self, "phase", "angle");
    
    Opal.def(self, '$bit_length', $Number_bit_length$31 = function $$bit_length() {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
      } else {
        self.$raise($$($nesting, 'NoMethodError').$new("" + "undefined method `bit_length` for " + (self) + ":Float", "bit_length"))
      };
      
      if (self === 0 || self === -1) {
        return 0;
      }

      var result = 0,
          value  = self < 0 ? ~self : self;

      while (value != 0) {
        result   += 1;
        value  >>>= 1;
      }

      return result;
    ;
    }, $Number_bit_length$31.$$arity = 0);
    
    Opal.def(self, '$ceil', $Number_ceil$32 = function $$ceil(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.ceil(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_ceil$32.$$arity = -1);
    
    Opal.def(self, '$chr', $Number_chr$33 = function $$chr(encoding) {
      var self = this;

      
      ;
      return String.fromCharCode(self);;
    }, $Number_chr$33.$$arity = -1);
    
    Opal.def(self, '$denominator', $Number_denominator$34 = function $$denominator() {
      var $iter = $Number_denominator$34.$$p, $yield = $iter || nil, self = this, $ret_or_4 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_denominator$34.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy((function() {if ($truthy(($ret_or_4 = self['$nan?']()))) {
        return $ret_or_4
      } else {
        return self['$infinite?']()
      }; return nil; })())) {
        return 1
      } else {
        return $send2(self, Opal.find_super_dispatcher(self, 'denominator', $Number_denominator$34, false, true), 'denominator', $zuper, $iter)
      }
    }, $Number_denominator$34.$$arity = 0);
    
    Opal.def(self, '$downto', $Number_downto$35 = function $$downto(stop) {
      var $iter = $Number_downto$35.$$p, block = $iter || nil, $$36, self = this;

      if ($iter) $Number_downto$35.$$p = null;
      
      
      if ($iter) $Number_downto$35.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["downto", stop], ($$36 = function(){var self = $$36.$$s == null ? this : $$36.$$s;

        
          if ($truthy($$($nesting, 'Numeric')['$==='](stop))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_gt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(self, stop), 1)
          };}, $$36.$$s = self, $$36.$$arity = 0, $$36))
      };
      
      if (!stop.$$is_number) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i >= stop; i--) {
        block(i);
      }
    ;
      return self;
    }, $Number_downto$35.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$equal?', $Number_equal$ques$37 = function(other) {
      var self = this, $ret_or_5 = nil;

      if ($truthy(($ret_or_5 = self['$=='](other)))) {
        return $ret_or_5
      } else {
        return isNaN(self) && isNaN(other);
      }
    }, $Number_equal$ques$37.$$arity = 1);
    
    Opal.def(self, '$even?', $Number_even$ques$38 = function() {
      var self = this;

      return self % 2 === 0;
    }, $Number_even$ques$38.$$arity = 0);
    
    Opal.def(self, '$floor', $Number_floor$39 = function $$floor(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.floor(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_floor$39.$$arity = -1);
    
    Opal.def(self, '$gcd', $Number_gcd$40 = function $$gcd(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an integer")
      };
      
      var min = Math.abs(self),
          max = Math.abs(other);

      while (min > 0) {
        var tmp = min;

        min = max % min;
        max = tmp;
      }

      return max;
    ;
    }, $Number_gcd$40.$$arity = 1);
    
    Opal.def(self, '$gcdlcm', $Number_gcdlcm$41 = function $$gcdlcm(other) {
      var self = this;

      return [self.$gcd(other), self.$lcm(other)]
    }, $Number_gcdlcm$41.$$arity = 1);
    
    Opal.def(self, '$integer?', $Number_integer$ques$42 = function() {
      var self = this;

      return self % 1 === 0;
    }, $Number_integer$ques$42.$$arity = 0);
    
    Opal.def(self, '$is_a?', $Number_is_a$ques$43 = function(klass) {
      var $iter = $Number_is_a$ques$43.$$p, $yield = $iter || nil, self = this, $ret_or_6 = nil, $ret_or_7 = nil, $ret_or_8 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_is_a$ques$43.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy((function() {if ($truthy(($ret_or_6 = klass['$==']($$($nesting, 'Integer'))))) {
        return $$($nesting, 'Integer')['$==='](self)
      } else {
        return $ret_or_6
      }; return nil; })())) {
        return true};
      if ($truthy((function() {if ($truthy(($ret_or_7 = klass['$==']($$($nesting, 'Integer'))))) {
        return $$($nesting, 'Integer')['$==='](self)
      } else {
        return $ret_or_7
      }; return nil; })())) {
        return true};
      if ($truthy((function() {if ($truthy(($ret_or_8 = klass['$==']($$($nesting, 'Float'))))) {
        return $$($nesting, 'Float')['$==='](self)
      } else {
        return $ret_or_8
      }; return nil; })())) {
        return true};
      return $send2(self, Opal.find_super_dispatcher(self, 'is_a?', $Number_is_a$ques$43, false, true), 'is_a?', $zuper, $iter);
    }, $Number_is_a$ques$43.$$arity = 1);
    Opal.alias(self, "kind_of?", "is_a?");
    
    Opal.def(self, '$instance_of?', $Number_instance_of$ques$44 = function(klass) {
      var $iter = $Number_instance_of$ques$44.$$p, $yield = $iter || nil, self = this, $ret_or_9 = nil, $ret_or_10 = nil, $ret_or_11 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_instance_of$ques$44.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy((function() {if ($truthy(($ret_or_9 = klass['$==']($$($nesting, 'Integer'))))) {
        return $$($nesting, 'Integer')['$==='](self)
      } else {
        return $ret_or_9
      }; return nil; })())) {
        return true};
      if ($truthy((function() {if ($truthy(($ret_or_10 = klass['$==']($$($nesting, 'Integer'))))) {
        return $$($nesting, 'Integer')['$==='](self)
      } else {
        return $ret_or_10
      }; return nil; })())) {
        return true};
      if ($truthy((function() {if ($truthy(($ret_or_11 = klass['$==']($$($nesting, 'Float'))))) {
        return $$($nesting, 'Float')['$==='](self)
      } else {
        return $ret_or_11
      }; return nil; })())) {
        return true};
      return $send2(self, Opal.find_super_dispatcher(self, 'instance_of?', $Number_instance_of$ques$44, false, true), 'instance_of?', $zuper, $iter);
    }, $Number_instance_of$ques$44.$$arity = 1);
    
    Opal.def(self, '$lcm', $Number_lcm$45 = function $$lcm(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an integer")
      };
      
      if (self == 0 || other == 0) {
        return 0;
      }
      else {
        return Math.abs(self * other / self.$gcd(other));
      }
    ;
    }, $Number_lcm$45.$$arity = 1);
    Opal.alias(self, "magnitude", "abs");
    Opal.alias(self, "modulo", "%");
    
    Opal.def(self, '$next', $Number_next$46 = function $$next() {
      var self = this;

      return self + 1;
    }, $Number_next$46.$$arity = 0);
    
    Opal.def(self, '$nobits?', $Number_nobits$ques$47 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) == 0;;
    }, $Number_nobits$ques$47.$$arity = 1);
    
    Opal.def(self, '$nonzero?', $Number_nonzero$ques$48 = function() {
      var self = this;

      return self == 0 ? nil : self;
    }, $Number_nonzero$ques$48.$$arity = 0);
    
    Opal.def(self, '$numerator', $Number_numerator$49 = function $$numerator() {
      var $iter = $Number_numerator$49.$$p, $yield = $iter || nil, self = this, $ret_or_12 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_numerator$49.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy((function() {if ($truthy(($ret_or_12 = self['$nan?']()))) {
        return $ret_or_12
      } else {
        return self['$infinite?']()
      }; return nil; })())) {
        return self
      } else {
        return $send2(self, Opal.find_super_dispatcher(self, 'numerator', $Number_numerator$49, false, true), 'numerator', $zuper, $iter)
      }
    }, $Number_numerator$49.$$arity = 0);
    
    Opal.def(self, '$odd?', $Number_odd$ques$50 = function() {
      var self = this;

      return self % 2 !== 0;
    }, $Number_odd$ques$50.$$arity = 0);
    
    Opal.def(self, '$ord', $Number_ord$51 = function $$ord() {
      var self = this;

      return self
    }, $Number_ord$51.$$arity = 0);
    
    Opal.def(self, '$pow', $Number_pow$52 = function $$pow(b, m) {
      var self = this;

      
      ;
      
      if (self == 0) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      }

      if (m === undefined) {
        return self['$**'](b);
      } else {
        if (!($$($nesting, 'Integer')['$==='](b))) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 2nd argument not allowed unless a 1st argument is integer")
        }

        if (b < 0) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 1st argument cannot be negative when 2nd argument specified")
        }

        if (!($$($nesting, 'Integer')['$==='](m))) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 2nd argument not allowed unless all arguments are integers")
        }

        if (m === 0) {
          self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
        }

        return self['$**'](b)['$%'](m)
      }
    ;
    }, $Number_pow$52.$$arity = -2);
    
    Opal.def(self, '$pred', $Number_pred$53 = function $$pred() {
      var self = this;

      return self - 1;
    }, $Number_pred$53.$$arity = 0);
    
    Opal.def(self, '$quo', $Number_quo$54 = function $$quo(other) {
      var $iter = $Number_quo$54.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_quo$54.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $send2(self, Opal.find_super_dispatcher(self, 'quo', $Number_quo$54, false, true), 'quo', $zuper, $iter)
      } else {
        return $rb_divide(self, other)
      }
    }, $Number_quo$54.$$arity = 1);
    
    Opal.def(self, '$rationalize', $Number_rationalize$55 = function $$rationalize(eps) {
      var $a, $b, self = this, f = nil, n = nil;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $$($nesting, 'Rational').$new(self, 1)
      } else if ($truthy(self['$infinite?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "Infinity")
      } else if ($truthy(self['$nan?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "NaN")
      } else if ($truthy(eps == null)) {
        
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (n = ($a[1] == null ? nil : $a[1])), $b;
        f = $$($nesting, 'Math').$ldexp(f, $$$($$($nesting, 'Float'), 'MANT_DIG')).$to_i();
        n = $rb_minus(n, $$$($$($nesting, 'Float'), 'MANT_DIG'));
        return $$($nesting, 'Rational').$new($rb_times(2, f), (1)['$<<']($rb_minus(1, n))).$rationalize($$($nesting, 'Rational').$new(1, (1)['$<<']($rb_minus(1, n))));
      } else {
        return self.$to_r().$rationalize(eps)
      };
    }, $Number_rationalize$55.$$arity = -1);
    
    Opal.def(self, '$remainder', $Number_remainder$56 = function $$remainder(y) {
      var self = this;

      return $rb_minus(self, $rb_times(y, $rb_divide(self, y).$truncate()))
    }, $Number_remainder$56.$$arity = 1);
    
    Opal.def(self, '$round', $Number_round$57 = function $$round(ndigits) {
      var $a, $b, self = this, $ret_or_13 = nil, $ret_or_14 = nil, $ret_or_15 = nil, _ = nil, exp = nil;

      
      ;
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        
        if ($truthy(ndigits == null)) {
          return self};
        if ($truthy((function() {if ($truthy(($ret_or_13 = $$($nesting, 'Float')['$==='](ndigits)))) {
          return ndigits['$infinite?']()
        } else {
          return $ret_or_13
        }; return nil; })())) {
          self.$raise($$($nesting, 'RangeError'), "Infinity")};
        ndigits = $$($nesting, 'Opal')['$coerce_to!'](ndigits, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_lt(ndigits, $$$($$($nesting, 'Integer'), 'MIN')))) {
          self.$raise($$($nesting, 'RangeError'), "out of bounds")};
        if ($truthy(ndigits >= 0)) {
          return self};
        ndigits = ndigits['$-@']();
        
        if (0.415241 * ndigits - 0.125 > self.$size()) {
          return 0;
        }

        var f = Math.pow(10, ndigits),
            x = Math.floor((Math.abs(self) + f / 2) / f) * f;

        return self < 0 ? -x : x;
      ;
      } else {
        
        if ($truthy((function() {if ($truthy(($ret_or_14 = self['$nan?']()))) {
          return ndigits == null;
        } else {
          return $ret_or_14
        }; return nil; })())) {
          self.$raise($$($nesting, 'FloatDomainError'), "NaN")};
        ndigits = $$($nesting, 'Opal')['$coerce_to!'](ndigits || 0, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_le(ndigits, 0))) {
          if ($truthy(self['$nan?']())) {
            self.$raise($$($nesting, 'RangeError'), "NaN")
          } else if ($truthy(self['$infinite?']())) {
            self.$raise($$($nesting, 'FloatDomainError'), "Infinity")}
        } else if (ndigits['$=='](0)) {
          return Math.round(self)
        } else if ($truthy((function() {if ($truthy(($ret_or_15 = self['$nan?']()))) {
          return $ret_or_15
        } else {
          return self['$infinite?']()
        }; return nil; })())) {
          return self};
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (exp = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus($$$($$($nesting, 'Float'), 'DIG'), 2), (function() {if ($truthy($rb_gt(exp, 0))) {
          return $rb_divide(exp, 4)
        } else {
          return $rb_minus($rb_divide(exp, 3), 1)
        }; return nil; })())))) {
          return self};
        if ($truthy($rb_lt(ndigits, (function() {if ($truthy($rb_gt(exp, 0))) {
          return $rb_plus($rb_divide(exp, 3), 1)
        } else {
          return $rb_divide(exp, 4)
        }; return nil; })()['$-@']()))) {
          return 0};
        return Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits);;
      };
    }, $Number_round$57.$$arity = -1);
    
    Opal.def(self, '$step', $Number_step$58 = function $$step($a, $b, $c) {
      var $iter = $Number_step$58.$$p, block = $iter || nil, $post_args, $kwargs, limit, step, to, by, $$59, self = this, positional_args = nil, keyword_args = nil;

      if ($iter) $Number_step$58.$$p = null;
      
      
      if ($iter) $Number_step$58.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      if ($post_args.length > 0) {
        limit = $post_args[0];
        $post_args.splice(0, 1);
      };
      
      if ($post_args.length > 0) {
        step = $post_args[0];
        $post_args.splice(0, 1);
      };
      
      to = $kwargs.$$smap["to"];;
      
      by = $kwargs.$$smap["by"];;
      
      if (limit !== undefined && to !== undefined) {
        self.$raise($$($nesting, 'ArgumentError'), "to is given twice")
      }

      if (step !== undefined && by !== undefined) {
        self.$raise($$($nesting, 'ArgumentError'), "step is given twice")
      }

      function validateParameters() {
        if (to !== undefined) {
          limit = to;
        }

        if (limit === undefined) {
          limit = nil;
        }

        if (step === nil) {
          self.$raise($$($nesting, 'TypeError'), "step must be numeric")
        }

        if (step === 0) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be 0")
        }

        if (by !== undefined) {
          step = by;
        }

        if (step === nil || step == null) {
          step = 1;
        }

        var sign = step['$<=>'](0);

        if (sign === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "0 can't be coerced into " + (step.$class()))
        }

        if (limit === nil || limit == null) {
          limit = sign > 0 ? $$$($$($nesting, 'Float'), 'INFINITY') : $$$($$($nesting, 'Float'), 'INFINITY')['$-@']();
        }

        $$($nesting, 'Opal').$compare(self, limit)
      }

      function stepFloatSize() {
        if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else if (step === Infinity || step === -Infinity) {
          return 1;
        } else {
          var abs = Math.abs, floor = Math.floor,
              err = (abs(self) + abs(limit) + abs(limit - self)) / abs(step) * $$$($$($nesting, 'Float'), 'EPSILON');

          if (err === Infinity || err === -Infinity) {
            return 0;
          } else {
            if (err > 0.5) {
              err = 0.5;
            }

            return floor((limit - self) / step + err) + 1
          }
        }
      }

      function stepSize() {
        validateParameters();

        if (step === 0) {
          return Infinity;
        }

        if (step % 1 !== 0) {
          return stepFloatSize();
        } else if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else {
          var ceil = Math.ceil, abs = Math.abs,
              lhs = abs(self - limit) + 1,
              rhs = abs(step);

          return ceil(lhs / rhs);
        }
      }
    ;
      if ((block !== nil)) {
      } else {
        
        positional_args = [];
        keyword_args = $hash2([], {});
        
        if (limit !== undefined) {
          positional_args.push(limit);
        }

        if (step !== undefined) {
          positional_args.push(step);
        }

        if (to !== undefined) {
          Opal.hash_put(keyword_args, "to", to);
        }

        if (by !== undefined) {
          Opal.hash_put(keyword_args, "by", by);
        }

        if (keyword_args['$any?']()) {
          positional_args.push(keyword_args);
        }
      ;
        return $send(self, 'enum_for', ["step"].concat(Opal.to_a(positional_args)), ($$59 = function(){var self = $$59.$$s == null ? this : $$59.$$s;

        return stepSize();}, $$59.$$s = self, $$59.$$arity = 0, $$59));
      };
      
      validateParameters();

      if (step === 0) {
        while (true) {
          block(self);
        }
      }

      if (self % 1 !== 0 || limit % 1 !== 0 || step % 1 !== 0) {
        var n = stepFloatSize();

        if (n > 0) {
          if (step === Infinity || step === -Infinity) {
            block(self);
          } else {
            var i = 0, d;

            if (step > 0) {
              while (i < n) {
                d = i * step + self;
                if (limit < d) {
                  d = limit;
                }
                block(d);
                i += 1;
              }
            } else {
              while (i < n) {
                d = i * step + self;
                if (limit > d) {
                  d = limit;
                }
                block(d);
                i += 1
              }
            }
          }
        }
      } else {
        var value = self;

        if (step > 0) {
          while (value <= limit) {
            block(value);
            value += step;
          }
        } else {
          while (value >= limit) {
            block(value);
            value += step
          }
        }
      }

      return self;
    ;
    }, $Number_step$58.$$arity = -1);
    Opal.alias(self, "succ", "next");
    
    Opal.def(self, '$times', $Number_times$60 = function $$times() {
      var $iter = $Number_times$60.$$p, block = $iter || nil, $$61, self = this;

      if ($iter) $Number_times$60.$$p = null;
      
      
      if ($iter) $Number_times$60.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["times"], ($$61 = function(){var self = $$61.$$s == null ? this : $$61.$$s;

        return self}, $$61.$$s = self, $$61.$$arity = 0, $$61))
      };
      
      for (var i = 0; i < self; i++) {
        block(i);
      }
    ;
      return self;
    }, $Number_times$60.$$arity = 0);
    
    Opal.def(self, '$to_f', $Number_to_f$62 = function $$to_f() {
      var self = this;

      return self
    }, $Number_to_f$62.$$arity = 0);
    
    Opal.def(self, '$to_i', $Number_to_i$63 = function $$to_i() {
      var self = this;

      return parseInt(self, 10);
    }, $Number_to_i$63.$$arity = 0);
    Opal.alias(self, "to_int", "to_i");
    
    Opal.def(self, '$to_r', $Number_to_r$64 = function $$to_r() {
      var $a, $b, self = this, f = nil, e = nil;

      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $$($nesting, 'Rational').$new(self, 1)
      } else {
        
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (e = ($a[1] == null ? nil : $a[1])), $b;
        f = $$($nesting, 'Math').$ldexp(f, $$$($$($nesting, 'Float'), 'MANT_DIG')).$to_i();
        e = $rb_minus(e, $$$($$($nesting, 'Float'), 'MANT_DIG'));
        return $rb_times(f, $$$($$($nesting, 'Float'), 'RADIX')['$**'](e)).$to_r();
      }
    }, $Number_to_r$64.$$arity = 0);
    
    Opal.def(self, '$to_s', $Number_to_s$65 = function $$to_s(base) {
      var self = this, $ret_or_16 = nil;

      
      
      if (base == null) {
        base = 10;
      };
      base = $$($nesting, 'Opal')['$coerce_to!'](base, $$($nesting, 'Integer'), "to_int");
      if ($truthy((function() {if ($truthy(($ret_or_16 = $rb_lt(base, 2)))) {
        return $ret_or_16
      } else {
        return $rb_gt(base, 36)
      }; return nil; })())) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))};
      return self.toString(base);;
    }, $Number_to_s$65.$$arity = -1);
    
    Opal.def(self, '$truncate', $Number_truncate$66 = function $$truncate(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = parseInt(f * factor, 10) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_truncate$66.$$arity = -1);
    Opal.alias(self, "inspect", "to_s");
    
    Opal.def(self, '$digits', $Number_digits$67 = function $$digits(base) {
      var self = this;

      
      
      if (base == null) {
        base = 10;
      };
      if ($rb_lt(self, 0)) {
        self.$raise($$$($$($nesting, 'Math'), 'DomainError'), "out of domain")};
      base = $$($nesting, 'Opal')['$coerce_to!'](base, $$($nesting, 'Integer'), "to_int");
      if ($truthy($rb_lt(base, 2))) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))};
      
      var value = self, result = [];

      while (value !== 0) {
        result.push(value % base);
        value = parseInt(value / base, 10);
      }

      return result;
    ;
    }, $Number_digits$67.$$arity = -1);
    
    Opal.def(self, '$divmod', $Number_divmod$68 = function $$divmod(other) {
      var $iter = $Number_divmod$68.$$p, $yield = $iter || nil, self = this, $ret_or_17 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_divmod$68.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy((function() {if ($truthy(($ret_or_17 = self['$nan?']()))) {
        return $ret_or_17
      } else {
        return other['$nan?']()
      }; return nil; })())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "NaN")
      } else if ($truthy(self['$infinite?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "Infinity")
      } else {
        return $send2(self, Opal.find_super_dispatcher(self, 'divmod', $Number_divmod$68, false, true), 'divmod', $zuper, $iter)
      }
    }, $Number_divmod$68.$$arity = 1);
    
    Opal.def(self, '$upto', $Number_upto$69 = function $$upto(stop) {
      var $iter = $Number_upto$69.$$p, block = $iter || nil, $$70, self = this;

      if ($iter) $Number_upto$69.$$p = null;
      
      
      if ($iter) $Number_upto$69.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["upto", stop], ($$70 = function(){var self = $$70.$$s == null ? this : $$70.$$s;

        
          if ($truthy($$($nesting, 'Numeric')['$==='](stop))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_lt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(stop, self), 1)
          };}, $$70.$$s = self, $$70.$$arity = 0, $$70))
      };
      
      if (!stop.$$is_number) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i <= stop; i++) {
        block(i);
      }
    ;
      return self;
    }, $Number_upto$69.$$arity = 1);
    
    Opal.def(self, '$zero?', $Number_zero$ques$71 = function() {
      var self = this;

      return self == 0;
    }, $Number_zero$ques$71.$$arity = 0);
    
    Opal.def(self, '$size', $Number_size$72 = function $$size() {
      var self = this;

      return 4
    }, $Number_size$72.$$arity = 0);
    
    Opal.def(self, '$nan?', $Number_nan$ques$73 = function() {
      var self = this;

      return isNaN(self);
    }, $Number_nan$ques$73.$$arity = 0);
    
    Opal.def(self, '$finite?', $Number_finite$ques$74 = function() {
      var self = this;

      return self != Infinity && self != -Infinity && !isNaN(self);
    }, $Number_finite$ques$74.$$arity = 0);
    
    Opal.def(self, '$infinite?', $Number_infinite$ques$75 = function() {
      var self = this;

      
      if (self == Infinity) {
        return +1;
      }
      else if (self == -Infinity) {
        return -1;
      }
      else {
        return nil;
      }
    
    }, $Number_infinite$ques$75.$$arity = 0);
    
    Opal.def(self, '$positive?', $Number_positive$ques$76 = function() {
      var self = this;

      return self != 0 && (self == Infinity || 1 / self > 0);
    }, $Number_positive$ques$76.$$arity = 0);
    return (Opal.def(self, '$negative?', $Number_negative$ques$77 = function() {
      var self = this;

      return self == -Infinity || 1 / self < 0;
    }, $Number_negative$ques$77.$$arity = 0), nil) && 'negative?';
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  Opal.const_set($nesting[0], 'Fixnum', $$($nesting, 'Number'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Integer');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    self.$$is_integer_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$78, $sqrt$79;

      
      
      Opal.def(self, '$allocate', $allocate$78 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$78.$$arity = 0);
      
      Opal.udef(self, '$' + "new");;
      return (Opal.def(self, '$sqrt', $sqrt$79 = function $$sqrt(n) {
        var self = this;

        
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        
        if (n < 0) {
          self.$raise($$$($$($nesting, 'Math'), 'DomainError'), "Numerical argument is out of domain - \"isqrt\"")
        }

        return parseInt(Math.sqrt(n), 10);
      ;
      }, $sqrt$79.$$arity = 1), nil) && 'sqrt';
    })(Opal.get_singleton_class(self), $nesting);
    Opal.const_set($nesting[0], 'MAX', Math.pow(2, 30) - 1);
    return Opal.const_set($nesting[0], 'MIN', -Math.pow(2, 30));
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Float');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$80, $eq_eq_eq$81;

      
      
      Opal.def(self, '$allocate', $allocate$80 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$80.$$arity = 0);
      
      Opal.udef(self, '$' + "new");;
      return (Opal.def(self, '$===', $eq_eq_eq$81 = function(other) {
        var self = this;

        return !!other.$$is_number;
      }, $eq_eq_eq$81.$$arity = 1), nil) && '===';
    })(Opal.get_singleton_class(self), $nesting);
    Opal.const_set($nesting[0], 'INFINITY', Infinity);
    Opal.const_set($nesting[0], 'MAX', Number.MAX_VALUE);
    Opal.const_set($nesting[0], 'MIN', Number.MIN_VALUE);
    Opal.const_set($nesting[0], 'NAN', NaN);
    Opal.const_set($nesting[0], 'DIG', 15);
    Opal.const_set($nesting[0], 'MANT_DIG', 53);
    Opal.const_set($nesting[0], 'RADIX', 2);
    return Opal.const_set($nesting[0], 'EPSILON', Number.EPSILON || 2.2204460492503130808472633361816E-16);
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/range"] = function(Opal) {
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $send2 = Opal.send2;

  Opal.add_stubs(['$require', '$include', '$attr_reader', '$raise', '$<=>', '$include?', '$<=', '$<', '$enum_for', '$size', '$upto', '$to_proc', '$respond_to?', '$class', '$succ', '$!', '$==', '$===', '$exclude_end?', '$eql?', '$begin', '$end', '$last', '$to_a', '$>', '$-', '$abs', '$to_i', '$coerce_to!', '$ceil', '$/', '$loop', '$+', '$*', '$>=', '$each_with_index', '$%', '$bsearch', '$inspect', '$[]', '$hash']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Range');

    var $nesting = [self].concat($parent_nesting), $Range_initialize$1, $Range_$eq_eq_eq$2, $Range_cover$ques$3, $Range_each$4, $Range_eql$ques$6, $Range_exclude_end$ques$7, $Range_first$8, $Range_last$9, $Range_max$10, $Range_min$11, $Range_size$12, $Range_step$13, $Range_bsearch$17, $Range_to_s$18, $Range_inspect$19, $Range_marshal_load$20, $Range_hash$21;

    self.$$prototype.begin = self.$$prototype.end = self.$$prototype.excl = nil;
    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_range = true;
    self.$attr_reader("begin", "end");
    
    Opal.def(self, '$initialize', $Range_initialize$1 = function $$initialize(first, last, exclude) {
      var self = this;

      
      
      if (exclude == null) {
        exclude = false;
      };
      if ($truthy(self.begin)) {
        self.$raise($$($nesting, 'NameError'), "'initialize' called twice")};
      if ($truthy(first['$<=>'](last))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "bad value for range")
      };
      self.begin = first;
      self.end = last;
      return (self.excl = exclude);
    }, $Range_initialize$1.$$arity = -3);
    
    Opal.def(self, '$===', $Range_$eq_eq_eq$2 = function(value) {
      var self = this;

      return self['$include?'](value)
    }, $Range_$eq_eq_eq$2.$$arity = 1);
    
    Opal.def(self, '$cover?', $Range_cover$ques$3 = function(value) {
      var self = this, beg_cmp = nil, $ret_or_1 = nil, end_cmp = nil, $ret_or_2 = nil, $ret_or_3 = nil;

      
      beg_cmp = self.begin['$<=>'](value);
      if ($truthy((function() {if ($truthy(($ret_or_1 = beg_cmp))) {
        return $rb_le(beg_cmp, 0)
      } else {
        return $ret_or_1
      }; return nil; })())) {
      } else {
        return false
      };
      end_cmp = value['$<=>'](self.end);
      if ($truthy(self.excl)) {
        if ($truthy(($ret_or_2 = end_cmp))) {
          return $rb_lt(end_cmp, 0)
        } else {
          return $ret_or_2
        }
      } else if ($truthy(($ret_or_3 = end_cmp))) {
        return $rb_le(end_cmp, 0)
      } else {
        return $ret_or_3
      };
    }, $Range_cover$ques$3.$$arity = 1);
    
    Opal.def(self, '$each', $Range_each$4 = function $$each() {
      var $iter = $Range_each$4.$$p, block = $iter || nil, $$5, $a, self = this, current = nil, last = nil, $ret_or_4 = nil;

      if ($iter) $Range_each$4.$$p = null;
      
      
      if ($iter) $Range_each$4.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$5 = function(){var self = $$5.$$s == null ? this : $$5.$$s;

        return self.$size()}, $$5.$$s = self, $$5.$$arity = 0, $$5))
      };
      
      var i, limit;

      if (self.begin.$$is_number && self.end.$$is_number) {
        if (self.begin % 1 !== 0 || self.end % 1 !== 0) {
          self.$raise($$($nesting, 'TypeError'), "can't iterate from Float")
        }

        for (i = self.begin, limit = self.end + (function() {if ($truthy(self.excl)) {
        return 0
      } else {
        return 1
      }; return nil; })(); i < limit; i++) {
          block(i);
        }

        return self;
      }

      if (self.begin.$$is_string && self.end.$$is_string) {
        $send(self.begin, 'upto', [self.end, self.excl], block.$to_proc())
        return self;
      }
    ;
      current = self.begin;
      last = self.end;
      if ($truthy(current['$respond_to?']("succ"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't iterate from " + (current.$class()))
      };
      while ($truthy($rb_lt(current['$<=>'](last), 0))) {
        
        Opal.yield1(block, current);
        current = current.$succ();
      };
      if ($truthy((function() {if ($truthy(($ret_or_4 = self.excl['$!']()))) {
        return current['$=='](last)
      } else {
        return $ret_or_4
      }; return nil; })())) {
        Opal.yield1(block, current)};
      return self;
    }, $Range_each$4.$$arity = 0);
    
    Opal.def(self, '$eql?', $Range_eql$ques$6 = function(other) {
      var self = this, $ret_or_5 = nil, $ret_or_6 = nil;

      
      if ($truthy($$($nesting, 'Range')['$==='](other))) {
      } else {
        return false
      };
      if ($truthy(($ret_or_5 = (function() {if ($truthy(($ret_or_6 = self.excl['$==='](other['$exclude_end?']())))) {
        return self.begin['$eql?'](other.$begin())
      } else {
        return $ret_or_6
      }; return nil; })()))) {
        return self.end['$eql?'](other.$end())
      } else {
        return $ret_or_5
      };
    }, $Range_eql$ques$6.$$arity = 1);
    Opal.alias(self, "==", "eql?");
    
    Opal.def(self, '$exclude_end?', $Range_exclude_end$ques$7 = function() {
      var self = this;

      return self.excl
    }, $Range_exclude_end$ques$7.$$arity = 0);
    
    Opal.def(self, '$first', $Range_first$8 = function $$first(n) {
      var $iter = $Range_first$8.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_first$8.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      ;
      if ($truthy(n == null)) {
        return self.begin};
      return $send2(self, Opal.find_super_dispatcher(self, 'first', $Range_first$8, false, true), 'first', $zuper, $iter);
    }, $Range_first$8.$$arity = -1);
    Opal.alias(self, "include?", "cover?");
    
    Opal.def(self, '$last', $Range_last$9 = function $$last(n) {
      var self = this;

      
      ;
      if ($truthy(n == null)) {
        return self.end};
      return self.$to_a().$last(n);
    }, $Range_last$9.$$arity = -1);
    
    Opal.def(self, '$max', $Range_max$10 = function $$max() {
      var $iter = $Range_max$10.$$p, $yield = $iter || nil, self = this, $ret_or_7 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_max$10.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if (($yield !== nil)) {
        return $send2(self, Opal.find_super_dispatcher(self, 'max', $Range_max$10, false, true), 'max', $zuper, $iter)
      } else if ($truthy($rb_gt(self.begin, self.end))) {
        return nil
      } else if ($truthy((function() {if ($truthy(($ret_or_7 = self.excl))) {
        return self.begin['$=='](self.end)
      } else {
        return $ret_or_7
      }; return nil; })())) {
        return nil
      } else {
        return self.excl ? self.end - 1 : self.end
      }
    }, $Range_max$10.$$arity = 0);
    Opal.alias(self, "member?", "cover?");
    
    Opal.def(self, '$min', $Range_min$11 = function $$min() {
      var $iter = $Range_min$11.$$p, $yield = $iter || nil, self = this, $ret_or_8 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_min$11.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if (($yield !== nil)) {
        return $send2(self, Opal.find_super_dispatcher(self, 'min', $Range_min$11, false, true), 'min', $zuper, $iter)
      } else if ($truthy($rb_gt(self.begin, self.end))) {
        return nil
      } else if ($truthy((function() {if ($truthy(($ret_or_8 = self.excl))) {
        return self.begin['$=='](self.end)
      } else {
        return $ret_or_8
      }; return nil; })())) {
        return nil
      } else {
        return self.begin
      }
    }, $Range_min$11.$$arity = 0);
    
    Opal.def(self, '$size', $Range_size$12 = function $$size() {
      var self = this, range_begin = nil, range_end = nil, $ret_or_9 = nil, infinity = nil;

      
      range_begin = self.begin;
      range_end = self.end;
      if ($truthy(self.excl)) {
        range_end = $rb_minus(range_end, 1)};
      if ($truthy((function() {if ($truthy(($ret_or_9 = $$($nesting, 'Numeric')['$==='](range_begin)))) {
        return $$($nesting, 'Numeric')['$==='](range_end)
      } else {
        return $ret_or_9
      }; return nil; })())) {
      } else {
        return nil
      };
      if ($truthy($rb_lt(range_end, range_begin))) {
        return 0};
      infinity = $$$($$($nesting, 'Float'), 'INFINITY');
      if ($truthy([range_begin.$abs(), range_end.$abs()]['$include?'](infinity))) {
        return infinity};
      return (Math.abs(range_end - range_begin) + 1).$to_i();
    }, $Range_size$12.$$arity = 0);
    
    Opal.def(self, '$step', $Range_step$13 = function $$step(n) {
      var $$14, $$15, $$16, $iter = $Range_step$13.$$p, $yield = $iter || nil, self = this, i = nil;

      if ($iter) $Range_step$13.$$p = null;
      
      
      if (n == null) {
        n = 1;
      };
      
      function coerceStepSize() {
        if (!n.$$is_number) {
          n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int")
        }

        if (n < 0) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be negative")
        } else if (n === 0) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be 0")
        }
      }

      function enumeratorSize() {
        if (!self.begin['$respond_to?']("succ")) {
          return nil;
        }

        if (self.begin.$$is_string && self.end.$$is_string) {
          return nil;
        }

        if (n % 1 === 0) {
          return $rb_divide(self.$size(), n).$ceil();
        } else {
          // n is a float
          var begin = self.begin, end = self.end,
              abs = Math.abs, floor = Math.floor,
              err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * $$$($$($nesting, 'Float'), 'EPSILON'),
              size;

          if (err > 0.5) {
            err = 0.5;
          }

          if (self.excl) {
            size = floor((end - begin) / n - err);
            if (size * n + begin < end) {
              size++;
            }
          } else {
            size = floor((end - begin) / n + err) + 1
          }

          return size;
        }
      }
    ;
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["step", n], ($$14 = function(){var self = $$14.$$s == null ? this : $$14.$$s;

        
          coerceStepSize();
          return enumeratorSize();
        }, $$14.$$s = self, $$14.$$arity = 0, $$14))
      };
      coerceStepSize();
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
        
        i = 0;
        (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], ($$15 = function(){var self = $$15.$$s == null ? this : $$15.$$s, current = nil;
          if (self.begin == null) self.begin = nil;
          if (self.excl == null) self.excl = nil;
          if (self.end == null) self.end = nil;

        
          current = $rb_plus(self.begin, $rb_times(i, n));
          if ($truthy(self.excl)) {
            if ($truthy($rb_ge(current, self.end))) {
              
              Opal.brk(nil, $brk)}
          } else if ($truthy($rb_gt(current, self.end))) {
            
            Opal.brk(nil, $brk)};
          Opal.yield1($yield, current);
          return (i = $rb_plus(i, 1));}, $$15.$$s = self, $$15.$$brk = $brk, $$15.$$arity = 0, $$15))
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      } else {
        
        
        if (self.begin.$$is_string && self.end.$$is_string && n % 1 !== 0) {
          self.$raise($$($nesting, 'TypeError'), "no implicit conversion to float from string")
        }
      ;
        $send(self, 'each_with_index', [], ($$16 = function(value, idx){var self = $$16.$$s == null ? this : $$16.$$s;

        
          
          if (value == null) {
            value = nil;
          };
          
          if (idx == null) {
            idx = nil;
          };
          if (idx['$%'](n)['$=='](0)) {
            return Opal.yield1($yield, value);
          } else {
            return nil
          };}, $$16.$$s = self, $$16.$$arity = 2, $$16));
      };
      return self;
    }, $Range_step$13.$$arity = -1);
    
    Opal.def(self, '$bsearch', $Range_bsearch$17 = function $$bsearch() {
      var $iter = $Range_bsearch$17.$$p, block = $iter || nil, self = this;

      if ($iter) $Range_bsearch$17.$$p = null;
      
      
      if ($iter) $Range_bsearch$17.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch")
      };
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't do binary search for " + (self.begin.$class()))
      };
      return $send(self.$to_a(), 'bsearch', [], block.$to_proc());
    }, $Range_bsearch$17.$$arity = 0);
    
    Opal.def(self, '$to_s', $Range_to_s$18 = function $$to_s() {
      var self = this;

      return "" + (self.begin) + ((function() {if ($truthy(self.excl)) {
        return "..."
      } else {
        return ".."
      }; return nil; })()) + (self.end)
    }, $Range_to_s$18.$$arity = 0);
    
    Opal.def(self, '$inspect', $Range_inspect$19 = function $$inspect() {
      var self = this;

      return "" + (self.begin.$inspect()) + ((function() {if ($truthy(self.excl)) {
        return "..."
      } else {
        return ".."
      }; return nil; })()) + (self.end.$inspect())
    }, $Range_inspect$19.$$arity = 0);
    
    Opal.def(self, '$marshal_load', $Range_marshal_load$20 = function $$marshal_load(args) {
      var self = this;

      
      self.begin = args['$[]']("begin");
      self.end = args['$[]']("end");
      return (self.excl = args['$[]']("excl"));
    }, $Range_marshal_load$20.$$arity = 1);
    return (Opal.def(self, '$hash', $Range_hash$21 = function $$hash() {
      var self = this;

      return [self.begin, self.end, self.excl].$hash()
    }, $Range_hash$21.$$arity = 0), nil) && 'hash';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/proc"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$raise', '$proc', '$call', '$to_proc', '$coerce_to!']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Proc');

    var $nesting = [self].concat($parent_nesting), $Proc_new$1, $Proc_call$2, $Proc_$gt$gt$3, $Proc_$lt$lt$5, $Proc_to_proc$7, $Proc_lambda$ques$8, $Proc_arity$9, $Proc_source_location$10, $Proc_binding$11, $Proc_parameters$12, $Proc_curry$13, $Proc_dup$14;

    
    Opal.defineProperty(self.$$prototype, '$$is_proc', true);
    Opal.defineProperty(self.$$prototype, '$$is_lambda', false);
    Opal.defs(self, '$new', $Proc_new$1 = function() {
      var $iter = $Proc_new$1.$$p, block = $iter || nil, self = this;

      if ($iter) $Proc_new$1.$$p = null;
      
      
      if ($iter) $Proc_new$1.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create a Proc object without a block")
      };
      return block;
    }, $Proc_new$1.$$arity = 0);
    
    Opal.def(self, '$call', $Proc_call$2 = function $$call($a) {
      var $iter = $Proc_call$2.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Proc_call$2.$$p = null;
      
      
      if ($iter) $Proc_call$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (block !== nil) {
        self.$$p = block;
      }

      var result, $brk = self.$$brk;

      if ($brk) {
        try {
          if (self.$$is_lambda) {
            result = self.apply(null, args);
          }
          else {
            result = Opal.yieldX(self, args);
          }
        } catch (err) {
          if (err === $brk) {
            return $brk.$v
          }
          else {
            throw err
          }
        }
      }
      else {
        if (self.$$is_lambda) {
          result = self.apply(null, args);
        }
        else {
          result = Opal.yieldX(self, args);
        }
      }

      return result;
    ;
    }, $Proc_call$2.$$arity = -1);
    Opal.alias(self, "[]", "call");
    Opal.alias(self, "===", "call");
    Opal.alias(self, "yield", "call");
    
    Opal.def(self, '$>>', $Proc_$gt$gt$3 = function(other) {
      var $$4, $iter = $Proc_$gt$gt$3.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Proc_$gt$gt$3.$$p = null;
      return $send(self, 'proc', [], ($$4 = function($a){var self = $$4.$$s == null ? this : $$4.$$s, $iter = $$4.$$p, block = $iter || nil, $post_args, args, out = nil;

      
        
        if ($iter) $$4.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        out = $send(self, 'call', Opal.to_a(args), block.$to_proc());
        return other.$call(out);}, $$4.$$s = self, $$4.$$arity = -1, $$4))
    }, $Proc_$gt$gt$3.$$arity = 1);
    
    Opal.def(self, '$<<', $Proc_$lt$lt$5 = function(other) {
      var $$6, $iter = $Proc_$lt$lt$5.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Proc_$lt$lt$5.$$p = null;
      return $send(self, 'proc', [], ($$6 = function($a){var self = $$6.$$s == null ? this : $$6.$$s, $iter = $$6.$$p, block = $iter || nil, $post_args, args, out = nil;

      
        
        if ($iter) $$6.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        out = $send(other, 'call', Opal.to_a(args), block.$to_proc());
        return self.$call(out);}, $$6.$$s = self, $$6.$$arity = -1, $$6))
    }, $Proc_$lt$lt$5.$$arity = 1);
    
    Opal.def(self, '$to_proc', $Proc_to_proc$7 = function $$to_proc() {
      var self = this;

      return self
    }, $Proc_to_proc$7.$$arity = 0);
    
    Opal.def(self, '$lambda?', $Proc_lambda$ques$8 = function() {
      var self = this;

      return !!self.$$is_lambda;
    }, $Proc_lambda$ques$8.$$arity = 0);
    
    Opal.def(self, '$arity', $Proc_arity$9 = function $$arity() {
      var self = this;

      
      if (self.$$is_curried) {
        return -1;
      } else {
        return self.$$arity;
      }
    
    }, $Proc_arity$9.$$arity = 0);
    
    Opal.def(self, '$source_location', $Proc_source_location$10 = function $$source_location() {
      var self = this;

      
      if (self.$$is_curried) { return nil; };
      return nil;
    }, $Proc_source_location$10.$$arity = 0);
    
    Opal.def(self, '$binding', $Proc_binding$11 = function $$binding() {
      var self = this;

      
      if (self.$$is_curried) { self.$raise($$($nesting, 'ArgumentError'), "Can't create Binding") };
      return nil;
    }, $Proc_binding$11.$$arity = 0);
    
    Opal.def(self, '$parameters', $Proc_parameters$12 = function $$parameters() {
      var self = this;

      
      if (self.$$is_curried) {
        return [["rest"]];
      } else if (self.$$parameters) {
        if (self.$$is_lambda) {
          return self.$$parameters;
        } else {
          var result = [], i, length;

          for (i = 0, length = self.$$parameters.length; i < length; i++) {
            var parameter = self.$$parameters[i];

            if (parameter[0] === 'req') {
              // required arguments always have name
              parameter = ['opt', parameter[1]];
            }

            result.push(parameter);
          }

          return result;
        }
      } else {
        return [];
      }
    
    }, $Proc_parameters$12.$$arity = 0);
    
    Opal.def(self, '$curry', $Proc_curry$13 = function $$curry(arity) {
      var self = this;

      
      ;
      
      if (arity === undefined) {
        arity = self.length;
      }
      else {
        arity = $$($nesting, 'Opal')['$coerce_to!'](arity, $$($nesting, 'Integer'), "to_int");
        if (self.$$is_lambda && arity !== self.length) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arity) + " for " + (self.length) + ")")
        }
      }

      function curried () {
        var args = $slice.call(arguments),
            length = args.length,
            result;

        if (length > arity && self.$$is_lambda && !self.$$is_curried) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (length) + " for " + (arity) + ")")
        }

        if (length >= arity) {
          return self.$call.apply(self, args);
        }

        result = function () {
          return curried.apply(null,
            args.concat($slice.call(arguments)));
        }
        result.$$is_lambda = self.$$is_lambda;
        result.$$is_curried = true;

        return result;
      };

      curried.$$is_lambda = self.$$is_lambda;
      curried.$$is_curried = true;
      return curried;
    ;
    }, $Proc_curry$13.$$arity = -1);
    
    Opal.def(self, '$dup', $Proc_dup$14 = function $$dup() {
      var self = this;

      
      var original_proc = self.$$original_proc || self,
          proc = function () {
            return original_proc.apply(this, arguments);
          };

      for (var prop in self) {
        if (self.hasOwnProperty(prop)) {
          proc[prop] = self[prop];
        }
      }

      return proc;
    
    }, $Proc_dup$14.$$arity = 0);
    return Opal.alias(self, "clone", "dup");
  })($nesting[0], Function, $nesting)
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/method"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$arity', '$>>', '$<<', '$new', '$class', '$join', '$source_location', '$raise']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Method');

    var $nesting = [self].concat($parent_nesting), $Method_initialize$1, $Method_arity$2, $Method_parameters$3, $Method_source_location$4, $Method_comments$5, $Method_call$6, $Method_$gt$gt$7, $Method_$lt$lt$8, $Method_unbind$9, $Method_to_proc$10, $Method_inspect$11;

    self.$$prototype.method = self.$$prototype.receiver = self.$$prototype.owner = self.$$prototype.name = nil;
    
    self.$attr_reader("owner", "receiver", "name");
    
    Opal.def(self, '$initialize', $Method_initialize$1 = function $$initialize(receiver, owner, method, name) {
      var self = this;

      
      self.receiver = receiver;
      self.owner = owner;
      self.name = name;
      return (self.method = method);
    }, $Method_initialize$1.$$arity = 4);
    
    Opal.def(self, '$arity', $Method_arity$2 = function $$arity() {
      var self = this;

      return self.method.$arity()
    }, $Method_arity$2.$$arity = 0);
    
    Opal.def(self, '$parameters', $Method_parameters$3 = function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, $Method_parameters$3.$$arity = 0);
    
    Opal.def(self, '$source_location', $Method_source_location$4 = function $$source_location() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$source_location))) {
        return $ret_or_1
      } else {
        return ["(eval)", 0]
      }
    }, $Method_source_location$4.$$arity = 0);
    
    Opal.def(self, '$comments', $Method_comments$5 = function $$comments() {
      var self = this, $ret_or_2 = nil;

      if ($truthy(($ret_or_2 = self.method.$$comments))) {
        return $ret_or_2
      } else {
        return []
      }
    }, $Method_comments$5.$$arity = 0);
    
    Opal.def(self, '$call', $Method_call$6 = function $$call($a) {
      var $iter = $Method_call$6.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Method_call$6.$$p = null;
      
      
      if ($iter) $Method_call$6.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      self.method.$$p = block;

      return self.method.apply(self.receiver, args);
    ;
    }, $Method_call$6.$$arity = -1);
    Opal.alias(self, "[]", "call");
    
    Opal.def(self, '$>>', $Method_$gt$gt$7 = function(other) {
      var self = this;

      return self.method['$>>'](other)
    }, $Method_$gt$gt$7.$$arity = 1);
    
    Opal.def(self, '$<<', $Method_$lt$lt$8 = function(other) {
      var self = this;

      return self.method['$<<'](other)
    }, $Method_$lt$lt$8.$$arity = 1);
    
    Opal.def(self, '$unbind', $Method_unbind$9 = function $$unbind() {
      var self = this;

      return $$($nesting, 'UnboundMethod').$new(self.receiver.$class(), self.owner, self.method, self.name)
    }, $Method_unbind$9.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Method_to_proc$10 = function $$to_proc() {
      var self = this;

      
      var proc = self.$call.bind(self);
      proc.$$unbound = self.method;
      proc.$$is_lambda = true;
      proc.$$arity = self.method.$$arity;
      proc.$$parameters = self.method.$$parameters;
      return proc;
    
    }, $Method_to_proc$10.$$arity = 0);
    return (Opal.def(self, '$inspect', $Method_inspect$11 = function $$inspect() {
      var self = this;

      return "" + "#<" + (self.$class()) + ": " + (self.receiver.$class()) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, $Method_inspect$11.$$arity = 0), nil) && 'inspect';
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'UnboundMethod');

    var $nesting = [self].concat($parent_nesting), $UnboundMethod_initialize$12, $UnboundMethod_arity$13, $UnboundMethod_parameters$14, $UnboundMethod_source_location$15, $UnboundMethod_comments$16, $UnboundMethod_bind$17, $UnboundMethod_inspect$18;

    self.$$prototype.method = self.$$prototype.owner = self.$$prototype.name = self.$$prototype.source = nil;
    
    self.$attr_reader("source", "owner", "name");
    
    Opal.def(self, '$initialize', $UnboundMethod_initialize$12 = function $$initialize(source, owner, method, name) {
      var self = this;

      
      self.source = source;
      self.owner = owner;
      self.method = method;
      return (self.name = name);
    }, $UnboundMethod_initialize$12.$$arity = 4);
    
    Opal.def(self, '$arity', $UnboundMethod_arity$13 = function $$arity() {
      var self = this;

      return self.method.$arity()
    }, $UnboundMethod_arity$13.$$arity = 0);
    
    Opal.def(self, '$parameters', $UnboundMethod_parameters$14 = function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, $UnboundMethod_parameters$14.$$arity = 0);
    
    Opal.def(self, '$source_location', $UnboundMethod_source_location$15 = function $$source_location() {
      var self = this, $ret_or_3 = nil;

      if ($truthy(($ret_or_3 = self.method.$$source_location))) {
        return $ret_or_3
      } else {
        return ["(eval)", 0]
      }
    }, $UnboundMethod_source_location$15.$$arity = 0);
    
    Opal.def(self, '$comments', $UnboundMethod_comments$16 = function $$comments() {
      var self = this, $ret_or_4 = nil;

      if ($truthy(($ret_or_4 = self.method.$$comments))) {
        return $ret_or_4
      } else {
        return []
      }
    }, $UnboundMethod_comments$16.$$arity = 0);
    
    Opal.def(self, '$bind', $UnboundMethod_bind$17 = function $$bind(object) {
      var self = this;

      
      if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {
        return $$($nesting, 'Method').$new(object, self.owner, self.method, self.name);
      }
      else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't bind singleton method to a different class (expected " + (object) + ".kind_of?(" + (self.owner) + " to be true)");
      }
    
    }, $UnboundMethod_bind$17.$$arity = 1);
    return (Opal.def(self, '$inspect', $UnboundMethod_inspect$18 = function $$inspect() {
      var self = this;

      return "" + "#<" + (self.$class()) + ": " + (self.source) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, $UnboundMethod_inspect$18.$$arity = 0), nil) && 'inspect';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/variables"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $gvars = Opal.gvars, $hash2 = Opal.hash2;

  Opal.add_stubs(['$new']);
  
  $gvars['&'] = $gvars['~'] = $gvars['`'] = $gvars["'"] = nil;
  $gvars.LOADED_FEATURES = ($gvars["\""] = Opal.loaded_features);
  $gvars.LOAD_PATH = ($gvars[":"] = []);
  $gvars["/"] = "\n";
  $gvars[","] = nil;
  Opal.const_set($nesting[0], 'ARGV', []);
  Opal.const_set($nesting[0], 'ARGF', $$($nesting, 'Object').$new());
  Opal.const_set($nesting[0], 'ENV', $hash2([], {}));
  $gvars.VERBOSE = false;
  $gvars.DEBUG = false;
  return ($gvars.SAFE = 0);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/io"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $module = Opal.module, $gvars = Opal.gvars, $send = Opal.send, $writer = nil;

  Opal.add_stubs(['$attr_accessor', '$size', '$write', '$String', '$chomp', '$getbyte', '$getc', '$raise', '$new', '$write_proc=', '$-', '$extend']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IO');

    var $nesting = [self].concat($parent_nesting), $IO_tty$ques$1, $IO_closed$ques$2, $IO_write$3, $IO_flush$4;

    self.$$prototype.tty = self.$$prototype.closed = nil;
    
    Opal.const_set($nesting[0], 'SEEK_SET', 0);
    Opal.const_set($nesting[0], 'SEEK_CUR', 1);
    Opal.const_set($nesting[0], 'SEEK_END', 2);
    
    Opal.def(self, '$tty?', $IO_tty$ques$1 = function() {
      var self = this;

      return self.tty
    }, $IO_tty$ques$1.$$arity = 0);
    
    Opal.def(self, '$closed?', $IO_closed$ques$2 = function() {
      var self = this;

      return self.closed
    }, $IO_closed$ques$2.$$arity = 0);
    self.$attr_accessor("write_proc");
    
    Opal.def(self, '$write', $IO_write$3 = function $$write(string) {
      var self = this;

      
      self.write_proc(string);
      return string.$size();
    }, $IO_write$3.$$arity = 1);
    self.$attr_accessor("sync", "tty");
    
    Opal.def(self, '$flush', $IO_flush$4 = function $$flush() {
      var self = this;

      return nil
    }, $IO_flush$4.$$arity = 0);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Writable');

      var $nesting = [self].concat($parent_nesting), $Writable_$lt$lt$5, $Writable_print$6, $Writable_puts$7;

      
      
      Opal.def(self, '$<<', $Writable_$lt$lt$5 = function(string) {
        var self = this;

        
        self.$write(string);
        return self;
      }, $Writable_$lt$lt$5.$$arity = 1);
      
      Opal.def(self, '$print', $Writable_print$6 = function $$print($a) {
        var $post_args, args, self = this;
        if ($gvars[","] == null) $gvars[","] = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        
        for (var i = 0, ii = args.length; i < ii; i++) {
          args[i] = self.$String(args[i])
        }
        self.$write(args.join($gvars[","]));
      ;
        return nil;
      }, $Writable_print$6.$$arity = -1);
      
      Opal.def(self, '$puts', $Writable_puts$7 = function $$puts($a) {
        var $post_args, args, self = this;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        
        for (var i = 0, ii = args.length; i < ii; i++) {
          args[i] = self.$String(args[i]).$chomp()
        }
        self.$write(args.concat([nil]).join($gvars["/"]));
      ;
        return nil;
      }, $Writable_puts$7.$$arity = -1);
    })($nesting[0], $nesting);
    return (function($base, $parent_nesting) {
      var self = $module($base, 'Readable');

      var $nesting = [self].concat($parent_nesting), $Readable_readbyte$8, $Readable_readchar$9, $Readable_readline$10, $Readable_readpartial$11;

      
      
      Opal.def(self, '$readbyte', $Readable_readbyte$8 = function $$readbyte() {
        var self = this;

        return self.$getbyte()
      }, $Readable_readbyte$8.$$arity = 0);
      
      Opal.def(self, '$readchar', $Readable_readchar$9 = function $$readchar() {
        var self = this;

        return self.$getc()
      }, $Readable_readchar$9.$$arity = 0);
      
      Opal.def(self, '$readline', $Readable_readline$10 = function $$readline(sep) {
        var self = this;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        
        
        if (sep == null) {
          sep = $gvars["/"];
        };
        return self.$raise($$($nesting, 'NotImplementedError'));
      }, $Readable_readline$10.$$arity = -1);
      
      Opal.def(self, '$readpartial', $Readable_readpartial$11 = function $$readpartial(integer, outbuf) {
        var self = this;

        
        
        if (outbuf == null) {
          outbuf = nil;
        };
        return self.$raise($$($nesting, 'NotImplementedError'));
      }, $Readable_readpartial$11.$$arity = -2);
    })($nesting[0], $nesting);
  })($nesting[0], null, $nesting);
  Opal.const_set($nesting[0], 'STDERR', ($gvars.stderr = $$($nesting, 'IO').$new()));
  Opal.const_set($nesting[0], 'STDIN', ($gvars.stdin = $$($nesting, 'IO').$new()));
  Opal.const_set($nesting[0], 'STDOUT', ($gvars.stdout = $$($nesting, 'IO').$new()));
  var console = Opal.global.console;
  
  $writer = [typeof(process) === 'object' && typeof(process.stdout) === 'object' ? function(s){process.stdout.write(s)} : function(s){console.log(s)}];
  $send($$($nesting, 'STDOUT'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [typeof(process) === 'object' && typeof(process.stderr) === 'object' ? function(s){process.stderr.write(s)} : function(s){console.warn(s)}];
  $send($$($nesting, 'STDERR'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  $$($nesting, 'STDOUT').$extend($$$($$($nesting, 'IO'), 'Writable'));
  return $$($nesting, 'STDERR').$extend($$$($$($nesting, 'IO'), 'Writable'));
};

/* Generated by Opal 1.1.1 */
Opal.modules["opal/regexp_anchors"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module;

  Opal.add_stubs(['$==', '$new']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    
    Opal.const_set($nesting[0], 'REGEXP_START', (function() {if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
      return "^"
    } else {
      return nil
    }; return nil; })());
    Opal.const_set($nesting[0], 'REGEXP_END', (function() {if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
      return "$"
    } else {
      return nil
    }; return nil; })());
    Opal.const_set($nesting[0], 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'INLINE_IDENTIFIER_REGEXP', $$($nesting, 'Regexp').$new("" + "[^" + ($$($nesting, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS')) + "]*[^" + ($$($nesting, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS')) + "]"));
    Opal.const_set($nesting[0], 'FORBIDDEN_CONST_NAME_CHARS', "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'CONST_NAME_REGEXP', $$($nesting, 'Regexp').$new("" + ($$($nesting, 'REGEXP_START')) + "(::)?[A-Z][^" + ($$($nesting, 'FORBIDDEN_CONST_NAME_CHARS')) + "]*" + ($$($nesting, 'REGEXP_END'))));
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.1.1 */
Opal.modules["opal/mini"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$require']);
  
  self.$require("opal/base");
  self.$require("corelib/nil");
  self.$require("corelib/boolean");
  self.$require("corelib/string");
  self.$require("corelib/comparable");
  self.$require("corelib/enumerable");
  self.$require("corelib/enumerator");
  self.$require("corelib/array");
  self.$require("corelib/hash");
  self.$require("corelib/number");
  self.$require("corelib/range");
  self.$require("corelib/proc");
  self.$require("corelib/method");
  self.$require("corelib/regexp");
  self.$require("corelib/variables");
  self.$require("corelib/io");
  return self.$require("opal/regexp_anchors");
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/kernel/format"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $coerce_to = Opal.coerce_to, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$==', '$length', '$respond_to?', '$[]', '$coerce_to?', '$nil?', '$to_a', '$raise', '$to_int', '$fetch', '$Integer', '$Float', '$to_ary', '$to_str', '$inspect', '$to_s']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_format$1;

    
    
    Opal.def(self, '$format', $Kernel_format$1 = function $$format(format_string, $a) {
      var $post_args, args, self = this, $ret_or_1 = nil, ary = nil;
      if ($gvars.DEBUG == null) $gvars.DEBUG = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      if ($truthy((function() {if ($truthy(($ret_or_1 = args.$length()['$=='](1)))) {
        return args['$[]'](0)['$respond_to?']("to_ary")
      } else {
        return $ret_or_1
      }; return nil; })())) {
        
        ary = $$($nesting, 'Opal')['$coerce_to?'](args['$[]'](0), $$($nesting, 'Array'), "to_ary");
        if ($truthy(ary['$nil?']())) {
        } else {
          args = ary.$to_a()
        };};
      
      var result = '',
          //used for slicing:
          begin_slice = 0,
          end_slice,
          //used for iterating over the format string:
          i,
          len = format_string.length,
          //used for processing field values:
          arg,
          str,
          //used for processing %g and %G fields:
          exponent,
          //used for keeping track of width and precision:
          width,
          precision,
          //used for holding temporary values:
          tmp_num,
          //used for processing %{} and %<> fileds:
          hash_parameter_key,
          closing_brace_char,
          //used for processing %b, %B, %o, %x, and %X fields:
          base_number,
          base_prefix,
          base_neg_zero_regex,
          base_neg_zero_digit,
          //used for processing arguments:
          next_arg,
          seq_arg_num = 1,
          pos_arg_num = 0,
          //used for keeping track of flags:
          flags,
          FNONE  = 0,
          FSHARP = 1,
          FMINUS = 2,
          FPLUS  = 4,
          FZERO  = 8,
          FSPACE = 16,
          FWIDTH = 32,
          FPREC  = 64,
          FPREC0 = 128;

      function CHECK_FOR_FLAGS() {
        if (flags&FWIDTH) { self.$raise($$($nesting, 'ArgumentError'), "flag after width") }
        if (flags&FPREC0) { self.$raise($$($nesting, 'ArgumentError'), "flag after precision") }
      }

      function CHECK_FOR_WIDTH() {
        if (flags&FWIDTH) { self.$raise($$($nesting, 'ArgumentError'), "width given twice") }
        if (flags&FPREC0) { self.$raise($$($nesting, 'ArgumentError'), "width after precision") }
      }

      function GET_NTH_ARG(num) {
        if (num >= args.length) { self.$raise($$($nesting, 'ArgumentError'), "too few arguments") }
        return args[num];
      }

      function GET_NEXT_ARG() {
        switch (pos_arg_num) {
        case -1: self.$raise($$($nesting, 'ArgumentError'), "" + "unnumbered(" + (seq_arg_num) + ") mixed with numbered")
        case -2: self.$raise($$($nesting, 'ArgumentError'), "" + "unnumbered(" + (seq_arg_num) + ") mixed with named")
        }
        pos_arg_num = seq_arg_num++;
        return GET_NTH_ARG(pos_arg_num - 1);
      }

      function GET_POS_ARG(num) {
        if (pos_arg_num > 0) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "numbered(" + (num) + ") after unnumbered(" + (pos_arg_num) + ")")
        }
        if (pos_arg_num === -2) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "numbered(" + (num) + ") after named")
        }
        if (num < 1) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid index - " + (num) + "$")
        }
        pos_arg_num = -1;
        return GET_NTH_ARG(num - 1);
      }

      function GET_ARG() {
        return (next_arg === undefined ? GET_NEXT_ARG() : next_arg);
      }

      function READ_NUM(label) {
        var num, str = '';
        for (;; i++) {
          if (i === len) {
            self.$raise($$($nesting, 'ArgumentError'), "malformed format string - %*[0-9]")
          }
          if (format_string.charCodeAt(i) < 48 || format_string.charCodeAt(i) > 57) {
            i--;
            num = parseInt(str, 10) || 0;
            if (num > 2147483647) {
              self.$raise($$($nesting, 'ArgumentError'), "" + (label) + " too big")
            }
            return num;
          }
          str += format_string.charAt(i);
        }
      }

      function READ_NUM_AFTER_ASTER(label) {
        var arg, num = READ_NUM(label);
        if (format_string.charAt(i + 1) === '$') {
          i++;
          arg = GET_POS_ARG(num);
        } else {
          arg = GET_NEXT_ARG();
        }
        return (arg).$to_int();
      }

      for (i = format_string.indexOf('%'); i !== -1; i = format_string.indexOf('%', i)) {
        str = undefined;

        flags = FNONE;
        width = -1;
        precision = -1;
        next_arg = undefined;

        end_slice = i;

        i++;

        switch (format_string.charAt(i)) {
        case '%':
          begin_slice = i;
        case '':
        case '\n':
        case '\0':
          i++;
          continue;
        }

        format_sequence: for (; i < len; i++) {
          switch (format_string.charAt(i)) {

          case ' ':
            CHECK_FOR_FLAGS();
            flags |= FSPACE;
            continue format_sequence;

          case '#':
            CHECK_FOR_FLAGS();
            flags |= FSHARP;
            continue format_sequence;

          case '+':
            CHECK_FOR_FLAGS();
            flags |= FPLUS;
            continue format_sequence;

          case '-':
            CHECK_FOR_FLAGS();
            flags |= FMINUS;
            continue format_sequence;

          case '0':
            CHECK_FOR_FLAGS();
            flags |= FZERO;
            continue format_sequence;

          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            tmp_num = READ_NUM('width');
            if (format_string.charAt(i + 1) === '$') {
              if (i + 2 === len) {
                str = '%';
                i++;
                break format_sequence;
              }
              if (next_arg !== undefined) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "value given twice - %" + (tmp_num) + "$")
              }
              next_arg = GET_POS_ARG(tmp_num);
              i++;
            } else {
              CHECK_FOR_WIDTH();
              flags |= FWIDTH;
              width = tmp_num;
            }
            continue format_sequence;

          case '<':
          case '\{':
            closing_brace_char = (format_string.charAt(i) === '<' ? '>' : '\}');
            hash_parameter_key = '';

            i++;

            for (;; i++) {
              if (i === len) {
                self.$raise($$($nesting, 'ArgumentError'), "malformed name - unmatched parenthesis")
              }
              if (format_string.charAt(i) === closing_brace_char) {

                if (pos_arg_num > 0) {
                  self.$raise($$($nesting, 'ArgumentError'), "" + "named " + (hash_parameter_key) + " after unnumbered(" + (pos_arg_num) + ")")
                }
                if (pos_arg_num === -1) {
                  self.$raise($$($nesting, 'ArgumentError'), "" + "named " + (hash_parameter_key) + " after numbered")
                }
                pos_arg_num = -2;

                if (args[0] === undefined || !args[0].$$is_hash) {
                  self.$raise($$($nesting, 'ArgumentError'), "one hash required")
                }

                next_arg = (args[0]).$fetch(hash_parameter_key);

                if (closing_brace_char === '>') {
                  continue format_sequence;
                } else {
                  str = next_arg.toString();
                  if (precision !== -1) { str = str.slice(0, precision); }
                  if (flags&FMINUS) {
                    while (str.length < width) { str = str + ' '; }
                  } else {
                    while (str.length < width) { str = ' ' + str; }
                  }
                  break format_sequence;
                }
              }
              hash_parameter_key += format_string.charAt(i);
            }

          case '*':
            i++;
            CHECK_FOR_WIDTH();
            flags |= FWIDTH;
            width = READ_NUM_AFTER_ASTER('width');
            if (width < 0) {
              flags |= FMINUS;
              width = -width;
            }
            continue format_sequence;

          case '.':
            if (flags&FPREC0) {
              self.$raise($$($nesting, 'ArgumentError'), "precision given twice")
            }
            flags |= FPREC|FPREC0;
            precision = 0;
            i++;
            if (format_string.charAt(i) === '*') {
              i++;
              precision = READ_NUM_AFTER_ASTER('precision');
              if (precision < 0) {
                flags &= ~FPREC;
              }
              continue format_sequence;
            }
            precision = READ_NUM('precision');
            continue format_sequence;

          case 'd':
          case 'i':
          case 'u':
            arg = self.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              str = (-arg).toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            break format_sequence;

          case 'b':
          case 'B':
          case 'o':
          case 'x':
          case 'X':
            switch (format_string.charAt(i)) {
            case 'b':
            case 'B':
              base_number = 2;
              base_prefix = '0b';
              base_neg_zero_regex = /^1+/;
              base_neg_zero_digit = '1';
              break;
            case 'o':
              base_number = 8;
              base_prefix = '0';
              base_neg_zero_regex = /^3?7+/;
              base_neg_zero_digit = '7';
              break;
            case 'x':
            case 'X':
              base_number = 16;
              base_prefix = '0x';
              base_neg_zero_regex = /^f+/;
              base_neg_zero_digit = 'f';
              break;
            }
            arg = self.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString(base_number);
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0) - ((flags&FSHARP && arg !== 0) ? base_prefix.length : 0)) { str = '0' + str; }
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (flags&FPLUS || flags&FSPACE) {
                str = (-arg).toString(base_number);
                while (str.length < precision) { str = '0' + str; }
                if (flags&FMINUS) {
                  if (flags&FSHARP) { str = base_prefix + str; }
                  str = '-' + str;
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 1 - (flags&FSHARP ? 2 : 0)) { str = '0' + str; }
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                  } else {
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              } else {
                str = (arg >>> 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);
                while (str.length < precision - 2) { str = base_neg_zero_digit + str; }
                if (flags&FMINUS) {
                  str = '..' + str;
                  if (flags&FSHARP) { str = base_prefix + str; }
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 2 - (flags&FSHARP ? base_prefix.length : 0)) { str = base_neg_zero_digit + str; }
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                  } else {
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase()) {
              str = str.toUpperCase();
            }
            break format_sequence;

          case 'f':
          case 'e':
          case 'E':
          case 'g':
          case 'G':
            arg = self.$Float(GET_ARG());
            if (arg >= 0 || isNaN(arg)) {
              if (arg === Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = arg.toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = arg.toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = arg.toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = arg.toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== Infinity && !isNaN(arg)) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (arg === -Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = (-arg).toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = (-arg).toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = (-arg).toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = (-arg).toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== -Infinity) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase() && arg !== Infinity && arg !== -Infinity && !isNaN(arg)) {
              str = str.toUpperCase();
            }
            str = str.replace(/([eE][-+]?)([0-9])$/, '$10$2');
            break format_sequence;

          case 'a':
          case 'A':
            // Not implemented because there are no specs for this field type.
            self.$raise($$($nesting, 'NotImplementedError'), "`A` and `a` format field types are not implemented in Opal yet")

          case 'c':
            arg = GET_ARG();
            if ((arg)['$respond_to?']("to_ary")) { arg = (arg).$to_ary()[0]; }
            if ((arg)['$respond_to?']("to_str")) {
              str = (arg).$to_str();
            } else {
              str = String.fromCharCode($coerce_to(arg, $$($nesting, 'Integer'), 'to_int'));
            }
            if (str.length !== 1) {
              self.$raise($$($nesting, 'ArgumentError'), "%c requires a character")
            }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 'p':
            str = (GET_ARG()).$inspect();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 's':
            str = (GET_ARG()).$to_s();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          default:
            self.$raise($$($nesting, 'ArgumentError'), "" + "malformed format string - %" + (format_string.charAt(i)))
          }
        }

        if (str === undefined) {
          self.$raise($$($nesting, 'ArgumentError'), "malformed format string - %")
        }

        result += format_string.slice(begin_slice, end_slice) + str;
        begin_slice = i + 1;
      }

      if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args.length) {
        self.$raise($$($nesting, 'ArgumentError'), "too many arguments for format string")
      }

      return result + format_string.slice(begin_slice);
    ;
    }, $Kernel_format$1.$$arity = -2);
    Opal.alias(self, "sprintf", "format");
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/string/encoding"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var $$11, $$14, $$17, $$20, $$23, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $writer = nil;

  Opal.add_stubs(['$require', '$+', '$[]', '$new', '$instance_eval', '$to_proc', '$each', '$const_set', '$sub', '$==', '$default_external', '$upcase', '$raise', '$attr_accessor', '$singleton_class', '$attr_reader', '$register', '$length', '$bytes', '$to_a', '$each_byte', '$dup', '$bytesize', '$enum_for', '$each_codepoint', '$coerce_to!', '$find', '$<', '$default_external=', '$-']);
  
  self.$require("corelib/string");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Encoding');

    var $nesting = [self].concat($parent_nesting), $Encoding_register$1, $Encoding_find$3, $Encoding_initialize$4, $Encoding_ascii_compatible$ques$5, $Encoding_dummy$ques$6, $Encoding_to_s$7, $Encoding_inspect$8, $Encoding_each_byte$9, $Encoding_bytesize$10;

    self.$$prototype.ascii = self.$$prototype.dummy = self.$$prototype.name = nil;
    
    Opal.defs(self, '$register', $Encoding_register$1 = function $$register(name, options) {
      var $iter = $Encoding_register$1.$$p, block = $iter || nil, $$2, self = this, names = nil, $ret_or_1 = nil, ascii = nil, $ret_or_2 = nil, dummy = nil, $ret_or_3 = nil, encoding = nil, register = nil;

      if ($iter) $Encoding_register$1.$$p = null;
      
      
      if ($iter) $Encoding_register$1.$$p = null;;
      
      if (options == null) {
        options = $hash2([], {});
      };
      names = $rb_plus([name], (function() {if ($truthy(($ret_or_1 = options['$[]']("aliases")))) {
        return $ret_or_1
      } else {
        return []
      }; return nil; })());
      ascii = (function() {if ($truthy(($ret_or_2 = options['$[]']("ascii")))) {
        return $ret_or_2
      } else {
        return false
      }; return nil; })();
      dummy = (function() {if ($truthy(($ret_or_3 = options['$[]']("dummy")))) {
        return $ret_or_3
      } else {
        return false
      }; return nil; })();
      encoding = self.$new(name, names, ascii, dummy);
      $send(encoding, 'instance_eval', [], block.$to_proc());
      register = Opal.encodings;
      return $send(names, 'each', [], ($$2 = function(encoding_name){var self = $$2.$$s == null ? this : $$2.$$s;

      
        
        if (encoding_name == null) {
          encoding_name = nil;
        };
        self.$const_set(encoding_name.$sub("-", "_"), encoding);
        return register[encoding_name] = encoding;}, $$2.$$s = self, $$2.$$arity = 1, $$2));
    }, $Encoding_register$1.$$arity = -2);
    Opal.defs(self, '$find', $Encoding_find$3 = function $$find(name) {
      var self = this, register = nil, encoding = nil, $ret_or_4 = nil;

      
      if (name['$==']("default_external")) {
        return self.$default_external()};
      register = Opal.encodings;
      encoding = (function() {if ($truthy(($ret_or_4 = register[name]))) {
        return $ret_or_4
      } else {
        return register[name.$upcase()]
      }; return nil; })();
      if ($truthy(encoding)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "unknown encoding name - " + (name))
      };
      return encoding;
    }, $Encoding_find$3.$$arity = 1);
    self.$singleton_class().$attr_accessor("default_external");
    self.$attr_reader("name", "names");
    
    Opal.def(self, '$initialize', $Encoding_initialize$4 = function $$initialize(name, names, ascii, dummy) {
      var self = this;

      
      self.name = name;
      self.names = names;
      self.ascii = ascii;
      return (self.dummy = dummy);
    }, $Encoding_initialize$4.$$arity = 4);
    
    Opal.def(self, '$ascii_compatible?', $Encoding_ascii_compatible$ques$5 = function() {
      var self = this;

      return self.ascii
    }, $Encoding_ascii_compatible$ques$5.$$arity = 0);
    
    Opal.def(self, '$dummy?', $Encoding_dummy$ques$6 = function() {
      var self = this;

      return self.dummy
    }, $Encoding_dummy$ques$6.$$arity = 0);
    
    Opal.def(self, '$to_s', $Encoding_to_s$7 = function $$to_s() {
      var self = this;

      return self.name
    }, $Encoding_to_s$7.$$arity = 0);
    
    Opal.def(self, '$inspect', $Encoding_inspect$8 = function $$inspect() {
      var self = this;

      return "" + "#<Encoding:" + (self.name) + ((function() {if ($truthy(self.dummy)) {
        return " (dummy)"
      } else {
        return nil
      }; return nil; })()) + ">"
    }, $Encoding_inspect$8.$$arity = 0);
    
    Opal.def(self, '$each_byte', $Encoding_each_byte$9 = function $$each_byte($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Encoding_each_byte$9.$$arity = -1);
    
    Opal.def(self, '$bytesize', $Encoding_bytesize$10 = function $$bytesize($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Encoding_bytesize$10.$$arity = -1);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'EncodingError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'StandardError'), $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CompatibilityError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'EncodingError'), $nesting);
  })($nesting[0], null, $nesting);
  $send($$($nesting, 'Encoding'), 'register', ["UTF-8", $hash2(["aliases", "ascii"], {"aliases": ["CP65001"], "ascii": true})], ($$11 = function(){var self = $$11.$$s == null ? this : $$11.$$s, $each_byte$12, $bytesize$13;

  
    
    Opal.def(self, '$each_byte', $each_byte$12 = function $$each_byte(string) {
      var $iter = $each_byte$12.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$12.$$p = null;
      
      
      if ($iter) $each_byte$12.$$p = null;;
      
      // Taken from: https://github.com/feross/buffer/blob/f52dffd9df0445b93c0c9065c2f8f0f46b2c729a/index.js#L1954-L2032
      var units = Infinity
      var codePoint
      var length = string.length
      var leadSurrogate = null

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i)

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue
            }

            // valid lead
            leadSurrogate = codePoint

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) {
              Opal.yield1(block, 0xEF);
              Opal.yield1(block, 0xBF);
              Opal.yield1(block, 0xBD);
            }
            leadSurrogate = codePoint
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) {
            Opal.yield1(block, 0xEF);
            Opal.yield1(block, 0xBF);
            Opal.yield1(block, 0xBD);
          }
        }

        leadSurrogate = null

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          Opal.yield1(block, codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          Opal.yield1(block, codePoint >> 0x6 | 0xC0);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          Opal.yield1(block, codePoint >> 0xC | 0xE0);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          Opal.yield1(block, codePoint >> 0x12 | 0xF0);
          Opal.yield1(block, codePoint >> 0xC & 0x3F | 0x80);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else {
          // Invalid code point
        }
      }
    ;
    }, $each_byte$12.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$13 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$13.$$arity = 1), nil) && 'bytesize';}, $$11.$$s = self, $$11.$$arity = 0, $$11));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-16LE"], ($$14 = function(){var self = $$14.$$s == null ? this : $$14.$$s, $each_byte$15, $bytesize$16;

  
    
    Opal.def(self, '$each_byte', $each_byte$15 = function $$each_byte(string) {
      var $iter = $each_byte$15.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$15.$$p = null;
      
      
      if ($iter) $each_byte$15.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, $each_byte$15.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$16 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$16.$$arity = 1), nil) && 'bytesize';}, $$14.$$s = self, $$14.$$arity = 0, $$14));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-16BE"], ($$17 = function(){var self = $$17.$$s == null ? this : $$17.$$s, $each_byte$18, $bytesize$19;

  
    
    Opal.def(self, '$each_byte', $each_byte$18 = function $$each_byte(string) {
      var $iter = $each_byte$18.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$18.$$p = null;
      
      
      if ($iter) $each_byte$18.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, $each_byte$18.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$19 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$19.$$arity = 1), nil) && 'bytesize';}, $$17.$$s = self, $$17.$$arity = 0, $$17));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-32LE"], ($$20 = function(){var self = $$20.$$s == null ? this : $$20.$$s, $each_byte$21, $bytesize$22;

  
    
    Opal.def(self, '$each_byte', $each_byte$21 = function $$each_byte(string) {
      var $iter = $each_byte$21.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$21.$$p = null;
      
      
      if ($iter) $each_byte$21.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, $each_byte$21.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$22 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$22.$$arity = 1), nil) && 'bytesize';}, $$20.$$s = self, $$20.$$arity = 0, $$20));
  $send($$($nesting, 'Encoding'), 'register', ["ASCII-8BIT", $hash2(["aliases", "ascii", "dummy"], {"aliases": ["BINARY", "US-ASCII", "ASCII"], "ascii": true, "dummy": true})], ($$23 = function(){var self = $$23.$$s == null ? this : $$23.$$s, $each_byte$24, $bytesize$25;

  
    
    Opal.def(self, '$each_byte', $each_byte$24 = function $$each_byte(string) {
      var $iter = $each_byte$24.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$24.$$p = null;
      
      
      if ($iter) $each_byte$24.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);
        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, $each_byte$24.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$25 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$25.$$arity = 1), nil) && 'bytesize';}, $$23.$$s = self, $$23.$$arity = 0, $$23));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_bytes$26, $String_bytesize$27, $String_each_byte$28, $String_each_codepoint$29, $String_codepoints$30, $String_encode$31, $String_force_encoding$32, $String_getbyte$33, $String_valid_encoding$ques$34;

    self.$$prototype.bytes = self.$$prototype.internal_encoding = nil;
    
    self.$attr_reader("encoding");
    self.$attr_reader("internal_encoding");
    Opal.defineProperty(String.prototype, 'bytes', nil);
    Opal.defineProperty(String.prototype, 'encoding', $$$($$($nesting, 'Encoding'), 'UTF_8'));
    Opal.defineProperty(String.prototype, 'internal_encoding', $$$($$($nesting, 'Encoding'), 'UTF_8'));
    
    Opal.def(self, '$bytes', $String_bytes$26 = function $$bytes() {
      var self = this, $ret_or_5 = nil;

      
      self.bytes = (function() {if ($truthy(($ret_or_5 = self.bytes))) {
        return $ret_or_5
      } else {
        return self.$each_byte().$to_a()
      }; return nil; })();
      return self.bytes.$dup();
    }, $String_bytes$26.$$arity = 0);
    
    Opal.def(self, '$bytesize', $String_bytesize$27 = function $$bytesize() {
      var self = this;

      return self.internal_encoding.$bytesize(self)
    }, $String_bytesize$27.$$arity = 0);
    
    Opal.def(self, '$each_byte', $String_each_byte$28 = function $$each_byte() {
      var $iter = $String_each_byte$28.$$p, block = $iter || nil, self = this;

      if ($iter) $String_each_byte$28.$$p = null;
      
      
      if ($iter) $String_each_byte$28.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_byte")
      };
      $send(self.internal_encoding, 'each_byte', [self], block.$to_proc());
      return self;
    }, $String_each_byte$28.$$arity = 0);
    
    Opal.def(self, '$each_codepoint', $String_each_codepoint$29 = function $$each_codepoint() {
      var $iter = $String_each_codepoint$29.$$p, block = $iter || nil, self = this;

      if ($iter) $String_each_codepoint$29.$$p = null;
      
      
      if ($iter) $String_each_codepoint$29.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_codepoint")
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        Opal.yield1(block, self.codePointAt(i));
      }
    ;
      return self;
    }, $String_each_codepoint$29.$$arity = 0);
    
    Opal.def(self, '$codepoints', $String_codepoints$30 = function $$codepoints() {
      var $iter = $String_codepoints$30.$$p, block = $iter || nil, self = this;

      if ($iter) $String_codepoints$30.$$p = null;
      
      
      if ($iter) $String_codepoints$30.$$p = null;;
      if ((block !== nil)) {
        return $send(self, 'each_codepoint', [], block.$to_proc())};
      return self.$each_codepoint().$to_a();
    }, $String_codepoints$30.$$arity = 0);
    
    Opal.def(self, '$encode', $String_encode$31 = function $$encode(encoding) {
      var self = this;

      return Opal.enc(self, encoding);
    }, $String_encode$31.$$arity = 1);
    
    Opal.def(self, '$force_encoding', $String_force_encoding$32 = function $$force_encoding(encoding) {
      var self = this;

      
      if (encoding === self.encoding) { return self; }

      encoding = $$($nesting, 'Opal')['$coerce_to!'](encoding, $$($nesting, 'String'), "to_s");
      encoding = $$($nesting, 'Encoding').$find(encoding);

      if (encoding === self.encoding) { return self; }

      Opal.set_encoding(self, encoding);

      return self;
    
    }, $String_force_encoding$32.$$arity = 1);
    
    Opal.def(self, '$getbyte', $String_getbyte$33 = function $$getbyte(idx) {
      var self = this, string_bytes = nil;

      
      string_bytes = self.$bytes();
      idx = $$($nesting, 'Opal')['$coerce_to!'](idx, $$($nesting, 'Integer'), "to_int");
      if ($truthy($rb_lt(string_bytes.$length(), idx))) {
        return nil};
      return string_bytes['$[]'](idx);
    }, $String_getbyte$33.$$arity = 1);
    return (Opal.def(self, '$valid_encoding?', $String_valid_encoding$ques$34 = function() {
      var self = this;

      return true
    }, $String_valid_encoding$ques$34.$$arity = 0), nil) && 'valid_encoding?';
  })($nesting[0], null, $nesting);
  
  $writer = [$$$($$($nesting, 'Encoding'), 'UTF_8')];
  $send($$($nesting, 'Encoding'), 'default_external=', Opal.to_a($writer));
  return $writer[$rb_minus($writer["length"], 1)];;
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/math"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $type_error = Opal.type_error, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$raise', '$Float', '$Integer', '$module_function', '$checked', '$float!', '$===', '$gamma', '$-', '$integer!', '$/', '$infinite?']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Math');

    var $nesting = [self].concat($parent_nesting), $Math_checked$1, $Math_float$excl$2, $Math_integer$excl$3, $Math_acos$4, $Math_acosh$5, $Math_asin$6, $Math_asinh$7, $Math_atan$8, $Math_atan2$9, $Math_atanh$10, $Math_cbrt$11, $Math_cos$12, $Math_cosh$13, $Math_erf$14, $Math_erfc$15, $Math_exp$16, $Math_frexp$17, $Math_gamma$18, $Math_hypot$19, $Math_ldexp$20, $Math_lgamma$21, $Math_log$22, $Math_log10$23, $Math_log2$24, $Math_sin$25, $Math_sinh$26, $Math_sqrt$27, $Math_tan$28, $Math_tanh$29;

    
    Opal.const_set($nesting[0], 'E', Math.E);
    Opal.const_set($nesting[0], 'PI', Math.PI);
    Opal.const_set($nesting[0], 'DomainError', $$($nesting, 'Class').$new($$($nesting, 'StandardError')));
    Opal.defs(self, '$checked', $Math_checked$1 = function $$checked(method, $a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      
      if (isNaN(args[0]) || (args.length == 2 && isNaN(args[1]))) {
        return NaN;
      }

      var result = Math[method].apply(null, args);

      if (isNaN(result)) {
        self.$raise($$($nesting, 'DomainError'), "" + "Numerical argument is out of domain - \"" + (method) + "\"");
      }

      return result;
    ;
    }, $Math_checked$1.$$arity = -2);
    Opal.defs(self, '$float!', $Math_float$excl$2 = function(value) {
      var self = this;

      try {
        return self.$Float(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return self.$raise($type_error(value, $$($nesting, 'Float')))
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Math_float$excl$2.$$arity = 1);
    Opal.defs(self, '$integer!', $Math_integer$excl$3 = function(value) {
      var self = this;

      try {
        return self.$Integer(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return self.$raise($type_error(value, $$($nesting, 'Integer')))
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Math_integer$excl$3.$$arity = 1);
    self.$module_function();
    
    Opal.def(self, '$acos', $Math_acos$4 = function $$acos(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("acos", $$($nesting, 'Math')['$float!'](x))
    }, $Math_acos$4.$$arity = 1);
    if ($truthy((typeof(Math.acosh) !== "undefined"))) {
    } else {
      
      Math.acosh = function(x) {
        return Math.log(x + Math.sqrt(x * x - 1));
      }
    
    };
    
    Opal.def(self, '$acosh', $Math_acosh$5 = function $$acosh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("acosh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_acosh$5.$$arity = 1);
    
    Opal.def(self, '$asin', $Math_asin$6 = function $$asin(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("asin", $$($nesting, 'Math')['$float!'](x))
    }, $Math_asin$6.$$arity = 1);
    if ($truthy((typeof(Math.asinh) !== "undefined"))) {
    } else {
      
      Math.asinh = function(x) {
        return Math.log(x + Math.sqrt(x * x + 1))
      }
    
    };
    
    Opal.def(self, '$asinh', $Math_asinh$7 = function $$asinh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("asinh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_asinh$7.$$arity = 1);
    
    Opal.def(self, '$atan', $Math_atan$8 = function $$atan(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("atan", $$($nesting, 'Math')['$float!'](x))
    }, $Math_atan$8.$$arity = 1);
    
    Opal.def(self, '$atan2', $Math_atan2$9 = function $$atan2(y, x) {
      var self = this;

      return $$($nesting, 'Math').$checked("atan2", $$($nesting, 'Math')['$float!'](y), $$($nesting, 'Math')['$float!'](x))
    }, $Math_atan2$9.$$arity = 2);
    if ($truthy((typeof(Math.atanh) !== "undefined"))) {
    } else {
      
      Math.atanh = function(x) {
        return 0.5 * Math.log((1 + x) / (1 - x));
      }
    
    };
    
    Opal.def(self, '$atanh', $Math_atanh$10 = function $$atanh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("atanh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_atanh$10.$$arity = 1);
    if ($truthy((typeof(Math.cbrt) !== "undefined"))) {
    } else {
      
      Math.cbrt = function(x) {
        if (x == 0) {
          return 0;
        }

        if (x < 0) {
          return -Math.cbrt(-x);
        }

        var r  = x,
            ex = 0;

        while (r < 0.125) {
          r *= 8;
          ex--;
        }

        while (r > 1.0) {
          r *= 0.125;
          ex++;
        }

        r = (-0.46946116 * r + 1.072302) * r + 0.3812513;

        while (ex < 0) {
          r *= 0.5;
          ex++;
        }

        while (ex > 0) {
          r *= 2;
          ex--;
        }

        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);

        return r;
      }
    
    };
    
    Opal.def(self, '$cbrt', $Math_cbrt$11 = function $$cbrt(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("cbrt", $$($nesting, 'Math')['$float!'](x))
    }, $Math_cbrt$11.$$arity = 1);
    
    Opal.def(self, '$cos', $Math_cos$12 = function $$cos(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("cos", $$($nesting, 'Math')['$float!'](x))
    }, $Math_cos$12.$$arity = 1);
    if ($truthy((typeof(Math.cosh) !== "undefined"))) {
    } else {
      
      Math.cosh = function(x) {
        return (Math.exp(x) + Math.exp(-x)) / 2;
      }
    
    };
    
    Opal.def(self, '$cosh', $Math_cosh$13 = function $$cosh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("cosh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_cosh$13.$$arity = 1);
    if ($truthy((typeof(Math.erf) !== "undefined"))) {
    } else {
      
      Opal.defineProperty(Math, 'erf', function(x) {
        var A1 =  0.254829592,
            A2 = -0.284496736,
            A3 =  1.421413741,
            A4 = -1.453152027,
            A5 =  1.061405429,
            P  =  0.3275911;

        var sign = 1;

        if (x < 0) {
            sign = -1;
        }

        x = Math.abs(x);

        var t = 1.0 / (1.0 + P * x);
        var y = 1.0 - (((((A5 * t + A4) * t) + A3) * t + A2) * t + A1) * t * Math.exp(-x * x);

        return sign * y;
      });
    
    };
    
    Opal.def(self, '$erf', $Math_erf$14 = function $$erf(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("erf", $$($nesting, 'Math')['$float!'](x))
    }, $Math_erf$14.$$arity = 1);
    if ($truthy((typeof(Math.erfc) !== "undefined"))) {
    } else {
      
      Opal.defineProperty(Math, 'erfc', function(x) {
        var z = Math.abs(x),
            t = 1.0 / (0.5 * z + 1.0);

        var A1 = t * 0.17087277 + -0.82215223,
            A2 = t * A1 + 1.48851587,
            A3 = t * A2 + -1.13520398,
            A4 = t * A3 + 0.27886807,
            A5 = t * A4 + -0.18628806,
            A6 = t * A5 + 0.09678418,
            A7 = t * A6 + 0.37409196,
            A8 = t * A7 + 1.00002368,
            A9 = t * A8,
            A10 = -z * z - 1.26551223 + A9;

        var a = t * Math.exp(A10);

        if (x < 0.0) {
          return 2.0 - a;
        }
        else {
          return a;
        }
      });
    
    };
    
    Opal.def(self, '$erfc', $Math_erfc$15 = function $$erfc(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("erfc", $$($nesting, 'Math')['$float!'](x))
    }, $Math_erfc$15.$$arity = 1);
    
    Opal.def(self, '$exp', $Math_exp$16 = function $$exp(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("exp", $$($nesting, 'Math')['$float!'](x))
    }, $Math_exp$16.$$arity = 1);
    
    Opal.def(self, '$frexp', $Math_frexp$17 = function $$frexp(x) {
      var self = this;

      
      x = $$($nesting, 'Math')['$float!'](x);
      
      if (isNaN(x)) {
        return [NaN, 0];
      }

      var ex   = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1,
          frac = x / Math.pow(2, ex);

      return [frac, ex];
    ;
    }, $Math_frexp$17.$$arity = 1);
    
    Opal.def(self, '$gamma', $Math_gamma$18 = function $$gamma(n) {
      var self = this;

      
      n = $$($nesting, 'Math')['$float!'](n);
      
      var i, t, x, value, result, twoN, threeN, fourN, fiveN;

      var G = 4.7421875;

      var P = [
         0.99999999999999709182,
         57.156235665862923517,
        -59.597960355475491248,
         14.136097974741747174,
        -0.49191381609762019978,
         0.33994649984811888699e-4,
         0.46523628927048575665e-4,
        -0.98374475304879564677e-4,
         0.15808870322491248884e-3,
        -0.21026444172410488319e-3,
         0.21743961811521264320e-3,
        -0.16431810653676389022e-3,
         0.84418223983852743293e-4,
        -0.26190838401581408670e-4,
         0.36899182659531622704e-5
      ];


      if (isNaN(n)) {
        return NaN;
      }

      if (n === 0 && 1 / n < 0) {
        return -Infinity;
      }

      if (n === -1 || n === -Infinity) {
        self.$raise($$($nesting, 'DomainError'), "Numerical argument is out of domain - \"gamma\"");
      }

      if ($$($nesting, 'Integer')['$==='](n)) {
        if (n <= 0) {
          return isFinite(n) ? Infinity : NaN;
        }

        if (n > 171) {
          return Infinity;
        }

        value  = n - 2;
        result = n - 1;

        while (value > 1) {
          result *= value;
          value--;
        }

        if (result == 0) {
          result = 1;
        }

        return result;
      }

      if (n < 0.5) {
        return Math.PI / (Math.sin(Math.PI * n) * $$($nesting, 'Math').$gamma($rb_minus(1, n)));
      }

      if (n >= 171.35) {
        return Infinity;
      }

      if (n > 85.0) {
        twoN   = n * n;
        threeN = twoN * n;
        fourN  = threeN * n;
        fiveN  = fourN * n;

        return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *
          (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) -
          571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) +
          5246819 / (75246796800 * fiveN * n));
      }

      n -= 1;
      x  = P[0];

      for (i = 1; i < P.length; ++i) {
        x += P[i] / (n + i);
      }

      t = n + G + 0.5;

      return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
    ;
    }, $Math_gamma$18.$$arity = 1);
    if ($truthy((typeof(Math.hypot) !== "undefined"))) {
    } else {
      
      Math.hypot = function(x, y) {
        return Math.sqrt(x * x + y * y)
      }
    
    };
    
    Opal.def(self, '$hypot', $Math_hypot$19 = function $$hypot(x, y) {
      var self = this;

      return $$($nesting, 'Math').$checked("hypot", $$($nesting, 'Math')['$float!'](x), $$($nesting, 'Math')['$float!'](y))
    }, $Math_hypot$19.$$arity = 2);
    
    Opal.def(self, '$ldexp', $Math_ldexp$20 = function $$ldexp(mantissa, exponent) {
      var self = this;

      
      mantissa = $$($nesting, 'Math')['$float!'](mantissa);
      exponent = $$($nesting, 'Math')['$integer!'](exponent);
      
      if (isNaN(exponent)) {
        self.$raise($$($nesting, 'RangeError'), "float NaN out of range of integer");
      }

      return mantissa * Math.pow(2, exponent);
    ;
    }, $Math_ldexp$20.$$arity = 2);
    
    Opal.def(self, '$lgamma', $Math_lgamma$21 = function $$lgamma(n) {
      var self = this;

      
      if (n == -1) {
        return [Infinity, 1];
      }
      else {
        return [Math.log(Math.abs($$($nesting, 'Math').$gamma(n))), $$($nesting, 'Math').$gamma(n) < 0 ? -1 : 1];
      }
    
    }, $Math_lgamma$21.$$arity = 1);
    
    Opal.def(self, '$log', $Math_log$22 = function $$log(x, base) {
      var self = this;

      
      ;
      if ($truthy($$($nesting, 'String')['$==='](x))) {
        self.$raise($type_error(x, $$($nesting, 'Float')))};
      if ($truthy(base == null)) {
        return $$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](x))
      } else {
        
        if ($truthy($$($nesting, 'String')['$==='](base))) {
          self.$raise($type_error(base, $$($nesting, 'Float')))};
        return $rb_divide($$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](x)), $$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](base)));
      };
    }, $Math_log$22.$$arity = -2);
    if ($truthy((typeof(Math.log10) !== "undefined"))) {
    } else {
      
      Math.log10 = function(x) {
        return Math.log(x) / Math.LN10;
      }
    
    };
    
    Opal.def(self, '$log10', $Math_log10$23 = function $$log10(x) {
      var self = this;

      
      if ($truthy($$($nesting, 'String')['$==='](x))) {
        self.$raise($type_error(x, $$($nesting, 'Float')))};
      return $$($nesting, 'Math').$checked("log10", $$($nesting, 'Math')['$float!'](x));
    }, $Math_log10$23.$$arity = 1);
    if ($truthy((typeof(Math.log2) !== "undefined"))) {
    } else {
      
      Math.log2 = function(x) {
        return Math.log(x) / Math.LN2;
      }
    
    };
    
    Opal.def(self, '$log2', $Math_log2$24 = function $$log2(x) {
      var self = this;

      
      if ($truthy($$($nesting, 'String')['$==='](x))) {
        self.$raise($type_error(x, $$($nesting, 'Float')))};
      return $$($nesting, 'Math').$checked("log2", $$($nesting, 'Math')['$float!'](x));
    }, $Math_log2$24.$$arity = 1);
    
    Opal.def(self, '$sin', $Math_sin$25 = function $$sin(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("sin", $$($nesting, 'Math')['$float!'](x))
    }, $Math_sin$25.$$arity = 1);
    if ($truthy((typeof(Math.sinh) !== "undefined"))) {
    } else {
      
      Math.sinh = function(x) {
        return (Math.exp(x) - Math.exp(-x)) / 2;
      }
    
    };
    
    Opal.def(self, '$sinh', $Math_sinh$26 = function $$sinh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("sinh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_sinh$26.$$arity = 1);
    
    Opal.def(self, '$sqrt', $Math_sqrt$27 = function $$sqrt(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("sqrt", $$($nesting, 'Math')['$float!'](x))
    }, $Math_sqrt$27.$$arity = 1);
    
    Opal.def(self, '$tan', $Math_tan$28 = function $$tan(x) {
      var self = this;

      
      x = $$($nesting, 'Math')['$float!'](x);
      if ($truthy(x['$infinite?']())) {
        return $$$($$($nesting, 'Float'), 'NAN')};
      return $$($nesting, 'Math').$checked("tan", $$($nesting, 'Math')['$float!'](x));
    }, $Math_tan$28.$$arity = 1);
    if ($truthy((typeof(Math.tanh) !== "undefined"))) {
    } else {
      
      Math.tanh = function(x) {
        if (x == Infinity) {
          return 1;
        }
        else if (x == -Infinity) {
          return -1;
        }
        else {
          return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
        }
      }
    
    };
    
    Opal.def(self, '$tanh', $Math_tanh$29 = function $$tanh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("tanh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_tanh$29.$$arity = 1);
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/complex"] = function(Opal) {
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $module = Opal.module;

  Opal.add_stubs(['$require', '$===', '$real?', '$raise', '$new', '$*', '$cos', '$sin', '$attr_reader', '$class', '$==', '$real', '$imag', '$Complex', '$-@', '$+', '$__coerced__', '$-', '$nan?', '$/', '$conj', '$abs2', '$quo', '$polar', '$exp', '$log', '$>', '$!=', '$divmod', '$**', '$hypot', '$atan2', '$lcm', '$denominator', '$finite?', '$infinite?', '$numerator', '$abs', '$arg', '$rationalize', '$to_f', '$to_i', '$to_r', '$inspect', '$positive?', '$zero?', '$Rational']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Complex');

    var $nesting = [self].concat($parent_nesting), $Complex_rect$1, $Complex_polar$2, $Complex_initialize$3, $Complex_coerce$4, $Complex_$eq_eq$5, $Complex_$minus$$6, $Complex_$plus$7, $Complex_$minus$8, $Complex_$$9, $Complex_$slash$10, $Complex_$$$11, $Complex_abs$12, $Complex_abs2$13, $Complex_angle$14, $Complex_conj$15, $Complex_denominator$16, $Complex_eql$ques$17, $Complex_fdiv$18, $Complex_finite$ques$19, $Complex_hash$20, $Complex_infinite$ques$21, $Complex_inspect$22, $Complex_numerator$23, $Complex_polar$24, $Complex_rationalize$25, $Complex_real$ques$26, $Complex_rect$27, $Complex_to_f$28, $Complex_to_i$29, $Complex_to_r$30, $Complex_to_s$31;

    self.$$prototype.real = self.$$prototype.imag = nil;
    
    Opal.defs(self, '$rect', $Complex_rect$1 = function $$rect(real, imag) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

      
      
      if (imag == null) {
        imag = 0;
      };
      if ($truthy((function() {if ($truthy(($ret_or_1 = (function() {if ($truthy(($ret_or_2 = (function() {if ($truthy(($ret_or_3 = $$($nesting, 'Numeric')['$==='](real)))) {
        return real['$real?']()
      } else {
        return $ret_or_3
      }; return nil; })()))) {
        return $$($nesting, 'Numeric')['$==='](imag)
      } else {
        return $ret_or_2
      }; return nil; })()))) {
        return imag['$real?']()
      } else {
        return $ret_or_1
      }; return nil; })())) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not a real")
      };
      return self.$new(real, imag);
    }, $Complex_rect$1.$$arity = -2);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      return Opal.alias(self, "rectangular", "rect")
    })(Opal.get_singleton_class(self), $nesting);
    Opal.defs(self, '$polar', $Complex_polar$2 = function $$polar(r, theta) {
      var self = this, $ret_or_4 = nil, $ret_or_5 = nil, $ret_or_6 = nil;

      
      
      if (theta == null) {
        theta = 0;
      };
      if ($truthy((function() {if ($truthy(($ret_or_4 = (function() {if ($truthy(($ret_or_5 = (function() {if ($truthy(($ret_or_6 = $$($nesting, 'Numeric')['$==='](r)))) {
        return r['$real?']()
      } else {
        return $ret_or_6
      }; return nil; })()))) {
        return $$($nesting, 'Numeric')['$==='](theta)
      } else {
        return $ret_or_5
      }; return nil; })()))) {
        return theta['$real?']()
      } else {
        return $ret_or_4
      }; return nil; })())) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not a real")
      };
      return self.$new($rb_times(r, $$($nesting, 'Math').$cos(theta)), $rb_times(r, $$($nesting, 'Math').$sin(theta)));
    }, $Complex_polar$2.$$arity = -2);
    self.$attr_reader("real", "imag");
    
    Opal.def(self, '$initialize', $Complex_initialize$3 = function $$initialize(real, imag) {
      var self = this;

      
      
      if (imag == null) {
        imag = 0;
      };
      self.real = real;
      return (self.imag = imag);
    }, $Complex_initialize$3.$$arity = -2);
    
    Opal.def(self, '$coerce', $Complex_coerce$4 = function $$coerce(other) {
      var self = this, $ret_or_7 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return [other, self]
      } else if ($truthy((function() {if ($truthy(($ret_or_7 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_7
      }; return nil; })())) {
        return [$$($nesting, 'Complex').$new(other, 0), self]
      } else {
        return self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      }
    }, $Complex_coerce$4.$$arity = 1);
    
    Opal.def(self, '$==', $Complex_$eq_eq$5 = function(other) {
      var self = this, $ret_or_8 = nil, $ret_or_9 = nil, $ret_or_10 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        if ($truthy(($ret_or_8 = self.real['$=='](other.$real())))) {
          return self.imag['$=='](other.$imag())
        } else {
          return $ret_or_8
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_9 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_9
      }; return nil; })())) {
        if ($truthy(($ret_or_10 = self.real['$=='](other)))) {
          return self.imag['$=='](0)
        } else {
          return $ret_or_10
        }
      } else {
        return other['$=='](self)
      }
    }, $Complex_$eq_eq$5.$$arity = 1);
    
    Opal.def(self, '$-@', $Complex_$minus$$6 = function() {
      var self = this;

      return self.$Complex(self.real['$-@'](), self.imag['$-@']())
    }, $Complex_$minus$$6.$$arity = 0);
    
    Opal.def(self, '$+', $Complex_$plus$7 = function(other) {
      var self = this, $ret_or_11 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_plus(self.real, other.$real()), $rb_plus(self.imag, other.$imag()))
      } else if ($truthy((function() {if ($truthy(($ret_or_11 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_11
      }; return nil; })())) {
        return self.$Complex($rb_plus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("+", other)
      }
    }, $Complex_$plus$7.$$arity = 1);
    
    Opal.def(self, '$-', $Complex_$minus$8 = function(other) {
      var self = this, $ret_or_12 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_minus(self.real, other.$real()), $rb_minus(self.imag, other.$imag()))
      } else if ($truthy((function() {if ($truthy(($ret_or_12 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_12
      }; return nil; })())) {
        return self.$Complex($rb_minus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("-", other)
      }
    }, $Complex_$minus$8.$$arity = 1);
    
    Opal.def(self, '$*', $Complex_$$9 = function(other) {
      var self = this, $ret_or_13 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_minus($rb_times(self.real, other.$real()), $rb_times(self.imag, other.$imag())), $rb_plus($rb_times(self.real, other.$imag()), $rb_times(self.imag, other.$real())))
      } else if ($truthy((function() {if ($truthy(($ret_or_13 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_13
      }; return nil; })())) {
        return self.$Complex($rb_times(self.real, other), $rb_times(self.imag, other))
      } else {
        return self.$__coerced__("*", other)
      }
    }, $Complex_$$9.$$arity = 1);
    
    Opal.def(self, '$/', $Complex_$slash$10 = function(other) {
      var self = this, $ret_or_14 = nil, $ret_or_15 = nil, $ret_or_16 = nil, $ret_or_17 = nil, $ret_or_18 = nil, $ret_or_19 = nil, $ret_or_20 = nil, $ret_or_21 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        if ($truthy((function() {if ($truthy(($ret_or_14 = (function() {if ($truthy(($ret_or_15 = (function() {if ($truthy(($ret_or_16 = (function() {if ($truthy(($ret_or_17 = $$($nesting, 'Number')['$==='](self.real)))) {
          return self.real['$nan?']()
        } else {
          return $ret_or_17
        }; return nil; })()))) {
          return $ret_or_16
        } else {
          
          if ($truthy(($ret_or_18 = $$($nesting, 'Number')['$==='](self.imag)))) {
            return self.imag['$nan?']()
          } else {
            return $ret_or_18
          };
        }; return nil; })()))) {
          return $ret_or_15
        } else {
          
          if ($truthy(($ret_or_19 = $$($nesting, 'Number')['$==='](other.$real())))) {
            return other.$real()['$nan?']()
          } else {
            return $ret_or_19
          };
        }; return nil; })()))) {
          return $ret_or_14
        } else {
          
          if ($truthy(($ret_or_20 = $$($nesting, 'Number')['$==='](other.$imag())))) {
            return other.$imag()['$nan?']()
          } else {
            return $ret_or_20
          };
        }; return nil; })())) {
          return $$($nesting, 'Complex').$new($$$($$($nesting, 'Float'), 'NAN'), $$$($$($nesting, 'Float'), 'NAN'))
        } else {
          return $rb_divide($rb_times(self, other.$conj()), other.$abs2())
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_21 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_21
      }; return nil; })())) {
        return self.$Complex(self.real.$quo(other), self.imag.$quo(other))
      } else {
        return self.$__coerced__("/", other)
      }
    }, $Complex_$slash$10.$$arity = 1);
    
    Opal.def(self, '$**', $Complex_$$$11 = function(other) {
      var $a, $b, $c, $d, self = this, r = nil, theta = nil, ore = nil, oim = nil, nr = nil, ntheta = nil, x = nil, z = nil, n = nil, div = nil, mod = nil, $ret_or_22 = nil;

      
      if (other['$=='](0)) {
        return $$($nesting, 'Complex').$new(1, 0)};
      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        
        $b = self.$polar(), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        ore = other.$real();
        oim = other.$imag();
        nr = $$($nesting, 'Math').$exp($rb_minus($rb_times(ore, $$($nesting, 'Math').$log(r)), $rb_times(oim, theta)));
        ntheta = $rb_plus($rb_times(theta, ore), $rb_times(oim, $$($nesting, 'Math').$log(r)));
        return $$($nesting, 'Complex').$polar(nr, ntheta);
      } else if ($truthy($$($nesting, 'Integer')['$==='](other))) {
        if ($truthy($rb_gt(other, 0))) {
          
          x = self;
          z = x;
          n = $rb_minus(other, 1);
          while ($truthy(n['$!='](0))) {
            
            $c = n.$divmod(2), $b = Opal.to_ary($c), (div = ($b[0] == null ? nil : $b[0])), (mod = ($b[1] == null ? nil : $b[1])), $c;
            while (mod['$=='](0)) {
              
              x = self.$Complex($rb_minus($rb_times(x.$real(), x.$real()), $rb_times(x.$imag(), x.$imag())), $rb_times($rb_times(2, x.$real()), x.$imag()));
              n = div;
              $d = n.$divmod(2), $c = Opal.to_ary($d), (div = ($c[0] == null ? nil : $c[0])), (mod = ($c[1] == null ? nil : $c[1])), $d;
            };
            z = $rb_times(z, x);
            n = $rb_minus(n, 1);
          };
          return z;
        } else {
          return $rb_divide($$($nesting, 'Rational').$new(1, 1), self)['$**'](other['$-@']())
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_22 = $$($nesting, 'Float')['$==='](other)))) {
        return $ret_or_22
      } else {
        return $$($nesting, 'Rational')['$==='](other)
      }; return nil; })())) {
        
        $b = self.$polar(), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        return $$($nesting, 'Complex').$polar(r['$**'](other), $rb_times(theta, other));
      } else {
        return self.$__coerced__("**", other)
      };
    }, $Complex_$$$11.$$arity = 1);
    
    Opal.def(self, '$abs', $Complex_abs$12 = function $$abs() {
      var self = this;

      return $$($nesting, 'Math').$hypot(self.real, self.imag)
    }, $Complex_abs$12.$$arity = 0);
    
    Opal.def(self, '$abs2', $Complex_abs2$13 = function $$abs2() {
      var self = this;

      return $rb_plus($rb_times(self.real, self.real), $rb_times(self.imag, self.imag))
    }, $Complex_abs2$13.$$arity = 0);
    
    Opal.def(self, '$angle', $Complex_angle$14 = function $$angle() {
      var self = this;

      return $$($nesting, 'Math').$atan2(self.imag, self.real)
    }, $Complex_angle$14.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    
    Opal.def(self, '$conj', $Complex_conj$15 = function $$conj() {
      var self = this;

      return self.$Complex(self.real, self.imag['$-@']())
    }, $Complex_conj$15.$$arity = 0);
    Opal.alias(self, "conjugate", "conj");
    
    Opal.def(self, '$denominator', $Complex_denominator$16 = function $$denominator() {
      var self = this;

      return self.real.$denominator().$lcm(self.imag.$denominator())
    }, $Complex_denominator$16.$$arity = 0);
    Opal.alias(self, "divide", "/");
    
    Opal.def(self, '$eql?', $Complex_eql$ques$17 = function(other) {
      var self = this, $ret_or_23 = nil, $ret_or_24 = nil;

      if ($truthy(($ret_or_23 = (function() {if ($truthy(($ret_or_24 = $$($nesting, 'Complex')['$==='](other)))) {
        return self.real.$class()['$=='](self.imag.$class())
      } else {
        return $ret_or_24
      }; return nil; })()))) {
        return self['$=='](other)
      } else {
        return $ret_or_23
      }
    }, $Complex_eql$ques$17.$$arity = 1);
    
    Opal.def(self, '$fdiv', $Complex_fdiv$18 = function $$fdiv(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Numeric')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      };
      return $rb_divide(self, other);
    }, $Complex_fdiv$18.$$arity = 1);
    
    Opal.def(self, '$finite?', $Complex_finite$ques$19 = function() {
      var self = this, $ret_or_25 = nil;

      if ($truthy(($ret_or_25 = self.real['$finite?']()))) {
        return self.imag['$finite?']()
      } else {
        return $ret_or_25
      }
    }, $Complex_finite$ques$19.$$arity = 0);
    
    Opal.def(self, '$hash', $Complex_hash$20 = function $$hash() {
      var self = this;

      return "" + "Complex:" + (self.real) + ":" + (self.imag)
    }, $Complex_hash$20.$$arity = 0);
    Opal.alias(self, "imaginary", "imag");
    
    Opal.def(self, '$infinite?', $Complex_infinite$ques$21 = function() {
      var self = this, $ret_or_26 = nil;

      if ($truthy(($ret_or_26 = self.real['$infinite?']()))) {
        return $ret_or_26
      } else {
        return self.imag['$infinite?']()
      }
    }, $Complex_infinite$ques$21.$$arity = 0);
    
    Opal.def(self, '$inspect', $Complex_inspect$22 = function $$inspect() {
      var self = this;

      return "" + "(" + (self) + ")"
    }, $Complex_inspect$22.$$arity = 0);
    Opal.alias(self, "magnitude", "abs");
    
    Opal.udef(self, '$' + "negative?");;
    
    Opal.def(self, '$numerator', $Complex_numerator$23 = function $$numerator() {
      var self = this, d = nil;

      
      d = self.$denominator();
      return self.$Complex($rb_times(self.real.$numerator(), $rb_divide(d, self.real.$denominator())), $rb_times(self.imag.$numerator(), $rb_divide(d, self.imag.$denominator())));
    }, $Complex_numerator$23.$$arity = 0);
    Opal.alias(self, "phase", "arg");
    
    Opal.def(self, '$polar', $Complex_polar$24 = function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, $Complex_polar$24.$$arity = 0);
    
    Opal.udef(self, '$' + "positive?");;
    Opal.alias(self, "quo", "/");
    
    Opal.def(self, '$rationalize', $Complex_rationalize$25 = function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($truthy(self.imag['$!='](0))) {
        self.$raise($$($nesting, 'RangeError'), "" + "can't' convert " + (self) + " into Rational")};
      return self.$real().$rationalize(eps);
    }, $Complex_rationalize$25.$$arity = -1);
    
    Opal.def(self, '$real?', $Complex_real$ques$26 = function() {
      var self = this;

      return false
    }, $Complex_real$ques$26.$$arity = 0);
    
    Opal.def(self, '$rect', $Complex_rect$27 = function $$rect() {
      var self = this;

      return [self.real, self.imag]
    }, $Complex_rect$27.$$arity = 0);
    Opal.alias(self, "rectangular", "rect");
    
    Opal.def(self, '$to_f', $Complex_to_f$28 = function $$to_f() {
      var self = this;

      
      if (self.imag['$=='](0)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Float")
      };
      return self.real.$to_f();
    }, $Complex_to_f$28.$$arity = 0);
    
    Opal.def(self, '$to_i', $Complex_to_i$29 = function $$to_i() {
      var self = this;

      
      if (self.imag['$=='](0)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Integer")
      };
      return self.real.$to_i();
    }, $Complex_to_i$29.$$arity = 0);
    
    Opal.def(self, '$to_r', $Complex_to_r$30 = function $$to_r() {
      var self = this;

      
      if (self.imag['$=='](0)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Rational")
      };
      return self.real.$to_r();
    }, $Complex_to_r$30.$$arity = 0);
    
    Opal.def(self, '$to_s', $Complex_to_s$31 = function $$to_s() {
      var self = this, result = nil, $ret_or_27 = nil, $ret_or_28 = nil, $ret_or_29 = nil, $ret_or_30 = nil, $ret_or_31 = nil;

      
      result = self.real.$inspect();
      result = $rb_plus(result, (function() {if ($truthy((function() {if ($truthy(($ret_or_27 = (function() {if ($truthy(($ret_or_28 = (function() {if ($truthy(($ret_or_29 = $$($nesting, 'Number')['$==='](self.imag)))) {
        return self.imag['$nan?']()
      } else {
        return $ret_or_29
      }; return nil; })()))) {
        return $ret_or_28
      } else {
        return self.imag['$positive?']()
      }; return nil; })()))) {
        return $ret_or_27
      } else {
        return self.imag['$zero?']()
      }; return nil; })())) {
        return "+"
      } else {
        return "-"
      }; return nil; })());
      result = $rb_plus(result, self.imag.$abs().$inspect());
      if ($truthy((function() {if ($truthy(($ret_or_30 = $$($nesting, 'Number')['$==='](self.imag)))) {
        
        if ($truthy(($ret_or_31 = self.imag['$nan?']()))) {
          return $ret_or_31
        } else {
          return self.imag['$infinite?']()
        };
      } else {
        return $ret_or_30
      }; return nil; })())) {
        result = $rb_plus(result, "*")};
      return $rb_plus(result, "i");
    }, $Complex_to_s$31.$$arity = 0);
    return Opal.const_set($nesting[0], 'I', self.$new(0, 1));
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_Complex$32;

    
    Opal.def(self, '$Complex', $Kernel_Complex$32 = function $$Complex(real, imag) {
      var self = this;

      
      
      if (imag == null) {
        imag = nil;
      };
      if ($truthy(imag)) {
        return $$($nesting, 'Complex').$new(real, imag)
      } else {
        return $$($nesting, 'Complex').$new(real, 0)
      };
    }, $Kernel_Complex$32.$$arity = -2)
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_to_c$33;

    return (Opal.def(self, '$to_c', $String_to_c$33 = function $$to_c() {
      var self = this;

      
      var str = self,
          re = /[+-]?[\d_]+(\.[\d_]+)?(e\d+)?/,
          match = str.match(re),
          real, imag, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      // handles both floats and rationals
      function cutNumber() {
        if (isFloat()) {
          var numerator = parseFloat(cutFloat());

          if (str[0] === '/') {
            // rational real part
            str = str.slice(1);

            if (isFloat()) {
              var denominator = parseFloat(cutFloat());
              return self.$Rational(numerator, denominator);
            } else {
              // reverting '/'
              str = '/' + str;
              return numerator;
            }
          } else {
            // float real part, no denominator
            return numerator;
          }
        } else {
          return null;
        }
      }

      real = cutNumber();

      if (!real) {
        if (str[0] === 'i') {
          // i => Complex(0, 1)
          return self.$Complex(0, 1);
        }
        if (str[0] === '-' && str[1] === 'i') {
          // -i => Complex(0, -1)
          return self.$Complex(0, -1);
        }
        if (str[0] === '+' && str[1] === 'i') {
          // +i => Complex(0, 1)
          return self.$Complex(0, 1);
        }
        // anything => Complex(0, 0)
        return self.$Complex(0, 0);
      }

      imag = cutNumber();
      if (!imag) {
        if (str[0] === 'i') {
          // 3i => Complex(0, 3)
          return self.$Complex(0, real);
        } else {
          // 3 => Complex(3, 0)
          return self.$Complex(real, 0);
        }
      } else {
        // 3+2i => Complex(3, 2)
        return self.$Complex(real, imag);
      }
    
    }, $String_to_c$33.$$arity = 0), nil) && 'to_c'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/rational"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $module = Opal.module;

  Opal.add_stubs(['$require', '$to_i', '$==', '$raise', '$<', '$-@', '$new', '$gcd', '$/', '$nil?', '$===', '$reduce', '$to_r', '$equal?', '$!', '$coerce_to!', '$to_f', '$numerator', '$denominator', '$<=>', '$-', '$*', '$__coerced__', '$+', '$Rational', '$>', '$**', '$abs', '$ceil', '$with_precision', '$floor', '$<=', '$truncate', '$send', '$convert']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Rational');

    var $nesting = [self].concat($parent_nesting), $Rational_reduce$1, $Rational_convert$2, $Rational_initialize$3, $Rational_numerator$4, $Rational_denominator$5, $Rational_coerce$6, $Rational_$eq_eq$7, $Rational_$lt_eq_gt$8, $Rational_$plus$9, $Rational_$minus$10, $Rational_$$11, $Rational_$slash$12, $Rational_$$$13, $Rational_abs$14, $Rational_ceil$15, $Rational_floor$16, $Rational_hash$17, $Rational_inspect$18, $Rational_rationalize$19, $Rational_round$20, $Rational_to_f$21, $Rational_to_i$22, $Rational_to_r$23, $Rational_to_s$24, $Rational_truncate$25, $Rational_with_precision$26;

    self.$$prototype.num = self.$$prototype.den = nil;
    
    Opal.defs(self, '$reduce', $Rational_reduce$1 = function $$reduce(num, den) {
      var self = this, gcd = nil;

      
      num = num.$to_i();
      den = den.$to_i();
      if (den['$=='](0)) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      } else if ($truthy($rb_lt(den, 0))) {
        
        num = num['$-@']();
        den = den['$-@']();
      } else if (den['$=='](1)) {
        return self.$new(num, den)};
      gcd = num.$gcd(den);
      return self.$new($rb_divide(num, gcd), $rb_divide(den, gcd));
    }, $Rational_reduce$1.$$arity = 2);
    Opal.defs(self, '$convert', $Rational_convert$2 = function $$convert(num, den) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil, $ret_or_5 = nil, $ret_or_6 = nil, $ret_or_7 = nil, $ret_or_8 = nil;

      
      if ($truthy((function() {if ($truthy(($ret_or_1 = num['$nil?']()))) {
        return $ret_or_1
      } else {
        return den['$nil?']()
      }; return nil; })())) {
        self.$raise($$($nesting, 'TypeError'), "cannot convert nil into Rational")};
      if ($truthy((function() {if ($truthy(($ret_or_2 = $$($nesting, 'Integer')['$==='](num)))) {
        return $$($nesting, 'Integer')['$==='](den)
      } else {
        return $ret_or_2
      }; return nil; })())) {
        return self.$reduce(num, den)};
      if ($truthy((function() {if ($truthy(($ret_or_3 = (function() {if ($truthy(($ret_or_4 = $$($nesting, 'Float')['$==='](num)))) {
        return $ret_or_4
      } else {
        return $$($nesting, 'String')['$==='](num)
      }; return nil; })()))) {
        return $ret_or_3
      } else {
        return $$($nesting, 'Complex')['$==='](num)
      }; return nil; })())) {
        num = num.$to_r()};
      if ($truthy((function() {if ($truthy(($ret_or_5 = (function() {if ($truthy(($ret_or_6 = $$($nesting, 'Float')['$==='](den)))) {
        return $ret_or_6
      } else {
        return $$($nesting, 'String')['$==='](den)
      }; return nil; })()))) {
        return $ret_or_5
      } else {
        return $$($nesting, 'Complex')['$==='](den)
      }; return nil; })())) {
        den = den.$to_r()};
      if ($truthy((function() {if ($truthy(($ret_or_7 = den['$equal?'](1)))) {
        return $$($nesting, 'Integer')['$==='](num)['$!']()
      } else {
        return $ret_or_7
      }; return nil; })())) {
        return $$($nesting, 'Opal')['$coerce_to!'](num, $$($nesting, 'Rational'), "to_r")
      } else if ($truthy((function() {if ($truthy(($ret_or_8 = $$($nesting, 'Numeric')['$==='](num)))) {
        return $$($nesting, 'Numeric')['$==='](den)
      } else {
        return $ret_or_8
      }; return nil; })())) {
        return $rb_divide(num, den)
      } else {
        return self.$reduce(num, den)
      };
    }, $Rational_convert$2.$$arity = 2);
    
    Opal.def(self, '$initialize', $Rational_initialize$3 = function $$initialize(num, den) {
      var self = this;

      
      self.num = num;
      return (self.den = den);
    }, $Rational_initialize$3.$$arity = 2);
    
    Opal.def(self, '$numerator', $Rational_numerator$4 = function $$numerator() {
      var self = this;

      return self.num
    }, $Rational_numerator$4.$$arity = 0);
    
    Opal.def(self, '$denominator', $Rational_denominator$5 = function $$denominator() {
      var self = this;

      return self.den
    }, $Rational_denominator$5.$$arity = 0);
    
    Opal.def(self, '$coerce', $Rational_coerce$6 = function $$coerce(other) {
      var self = this, $case = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {return [other, self]}
      else if ($$($nesting, 'Integer')['$===']($case)) {return [other.$to_r(), self]}
      else if ($$($nesting, 'Float')['$===']($case)) {return [other, self.$to_f()]}
      else { return nil }})()
    }, $Rational_coerce$6.$$arity = 1);
    
    Opal.def(self, '$==', $Rational_$eq_eq$7 = function(other) {
      var self = this, $case = nil, $ret_or_9 = nil, $ret_or_10 = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {if ($truthy(($ret_or_9 = self.num['$=='](other.$numerator())))) {
        return self.den['$=='](other.$denominator())
      } else {
        return $ret_or_9
      }}
      else if ($$($nesting, 'Integer')['$===']($case)) {if ($truthy(($ret_or_10 = self.num['$=='](other)))) {
        return self.den['$=='](1)
      } else {
        return $ret_or_10
      }}
      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$=='](other)}
      else {return other['$=='](self)}})()
    }, $Rational_$eq_eq$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Rational_$lt_eq_gt$8 = function(other) {
      var self = this, $case = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {return $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()))['$<=>'](0)}
      else if ($$($nesting, 'Integer')['$===']($case)) {return $rb_minus(self.num, $rb_times(self.den, other))['$<=>'](0)}
      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$<=>'](other)}
      else {return self.$__coerced__("<=>", other)}})()
    }, $Rational_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$+', $Rational_$plus$9 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_plus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_plus(self.num, $rb_times(other, self.den)), self.den)}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_plus(self.$to_f(), other)}
      else {return self.$__coerced__("+", other)}})()
    }, $Rational_$plus$9.$$arity = 1);
    
    Opal.def(self, '$-', $Rational_$minus$10 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_minus(self.num, $rb_times(other, self.den)), self.den)}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_minus(self.$to_f(), other)}
      else {return self.$__coerced__("-", other)}})()
    }, $Rational_$minus$10.$$arity = 1);
    
    Opal.def(self, '$*', $Rational_$$11 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_times(self.num, other.$numerator());
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_times(self.num, other), self.den)}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_times(self.$to_f(), other)}
      else {return self.$__coerced__("*", other)}})()
    }, $Rational_$$11.$$arity = 1);
    
    Opal.def(self, '$/', $Rational_$slash$12 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_times(self.num, other.$denominator());
      den = $rb_times(self.den, other.$numerator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {if (other['$=='](0)) {
        return $rb_divide(self.$to_f(), 0.0)
      } else {
        return self.$Rational(self.num, $rb_times(self.den, other))
      }}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_divide(self.$to_f(), other)}
      else {return self.$__coerced__("/", other)}})()
    }, $Rational_$slash$12.$$arity = 1);
    
    Opal.def(self, '$**', $Rational_$$$13 = function(other) {
      var self = this, $case = nil, $ret_or_11 = nil, $ret_or_12 = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Integer')['$===']($case)) {if ($truthy((function() {if ($truthy(($ret_or_11 = self['$=='](0)))) {
        return $rb_lt(other, 0)
      } else {
        return $ret_or_11
      }; return nil; })())) {
        return $$$($$($nesting, 'Float'), 'INFINITY')
      } else if ($truthy($rb_gt(other, 0))) {
        return self.$Rational(self.num['$**'](other), self.den['$**'](other))
      } else if ($truthy($rb_lt(other, 0))) {
        return self.$Rational(self.den['$**'](other['$-@']()), self.num['$**'](other['$-@']()))
      } else {
        return self.$Rational(1, 1)
      }}
      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$**'](other)}
      else if ($$($nesting, 'Rational')['$===']($case)) {if (other['$=='](0)) {
        return self.$Rational(1, 1)
      } else if (other.$denominator()['$=='](1)) {
        if ($truthy($rb_lt(other, 0))) {
          return self.$Rational(self.den['$**'](other.$numerator().$abs()), self.num['$**'](other.$numerator().$abs()))
        } else {
          return self.$Rational(self.num['$**'](other.$numerator()), self.den['$**'](other.$numerator()))
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_12 = self['$=='](0)))) {
        return $rb_lt(other, 0)
      } else {
        return $ret_or_12
      }; return nil; })())) {
        return self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      } else {
        return self.$to_f()['$**'](other)
      }}
      else {return self.$__coerced__("**", other)}})()
    }, $Rational_$$$13.$$arity = 1);
    
    Opal.def(self, '$abs', $Rational_abs$14 = function $$abs() {
      var self = this;

      return self.$Rational(self.num.$abs(), self.den.$abs())
    }, $Rational_abs$14.$$arity = 0);
    
    Opal.def(self, '$ceil', $Rational_ceil$15 = function $$ceil(precision) {
      var self = this;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$ceil()
      } else {
        return self.$with_precision("ceil", precision)
      };
    }, $Rational_ceil$15.$$arity = -1);
    Opal.alias(self, "divide", "/");
    
    Opal.def(self, '$floor', $Rational_floor$16 = function $$floor(precision) {
      var self = this;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$floor()
      } else {
        return self.$with_precision("floor", precision)
      };
    }, $Rational_floor$16.$$arity = -1);
    
    Opal.def(self, '$hash', $Rational_hash$17 = function $$hash() {
      var self = this;

      return "" + "Rational:" + (self.num) + ":" + (self.den)
    }, $Rational_hash$17.$$arity = 0);
    
    Opal.def(self, '$inspect', $Rational_inspect$18 = function $$inspect() {
      var self = this;

      return "" + "(" + (self) + ")"
    }, $Rational_inspect$18.$$arity = 0);
    Opal.alias(self, "quo", "/");
    
    Opal.def(self, '$rationalize', $Rational_rationalize$19 = function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }

      if (eps == null) {
        return self;
      }

      var e = eps.$abs(),
          a = $rb_minus(self, e),
          b = $rb_plus(self, e);

      var p0 = 0,
          p1 = 1,
          q0 = 1,
          q1 = 0,
          p2, q2;

      var c, k, t;

      while (true) {
        c = (a).$ceil();

        if ($rb_le(c, b)) {
          break;
        }

        k  = c - 1;
        p2 = k * p1 + p0;
        q2 = k * q1 + q0;
        t  = $rb_divide(1, $rb_minus(b, k));
        b  = $rb_divide(1, $rb_minus(a, k));
        a  = t;

        p0 = p1;
        q0 = q1;
        p1 = p2;
        q1 = q2;
      }

      return self.$Rational(c * p1 + p0, c * q1 + q0);
    ;
    }, $Rational_rationalize$19.$$arity = -1);
    
    Opal.def(self, '$round', $Rational_round$20 = function $$round(precision) {
      var self = this, num = nil, den = nil, approx = nil;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
      } else {
        return self.$with_precision("round", precision)
      };
      if (self.num['$=='](0)) {
        return 0};
      if (self.den['$=='](1)) {
        return self.num};
      num = $rb_plus($rb_times(self.num.$abs(), 2), self.den);
      den = $rb_times(self.den, 2);
      approx = $rb_divide(num, den).$truncate();
      if ($truthy($rb_lt(self.num, 0))) {
        return approx['$-@']()
      } else {
        return approx
      };
    }, $Rational_round$20.$$arity = -1);
    
    Opal.def(self, '$to_f', $Rational_to_f$21 = function $$to_f() {
      var self = this;

      return $rb_divide(self.num, self.den)
    }, $Rational_to_f$21.$$arity = 0);
    
    Opal.def(self, '$to_i', $Rational_to_i$22 = function $$to_i() {
      var self = this;

      return self.$truncate()
    }, $Rational_to_i$22.$$arity = 0);
    
    Opal.def(self, '$to_r', $Rational_to_r$23 = function $$to_r() {
      var self = this;

      return self
    }, $Rational_to_r$23.$$arity = 0);
    
    Opal.def(self, '$to_s', $Rational_to_s$24 = function $$to_s() {
      var self = this;

      return "" + (self.num) + "/" + (self.den)
    }, $Rational_to_s$24.$$arity = 0);
    
    Opal.def(self, '$truncate', $Rational_truncate$25 = function $$truncate(precision) {
      var self = this;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
        if ($truthy($rb_lt(self.num, 0))) {
          return self.$ceil()
        } else {
          return self.$floor()
        }
      } else {
        return self.$with_precision("truncate", precision)
      };
    }, $Rational_truncate$25.$$arity = -1);
    return (Opal.def(self, '$with_precision', $Rational_with_precision$26 = function $$with_precision(method, precision) {
      var self = this, p = nil, s = nil;

      
      if ($truthy($$($nesting, 'Integer')['$==='](precision))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an Integer")
      };
      p = (10)['$**'](precision);
      s = $rb_times(self, p);
      if ($truthy($rb_lt(precision, 1))) {
        return $rb_divide(s.$send(method), p).$to_i()
      } else {
        return self.$Rational(s.$send(method), p)
      };
    }, $Rational_with_precision$26.$$arity = 2), nil) && 'with_precision';
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_Rational$27;

    
    Opal.def(self, '$Rational', $Kernel_Rational$27 = function $$Rational(numerator, denominator) {
      var self = this;

      
      
      if (denominator == null) {
        denominator = 1;
      };
      return $$($nesting, 'Rational').$convert(numerator, denominator);
    }, $Kernel_Rational$27.$$arity = -2)
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_to_r$28;

    return (Opal.def(self, '$to_r', $String_to_r$28 = function $$to_r() {
      var self = this;

      
      var str = self.trimLeft(),
          re = /^[+-]?[\d_]+(\.[\d_]+)?/,
          match = str.match(re),
          numerator, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      if (isFloat()) {
        numerator = parseFloat(cutFloat());

        if (str[0] === '/') {
          // rational real part
          str = str.slice(1);

          if (isFloat()) {
            denominator = parseFloat(cutFloat());
            return self.$Rational(numerator, denominator);
          } else {
            return self.$Rational(numerator, 1);
          }
        } else {
          return self.$Rational(numerator, 1);
        }
      } else {
        return self.$Rational(0, 1);
      }
    
    }, $String_to_r$28.$$arity = 0), nil) && 'to_r'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/time"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range;

  Opal.add_stubs(['$require', '$include', '$===', '$raise', '$coerce_to!', '$respond_to?', '$to_str', '$to_i', '$new', '$<=>', '$to_f', '$nil?', '$>', '$<', '$strftime', '$year', '$month', '$day', '$+', '$round', '$/', '$-', '$copy_instance_variables', '$initialize_dup', '$is_a?', '$zero?', '$wday', '$utc?', '$mon', '$yday', '$hour', '$min', '$sec', '$rjust', '$ljust', '$zone', '$to_s', '$[]', '$cweek_cyear', '$isdst', '$<=', '$!=', '$==', '$ceil']);
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $Time_at$1, $Time_new$2, $Time_local$3, $Time_gm$4, $Time_now$5, $Time_$plus$6, $Time_$minus$7, $Time_$lt_eq_gt$8, $Time_$eq_eq$9, $Time_asctime$10, $Time_day$11, $Time_yday$12, $Time_isdst$13, $Time_dup$14, $Time_eql$ques$15, $Time_friday$ques$16, $Time_hash$17, $Time_hour$18, $Time_inspect$19, $Time_min$20, $Time_mon$21, $Time_monday$ques$22, $Time_saturday$ques$23, $Time_sec$24, $Time_succ$25, $Time_usec$26, $Time_zone$27, $Time_getgm$28, $Time_gmtime$29, $Time_gmt$ques$30, $Time_gmt_offset$31, $Time_strftime$32, $Time_sunday$ques$33, $Time_thursday$ques$34, $Time_to_a$35, $Time_to_f$36, $Time_to_i$37, $Time_tuesday$ques$38, $Time_wday$39, $Time_wednesday$ques$40, $Time_year$41, $Time_cweek_cyear$42;

    
    self.$include($$($nesting, 'Comparable'));
    
    var days_of_week = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
        short_days   = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        short_months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        long_months  = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  ;
    Opal.defs(self, '$at', $Time_at$1 = function $$at(seconds, frac) {
      var self = this;

      
      ;
      
      var result;

      if ($$($nesting, 'Time')['$==='](seconds)) {
        if (frac !== undefined) {
          self.$raise($$($nesting, 'TypeError'), "can't convert Time into an exact number")
        }
        result = new Date(seconds.getTime());
        result.is_utc = seconds.is_utc;
        return result;
      }

      if (!seconds.$$is_number) {
        seconds = $$($nesting, 'Opal')['$coerce_to!'](seconds, $$($nesting, 'Integer'), "to_int");
      }

      if (frac === undefined) {
        return new Date(seconds * 1000);
      }

      if (!frac.$$is_number) {
        frac = $$($nesting, 'Opal')['$coerce_to!'](frac, $$($nesting, 'Integer'), "to_int");
      }

      return new Date(seconds * 1000 + (frac / 1000));
    ;
    }, $Time_at$1.$$arity = -2);
    
    function time_params(year, month, day, hour, min, sec) {
      if (year.$$is_string) {
        year = parseInt(year, 10);
      } else {
        year = $$($nesting, 'Opal')['$coerce_to!'](year, $$($nesting, 'Integer'), "to_int");
      }

      if (month === nil) {
        month = 1;
      } else if (!month.$$is_number) {
        if ((month)['$respond_to?']("to_str")) {
          month = (month).$to_str();
          switch (month.toLowerCase()) {
          case 'jan': month =  1; break;
          case 'feb': month =  2; break;
          case 'mar': month =  3; break;
          case 'apr': month =  4; break;
          case 'may': month =  5; break;
          case 'jun': month =  6; break;
          case 'jul': month =  7; break;
          case 'aug': month =  8; break;
          case 'sep': month =  9; break;
          case 'oct': month = 10; break;
          case 'nov': month = 11; break;
          case 'dec': month = 12; break;
          default: month = (month).$to_i();
          }
        } else {
          month = $$($nesting, 'Opal')['$coerce_to!'](month, $$($nesting, 'Integer'), "to_int");
        }
      }

      if (month < 1 || month > 12) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "month out of range: " + (month))
      }
      month = month - 1;

      if (day === nil) {
        day = 1;
      } else if (day.$$is_string) {
        day = parseInt(day, 10);
      } else {
        day = $$($nesting, 'Opal')['$coerce_to!'](day, $$($nesting, 'Integer'), "to_int");
      }

      if (day < 1 || day > 31) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "day out of range: " + (day))
      }

      if (hour === nil) {
        hour = 0;
      } else if (hour.$$is_string) {
        hour = parseInt(hour, 10);
      } else {
        hour = $$($nesting, 'Opal')['$coerce_to!'](hour, $$($nesting, 'Integer'), "to_int");
      }

      if (hour < 0 || hour > 24) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "hour out of range: " + (hour))
      }

      if (min === nil) {
        min = 0;
      } else if (min.$$is_string) {
        min = parseInt(min, 10);
      } else {
        min = $$($nesting, 'Opal')['$coerce_to!'](min, $$($nesting, 'Integer'), "to_int");
      }

      if (min < 0 || min > 59) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "min out of range: " + (min))
      }

      if (sec === nil) {
        sec = 0;
      } else if (!sec.$$is_number) {
        if (sec.$$is_string) {
          sec = parseInt(sec, 10);
        } else {
          sec = $$($nesting, 'Opal')['$coerce_to!'](sec, $$($nesting, 'Integer'), "to_int");
        }
      }

      if (sec < 0 || sec > 60) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "sec out of range: " + (sec))
      }

      return [year, month, day, hour, min, sec];
    }
  ;
    Opal.defs(self, '$new', $Time_new$2 = function(year, month, day, hour, min, sec, utc_offset) {
      var self = this;

      
      ;
      
      if (month == null) {
        month = nil;
      };
      
      if (day == null) {
        day = nil;
      };
      
      if (hour == null) {
        hour = nil;
      };
      
      if (min == null) {
        min = nil;
      };
      
      if (sec == null) {
        sec = nil;
      };
      
      if (utc_offset == null) {
        utc_offset = nil;
      };
      
      var args, result;

      if (year === undefined) {
        return new Date();
      }

      if (utc_offset !== nil) {
        self.$raise($$($nesting, 'ArgumentError'), "Opal does not support explicitly specifying UTC offset for Time")
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, $Time_new$2.$$arity = -1);
    Opal.defs(self, '$local', $Time_local$3 = function $$local(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      var self = this;

      
      
      if (month == null) {
        month = nil;
      };
      
      if (day == null) {
        day = nil;
      };
      
      if (hour == null) {
        hour = nil;
      };
      
      if (min == null) {
        min = nil;
      };
      
      if (sec == null) {
        sec = nil;
      };
      
      if (millisecond == null) {
        millisecond = nil;
      };
      
      if (_dummy1 == null) {
        _dummy1 = nil;
      };
      
      if (_dummy2 == null) {
        _dummy2 = nil;
      };
      
      if (_dummy3 == null) {
        _dummy3 = nil;
      };
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, $Time_local$3.$$arity = -2);
    Opal.defs(self, '$gm', $Time_gm$4 = function $$gm(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      var self = this;

      
      
      if (month == null) {
        month = nil;
      };
      
      if (day == null) {
        day = nil;
      };
      
      if (hour == null) {
        hour = nil;
      };
      
      if (min == null) {
        min = nil;
      };
      
      if (sec == null) {
        sec = nil;
      };
      
      if (millisecond == null) {
        millisecond = nil;
      };
      
      if (_dummy1 == null) {
        _dummy1 = nil;
      };
      
      if (_dummy2 == null) {
        _dummy2 = nil;
      };
      
      if (_dummy3 == null) {
        _dummy3 = nil;
      };
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        result.setUTCFullYear(year);
      }
      result.is_utc = true;
      return result;
    ;
    }, $Time_gm$4.$$arity = -2);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      
      Opal.alias(self, "mktime", "local");
      return Opal.alias(self, "utc", "gm");
    })(Opal.get_singleton_class(self), $nesting);
    Opal.defs(self, '$now', $Time_now$5 = function $$now() {
      var self = this;

      return self.$new()
    }, $Time_now$5.$$arity = 0);
    
    Opal.def(self, '$+', $Time_$plus$6 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Time')['$==='](other))) {
        self.$raise($$($nesting, 'TypeError'), "time + time?")};
      
      if (!other.$$is_number) {
        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Integer'), "to_int");
      }
      var result = new Date(self.getTime() + (other * 1000));
      result.is_utc = self.is_utc;
      return result;
    ;
    }, $Time_$plus$6.$$arity = 1);
    
    Opal.def(self, '$-', $Time_$minus$7 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Time')['$==='](other))) {
        return (self.getTime() - other.getTime()) / 1000};
      
      if (!other.$$is_number) {
        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Integer'), "to_int");
      }
      var result = new Date(self.getTime() - (other * 1000));
      result.is_utc = self.is_utc;
      return result;
    ;
    }, $Time_$minus$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Time_$lt_eq_gt$8 = function(other) {
      var self = this, r = nil;

      if ($truthy($$($nesting, 'Time')['$==='](other))) {
        return self.$to_f()['$<=>'](other.$to_f())
      } else {
        
        r = other['$<=>'](self);
        if ($truthy(r['$nil?']())) {
          return nil
        } else if ($truthy($rb_gt(r, 0))) {
          return -1
        } else if ($truthy($rb_lt(r, 0))) {
          return 1
        } else {
          return 0
        };
      }
    }, $Time_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$==', $Time_$eq_eq$9 = function(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = $$($nesting, 'Time')['$==='](other)))) {
        return self.$to_f() === other.$to_f()
      } else {
        return $ret_or_1
      }
    }, $Time_$eq_eq$9.$$arity = 1);
    
    Opal.def(self, '$asctime', $Time_asctime$10 = function $$asctime() {
      var self = this;

      return self.$strftime("%a %b %e %H:%M:%S %Y")
    }, $Time_asctime$10.$$arity = 0);
    Opal.alias(self, "ctime", "asctime");
    
    Opal.def(self, '$day', $Time_day$11 = function $$day() {
      var self = this;

      return self.is_utc ? self.getUTCDate() : self.getDate();
    }, $Time_day$11.$$arity = 0);
    
    Opal.def(self, '$yday', $Time_yday$12 = function $$yday() {
      var self = this, start_of_year = nil, start_of_day = nil, one_day = nil;

      
      start_of_year = $$($nesting, 'Time').$new(self.$year()).$to_i();
      start_of_day = $$($nesting, 'Time').$new(self.$year(), self.$month(), self.$day()).$to_i();
      one_day = 86400;
      return $rb_plus($rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(), 1);
    }, $Time_yday$12.$$arity = 0);
    
    Opal.def(self, '$isdst', $Time_isdst$13 = function $$isdst() {
      var self = this;

      
      var jan = new Date(self.getFullYear(), 0, 1),
          jul = new Date(self.getFullYear(), 6, 1);
      return self.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    
    }, $Time_isdst$13.$$arity = 0);
    Opal.alias(self, "dst?", "isdst");
    
    Opal.def(self, '$dup', $Time_dup$14 = function $$dup() {
      var self = this, copy = nil;

      
      copy = new Date(self.getTime());
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, $Time_dup$14.$$arity = 0);
    
    Opal.def(self, '$eql?', $Time_eql$ques$15 = function(other) {
      var self = this, $ret_or_2 = nil;

      if ($truthy(($ret_or_2 = other['$is_a?']($$($nesting, 'Time'))))) {
        return self['$<=>'](other)['$zero?']()
      } else {
        return $ret_or_2
      }
    }, $Time_eql$ques$15.$$arity = 1);
    
    Opal.def(self, '$friday?', $Time_friday$ques$16 = function() {
      var self = this;

      return self.$wday() == 5
    }, $Time_friday$ques$16.$$arity = 0);
    
    Opal.def(self, '$hash', $Time_hash$17 = function $$hash() {
      var self = this;

      return 'Time:' + self.getTime();
    }, $Time_hash$17.$$arity = 0);
    
    Opal.def(self, '$hour', $Time_hour$18 = function $$hour() {
      var self = this;

      return self.is_utc ? self.getUTCHours() : self.getHours();
    }, $Time_hour$18.$$arity = 0);
    
    Opal.def(self, '$inspect', $Time_inspect$19 = function $$inspect() {
      var self = this;

      if ($truthy(self['$utc?']())) {
        return self.$strftime("%Y-%m-%d %H:%M:%S UTC")
      } else {
        return self.$strftime("%Y-%m-%d %H:%M:%S %z")
      }
    }, $Time_inspect$19.$$arity = 0);
    Opal.alias(self, "mday", "day");
    
    Opal.def(self, '$min', $Time_min$20 = function $$min() {
      var self = this;

      return self.is_utc ? self.getUTCMinutes() : self.getMinutes();
    }, $Time_min$20.$$arity = 0);
    
    Opal.def(self, '$mon', $Time_mon$21 = function $$mon() {
      var self = this;

      return (self.is_utc ? self.getUTCMonth() : self.getMonth()) + 1;
    }, $Time_mon$21.$$arity = 0);
    
    Opal.def(self, '$monday?', $Time_monday$ques$22 = function() {
      var self = this;

      return self.$wday() == 1
    }, $Time_monday$ques$22.$$arity = 0);
    Opal.alias(self, "month", "mon");
    
    Opal.def(self, '$saturday?', $Time_saturday$ques$23 = function() {
      var self = this;

      return self.$wday() == 6
    }, $Time_saturday$ques$23.$$arity = 0);
    
    Opal.def(self, '$sec', $Time_sec$24 = function $$sec() {
      var self = this;

      return self.is_utc ? self.getUTCSeconds() : self.getSeconds();
    }, $Time_sec$24.$$arity = 0);
    
    Opal.def(self, '$succ', $Time_succ$25 = function $$succ() {
      var self = this;

      
      var result = new Date(self.getTime() + 1000);
      result.is_utc = self.is_utc;
      return result;
    
    }, $Time_succ$25.$$arity = 0);
    
    Opal.def(self, '$usec', $Time_usec$26 = function $$usec() {
      var self = this;

      return self.getMilliseconds() * 1000;
    }, $Time_usec$26.$$arity = 0);
    
    Opal.def(self, '$zone', $Time_zone$27 = function $$zone() {
      var self = this;

      
      var string = self.toString(),
          result;

      if (string.indexOf('(') == -1) {
        result = string.match(/[A-Z]{3,4}/)[0];
      }
      else {
        result = string.match(/\((.+)\)(?:\s|$)/)[1]
      }

      if (result == "GMT" && /(GMT\W*\d{4})/.test(string)) {
        return RegExp.$1;
      }
      else {
        return result;
      }
    
    }, $Time_zone$27.$$arity = 0);
    
    Opal.def(self, '$getgm', $Time_getgm$28 = function $$getgm() {
      var self = this;

      
      var result = new Date(self.getTime());
      result.is_utc = true;
      return result;
    
    }, $Time_getgm$28.$$arity = 0);
    Opal.alias(self, "getutc", "getgm");
    
    Opal.def(self, '$gmtime', $Time_gmtime$29 = function $$gmtime() {
      var self = this;

      
      self.is_utc = true;
      return self;
    
    }, $Time_gmtime$29.$$arity = 0);
    Opal.alias(self, "utc", "gmtime");
    
    Opal.def(self, '$gmt?', $Time_gmt$ques$30 = function() {
      var self = this;

      return self.is_utc === true;
    }, $Time_gmt$ques$30.$$arity = 0);
    
    Opal.def(self, '$gmt_offset', $Time_gmt_offset$31 = function $$gmt_offset() {
      var self = this;

      return self.is_utc ? 0 : -self.getTimezoneOffset() * 60;
    }, $Time_gmt_offset$31.$$arity = 0);
    
    Opal.def(self, '$strftime', $Time_strftime$32 = function $$strftime(format) {
      var self = this;

      
      return format.replace(/%([\-_#^0]*:{0,2})(\d+)?([EO]*)(.)/g, function(full, flags, width, _, conv) {
        var result = "",
            zero   = flags.indexOf('0') !== -1,
            pad    = flags.indexOf('-') === -1,
            blank  = flags.indexOf('_') !== -1,
            upcase = flags.indexOf('^') !== -1,
            invert = flags.indexOf('#') !== -1,
            colons = (flags.match(':') || []).length;

        width = parseInt(width, 10);

        if (zero && blank) {
          if (flags.indexOf('0') < flags.indexOf('_')) {
            zero = false;
          }
          else {
            blank = false;
          }
        }

        switch (conv) {
          case 'Y':
            result += self.$year();
            break;

          case 'C':
            zero    = !blank;
            result += Math.round(self.$year() / 100);
            break;

          case 'y':
            zero    = !blank;
            result += (self.$year() % 100);
            break;

          case 'm':
            zero    = !blank;
            result += self.$mon();
            break;

          case 'B':
            result += long_months[self.$mon() - 1];
            break;

          case 'b':
          case 'h':
            blank   = !zero;
            result += short_months[self.$mon() - 1];
            break;

          case 'd':
            zero    = !blank
            result += self.$day();
            break;

          case 'e':
            blank   = !zero
            result += self.$day();
            break;

          case 'j':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.$yday();
            break;

          case 'H':
            zero    = !blank;
            result += self.$hour();
            break;

          case 'k':
            blank   = !zero;
            result += self.$hour();
            break;

          case 'I':
            zero    = !blank;
            result += (self.$hour() % 12 || 12);
            break;

          case 'l':
            blank   = !zero;
            result += (self.$hour() % 12 || 12);
            break;

          case 'P':
            result += (self.$hour() >= 12 ? "pm" : "am");
            break;

          case 'p':
            result += (self.$hour() >= 12 ? "PM" : "AM");
            break;

          case 'M':
            zero    = !blank;
            result += self.$min();
            break;

          case 'S':
            zero    = !blank;
            result += self.$sec()
            break;

          case 'L':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.getMilliseconds();
            break;

          case 'N':
            width   = isNaN(width) ? 9 : width;
            result += (self.getMilliseconds().toString()).$rjust(3, "0");
            result  = (result).$ljust(width, "0");
            break;

          case 'z':
            var offset  = self.getTimezoneOffset(),
                hours   = Math.floor(Math.abs(offset) / 60),
                minutes = Math.abs(offset) % 60;

            result += offset < 0 ? "+" : "-";
            result += hours < 10 ? "0" : "";
            result += hours;

            if (colons > 0) {
              result += ":";
            }

            result += minutes < 10 ? "0" : "";
            result += minutes;

            if (colons > 1) {
              result += ":00";
            }

            break;

          case 'Z':
            result += self.$zone();
            break;

          case 'A':
            result += days_of_week[self.$wday()];
            break;

          case 'a':
            result += short_days[self.$wday()];
            break;

          case 'u':
            result += (self.$wday() + 1);
            break;

          case 'w':
            result += self.$wday();
            break;

          case 'V':
            result += self.$cweek_cyear()['$[]'](0).$to_s().$rjust(2, "0");
            break;

          case 'G':
            result += self.$cweek_cyear()['$[]'](1);
            break;

          case 'g':
            result += self.$cweek_cyear()['$[]'](1)['$[]']($range(-2, -1, false));
            break;

          case 's':
            result += self.$to_i();
            break;

          case 'n':
            result += "\n";
            break;

          case 't':
            result += "\t";
            break;

          case '%':
            result += "%";
            break;

          case 'c':
            result += self.$strftime("%a %b %e %T %Y");
            break;

          case 'D':
          case 'x':
            result += self.$strftime("%m/%d/%y");
            break;

          case 'F':
            result += self.$strftime("%Y-%m-%d");
            break;

          case 'v':
            result += self.$strftime("%e-%^b-%4Y");
            break;

          case 'r':
            result += self.$strftime("%I:%M:%S %p");
            break;

          case 'R':
            result += self.$strftime("%H:%M");
            break;

          case 'T':
          case 'X':
            result += self.$strftime("%H:%M:%S");
            break;

          default:
            return full;
        }

        if (upcase) {
          result = result.toUpperCase();
        }

        if (invert) {
          result = result.replace(/[A-Z]/, function(c) { c.toLowerCase() }).
                          replace(/[a-z]/, function(c) { c.toUpperCase() });
        }

        if (pad && (zero || blank)) {
          result = (result).$rjust(isNaN(width) ? 2 : width, blank ? " " : "0");
        }

        return result;
      });
    
    }, $Time_strftime$32.$$arity = 1);
    
    Opal.def(self, '$sunday?', $Time_sunday$ques$33 = function() {
      var self = this;

      return self.$wday() == 0
    }, $Time_sunday$ques$33.$$arity = 0);
    
    Opal.def(self, '$thursday?', $Time_thursday$ques$34 = function() {
      var self = this;

      return self.$wday() == 4
    }, $Time_thursday$ques$34.$$arity = 0);
    
    Opal.def(self, '$to_a', $Time_to_a$35 = function $$to_a() {
      var self = this;

      return [self.$sec(), self.$min(), self.$hour(), self.$day(), self.$month(), self.$year(), self.$wday(), self.$yday(), self.$isdst(), self.$zone()]
    }, $Time_to_a$35.$$arity = 0);
    
    Opal.def(self, '$to_f', $Time_to_f$36 = function $$to_f() {
      var self = this;

      return self.getTime() / 1000;
    }, $Time_to_f$36.$$arity = 0);
    
    Opal.def(self, '$to_i', $Time_to_i$37 = function $$to_i() {
      var self = this;

      return parseInt(self.getTime() / 1000, 10);
    }, $Time_to_i$37.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$tuesday?', $Time_tuesday$ques$38 = function() {
      var self = this;

      return self.$wday() == 2
    }, $Time_tuesday$ques$38.$$arity = 0);
    Opal.alias(self, "tv_sec", "to_i");
    Opal.alias(self, "tv_usec", "usec");
    Opal.alias(self, "utc?", "gmt?");
    Opal.alias(self, "gmtoff", "gmt_offset");
    Opal.alias(self, "utc_offset", "gmt_offset");
    
    Opal.def(self, '$wday', $Time_wday$39 = function $$wday() {
      var self = this;

      return self.is_utc ? self.getUTCDay() : self.getDay();
    }, $Time_wday$39.$$arity = 0);
    
    Opal.def(self, '$wednesday?', $Time_wednesday$ques$40 = function() {
      var self = this;

      return self.$wday() == 3
    }, $Time_wednesday$ques$40.$$arity = 0);
    
    Opal.def(self, '$year', $Time_year$41 = function $$year() {
      var self = this;

      return self.is_utc ? self.getUTCFullYear() : self.getFullYear();
    }, $Time_year$41.$$arity = 0);
    return (Opal.def(self, '$cweek_cyear', $Time_cweek_cyear$42 = function $$cweek_cyear() {
      var self = this, jan01 = nil, jan01_wday = nil, first_monday = nil, year = nil, $ret_or_3 = nil, offset = nil, week = nil, dec31 = nil, dec31_wday = nil, $ret_or_4 = nil;

      
      jan01 = $$($nesting, 'Time').$new(self.$year(), 1, 1);
      jan01_wday = jan01.$wday();
      first_monday = 0;
      year = self.$year();
      if ($truthy((function() {if ($truthy(($ret_or_3 = $rb_le(jan01_wday, 4)))) {
        return jan01_wday['$!='](0)
      } else {
        return $ret_or_3
      }; return nil; })())) {
        offset = $rb_minus(jan01_wday, 1)
      } else {
        
        offset = $rb_minus($rb_minus(jan01_wday, 7), 1);
        if (offset['$=='](-8)) {
          offset = -1};
      };
      week = $rb_divide($rb_plus(self.$yday(), offset), 7.0).$ceil();
      if ($truthy($rb_le(week, 0))) {
        return $$($nesting, 'Time').$new($rb_minus(self.$year(), 1), 12, 31).$cweek_cyear()
      } else if (week['$=='](53)) {
        
        dec31 = $$($nesting, 'Time').$new(self.$year(), 12, 31);
        dec31_wday = dec31.$wday();
        if ($truthy((function() {if ($truthy(($ret_or_4 = $rb_le(dec31_wday, 3)))) {
          return dec31_wday['$!='](0)
        } else {
          return $ret_or_4
        }; return nil; })())) {
          
          week = 1;
          year = $rb_plus(year, 1);};};
      return [week, year];
    }, $Time_cweek_cyear$42.$$arity = 0), nil) && 'cweek_cyear';
  })($nesting[0], Date, $nesting);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/struct"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$include', '$const_name!', '$unshift', '$map', '$coerce_to!', '$new', '$each', '$define_struct_attribute', '$allocate', '$initialize', '$alias_method', '$module_eval', '$to_proc', '$const_set', '$==', '$raise', '$<<', '$members', '$define_method', '$instance_eval', '$class', '$last', '$>', '$length', '$-', '$keys', '$any?', '$join', '$[]', '$[]=', '$each_with_index', '$hash', '$===', '$<', '$-@', '$size', '$>=', '$include?', '$to_sym', '$instance_of?', '$__id__', '$eql?', '$enum_for', '$name', '$+', '$each_pair', '$inspect', '$to_h', '$args', '$each_with_object', '$flatten', '$to_a', '$respond_to?', '$dig']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $Struct_new$1, $Struct_define_struct_attribute$6, $Struct_members$9, $Struct_inherited$10, $Struct_initialize$12, $Struct_initialize_copy$15, $Struct_members$16, $Struct_hash$17, $Struct_$$$18, $Struct_$$$eq$19, $Struct_$eq_eq$20, $Struct_eql$ques$21, $Struct_each$22, $Struct_each_pair$25, $Struct_length$28, $Struct_to_a$29, $Struct_inspect$31, $Struct_to_h$33, $Struct_values_at$35, $Struct_dig$37;

    
    self.$include($$($nesting, 'Enumerable'));
    Opal.defs(self, '$new', $Struct_new$1 = function(const_name, $a, $b) {
      var $iter = $Struct_new$1.$$p, block = $iter || nil, $post_args, $kwargs, args, keyword_init, $$2, $$3, self = this, klass = nil;

      if ($iter) $Struct_new$1.$$p = null;
      
      
      if ($iter) $Struct_new$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      args = $post_args;;
      
      keyword_init = $kwargs.$$smap["keyword_init"];
      if (keyword_init == null) {
        keyword_init = false
      };
      if ($truthy(const_name)) {
        
        try {
          const_name = $$($nesting, 'Opal')['$const_name!'](const_name)
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'TypeError'), $$($nesting, 'NameError')])) {
            try {
              
              args.$unshift(const_name);
              const_name = nil;
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };};
      $send(args, 'map', [], ($$2 = function(arg){var self = $$2.$$s == null ? this : $$2.$$s;

      
        
        if (arg == null) {
          arg = nil;
        };
        return $$($nesting, 'Opal')['$coerce_to!'](arg, $$($nesting, 'String'), "to_str");}, $$2.$$s = self, $$2.$$arity = 1, $$2));
      klass = $send($$($nesting, 'Class'), 'new', [self], ($$3 = function(){var self = $$3.$$s == null ? this : $$3.$$s, $$4;

      
        $send(args, 'each', [], ($$4 = function(arg){var self = $$4.$$s == null ? this : $$4.$$s;

        
          
          if (arg == null) {
            arg = nil;
          };
          return self.$define_struct_attribute(arg);}, $$4.$$s = self, $$4.$$arity = 1, $$4));
        return (function(self, $parent_nesting) {
          var $nesting = [self].concat($parent_nesting), $new$5;

          
          
          Opal.def(self, '$new', $new$5 = function($a) {
            var $post_args, args, self = this, instance = nil;

            
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            instance = self.$allocate();
            instance.$$data = {};
            $send(instance, 'initialize', Opal.to_a(args));
            return instance;
          }, $new$5.$$arity = -1);
          return self.$alias_method("[]", "new");
        })(Opal.get_singleton_class(self), $nesting);}, $$3.$$s = self, $$3.$$arity = 0, $$3));
      if ($truthy(block)) {
        $send(klass, 'module_eval', [], block.$to_proc())};
      klass.$$keyword_init = keyword_init;
      if ($truthy(const_name)) {
        $$($nesting, 'Struct').$const_set(const_name, klass)};
      return klass;
    }, $Struct_new$1.$$arity = -2);
    Opal.defs(self, '$define_struct_attribute', $Struct_define_struct_attribute$6 = function $$define_struct_attribute(name) {
      var $$7, $$8, self = this;

      
      if (self['$==']($$($nesting, 'Struct'))) {
        self.$raise($$($nesting, 'ArgumentError'), "you cannot define attributes to the Struct class")};
      self.$members()['$<<'](name);
      $send(self, 'define_method', [name], ($$7 = function(){var self = $$7.$$s == null ? this : $$7.$$s;

      return self.$$data[name];}, $$7.$$s = self, $$7.$$arity = 0, $$7));
      return $send(self, 'define_method', ["" + (name) + "="], ($$8 = function(value){var self = $$8.$$s == null ? this : $$8.$$s;

      
        
        if (value == null) {
          value = nil;
        };
        return self.$$data[name] = value;;}, $$8.$$s = self, $$8.$$arity = 1, $$8));
    }, $Struct_define_struct_attribute$6.$$arity = 1);
    Opal.defs(self, '$members', $Struct_members$9 = function $$members() {
      var self = this, $ret_or_1 = nil;
      if (self.members == null) self.members = nil;

      
      if (self['$==']($$($nesting, 'Struct'))) {
        self.$raise($$($nesting, 'ArgumentError'), "the Struct class has no members")};
      return (self.members = (function() {if ($truthy(($ret_or_1 = self.members))) {
        return $ret_or_1
      } else {
        return []
      }; return nil; })());
    }, $Struct_members$9.$$arity = 0);
    Opal.defs(self, '$inherited', $Struct_inherited$10 = function $$inherited(klass) {
      var $$11, self = this, members = nil;
      if (self.members == null) self.members = nil;

      
      members = self.members;
      return $send(klass, 'instance_eval', [], ($$11 = function(){var self = $$11.$$s == null ? this : $$11.$$s;

      return (self.members = members)}, $$11.$$s = self, $$11.$$arity = 0, $$11));
    }, $Struct_inherited$10.$$arity = 1);
    
    Opal.def(self, '$initialize', $Struct_initialize$12 = function $$initialize($a) {
      var $post_args, args, $$13, $$14, self = this, kwargs = nil, $ret_or_2 = nil, $ret_or_3 = nil, extra = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(self.$class().$$keyword_init)) {
        
        kwargs = (function() {if ($truthy(($ret_or_2 = args.$last()))) {
          return $ret_or_2
        } else {
          return $hash2([], {})
        }; return nil; })();
        if ($truthy((function() {if ($truthy(($ret_or_3 = $rb_gt(args.$length(), 1)))) {
          return $ret_or_3
        } else {
          return (args.length === 1 && !kwargs.$$is_hash);
        }; return nil; })())) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (given " + (args.$length()) + ", expected 0)")};
        extra = $rb_minus(kwargs.$keys(), self.$class().$members());
        if ($truthy(extra['$any?']())) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "unknown keywords: " + (extra.$join(", ")))};
        return $send(self.$class().$members(), 'each', [], ($$13 = function(name){var self = $$13.$$s == null ? this : $$13.$$s, $writer = nil;

        
          
          if (name == null) {
            name = nil;
          };
          $writer = [name, kwargs['$[]'](name)];
          $send(self, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$13.$$s = self, $$13.$$arity = 1, $$13));
      } else {
        
        if ($truthy($rb_gt(args.$length(), self.$class().$members().$length()))) {
          self.$raise($$($nesting, 'ArgumentError'), "struct size differs")};
        return $send(self.$class().$members(), 'each_with_index', [], ($$14 = function(name, index){var self = $$14.$$s == null ? this : $$14.$$s, $writer = nil;

        
          
          if (name == null) {
            name = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          $writer = [name, args['$[]'](index)];
          $send(self, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$14.$$s = self, $$14.$$arity = 2, $$14));
      };
    }, $Struct_initialize$12.$$arity = -1);
    
    Opal.def(self, '$initialize_copy', $Struct_initialize_copy$15 = function $$initialize_copy(from) {
      var self = this;

      
      self.$$data = {}
      var keys = Object.keys(from.$$data), i, max, name;
      for (i = 0, max = keys.length; i < max; i++) {
        name = keys[i];
        self.$$data[name] = from.$$data[name];
      }
    
    }, $Struct_initialize_copy$15.$$arity = 1);
    
    Opal.def(self, '$members', $Struct_members$16 = function $$members() {
      var self = this;

      return self.$class().$members()
    }, $Struct_members$16.$$arity = 0);
    
    Opal.def(self, '$hash', $Struct_hash$17 = function $$hash() {
      var self = this;

      return $$($nesting, 'Hash').$new(self.$$data).$hash()
    }, $Struct_hash$17.$$arity = 0);
    
    Opal.def(self, '$[]', $Struct_$$$18 = function(name) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](name))) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")};
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")};
        name = self.$class().$members()['$[]'](name);
      } else if ($truthy($$($nesting, 'String')['$==='](name))) {
        
        if(!self.$$data.hasOwnProperty(name)) {
          self.$raise($$($nesting, 'NameError').$new("" + "no member '" + (name) + "' in struct", name))
        }
      
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      return self.$$data[name];;
    }, $Struct_$$$18.$$arity = 1);
    
    Opal.def(self, '$[]=', $Struct_$$$eq$19 = function(name, value) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](name))) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")};
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")};
        name = self.$class().$members()['$[]'](name);
      } else if ($truthy($$($nesting, 'String')['$==='](name))) {
        if ($truthy(self.$class().$members()['$include?'](name.$to_sym()))) {
        } else {
          self.$raise($$($nesting, 'NameError').$new("" + "no member '" + (name) + "' in struct", name))
        }
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      return self.$$data[name] = value;;
    }, $Struct_$$$eq$19.$$arity = 2);
    
    Opal.def(self, '$==', $Struct_$eq_eq$20 = function(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
      } else {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$($nesting, 'Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, $Struct_$eq_eq$20.$$arity = 1);
    
    Opal.def(self, '$eql?', $Struct_eql$ques$21 = function(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
      } else {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$($nesting, 'Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, $Struct_eql$ques$21.$$arity = 1);
    
    Opal.def(self, '$each', $Struct_each$22 = function $$each() {
      var $$23, $$24, $iter = $Struct_each$22.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Struct_each$22.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$23 = function(){var self = $$23.$$s == null ? this : $$23.$$s;

        return self.$size()}, $$23.$$s = self, $$23.$$arity = 0, $$23))
      };
      $send(self.$class().$members(), 'each', [], ($$24 = function(name){var self = $$24.$$s == null ? this : $$24.$$s;

      
        
        if (name == null) {
          name = nil;
        };
        return Opal.yield1($yield, self['$[]'](name));;}, $$24.$$s = self, $$24.$$arity = 1, $$24));
      return self;
    }, $Struct_each$22.$$arity = 0);
    
    Opal.def(self, '$each_pair', $Struct_each_pair$25 = function $$each_pair() {
      var $$26, $$27, $iter = $Struct_each_pair$25.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Struct_each_pair$25.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_pair"], ($$26 = function(){var self = $$26.$$s == null ? this : $$26.$$s;

        return self.$size()}, $$26.$$s = self, $$26.$$arity = 0, $$26))
      };
      $send(self.$class().$members(), 'each', [], ($$27 = function(name){var self = $$27.$$s == null ? this : $$27.$$s;

      
        
        if (name == null) {
          name = nil;
        };
        return Opal.yield1($yield, [name, self['$[]'](name)]);;}, $$27.$$s = self, $$27.$$arity = 1, $$27));
      return self;
    }, $Struct_each_pair$25.$$arity = 0);
    
    Opal.def(self, '$length', $Struct_length$28 = function $$length() {
      var self = this;

      return self.$class().$members().$length()
    }, $Struct_length$28.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$to_a', $Struct_to_a$29 = function $$to_a() {
      var $$30, self = this;

      return $send(self.$class().$members(), 'map', [], ($$30 = function(name){var self = $$30.$$s == null ? this : $$30.$$s;

      
        
        if (name == null) {
          name = nil;
        };
        return self['$[]'](name);}, $$30.$$s = self, $$30.$$arity = 1, $$30))
    }, $Struct_to_a$29.$$arity = 0);
    Opal.alias(self, "values", "to_a");
    
    Opal.def(self, '$inspect', $Struct_inspect$31 = function $$inspect() {
      var $$32, self = this, result = nil, $ret_or_4 = nil;

      
      result = "#<struct ";
      if ($truthy((function() {if ($truthy(($ret_or_4 = $$($nesting, 'Struct')['$==='](self)))) {
        return self.$class().$name()
      } else {
        return $ret_or_4
      }; return nil; })())) {
        result = $rb_plus(result, "" + (self.$class()) + " ")};
      result = $rb_plus(result, $send(self.$each_pair(), 'map', [], ($$32 = function(name, value){var self = $$32.$$s == null ? this : $$32.$$s;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (value == null) {
          value = nil;
        };
        return "" + (name) + "=" + (value.$inspect());}, $$32.$$s = self, $$32.$$arity = 2, $$32)).$join(", "));
      result = $rb_plus(result, ">");
      return result;
    }, $Struct_inspect$31.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$to_h', $Struct_to_h$33 = function $$to_h() {
      var $iter = $Struct_to_h$33.$$p, block = $iter || nil, $$34, self = this;

      if ($iter) $Struct_to_h$33.$$p = null;
      
      
      if ($iter) $Struct_to_h$33.$$p = null;;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', Opal.to_a(self.$args()))};
      return $send(self.$class().$members(), 'each_with_object', [$hash2([], {})], ($$34 = function(name, h){var self = $$34.$$s == null ? this : $$34.$$s, $writer = nil;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (h == null) {
          h = nil;
        };
        $writer = [name, self['$[]'](name)];
        $send(h, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, $$34.$$s = self, $$34.$$arity = 2, $$34));
    }, $Struct_to_h$33.$$arity = 0);
    
    Opal.def(self, '$values_at', $Struct_values_at$35 = function $$values_at($a) {
      var $post_args, args, $$36, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      args = $send(args, 'map', [], ($$36 = function(arg){var self = $$36.$$s == null ? this : $$36.$$s;

      
        
        if (arg == null) {
          arg = nil;
        };
        return arg.$$is_range ? arg.$to_a() : arg;}, $$36.$$s = self, $$36.$$arity = 1, $$36)).$flatten();
      
      var result = [];
      for (var i = 0, len = args.length; i < len; i++) {
        if (!args[i].$$is_number) {
          self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + ((args[i]).$class()) + " into Integer")
        }
        result.push(self['$[]'](args[i]));
      }
      return result;
    ;
    }, $Struct_values_at$35.$$arity = -1);
    return (Opal.def(self, '$dig', $Struct_dig$37 = function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      keys = $post_args;;
      item = (function() {if ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key))) {
        return self.$$data[key] || nil;
      } else {
        return nil
      }; return nil; })();
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(keys));
    }, $Struct_dig$37.$$arity = -2), nil) && 'dig';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/main"] = function(Opal) {
  var $to_s$1, $include$2, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$include']);
  
  Opal.defs(self, '$to_s', $to_s$1 = function $$to_s() {
    var self = this;

    return "main"
  }, $to_s$1.$$arity = 0);
  return (Opal.defs(self, '$include', $include$2 = function $$include(mod) {
    var self = this;

    return $$($nesting, 'Object').$include(mod)
  }, $include$2.$$arity = 1), nil) && 'include';
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/dir"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$[]']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dir');

    var $nesting = [self].concat($parent_nesting);

    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $chdir$1, $pwd$2, $home$3;

      
      
      Opal.def(self, '$chdir', $chdir$1 = function $$chdir(dir) {
        var $iter = $chdir$1.$$p, $yield = $iter || nil, self = this, prev_cwd = nil;

        if ($iter) $chdir$1.$$p = null;
        return (function() { try {
        
        prev_cwd = Opal.current_dir;
        Opal.current_dir = dir;
        return Opal.yieldX($yield, []);;
        } finally {
          Opal.current_dir = prev_cwd
        }; })()
      }, $chdir$1.$$arity = 1);
      
      Opal.def(self, '$pwd', $pwd$2 = function $$pwd() {
        var self = this;

        return Opal.current_dir || '.';
      }, $pwd$2.$$arity = 0);
      Opal.alias(self, "getwd", "pwd");
      return (Opal.def(self, '$home', $home$3 = function $$home() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = $$($nesting, 'ENV')['$[]']("HOME")))) {
          return $ret_or_1
        } else {
          return "."
        }
      }, $home$3.$$arity = 0), nil) && 'home';
    })(Opal.get_singleton_class(self), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/file"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $klass = Opal.klass, $range = Opal.range, $send = Opal.send;

  Opal.add_stubs(['$respond_to?', '$to_path', '$pwd', '$split', '$sub', '$+', '$unshift', '$join', '$home', '$raise', '$start_with?', '$absolute_path', '$coerce_to!', '$basename', '$empty?', '$rindex', '$[]', '$nil?', '$==', '$-', '$length', '$gsub', '$find', '$=~', '$map', '$each_with_index', '$flatten', '$reject', '$to_proc', '$end_with?']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), windows_root_rx = nil;

    
    Opal.const_set($nesting[0], 'Separator', Opal.const_set($nesting[0], 'SEPARATOR', "/"));
    Opal.const_set($nesting[0], 'ALT_SEPARATOR', nil);
    Opal.const_set($nesting[0], 'PATH_SEPARATOR', ":");
    Opal.const_set($nesting[0], 'FNM_SYSCASE', 0);
    windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $absolute_path$1, $expand_path$2, $dirname$3, $basename$4, $extname$5, $exist$ques$6, $directory$ques$7, $join$9, $split$12;

      
      
      Opal.def(self, '$absolute_path', $absolute_path$1 = function $$absolute_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, new_parts = nil, $ret_or_1 = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;

        
        
        if (basedir == null) {
          basedir = nil;
        };
        sep = $$($nesting, 'SEPARATOR');
        sep_chars = $sep_chars();
        new_parts = [];
        path = (function() {if ($truthy(path['$respond_to?']("to_path"))) {
          return path.$to_path()
        } else {
          return path
        }; return nil; })();
        basedir = (function() {if ($truthy(($ret_or_1 = basedir))) {
          return $ret_or_1
        } else {
          return $$($nesting, 'Dir').$pwd()
        }; return nil; })();
        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);
        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);
        if ($truthy(path_abs)) {
          
          parts = path.$split(Opal.regexp(["[", sep_chars, "]"]));
          leading_sep = windows_root_rx.test(path) ? '' : path.$sub(Opal.regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = true;
        } else {
          
          parts = $rb_plus(basedir.$split(Opal.regexp(["[", sep_chars, "]"])), path.$split(Opal.regexp(["[", sep_chars, "]"])));
          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub(Opal.regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = basedir_abs;
        };
        
        var part;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];

          if (
            (part === nil) ||
            (part === ''  && ((new_parts.length === 0) || abs)) ||
            (part === '.' && ((new_parts.length === 0) || abs))
          ) {
            continue;
          }
          if (part === '..') {
            new_parts.pop();
          } else {
            new_parts.push(part);
          }
        }

        if (!abs && parts[0] !== '.') {
          new_parts.$unshift(".")
        }
      ;
        new_path = new_parts.$join(sep);
        if ($truthy(abs)) {
          new_path = $rb_plus(leading_sep, new_path)};
        return new_path;
      }, $absolute_path$1.$$arity = -2);
      
      Opal.def(self, '$expand_path', $expand_path$2 = function $$expand_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, home = nil, leading_sep = nil, home_path_regexp = nil;

        
        
        if (basedir == null) {
          basedir = nil;
        };
        sep = $$($nesting, 'SEPARATOR');
        sep_chars = $sep_chars();
        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {
          
          home = $$($nesting, 'Dir').$home();
          if ($truthy(home)) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "couldn't find HOME environment -- expanding `~'")
          };
          leading_sep = windows_root_rx.test(home) ? '' : home.$sub(Opal.regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          if ($truthy(home['$start_with?'](leading_sep))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "non-absolute home")
          };
          home = $rb_plus(home, sep);
          home_path_regexp = Opal.regexp(["^\\~(?:", sep, "|$)"]);
          path = path.$sub(home_path_regexp, home);
          if ($truthy(basedir)) {
            basedir = basedir.$sub(home_path_regexp, home)};};
        return self.$absolute_path(path, basedir);
      }, $expand_path$2.$$arity = -2);
      Opal.alias(self, "realpath", "expand_path");
      
      // Coerce a given path to a path string using #to_path and #to_str
      function $coerce_to_path(path) {
        if ($truthy((path)['$respond_to?']("to_path"))) {
          path = path.$to_path();
        }

        path = $$($nesting, 'Opal')['$coerce_to!'](path, $$($nesting, 'String'), "to_str");

        return path;
      }

      // Return a RegExp compatible char class
      function $sep_chars() {
        if ($$($nesting, 'ALT_SEPARATOR') === nil) {
          return Opal.escape_regexp($$($nesting, 'SEPARATOR'));
        } else {
          return Opal.escape_regexp($rb_plus($$($nesting, 'SEPARATOR'), $$($nesting, 'ALT_SEPARATOR')));
        }
      }
    ;
      
      Opal.def(self, '$dirname', $dirname$3 = function $$dirname(path) {
        var self = this, sep_chars = nil;

        
        sep_chars = $sep_chars();
        path = $coerce_to_path(path);
        
        var absolute = path.match(new RegExp("" + "^[" + (sep_chars) + "]"));

        path = path.replace(new RegExp("" + "[" + (sep_chars) + "]+$"), ''); // remove trailing separators
        path = path.replace(new RegExp("" + "[^" + (sep_chars) + "]+$"), ''); // remove trailing basename
        path = path.replace(new RegExp("" + "[" + (sep_chars) + "]+$"), ''); // remove final trailing separators

        if (path === '') {
          return absolute ? '/' : '.';
        }

        return path;
      ;
      }, $dirname$3.$$arity = 1);
      
      Opal.def(self, '$basename', $basename$4 = function $$basename(name, suffix) {
        var self = this, sep_chars = nil;

        
        
        if (suffix == null) {
          suffix = nil;
        };
        sep_chars = $sep_chars();
        name = $coerce_to_path(name);
        
        if (name.length == 0) {
          return name;
        }

        if (suffix !== nil) {
          suffix = $$($nesting, 'Opal')['$coerce_to!'](suffix, $$($nesting, 'String'), "to_str")
        } else {
          suffix = null;
        }

        name = name.replace(new RegExp("" + "(.)[" + (sep_chars) + "]*$"), '$1');
        name = name.replace(new RegExp("" + "^(?:.*[" + (sep_chars) + "])?([^" + (sep_chars) + "]+)$"), '$1');

        if (suffix === ".*") {
          name = name.replace(/\.[^\.]+$/, '');
        } else if(suffix !== null) {
          suffix = Opal.escape_regexp(suffix);
          name = name.replace(new RegExp("" + (suffix) + "$"), '');
        }

        return name;
      ;
      }, $basename$4.$$arity = -2);
      
      Opal.def(self, '$extname', $extname$5 = function $$extname(path) {
        var self = this, filename = nil, last_dot_idx = nil, $ret_or_2 = nil;

        
        path = $coerce_to_path(path);
        filename = self.$basename(path);
        if ($truthy(filename['$empty?']())) {
          return ""};
        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(".");
        if ($truthy((function() {if ($truthy(($ret_or_2 = last_dot_idx['$nil?']()))) {
          return $ret_or_2
        } else {
          return $rb_plus(last_dot_idx, 1)['$==']($rb_minus(filename.$length(), 1))
        }; return nil; })())) {
          return ""
        } else {
          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))
        };
      }, $extname$5.$$arity = 1);
      
      Opal.def(self, '$exist?', $exist$ques$6 = function(path) {
        var self = this;

        return Opal.modules[path] != null
      }, $exist$ques$6.$$arity = 1);
      Opal.alias(self, "exists?", "exist?");
      
      Opal.def(self, '$directory?', $directory$ques$7 = function(path) {
        var $$8, self = this, files = nil, file = nil;

        
        files = [];
        
        for (var key in Opal.modules) {
          files.push(key)
        }
      ;
        path = path.$gsub(Opal.regexp(["(^.", $$($nesting, 'SEPARATOR'), "+|", $$($nesting, 'SEPARATOR'), "+$)"]));
        file = $send(files, 'find', [], ($$8 = function(f){var self = $$8.$$s == null ? this : $$8.$$s;

        
          
          if (f == null) {
            f = nil;
          };
          return f['$=~'](Opal.regexp(["^", path]));}, $$8.$$s = self, $$8.$$arity = 1, $$8));
        return file;
      }, $directory$ques$7.$$arity = 1);
      
      Opal.def(self, '$join', $join$9 = function $$join($a) {
        var $post_args, paths, $$10, $$11, self = this, result = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        paths = $post_args;;
        if ($truthy(paths['$empty?']())) {
          return ""};
        result = "";
        paths = $send(paths.$flatten().$each_with_index(), 'map', [], ($$10 = function(item, index){var self = $$10.$$s == null ? this : $$10.$$s, $ret_or_3 = nil, $ret_or_4 = nil;

        
          
          if (item == null) {
            item = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          if ($truthy((function() {if ($truthy(($ret_or_3 = index['$=='](0)))) {
            return item['$empty?']()
          } else {
            return $ret_or_3
          }; return nil; })())) {
            return $$($nesting, 'SEPARATOR')
          } else if ($truthy((function() {if ($truthy(($ret_or_4 = paths.$length()['$==']($rb_plus(index, 1))))) {
            return item['$empty?']()
          } else {
            return $ret_or_4
          }; return nil; })())) {
            return $$($nesting, 'SEPARATOR')
          } else {
            return item
          };}, $$10.$$s = self, $$10.$$arity = 2, $$10));
        paths = $send(paths, 'reject', [], "empty?".$to_proc());
        $send(paths, 'each_with_index', [], ($$11 = function(item, index){var self = $$11.$$s == null ? this : $$11.$$s, next_item = nil, $ret_or_5 = nil, $ret_or_6 = nil;

        
          
          if (item == null) {
            item = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          next_item = paths['$[]']($rb_plus(index, 1));
          if ($truthy(next_item['$nil?']())) {
            return (result = "" + (result) + (item))
          } else {
            
            if ($truthy((function() {if ($truthy(($ret_or_5 = item['$end_with?']($$($nesting, 'SEPARATOR'))))) {
              return next_item['$start_with?']($$($nesting, 'SEPARATOR'))
            } else {
              return $ret_or_5
            }; return nil; })())) {
              item = item.$sub(Opal.regexp([$$($nesting, 'SEPARATOR'), "+$"]), "")};
            return (result = (function() {if ($truthy((function() {if ($truthy(($ret_or_6 = item['$end_with?']($$($nesting, 'SEPARATOR'))))) {
              return $ret_or_6
            } else {
              return next_item['$start_with?']($$($nesting, 'SEPARATOR'))
            }; return nil; })())) {
              return "" + (result) + (item)
            } else {
              return "" + (result) + (item) + ($$($nesting, 'SEPARATOR'))
            }; return nil; })());
          };}, $$11.$$s = self, $$11.$$arity = 2, $$11));
        return result;
      }, $join$9.$$arity = -1);
      return (Opal.def(self, '$split', $split$12 = function $$split(path) {
        var self = this;

        return path.$split($$($nesting, 'SEPARATOR'))
      }, $split$12.$$arity = 1), nil) && 'split';
    })(Opal.get_singleton_class(self), $nesting);
  })($nesting[0], $$($nesting, 'IO'), $nesting)
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/process"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$const_set', '$size', '$<<', '$__register_clock__', '$to_f', '$now', '$new', '$[]', '$raise']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Process');

    var $nesting = [self].concat($parent_nesting), $Process___register_clock__$1, $Process_pid$2, $Process_times$3, $Process_clock_gettime$4, monotonic = nil;

    
    self.__clocks__ = [];
    Opal.defs(self, '$__register_clock__', $Process___register_clock__$1 = function $$__register_clock__(name, func) {
      var self = this;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      self.$const_set(name, self.__clocks__.$size());
      return self.__clocks__['$<<'](func);
    }, $Process___register_clock__$1.$$arity = 2);
    self.$__register_clock__("CLOCK_REALTIME", function() { return Date.now() });
    monotonic = false;
    
    if (Opal.global.performance) {
      monotonic = function() {
        return performance.now()
      };
    }
    else if (Opal.global.process && process.hrtime) {
      // let now be the base to get smaller numbers
      var hrtime_base = process.hrtime();

      monotonic = function() {
        var hrtime = process.hrtime(hrtime_base);
        var us = (hrtime[1] / 1000) | 0; // cut below microsecs;
        return ((hrtime[0] * 1000) + (us / 1000));
      };
    }
  ;
    if ($truthy(monotonic)) {
      self.$__register_clock__("CLOCK_MONOTONIC", monotonic)};
    Opal.defs(self, '$pid', $Process_pid$2 = function $$pid() {
      var self = this;

      return 0
    }, $Process_pid$2.$$arity = 0);
    Opal.defs(self, '$times', $Process_times$3 = function $$times() {
      var self = this, t = nil;

      
      t = $$($nesting, 'Time').$now().$to_f();
      return $$$($$($nesting, 'Benchmark'), 'Tms').$new(t, t, t, t, t);
    }, $Process_times$3.$$arity = 0);
    return (Opal.defs(self, '$clock_gettime', $Process_clock_gettime$4 = function $$clock_gettime(clock_id, unit) {
      var self = this, $ret_or_1 = nil, clock = nil;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      
      if (unit == null) {
        unit = "float_second";
      };
      if ($truthy(($ret_or_1 = (clock = self.__clocks__['$[]'](clock_id))))) {
        $ret_or_1
      } else {
        self.$raise($$$($$($nesting, 'Errno'), 'EINVAL'), "" + "clock_gettime(" + (clock_id) + ") " + (self.__clocks__['$[]'](clock_id)))
      };
      
      var ms = clock();
      switch (unit) {
        case 'float_second':      return  (ms / 1000);         // number of seconds as a float (default)
        case 'float_millisecond': return  (ms / 1);            // number of milliseconds as a float
        case 'float_microsecond': return  (ms * 1000);         // number of microseconds as a float
        case 'second':            return ((ms / 1000)    | 0); // number of seconds as an integer
        case 'millisecond':       return ((ms / 1)       | 0); // number of milliseconds as an integer
        case 'microsecond':       return ((ms * 1000)    | 0); // number of microseconds as an integer
        case 'nanosecond':        return ((ms * 1000000) | 0); // number of nanoseconds as an integer
        default: self.$raise($$($nesting, 'ArgumentError'), "" + "unexpected unit: " + (unit))
      }
    ;
    }, $Process_clock_gettime$4.$$arity = -2), nil) && 'clock_gettime';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Signal');

    var $nesting = [self].concat($parent_nesting), $Signal_trap$5;

    return (Opal.defs(self, '$trap', $Signal_trap$5 = function $$trap($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Signal_trap$5.$$arity = -1), nil) && 'trap'
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'GC');

    var $nesting = [self].concat($parent_nesting), $GC_start$6;

    return (Opal.defs(self, '$start', $GC_start$6 = function $$start() {
      var self = this;

      return nil
    }, $GC_start$6.$$arity = 0), nil) && 'start'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/random"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$new_seed', '$coerce_to!', '$reseed', '$rand', '$seed', '$<', '$raise', '$encode', '$join', '$new', '$chr', '$===', '$==', '$state', '$const_defined?', '$const_set']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting), $Random_initialize$1, $Random_reseed$2, $Random_new_seed$3, $Random_rand$4, $Random_srand$5, $Random_urandom$6, $Random_$eq_eq$8, $Random_bytes$9, $Random_rand$11, $Random_generator$eq$12;

    
    self.$attr_reader("seed", "state");
    
    Opal.def(self, '$initialize', $Random_initialize$1 = function $$initialize(seed) {
      var self = this;

      
      
      if (seed == null) {
        seed = $$($nesting, 'Random').$new_seed();
      };
      seed = $$($nesting, 'Opal')['$coerce_to!'](seed, $$($nesting, 'Integer'), "to_int");
      self.state = seed;
      return self.$reseed(seed);
    }, $Random_initialize$1.$$arity = -1);
    
    Opal.def(self, '$reseed', $Random_reseed$2 = function $$reseed(seed) {
      var self = this;

      
      self.seed = seed;
      return self.$rng = Opal.$$rand.reseed(seed);;
    }, $Random_reseed$2.$$arity = 1);
    Opal.defs(self, '$new_seed', $Random_new_seed$3 = function $$new_seed() {
      var self = this;

      return Opal.$$rand.new_seed();
    }, $Random_new_seed$3.$$arity = 0);
    Opal.defs(self, '$rand', $Random_rand$4 = function $$rand(limit) {
      var self = this;

      
      ;
      return $$($nesting, 'DEFAULT').$rand(limit);
    }, $Random_rand$4.$$arity = -1);
    Opal.defs(self, '$srand', $Random_srand$5 = function $$srand(n) {
      var self = this, previous_seed = nil;

      
      
      if (n == null) {
        n = $$($nesting, 'Random').$new_seed();
      };
      n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      previous_seed = $$($nesting, 'DEFAULT').$seed();
      $$($nesting, 'DEFAULT').$reseed(n);
      return previous_seed;
    }, $Random_srand$5.$$arity = -1);
    Opal.defs(self, '$urandom', $Random_urandom$6 = function $$urandom(size) {
      var $$7, self = this;

      
      size = $$($nesting, 'Opal')['$coerce_to!'](size, $$($nesting, 'Integer'), "to_int");
      if ($truthy($rb_lt(size, 0))) {
        self.$raise($$($nesting, 'ArgumentError'), "negative string size (or size too big)")};
      return $send($$($nesting, 'Array'), 'new', [size], ($$7 = function(){var self = $$7.$$s == null ? this : $$7.$$s;

      return self.$rand(255).$chr()}, $$7.$$s = self, $$7.$$arity = 0, $$7)).$join().$encode("ASCII-8BIT");
    }, $Random_urandom$6.$$arity = 1);
    
    Opal.def(self, '$==', $Random_$eq_eq$8 = function(other) {
      var self = this, $ret_or_1 = nil;

      
      if ($truthy($$($nesting, 'Random')['$==='](other))) {
      } else {
        return false
      };
      if ($truthy(($ret_or_1 = self.$seed()['$=='](other.$seed())))) {
        return self.$state()['$=='](other.$state())
      } else {
        return $ret_or_1
      };
    }, $Random_$eq_eq$8.$$arity = 1);
    
    Opal.def(self, '$bytes', $Random_bytes$9 = function $$bytes(length) {
      var $$10, self = this;

      
      length = $$($nesting, 'Opal')['$coerce_to!'](length, $$($nesting, 'Integer'), "to_int");
      return $send($$($nesting, 'Array'), 'new', [length], ($$10 = function(){var self = $$10.$$s == null ? this : $$10.$$s;

      return self.$rand(255).$chr()}, $$10.$$s = self, $$10.$$arity = 0, $$10)).$join().$encode("ASCII-8BIT");
    }, $Random_bytes$9.$$arity = 1);
    
    Opal.def(self, '$rand', $Random_rand$11 = function $$rand(limit) {
      var self = this;

      
      ;
      
      function randomFloat() {
        self.state++;
        return Opal.$$rand.rand(self.$rng);
      }

      function randomInt() {
        return Math.floor(randomFloat() * limit);
      }

      function randomRange() {
        var min = limit.begin,
            max = limit.end;

        if (min === nil || max === nil) {
          return nil;
        }

        var length = max - min;

        if (length < 0) {
          return nil;
        }

        if (length === 0) {
          return min;
        }

        if (max % 1 === 0 && min % 1 === 0 && !limit.excl) {
          length++;
        }

        return self.$rand(length) + min;
      }

      if (limit == null) {
        return randomFloat();
      } else if (limit.$$is_range) {
        return randomRange();
      } else if (limit.$$is_number) {
        if (limit <= 0) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid argument - " + (limit))
        }

        if (limit % 1 === 0) {
          // integer
          return randomInt();
        } else {
          return randomFloat() * limit;
        }
      } else {
        limit = $$($nesting, 'Opal')['$coerce_to!'](limit, $$($nesting, 'Integer'), "to_int");

        if (limit <= 0) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid argument - " + (limit))
        }

        return randomInt();
      }
    ;
    }, $Random_rand$11.$$arity = -1);
    return (Opal.defs(self, '$generator=', $Random_generator$eq$12 = function(generator) {
      var self = this;

      
      Opal.$$rand = generator;
      if ($truthy(self['$const_defined?']("DEFAULT"))) {
        return $$($nesting, 'DEFAULT').$reseed()
      } else {
        return self.$const_set("DEFAULT", self.$new(self.$new_seed()))
      };
    }, $Random_generator$eq$12.$$arity = 1), nil) && 'generator=';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/random/mersenne_twister"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, mersenne_twister = nil;

  Opal.add_stubs(['$generator=', '$-']);
  
  mersenne_twister = (function() {
  /* Period parameters */
  var N = 624;
  var M = 397;
  var MATRIX_A = 0x9908b0df;      /* constant vector a */
  var UMASK = 0x80000000;         /* most significant w-r bits */
  var LMASK = 0x7fffffff;         /* least significant r bits */
  var MIXBITS = function(u,v) { return ( ((u) & UMASK) | ((v) & LMASK) ); };
  var TWIST = function(u,v) { return (MIXBITS((u),(v)) >>> 1) ^ ((v & 0x1) ? MATRIX_A : 0x0); };

  function init(s) {
    var mt = {left: 0, next: N, state: new Array(N)};
    init_genrand(mt, s);
    return mt;
  }

  /* initializes mt[N] with a seed */
  function init_genrand(mt, s) {
    var j, i;
    mt.state[0] = s >>> 0;
    for (j=1; j<N; j++) {
      mt.state[j] = (1812433253 * ((mt.state[j-1] ^ (mt.state[j-1] >> 30) >>> 0)) + j);
      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
      /* In the previous versions, MSBs of the seed affect   */
      /* only MSBs of the array state[].                     */
      /* 2002/01/09 modified by Makoto Matsumoto             */
      mt.state[j] &= 0xffffffff;  /* for >32 bit machines */
    }
    mt.left = 1;
    mt.next = N;
  }

  /* generate N words at one time */
  function next_state(mt) {
    var p = 0, _p = mt.state;
    var j;

    mt.left = N;
    mt.next = 0;

    for (j=N-M+1; --j; p++)
      _p[p] = _p[p+(M)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    for (j=M; --j; p++)
      _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[0]);
  }

  /* generates a random number on [0,0xffffffff]-interval */
  function genrand_int32(mt) {
    /* mt must be initialized */
    var y;

    if (--mt.left <= 0) next_state(mt);
    y = mt.state[mt.next++];

    /* Tempering */
    y ^= (y >>> 11);
    y ^= (y << 7) & 0x9d2c5680;
    y ^= (y << 15) & 0xefc60000;
    y ^= (y >>> 18);

    return y >>> 0;
  }

  function int_pair_to_real_exclusive(a, b) {
    a >>>= 5;
    b >>>= 6;
    return(a*67108864.0+b)*(1.0/9007199254740992.0);
  }

  // generates a random number on [0,1) with 53-bit resolution
  function genrand_real(mt) {
    /* mt must be initialized */
    var a = genrand_int32(mt), b = genrand_int32(mt);
    return int_pair_to_real_exclusive(a, b);
  }

  return { genrand_real: genrand_real, init: init };
})();
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting), $writer = nil;

    
    var MAX_INT = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
    Opal.const_set($nesting[0], 'MERSENNE_TWISTER_GENERATOR', {
    new_seed: function() { return Math.round(Math.random() * MAX_INT); },
    reseed: function(seed) { return mersenne_twister.init(seed); },
    rand: function(mt) { return mersenne_twister.genrand_real(mt); }
  });
    
    $writer = [$$($nesting, 'MERSENNE_TWISTER_GENERATOR')];
    $send(self, 'generator=', Opal.to_a($writer));
    return $writer[$rb_minus($writer["length"], 1)];;
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.1.1 */
Opal.modules["corelib/unsupported"] = function(Opal) {
  var $public$35, $private$36, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $module = Opal.module;

  Opal.add_stubs(['$raise', '$warn', '$%']);
  
  
  var warnings = {};

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
    case 'error':
      $$($nesting, 'Kernel').$raise($$($nesting, 'NotImplementedError'), message)
      break;
    case 'warning':
      warn(message)
      break;
    default: // ignore
      // noop
    }
  }

  function warn(string) {
    if (warnings[string]) {
      return;
    }

    warnings[string] = true;
    self.$warn(string);
  }
;
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_$lt$lt$1, $String_capitalize$excl$2, $String_chomp$excl$3, $String_chop$excl$4, $String_downcase$excl$5, $String_gsub$excl$6, $String_lstrip$excl$7, $String_next$excl$8, $String_reverse$excl$9, $String_slice$excl$10, $String_squeeze$excl$11, $String_strip$excl$12, $String_sub$excl$13, $String_succ$excl$14, $String_swapcase$excl$15, $String_tr$excl$16, $String_tr_s$excl$17, $String_upcase$excl$18, $String_prepend$19, $String_$$$eq$20, $String_clear$21, $String_encode$excl$22, $String_unicode_normalize$excl$23;

    
    var ERROR = "String#%s not supported. Mutable String methods are not supported in Opal.";
    
    Opal.def(self, '$<<', $String_$lt$lt$1 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("<<"));
    }, $String_$lt$lt$1.$$arity = -1);
    
    Opal.def(self, '$capitalize!', $String_capitalize$excl$2 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("capitalize!"));
    }, $String_capitalize$excl$2.$$arity = -1);
    
    Opal.def(self, '$chomp!', $String_chomp$excl$3 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("chomp!"));
    }, $String_chomp$excl$3.$$arity = -1);
    
    Opal.def(self, '$chop!', $String_chop$excl$4 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("chop!"));
    }, $String_chop$excl$4.$$arity = -1);
    
    Opal.def(self, '$downcase!', $String_downcase$excl$5 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("downcase!"));
    }, $String_downcase$excl$5.$$arity = -1);
    
    Opal.def(self, '$gsub!', $String_gsub$excl$6 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("gsub!"));
    }, $String_gsub$excl$6.$$arity = -1);
    
    Opal.def(self, '$lstrip!', $String_lstrip$excl$7 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("lstrip!"));
    }, $String_lstrip$excl$7.$$arity = -1);
    
    Opal.def(self, '$next!', $String_next$excl$8 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("next!"));
    }, $String_next$excl$8.$$arity = -1);
    
    Opal.def(self, '$reverse!', $String_reverse$excl$9 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("reverse!"));
    }, $String_reverse$excl$9.$$arity = -1);
    
    Opal.def(self, '$slice!', $String_slice$excl$10 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("slice!"));
    }, $String_slice$excl$10.$$arity = -1);
    
    Opal.def(self, '$squeeze!', $String_squeeze$excl$11 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("squeeze!"));
    }, $String_squeeze$excl$11.$$arity = -1);
    
    Opal.def(self, '$strip!', $String_strip$excl$12 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("strip!"));
    }, $String_strip$excl$12.$$arity = -1);
    
    Opal.def(self, '$sub!', $String_sub$excl$13 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("sub!"));
    }, $String_sub$excl$13.$$arity = -1);
    
    Opal.def(self, '$succ!', $String_succ$excl$14 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("succ!"));
    }, $String_succ$excl$14.$$arity = -1);
    
    Opal.def(self, '$swapcase!', $String_swapcase$excl$15 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("swapcase!"));
    }, $String_swapcase$excl$15.$$arity = -1);
    
    Opal.def(self, '$tr!', $String_tr$excl$16 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("tr!"));
    }, $String_tr$excl$16.$$arity = -1);
    
    Opal.def(self, '$tr_s!', $String_tr_s$excl$17 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("tr_s!"));
    }, $String_tr_s$excl$17.$$arity = -1);
    
    Opal.def(self, '$upcase!', $String_upcase$excl$18 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("upcase!"));
    }, $String_upcase$excl$18.$$arity = -1);
    
    Opal.def(self, '$prepend', $String_prepend$19 = function $$prepend($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("prepend"));
    }, $String_prepend$19.$$arity = -1);
    
    Opal.def(self, '$[]=', $String_$$$eq$20 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("[]="));
    }, $String_$$$eq$20.$$arity = -1);
    
    Opal.def(self, '$clear', $String_clear$21 = function $$clear($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("clear"));
    }, $String_clear$21.$$arity = -1);
    
    Opal.def(self, '$encode!', $String_encode$excl$22 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("encode!"));
    }, $String_encode$excl$22.$$arity = -1);
    return (Opal.def(self, '$unicode_normalize!', $String_unicode_normalize$excl$23 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("unicode_normalize!"));
    }, $String_unicode_normalize$excl$23.$$arity = -1), nil) && 'unicode_normalize!';
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_freeze$24, $Kernel_frozen$ques$25;

    
    var ERROR = "Object freezing is not supported by Opal";
    
    Opal.def(self, '$freeze', $Kernel_freeze$24 = function $$freeze() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_freeze$24.$$arity = 0);
    
    Opal.def(self, '$frozen?', $Kernel_frozen$ques$25 = function() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return false;
    }, $Kernel_frozen$ques$25.$$arity = 0);
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_taint$26, $Kernel_untaint$27, $Kernel_tainted$ques$28;

    
    var ERROR = "Object tainting is not supported by Opal";
    
    Opal.def(self, '$taint', $Kernel_taint$26 = function $$taint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_taint$26.$$arity = 0);
    
    Opal.def(self, '$untaint', $Kernel_untaint$27 = function $$untaint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_untaint$27.$$arity = 0);
    
    Opal.def(self, '$tainted?', $Kernel_tainted$ques$28 = function() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return false;
    }, $Kernel_tainted$ques$28.$$arity = 0);
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $Module_public$29, $Module_private_class_method$30, $Module_private_method_defined$ques$31, $Module_private_constant$32;

    
    
    Opal.def(self, '$public', $Module_public$29 = function($a) {
      var $post_args, methods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      methods = $post_args;;
      
      if (methods.length === 0) {
        self.$$module_function = false;
      }

      return nil;
    ;
    }, $Module_public$29.$$arity = -1);
    Opal.alias(self, "private", "public");
    Opal.alias(self, "protected", "public");
    Opal.alias(self, "nesting", "public");
    
    Opal.def(self, '$private_class_method', $Module_private_class_method$30 = function $$private_class_method($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self;
    }, $Module_private_class_method$30.$$arity = -1);
    Opal.alias(self, "public_class_method", "private_class_method");
    
    Opal.def(self, '$private_method_defined?', $Module_private_method_defined$ques$31 = function(obj) {
      var self = this;

      return false
    }, $Module_private_method_defined$ques$31.$$arity = 1);
    
    Opal.def(self, '$private_constant', $Module_private_constant$32 = function $$private_constant($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_private_constant$32.$$arity = -1);
    Opal.alias(self, "protected_method_defined?", "private_method_defined?");
    Opal.alias(self, "public_instance_methods", "instance_methods");
    Opal.alias(self, "public_instance_method", "instance_method");
    return Opal.alias(self, "public_method_defined?", "method_defined?");
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_private_methods$33;

    
    
    Opal.def(self, '$private_methods', $Kernel_private_methods$33 = function $$private_methods($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return [];
    }, $Kernel_private_methods$33.$$arity = -1);
    Opal.alias(self, "private_instance_methods", "private_methods");
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_eval$34;

    
    Opal.def(self, '$eval', $Kernel_eval$34 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), "" + "To use Kernel#eval, you must first require 'opal-parser'. " + ("" + "See https://github.com/opal/opal/blob/" + ($$($nesting, 'RUBY_ENGINE_VERSION')) + "/docs/opal_parser.md for details."));
    }, $Kernel_eval$34.$$arity = -1)
  })($nesting[0], $nesting);
  Opal.defs(self, '$public', $public$35 = function($a) {
    var $post_args, self = this;

    
    
    $post_args = Opal.slice.call(arguments, 0, arguments.length);
    ;
    return nil;
  }, $public$35.$$arity = -1);
  return (Opal.defs(self, '$private', $private$36 = function($a) {
    var $post_args, self = this;

    
    
    $post_args = Opal.slice.call(arguments, 0, arguments.length);
    ;
    return nil;
  }, $private$36.$$arity = -1), nil) && 'private';
};

/* Generated by Opal 1.1.1 */
(function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$require']);
  
  self.$require("opal/base");
  self.$require("opal/mini");
  self.$require("corelib/kernel/format");
  self.$require("corelib/string/encoding");
  self.$require("corelib/math");
  self.$require("corelib/complex");
  self.$require("corelib/rational");
  self.$require("corelib/time");
  self.$require("corelib/struct");
  self.$require("corelib/io");
  self.$require("corelib/main");
  self.$require("corelib/dir");
  self.$require("corelib/file");
  self.$require("corelib/process");
  self.$require("corelib/random");
  self.$require("corelib/random/mersenne_twister");
  return self.$require("corelib/unsupported");
})(Opal);

/* Generated by Opal 1.1.1 */
Opal.modules["json"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$new', '$push', '$[]=', '$-', '$[]', '$create_id', '$json_create', '$const_get', '$attr_accessor', '$create_id=', '$===', '$parse', '$generate', '$from_object', '$merge', '$to_json', '$responds_to?', '$to_io', '$write', '$to_s', '$to_a', '$strftime']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'JSON');

    var $nesting = [self].concat($parent_nesting), $JSON_$$$1, $JSON_parse$2, $JSON_parse$excl$3, $JSON_load$4, $JSON_from_object$5, $JSON_generate$6, $JSON_dump$7, $writer = nil;

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'JSONError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'StandardError'), $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ParserError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'JSONError'), $nesting);
    
    var $hasOwn = Opal.hasOwnProperty;

    function $parse(source) {
      try {
        return JSON.parse(source);
      } catch (e) {
        self.$raise($$$($$($nesting, 'JSON'), 'ParserError'), e.message);
      }
    };

    function to_opal(value, options) {
      var klass, arr, hash, i, ii, k;

      switch (typeof value) {
        case 'string':
          return value;

        case 'number':
          return value;

        case 'boolean':
          return !!value;

        case 'null':
          return nil;

        case 'object':
          if (!value) return nil;

          if (value.$$is_array) {
            arr = (options.array_class).$new();

            for (i = 0, ii = value.length; i < ii; i++) {
              (arr).$push(to_opal(value[i], options));
            }

            return arr;
          }
          else {
            hash = (options.object_class).$new();

            for (k in value) {
              if ($hasOwn.call(value, k)) {
                (($writer = [k, to_opal(value[k], options)]), $send((hash), '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
              }
            }

            if (!options.parse && (klass = (hash)['$[]']($$($nesting, 'JSON').$create_id())) != nil) {
              return $$$('::', 'Object').$const_get(klass).$json_create(hash);
            }
            else {
              return hash;
            }
          }
        }
    };
  ;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      return self.$attr_accessor("create_id")
    })(Opal.get_singleton_class(self), $nesting);
    
    $writer = ["json_class"];
    $send(self, 'create_id=', Opal.to_a($writer));
    $writer[$rb_minus($writer["length"], 1)];;
    Opal.defs(self, '$[]', $JSON_$$$1 = function(value, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      if ($truthy($$($nesting, 'String')['$==='](value))) {
        return self.$parse(value, options)
      } else {
        return self.$generate(value, options)
      };
    }, $JSON_$$$1.$$arity = -2);
    Opal.defs(self, '$parse', $JSON_parse$2 = function $$parse(source, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      return self.$from_object($parse(source), options.$merge($hash2(["parse"], {"parse": true})));
    }, $JSON_parse$2.$$arity = -2);
    Opal.defs(self, '$parse!', $JSON_parse$excl$3 = function(source, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      return self.$parse(source, options);
    }, $JSON_parse$excl$3.$$arity = -2);
    Opal.defs(self, '$load', $JSON_load$4 = function $$load(source, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      return self.$from_object($parse(source), options);
    }, $JSON_load$4.$$arity = -2);
    Opal.defs(self, '$from_object', $JSON_from_object$5 = function $$from_object(js_object, options) {
      var self = this, $ret_or_1 = nil, $writer = nil, $ret_or_2 = nil;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      if ($truthy(($ret_or_1 = options['$[]']("object_class")))) {
        $ret_or_1
      } else {
        
        $writer = ["object_class", $$($nesting, 'Hash')];
        $send(options, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };
      if ($truthy(($ret_or_2 = options['$[]']("array_class")))) {
        $ret_or_2
      } else {
        
        $writer = ["array_class", $$($nesting, 'Array')];
        $send(options, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };
      return to_opal(js_object, options.$$smap);;
    }, $JSON_from_object$5.$$arity = -2);
    Opal.defs(self, '$generate', $JSON_generate$6 = function $$generate(obj, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      return obj.$to_json(options);
    }, $JSON_generate$6.$$arity = -2);
    Opal.defs(self, '$dump', $JSON_dump$7 = function $$dump(obj, io, limit) {
      var self = this, string = nil;

      
      
      if (io == null) {
        io = nil;
      };
      
      if (limit == null) {
        limit = nil;
      };
      string = self.$generate(obj);
      if ($truthy(io)) {
        
        if ($truthy(io['$responds_to?']("to_io"))) {
          io = io.$to_io()};
        io.$write(string);
        return io;
      } else {
        return string
      };
    }, $JSON_dump$7.$$arity = -2);
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting), $Object_to_json$8;

    return (Opal.def(self, '$to_json', $Object_to_json$8 = function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, $Object_to_json$8.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Enumerable');

    var $nesting = [self].concat($parent_nesting), $Enumerable_to_json$9;

    
    Opal.def(self, '$to_json', $Enumerable_to_json$9 = function $$to_json() {
      var self = this;

      return self.$to_a().$to_json()
    }, $Enumerable_to_json$9.$$arity = 0)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_to_json$10;

    return (Opal.def(self, '$to_json', $Array_to_json$10 = function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        result.push((self[i]).$to_json());
      }

      return '[' + result.join(', ') + ']';
    
    }, $Array_to_json$10.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting), $Boolean_to_json$11;

    return (Opal.def(self, '$to_json', $Boolean_to_json$11 = function $$to_json() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, $Boolean_to_json$11.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $Hash_to_json$12;

    return (Opal.def(self, '$to_json', $Hash_to_json$12 = function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push((key).$to_s().$to_json() + ':' + (value).$to_json());
      }

      return '{' + result.join(', ') + '}';
    
    }, $Hash_to_json$12.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting), $NilClass_to_json$13;

    return (Opal.def(self, '$to_json', $NilClass_to_json$13 = function $$to_json() {
      var self = this;

      return "null"
    }, $NilClass_to_json$13.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Numeric');

    var $nesting = [self].concat($parent_nesting), $Numeric_to_json$14;

    return (Opal.def(self, '$to_json', $Numeric_to_json$14 = function $$to_json() {
      var self = this;

      return self.toString();
    }, $Numeric_to_json$14.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting);

    return Opal.alias(self, "to_json", "inspect")
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $Time_to_json$15;

    return (Opal.def(self, '$to_json', $Time_to_json$15 = function $$to_json() {
      var self = this;

      return self.$strftime("%FT%T%z").$to_json()
    }, $Time_to_json$15.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Date');

    var $nesting = [self].concat($parent_nesting), $Date_to_json$16, $Date_as_json$17;

    
    
    Opal.def(self, '$to_json', $Date_to_json$16 = function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, $Date_to_json$16.$$arity = 0);
    return (Opal.def(self, '$as_json', $Date_as_json$17 = function $$as_json() {
      var self = this;

      return self.$to_s()
    }, $Date_as_json$17.$$arity = 0), nil) && 'as_json';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.1.1 */
Opal.modules["date"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send2 = Opal.send2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$include', '$<=>', '$attr_reader', '$nonzero?', '$d', '$zero?', '$new', '$class', '$-@', '$+@', '$===', '$coerce', '$==', '$>', '$+', '$allocate', '$join', '$compact', '$map', '$to_proc', '$downcase', '$wrap', '$raise', '$clone', '$jd', '$>>', '$wday', '$year', '$month', '$day', '$-', '$to_s', '$to_i', '$<', '$*', '$reverse', '$step', '$abs', '$each']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Date');

    var $nesting = [self].concat($parent_nesting), $Date_initialize$16, $Date_$minus$17, $Date_$plus$18, $Date_$lt$19, $Date_$lt_eq$20, $Date_$gt$21, $Date_$gt_eq$22, $Date_$lt_eq_gt$23, $Date_$gt$gt$24, $Date_$lt$lt$25, $Date_clone$26, $Date_day$27, $Date_friday$ques$28, $Date_jd$29, $Date_julian$ques$30, $Date_monday$ques$31, $Date_month$32, $Date_next$33, $Date_next_day$34, $Date_next_month$35, $Date_next_year$36, $Date_prev_day$37, $Date_prev_month$38, $Date_prev_year$39, $Date_saturday$ques$40, $Date_strftime$41, $Date_sunday$ques$42, $Date_thursday$ques$43, $Date_to_s$44, $Date_to_time$45, $Date_to_n$46, $Date_tuesday$ques$47, $Date_step$48, $Date_upto$51, $Date_downto$52, $Date_wday$53, $Date_wednesday$ques$54, $Date_year$55, $Date_cwday$56, $Date_cweek$57;

    self.$$prototype.date = nil;
    
    self.$include($$($nesting, 'Comparable'));
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Infinity');

      var $nesting = [self].concat($parent_nesting), $Infinity_initialize$1, $Infinity_zero$ques$2, $Infinity_finite$ques$3, $Infinity_infinite$ques$4, $Infinity_nan$ques$5, $Infinity_abs$6, $Infinity_$minus$$7, $Infinity_$plus$$8, $Infinity_$lt_eq_gt$9, $Infinity_coerce$10, $Infinity_to_f$11;

      self.$$prototype.d = nil;
      
      self.$include($$($nesting, 'Comparable'));
      
      Opal.def(self, '$initialize', $Infinity_initialize$1 = function $$initialize(d) {
        var self = this;

        
        
        if (d == null) {
          d = 1;
        };
        return (self.d = d['$<=>'](0));
      }, $Infinity_initialize$1.$$arity = -1);
      self.$attr_reader("d");
      
      Opal.def(self, '$zero?', $Infinity_zero$ques$2 = function() {
        var self = this;

        return false
      }, $Infinity_zero$ques$2.$$arity = 0);
      
      Opal.def(self, '$finite?', $Infinity_finite$ques$3 = function() {
        var self = this;

        return false
      }, $Infinity_finite$ques$3.$$arity = 0);
      
      Opal.def(self, '$infinite?', $Infinity_infinite$ques$4 = function() {
        var self = this;

        return self.$d()['$nonzero?']()
      }, $Infinity_infinite$ques$4.$$arity = 0);
      
      Opal.def(self, '$nan?', $Infinity_nan$ques$5 = function() {
        var self = this;

        return self.$d()['$zero?']()
      }, $Infinity_nan$ques$5.$$arity = 0);
      
      Opal.def(self, '$abs', $Infinity_abs$6 = function $$abs() {
        var self = this;

        return self.$class().$new()
      }, $Infinity_abs$6.$$arity = 0);
      
      Opal.def(self, '$-@', $Infinity_$minus$$7 = function() {
        var self = this;

        return self.$class().$new(self.$d()['$-@']())
      }, $Infinity_$minus$$7.$$arity = 0);
      
      Opal.def(self, '$+@', $Infinity_$plus$$8 = function() {
        var self = this;

        return self.$class().$new(self.$d()['$+@']())
      }, $Infinity_$plus$$8.$$arity = 0);
      
      Opal.def(self, '$<=>', $Infinity_$lt_eq_gt$9 = function(other) {
        var $a, $b, self = this, $case = nil, l = nil, r = nil;

        return (function() {$case = other;
        if ($$($nesting, 'Infinity')['$===']($case)) {return self.$d()['$<=>'](other.$d())}
        else if ($$($nesting, 'Numeric')['$===']($case)) {return self.$d()}
        else {
        try {
          
          $b = other.$coerce(self), $a = Opal.to_ary($b), (l = ($a[0] == null ? nil : $a[0])), (r = ($a[1] == null ? nil : $a[1])), $b;
          return l['$<=>'](r);
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'NoMethodError')])) {
            try {
              return nil
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };}})()
      }, $Infinity_$lt_eq_gt$9.$$arity = 1);
      
      Opal.def(self, '$coerce', $Infinity_coerce$10 = function $$coerce(other) {
        var $iter = $Infinity_coerce$10.$$p, $yield = $iter || nil, self = this, $case = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $Infinity_coerce$10.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        return (function() {$case = other;
        if ($$($nesting, 'Numeric')['$===']($case)) {return [self.$d()['$-@'](), self.$d()]}
        else {return $send2(self, Opal.find_super_dispatcher(self, 'coerce', $Infinity_coerce$10, false, true), 'coerce', $zuper, $iter)}})()
      }, $Infinity_coerce$10.$$arity = 1);
      return (Opal.def(self, '$to_f', $Infinity_to_f$11 = function $$to_f() {
        var self = this;

        
        if (self.d['$=='](0)) {
          return 0};
        if ($truthy($rb_gt(self.d, 0))) {
          return $$$($$($nesting, 'Float'), 'INFINITY')
        } else {
          return $$$($$($nesting, 'Float'), 'INFINITY')['$-@']()
        };
      }, $Infinity_to_f$11.$$arity = 0), nil) && 'to_f';
    })($nesting[0], $$($nesting, 'Numeric'), $nesting);
    Opal.const_set($nesting[0], 'JULIAN', $$($nesting, 'Infinity').$new());
    Opal.const_set($nesting[0], 'GREGORIAN', $$($nesting, 'Infinity').$new()['$-@']());
    Opal.const_set($nesting[0], 'ITALY', 2299161);
    Opal.const_set($nesting[0], 'ENGLAND', 2361222);
    Opal.const_set($nesting[0], 'MONTHNAMES', $rb_plus([nil], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]));
    Opal.const_set($nesting[0], 'ABBR_MONTHNAMES', ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]);
    Opal.const_set($nesting[0], 'DAYNAMES', ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]);
    Opal.const_set($nesting[0], 'ABBR_DAYNAMES', ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $wrap$12, $parse$13, $today$14, $gregorian_leap$ques$15;

      
      Opal.alias(self, "civil", "new");
      
      Opal.def(self, '$wrap', $wrap$12 = function $$wrap(native$) {
        var self = this, instance = nil;

        
        instance = self.$allocate();
        instance.date = native$;
        return instance;
      }, $wrap$12.$$arity = 1);
      
      Opal.def(self, '$parse', $parse$13 = function $$parse(string, comp) {
        var self = this;

        
        
        if (comp == null) {
          comp = true;
        };
        
        var current_date = new Date();

        var current_day = current_date.getDate(),
            current_month = current_date.getMonth(),
            current_year = current_date.getFullYear(),
            current_wday = current_date.getDay(),
            full_month_name_regexp = $$($nesting, 'MONTHNAMES').$compact().$join("|");

        function match1(match) { return match[1]; }
        function match2(match) { return match[2]; }
        function match3(match) { return match[3]; }
        function match4(match) { return match[4]; }

        // Converts passed short year (0..99)
        // to a 4-digits year in the range (1969..2068)
        function fromShortYear(fn) {
          return function(match) {
            var short_year = fn(match);

            if (short_year >= 69) {
              short_year += 1900;
            } else {
              short_year += 2000;
            }
            return short_year;
          }
        }

        // Converts month abbr (nov) to a month number
        function fromMonthAbbr(fn) {
          return function(match) {
            var abbr = fn(match).toLowerCase();
            return $$($nesting, 'ABBR_MONTHNAMES').indexOf(abbr) + 1;
          }
        }

        function toInt(fn) {
          return function(match) {
            var value = fn(match);
            return parseInt(value, 10);
          }
        }

        // Depending on the 'comp' value appends 20xx to a passed year
        function to2000(fn) {
          return function(match) {
            var value = fn(match);
            if (comp) {
              return value + 2000;
            } else {
              return value;
            }
          }
        }

        // Converts passed week day name to a day number
        function fromDayName(fn) {
          return function(match) {
            var dayname = fn(match),
                wday = $send($$($nesting, 'DAYNAMES'), 'map', [], "downcase".$to_proc()).indexOf((dayname).$downcase());

            return current_day - current_wday + wday;
          }
        }

        // Converts passed month name to a month number
        function fromFullMonthName(fn) {
          return function(match) {
            var month_name = fn(match);
            return $send($$($nesting, 'MONTHNAMES').$compact(), 'map', [], "downcase".$to_proc()).indexOf((month_name).$downcase()) + 1;
          }
        }

        var rules = [
          {
            // DD as month day number
            regexp: /^(\d{2})$/,
            year: current_year,
            month: current_month,
            day: toInt(match1)
          },
          {
            // DDD as year day number
            regexp: /^(\d{3})$/,
            year: current_year,
            month: 0,
            day: toInt(match1)
          },
          {
            // MMDD as month and day
            regexp: /^(\d{2})(\d{2})$/,
            year: current_year,
            month: toInt(match1),
            day: toInt(match2)
          },
          {
            // YYDDD as year and day number in 1969--2068
            regexp: /^(\d{2})(\d{3})$/,
            year: fromShortYear(toInt(match1)),
            month: 0,
            day: toInt(match2)
          },
          {
            // YYMMDD as year, month and day in 1969--2068
            regexp: /^(\d{2})(\d{2})(\d{2})$/,
            year: fromShortYear(toInt(match1)),
            month: toInt(match2),
            day: toInt(match3)
          },
          {
            // YYYYDDD as year and day number
            regexp: /^(\d{4})(\d{3})$/,
            year: toInt(match1),
            month: 0,
            day: toInt(match2)
          },
          {
            // YYYYMMDD as year, month and day number
            regexp: /^(\d{4})(\d{2})(\d{2})$/,
            year: toInt(match1),
            month: toInt(match2),
            day: toInt(match3)
          },
          {
            // mmm YYYY
            regexp: /^([a-z]{3})[\s\.\/\-](\d{3,4})$/,
            year: toInt(match2),
            month: fromMonthAbbr(match1),
            day: 1
          },
          {
            // DD mmm YYYY
            regexp: /^(\d{1,2})[\s\.\/\-]([a-z]{3})[\s\.\/\-](\d{3,4})$/i,
            year: toInt(match3),
            month: fromMonthAbbr(match2),
            day: toInt(match1)
          },
          {
            // mmm DD YYYY
            regexp: /^([a-z]{3})[\s\.\/\-](\d{1,2})[\s\.\/\-](\d{3,4})$/i,
            year: toInt(match3),
            month: fromMonthAbbr(match1),
            day: toInt(match2)
          },
          {
            // YYYY mmm DD
            regexp: /^(\d{3,4})[\s\.\/\-]([a-z]{3})[\s\.\/\-](\d{1,2})$/i,
            year: toInt(match1),
            month: fromMonthAbbr(match2),
            day: toInt(match3)
          },
          {
            // YYYY-MM-DD YYYY/MM/DD YYYY.MM.DD
            regexp: /^(\-?\d{3,4})[\s\.\/\-](\d{1,2})[\s\.\/\-](\d{1,2})$/,
            year: toInt(match1),
            month: toInt(match2),
            day: toInt(match3)
          },
          {
            // YY-MM-DD
            regexp: /^(\d{2})[\s\.\/\-](\d{1,2})[\s\.\/\-](\d{1,2})$/,
            year: to2000(toInt(match1)),
            month: toInt(match2),
            day: toInt(match3)
          },
          {
            // DD-MM-YYYY
            regexp: /^(\d{1,2})[\s\.\/\-](\d{1,2})[\s\.\/\-](\-?\d{3,4})$/,
            year: toInt(match3),
            month: toInt(match2),
            day: toInt(match1)
          },
          {
            // ddd
            regexp: new RegExp("^(" + $$($nesting, 'DAYNAMES').$join("|") + ")$", 'i'),
            year: current_year,
            month: current_month,
            day: fromDayName(match1)
          },
          {
            // monthname daynumber YYYY
            regexp: new RegExp("^(" + full_month_name_regexp + ")[\\s\\.\\/\\-](\\d{1,2})(th|nd|rd)[\\s\\.\\/\\-](\\-?\\d{3,4})$", "i"),
            year: toInt(match4),
            month: fromFullMonthName(match1),
            day: toInt(match2)
          },
          {
            // monthname daynumber
            regexp: new RegExp("^(" + full_month_name_regexp + ")[\\s\\.\\/\\-](\\d{1,2})(th|nd|rd)", "i"),
            year: current_year,
            month: fromFullMonthName(match1),
            day: toInt(match2)
          },
          {
            // daynumber monthname YYYY
            regexp: new RegExp("^(\\d{1,2})(th|nd|rd)[\\s\\.\\/\\-](" + full_month_name_regexp + ")[\\s\\.\\/\\-](\\-?\\d{3,4})$", "i"),
            year: toInt(match4),
            month: fromFullMonthName(match3),
            day: toInt(match1)
          },
          {
            // YYYY monthname daynumber
            regexp: new RegExp("^(\\-?\\d{3,4})[\\s\\.\\/\\-](" + full_month_name_regexp + ")[\\s\\.\\/\\-](\\d{1,2})(th|nd|rd)$", "i"),
            year: toInt(match1),
            month: fromFullMonthName(match2),
            day: toInt(match3)
          }
        ]

        var rule, i, match;

        for (i = 0; i < rules.length; i++) {
          rule = rules[i];
          match = rule.regexp.exec(string);
          if (match) {
            var year = rule.year;
            if (typeof(year) === 'function') {
              year = year(match);
            }

            var month = rule.month;
            if (typeof(month) === 'function') {
              month = month(match) - 1
            }

            var day = rule.day;
            if (typeof(day) === 'function') {
              day = day(match);
            }

            var result = new Date(year, month, day);

            // an edge case, JS can't handle 'new Date(1)', minimal year is 1970
            if (year >= 0 && year <= 1970) {
              result.setFullYear(year);
            }

            return self.$wrap(result);
          }
        }
      ;
        return self.$raise($$($nesting, 'ArgumentError'), "invalid date");
      }, $parse$13.$$arity = -2);
      
      Opal.def(self, '$today', $today$14 = function $$today() {
        var self = this;

        return self.$wrap(new Date())
      }, $today$14.$$arity = 0);
      return (Opal.def(self, '$gregorian_leap?', $gregorian_leap$ques$15 = function(year) {
        var self = this;

        return (new Date(year, 1, 29).getMonth()-1) === 0
      }, $gregorian_leap$ques$15.$$arity = 1), nil) && 'gregorian_leap?';
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$initialize', $Date_initialize$16 = function $$initialize(year, month, day, start) {
      var self = this;

      
      
      if (year == null) {
        year = -4712;
      };
      
      if (month == null) {
        month = 1;
      };
      
      if (day == null) {
        day = 1;
      };
      
      if (start == null) {
        start = $$($nesting, 'ITALY');
      };
      
      // Because of Gregorian reform calendar goes from 1582-10-04 to 1582-10-15.
      // All days in between end up as 4 october.
      if (year === 1582 && month === 10 && day > 4 && day < 15) {
        day = 4;
      }
    ;
      return (self.date = new Date(year, month - 1, day));
    }, $Date_initialize$16.$$arity = -1);
    
    Opal.def(self, '$-', $Date_$minus$17 = function(date) {
      var self = this;

      
      if (date.$$is_number) {
        var result = self.$clone();
        result.date.setDate(self.date.getDate() - date);
        return result;
      }
      else if (date.date) {
        return Math.round((self.date - date.date) / (1000 * 60 * 60 * 24));
      }
      else {
        self.$raise($$($nesting, 'TypeError'));
      }
    
    }, $Date_$minus$17.$$arity = 1);
    
    Opal.def(self, '$+', $Date_$plus$18 = function(date) {
      var self = this;

      
      if (date.$$is_number) {
        var result = self.$clone();
        result.date.setDate(self.date.getDate() + date);
        return result;
      }
      else {
        self.$raise($$($nesting, 'TypeError'));
      }
    
    }, $Date_$plus$18.$$arity = 1);
    
    Opal.def(self, '$<', $Date_$lt$19 = function(other) {
      var self = this;

      
      var a = self.date, b = other.date;
      a.setHours(0, 0, 0, 0);
      b.setHours(0, 0, 0, 0);
      return a < b;
    
    }, $Date_$lt$19.$$arity = 1);
    
    Opal.def(self, '$<=', $Date_$lt_eq$20 = function(other) {
      var self = this;

      
      var a = self.date, b = other.date;
      a.setHours(0, 0, 0, 0);
      b.setHours(0, 0, 0, 0);
      return a <= b;
    
    }, $Date_$lt_eq$20.$$arity = 1);
    
    Opal.def(self, '$>', $Date_$gt$21 = function(other) {
      var self = this;

      
      var a = self.date, b = other.date;
      a.setHours(0, 0, 0, 0);
      b.setHours(0, 0, 0, 0);
      return a > b;
    
    }, $Date_$gt$21.$$arity = 1);
    
    Opal.def(self, '$>=', $Date_$gt_eq$22 = function(other) {
      var self = this;

      
      var a = self.date, b = other.date;
      a.setHours(0, 0, 0, 0);
      b.setHours(0, 0, 0, 0);
      return a >= b;
    
    }, $Date_$gt_eq$22.$$arity = 1);
    
    Opal.def(self, '$<=>', $Date_$lt_eq_gt$23 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.$jd()['$<=>'](other)
      }

      if ($$($nesting, 'Date')['$==='](other)) {
        var a = self.date, b = other.date;
        a.setHours(0, 0, 0, 0);
        b.setHours(0, 0, 0, 0);

        if (a < b) {
          return -1;
        }
        else if (a > b) {
          return 1;
        }
        else {
          return 0;
        }
      } else {
        return nil;
      }
    
    }, $Date_$lt_eq_gt$23.$$arity = 1);
    
    Opal.def(self, '$>>', $Date_$gt$gt$24 = function(n) {
      var self = this;

      
      if (!n.$$is_number) {
        self.$raise($$($nesting, 'TypeError'));
      }

      var result = self.$clone(), date = result.date, cur = date.getDate();
      date.setDate(1);
      date.setMonth(date.getMonth() + n);
      date.setDate(Math.min(cur, days_in_month(date.getFullYear(), date.getMonth())));
      return result;
    
    }, $Date_$gt$gt$24.$$arity = 1);
    
    Opal.def(self, '$<<', $Date_$lt$lt$25 = function(n) {
      var self = this;

      
      if (!n.$$is_number) {
        self.$raise($$($nesting, 'TypeError'));
      }

      return self['$>>'](-n);
    
    }, $Date_$lt$lt$25.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$clone', $Date_clone$26 = function $$clone() {
      var self = this;

      return $$($nesting, 'Date').$wrap(new Date(self.date.getTime()))
    }, $Date_clone$26.$$arity = 0);
    
    Opal.def(self, '$day', $Date_day$27 = function $$day() {
      var self = this;

      return self.date.getDate()
    }, $Date_day$27.$$arity = 0);
    
    Opal.def(self, '$friday?', $Date_friday$ques$28 = function() {
      var self = this;

      return self.$wday()['$=='](5)
    }, $Date_friday$ques$28.$$arity = 0);
    
    Opal.def(self, '$jd', $Date_jd$29 = function $$jd() {
      var self = this;

      
    //Adapted from http://www.physics.sfasu.edu/astro/javascript/julianday.html

    var mm = self.date.getMonth() + 1,
        dd = self.date.getDate(),
        yy = self.date.getFullYear(),
        hr = 12, mn = 0, sc = 0,
        ggg, s, a, j1, jd;

    hr = hr + (mn / 60) + (sc/3600);

    ggg = 1;
    if (yy <= 1585) {
      ggg = 0;
    }

    jd = -1 * Math.floor(7 * (Math.floor((mm + 9) / 12) + yy) / 4);

    s = 1;
    if ((mm - 9) < 0) {
      s =- 1;
    }

    a = Math.abs(mm - 9);
    j1 = Math.floor(yy + s * Math.floor(a / 7));
    j1 = -1 * Math.floor((Math.floor(j1 / 100) + 1) * 3 / 4);

    jd = jd + Math.floor(275 * mm / 9) + dd + (ggg * j1);
    jd = jd + 1721027 + 2 * ggg + 367 * yy - 0.5;
    jd = jd + (hr / 24);

    return jd;
    
    }, $Date_jd$29.$$arity = 0);
    
    Opal.def(self, '$julian?', $Date_julian$ques$30 = function() {
      var self = this;

      return self.date < new Date(1582, 10 - 1, 15, 12)
    }, $Date_julian$ques$30.$$arity = 0);
    
    Opal.def(self, '$monday?', $Date_monday$ques$31 = function() {
      var self = this;

      return self.$wday()['$=='](1)
    }, $Date_monday$ques$31.$$arity = 0);
    
    Opal.def(self, '$month', $Date_month$32 = function $$month() {
      var self = this;

      return self.date.getMonth() + 1
    }, $Date_month$32.$$arity = 0);
    
    Opal.def(self, '$next', $Date_next$33 = function $$next() {
      var self = this;

      return $rb_plus(self, 1)
    }, $Date_next$33.$$arity = 0);
    
    Opal.def(self, '$next_day', $Date_next_day$34 = function $$next_day(n) {
      var self = this;

      
      
      if (n == null) {
        n = 1;
      };
      return $rb_plus(self, n);
    }, $Date_next_day$34.$$arity = -1);
    
    Opal.def(self, '$next_month', $Date_next_month$35 = function $$next_month(n) {
      var self = this;

      
      
      if (n == null) {
        n = 1;
      };
      
      var result = self.$clone(), date = result.date, cur = date.getDate();
      date.setDate(1);
      date.setMonth(date.getMonth() + n);
      date.setDate(Math.min(cur, days_in_month(date.getFullYear(), date.getMonth())));
      return result;
    ;
    }, $Date_next_month$35.$$arity = -1);
    
    Opal.def(self, '$next_year', $Date_next_year$36 = function $$next_year(years) {
      var self = this;

      
      
      if (years == null) {
        years = 1;
      };
      return self.$class().$new($rb_plus(self.$year(), years), self.$month(), self.$day());
    }, $Date_next_year$36.$$arity = -1);
    
    Opal.def(self, '$prev_day', $Date_prev_day$37 = function $$prev_day(n) {
      var self = this;

      
      
      if (n == null) {
        n = 1;
      };
      return $rb_minus(self, n);
    }, $Date_prev_day$37.$$arity = -1);
    
    Opal.def(self, '$prev_month', $Date_prev_month$38 = function $$prev_month(n) {
      var self = this;

      
      
      if (n == null) {
        n = 1;
      };
      
      var result = self.$clone(), date = result.date, cur = date.getDate();
      date.setDate(1);
      date.setMonth(date.getMonth() - n);
      date.setDate(Math.min(cur, days_in_month(date.getFullYear(), date.getMonth())));
      return result;
    ;
    }, $Date_prev_month$38.$$arity = -1);
    
    Opal.def(self, '$prev_year', $Date_prev_year$39 = function $$prev_year(years) {
      var self = this;

      
      
      if (years == null) {
        years = 1;
      };
      return self.$class().$new($rb_minus(self.$year(), years), self.$month(), self.$day());
    }, $Date_prev_year$39.$$arity = -1);
    
    Opal.def(self, '$saturday?', $Date_saturday$ques$40 = function() {
      var self = this;

      return self.$wday()['$=='](6)
    }, $Date_saturday$ques$40.$$arity = 0);
    
    Opal.def(self, '$strftime', $Date_strftime$41 = function $$strftime(format) {
      var self = this;

      
      
      if (format == null) {
        format = "";
      };
      
      if (format == '') {
        return self.$to_s();
      }

      return self.date.$strftime(format);
    ;
    }, $Date_strftime$41.$$arity = -1);
    Opal.alias(self, "succ", "next");
    
    Opal.def(self, '$sunday?', $Date_sunday$ques$42 = function() {
      var self = this;

      return self.$wday()['$=='](0)
    }, $Date_sunday$ques$42.$$arity = 0);
    
    Opal.def(self, '$thursday?', $Date_thursday$ques$43 = function() {
      var self = this;

      return self.$wday()['$=='](4)
    }, $Date_thursday$ques$43.$$arity = 0);
    
    Opal.def(self, '$to_s', $Date_to_s$44 = function $$to_s() {
      var self = this;

      
      var d = self.date, year = d.getFullYear(), month = d.getMonth() + 1, day = d.getDate();
      if (month < 10) { month = '0' + month; }
      if (day < 10) { day = '0' + day; }
      return year + '-' + month + '-' + day;
    
    }, $Date_to_s$44.$$arity = 0);
    
    Opal.def(self, '$to_time', $Date_to_time$45 = function $$to_time() {
      var self = this;

      return $$($nesting, 'Time').$new(self.$year(), self.$month(), self.$day())
    }, $Date_to_time$45.$$arity = 0);
    
    Opal.def(self, '$to_n', $Date_to_n$46 = function $$to_n() {
      var self = this;

      return self.date
    }, $Date_to_n$46.$$arity = 0);
    
    Opal.def(self, '$tuesday?', $Date_tuesday$ques$47 = function() {
      var self = this;

      return self.$wday()['$=='](2)
    }, $Date_tuesday$ques$47.$$arity = 0);
    
    Opal.def(self, '$step', $Date_step$48 = function $$step(limit, step) {
      var $iter = $Date_step$48.$$p, block = $iter || nil, $$49, $$50, self = this, steps_count = nil, steps = nil, result = nil;

      if ($iter) $Date_step$48.$$p = null;
      
      
      if ($iter) $Date_step$48.$$p = null;;
      
      if (step == null) {
        step = 1;
      };
      steps_count = $rb_minus(limit, self).$to_i();
      steps = (function() {if ($truthy($rb_lt($rb_times(steps_count, step), 0))) {
        return []
      } else if ($truthy($rb_lt(steps_count, 0))) {
        return $send(Opal.Range.$new(0, steps_count['$-@'](), false).$step(step.$abs()), 'map', [], "-@".$to_proc()).$reverse()
      } else {
        return Opal.Range.$new(0, steps_count, false).$step(step.$abs())
      }; return nil; })();
      result = $send(steps, 'map', [], ($$49 = function(i){var self = $$49.$$s == null ? this : $$49.$$s;

      
        
        if (i == null) {
          i = nil;
        };
        return $rb_plus(self, i);}, $$49.$$s = self, $$49.$$arity = 1, $$49));
      if ((block !== nil)) {
        
        $send(result, 'each', [], ($$50 = function(i){var self = $$50.$$s == null ? this : $$50.$$s;

        
          
          if (i == null) {
            i = nil;
          };
          return Opal.yield1(block, i);;}, $$50.$$s = self, $$50.$$arity = 1, $$50));
        return self;
      } else {
        return result
      };
    }, $Date_step$48.$$arity = -2);
    
    Opal.def(self, '$upto', $Date_upto$51 = function $$upto(max) {
      var $iter = $Date_upto$51.$$p, block = $iter || nil, self = this;

      if ($iter) $Date_upto$51.$$p = null;
      
      
      if ($iter) $Date_upto$51.$$p = null;;
      return $send(self, 'step', [max, 1], block.$to_proc());
    }, $Date_upto$51.$$arity = 1);
    
    Opal.def(self, '$downto', $Date_downto$52 = function $$downto(min) {
      var $iter = $Date_downto$52.$$p, block = $iter || nil, self = this;

      if ($iter) $Date_downto$52.$$p = null;
      
      
      if ($iter) $Date_downto$52.$$p = null;;
      return $send(self, 'step', [min, -1], block.$to_proc());
    }, $Date_downto$52.$$arity = 1);
    
    Opal.def(self, '$wday', $Date_wday$53 = function $$wday() {
      var self = this;

      return self.date.getDay()
    }, $Date_wday$53.$$arity = 0);
    
    Opal.def(self, '$wednesday?', $Date_wednesday$ques$54 = function() {
      var self = this;

      return self.$wday()['$=='](3)
    }, $Date_wednesday$ques$54.$$arity = 0);
    
    Opal.def(self, '$year', $Date_year$55 = function $$year() {
      var self = this;

      return self.date.getFullYear()
    }, $Date_year$55.$$arity = 0);
    
    Opal.def(self, '$cwday', $Date_cwday$56 = function $$cwday() {
      var self = this;

      return self.date.getDay() || 7
    }, $Date_cwday$56.$$arity = 0);
    
    Opal.def(self, '$cweek', $Date_cweek$57 = function $$cweek() {
      var self = this;

      
      var d = new Date(self.date);
      d.setHours(0,0,0);
      d.setDate(d.getDate()+4-(d.getDay()||7));
      return Math.ceil((((d-new Date(d.getFullYear(),0,1))/8.64e7)+1)/7);
    
    }, $Date_cweek$57.$$arity = 0);
    
    function days_in_month(year, month) {
      var leap = ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);
      return [31, (leap ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month]
    }
  ;
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.1.1 */
Opal.modules["todo"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $range = Opal.range, $send = Opal.send;

  Opal.add_stubs(['$require', '$setup', '$first', '$[]', '$===', '$nil?', '$empty?', '$raise', '$+', '$add', '$join', '$>', '$length', '$change_state', '$to_i', '$list', '$<', '$set_priority', '$due_date', '$append', '$rename', '$!=', '$delete', '$add_note', '$delete_note', '$show', '$push', '$strip', '$usage', '$colorize', '$gsub', '$to_s', '$private', '$keys', '$map', '$select', '$parse', '$strftime', '$today', '$downcase', '$!', '$each', '$split', '$==', '$chomp', '$[]=', '$-', '$has_key?', '$sort', '$generate', '$match', '$convert_due_date', '$postprocess_tags', '$load_tasks', '$write_tasks', '$max', '$size', '$sort_by', '$start_with?', '$abs', '$rjust', '$kind_of?', '$index']);
  
  self.$require("./json.rb");
  self.$require("./date.rb");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Todo');

    var $nesting = [self].concat($parent_nesting), $Todo_execute$1, $Todo_to_s$2, $Todo_to_html$3, $Todo_usage$4, $Todo_setup$7, $Todo_load_tasks$11, $Todo_write_tasks$13, $Todo_postprocess_tags$15, $Todo_add$16, $Todo_append$17, $Todo_rename$18, $Todo_delete$19, $Todo_change_state$20, $Todo_set_priority$21, $Todo_due_date$22, $Todo_list$23, $Todo_add_note$29, $Todo_delete_note$30, $Todo_show$31, $Todo_colorize$33, $Todo_convert_due_date$34;

    self.$$prototype.text_buffer = self.$$prototype.queries = self.$$prototype.today = self.$$prototype.due_date_days = nil;
    
    Opal.const_set($nesting[0], 'COLOR_CODES', $hash2(["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white"], {"black": 30, "red": 31, "green": 32, "yellow": 33, "blue": 34, "magenta": 35, "cyan": 36, "white": 37}));
    Opal.const_set($nesting[0], 'STATES', $hash2(["new", "done", "started", "blocked", "default"], {"new": "[ ]", "done": "[x]", "started": "[>]", "blocked": "[!]", "default": "[?]"}));
    Opal.const_set($nesting[0], 'ORDER', $hash2(["new", "done", "started", "blocked", "default"], {"new": 3, "done": 4, "started": 2, "blocked": 1, "default": 100}));
    Opal.const_set($nesting[0], 'COLORS', $hash2(["new", "done", "started", "blocked", "default"], {"new": "white", "done": "blue", "started": "green", "blocked": "yellow", "default": "magenta"}));
    Opal.const_set($nesting[0], 'DATE_FORMAT', "%Y-%m-%d");
    Opal.const_set($nesting[0], 'DUE_DATE_DAYS_SIMPLE', ["today", "tomorrow"]);
    Opal.const_set($nesting[0], 'DUE_DATE_TAG_PATTERN', /(^| )due:([a-zA-Z0-9-]+)/);
    Opal.const_set($nesting[0], 'CONTEXT_TAG_PATTERN', /(^| )[@+][\w-]+/);
    Opal.const_set($nesting[0], 'PRIORITY_FLAG', "*");
    Opal.const_set($nesting[0], 'TODO_FILE', "todo.jsonl");
    
    Opal.def(self, '$execute', $Todo_execute$1 = function $$execute(arguments$) {
      var self = this, action = nil, args = nil, $ret_or_1 = nil, $case = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil, $ret_or_5 = nil, $ret_or_6 = nil, $ret_or_7 = nil, $ret_or_8 = nil, error = nil;

      
      self.text_buffer = [];
      
      try {
        
        self.$setup();
        action = arguments$.$first();
        args = (function() {if ($truthy(($ret_or_1 = arguments$['$[]']($range(1, -1, false))))) {
          return $ret_or_1
        } else {
          return []
        }; return nil; })();
        $case = action;
        if ("add"['$===']($case)) {
        if ($truthy((function() {if ($truthy(($ret_or_2 = args['$nil?']()))) {
          return $ret_or_2
        } else {
          return args['$empty?']()
        }; return nil; })())) {
          self.$raise($rb_plus(action, " command requires at least one parameter"))};
        self.$add(args.$join(" "));}
        else if ("start"['$===']($case)) {if ($truthy($rb_gt(args.$length(), 0))) {
          self.$change_state(args.$first().$to_i(), "started", (function() {if ($truthy(($ret_or_3 = args['$[]']($range(1, -1, false))))) {
            return $ret_or_3
          } else {
            return []
          }; return nil; })().$join(" "))
        } else {
          self.$list(nil, [":started"])
        }}
        else if ("done"['$===']($case)) {if ($truthy($rb_gt(args.$length(), 0))) {
          self.$change_state(args.$first().$to_i(), "done", (function() {if ($truthy(($ret_or_4 = args['$[]']($range(1, -1, false))))) {
            return $ret_or_4
          } else {
            return []
          }; return nil; })().$join(" "))
        } else {
          self.$list(nil, [":done"])
        }}
        else if ("block"['$===']($case)) {if ($truthy($rb_gt(args.$length(), 0))) {
          self.$change_state(args.$first().$to_i(), "blocked", (function() {if ($truthy(($ret_or_5 = args['$[]']($range(1, -1, false))))) {
            return $ret_or_5
          } else {
            return []
          }; return nil; })().$join(" "))
        } else {
          self.$list(nil, [":blocked"])
        }}
        else if ("reset"['$===']($case)) {if ($truthy($rb_gt(args.$length(), 0))) {
          self.$change_state(args.$first().$to_i(), "new", (function() {if ($truthy(($ret_or_6 = args['$[]']($range(1, -1, false))))) {
            return $ret_or_6
          } else {
            return []
          }; return nil; })().$join(" "))
        } else {
          self.$list(nil, [":new"])
        }}
        else if ("prio"['$===']($case)) {
        if ($truthy($rb_lt(args.$length(), 1))) {
          self.$raise($rb_plus(action, " command requires at least one parameter"))};
        self.$set_priority(args.$first().$to_i(), (function() {if ($truthy(($ret_or_7 = args['$[]']($range(1, -1, false))))) {
          return $ret_or_7
        } else {
          return []
        }; return nil; })().$join(" "));}
        else if ("due"['$===']($case)) {
        if ($truthy($rb_lt(args.$length(), 1))) {
          self.$raise($rb_plus(action, " command requires at least one parameter"))};
        self.$due_date(args.$first().$to_i(), (function() {if ($truthy(($ret_or_8 = args['$[]']($range(1, -1, false))))) {
          return $ret_or_8
        } else {
          return []
        }; return nil; })().$join(" "));}
        else if ("append"['$===']($case)) {
        if ($truthy($rb_lt(args.$length(), 2))) {
          self.$raise($rb_plus(action, " command requires at least two parameters"))};
        self.$append(args.$first().$to_i(), args['$[]']($range(1, -1, false)).$join(" "));}
        else if ("rename"['$===']($case)) {
        if ($truthy($rb_lt(args.$length(), 2))) {
          self.$raise($rb_plus(action, " command requires at least two parameters"))};
        self.$rename(args.$first().$to_i(), args['$[]']($range(1, -1, false)).$join(" "));}
        else if ("del"['$===']($case)) {
        if ($truthy(args.$length()['$!='](1))) {
          self.$raise($rb_plus(action, " command requires exactly one parameter"))};
        self.$delete(args.$first().$to_i());}
        else if ("note"['$===']($case)) {
        if ($truthy($rb_lt(args.$length(), 2))) {
          self.$raise($rb_plus(action, " command requires at least two parameters"))};
        self.$add_note(args.$first().$to_i(), args['$[]']($range(1, -1, false)).$join(" "));}
        else if ("delnote"['$===']($case)) {
        if ($truthy(args.$length()['$!='](1))) {
          self.$raise($rb_plus(action, " command requires exactly one parameter"))};
        self.$delete_note(args.$first().$to_i());}
        else if ("list"['$===']($case)) {self.$list(nil, args)}
        else if ("show"['$===']($case)) {
        if ($truthy(args.$length()['$!='](1))) {
          self.$raise($rb_plus(action, " command requires exactly one parameter"))};
        self.$show(args.$first().$to_i());}
        else if ("help"['$===']($case)) {
        if ($truthy($rb_gt(args.$length(), 0))) {
          self.$raise($rb_plus(action, " command has no parameters"))};
        self.text_buffer.$push(self.$usage().$strip());}
        else {self.$list(nil, arguments$)};
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {(error = $err)
          try {
            self.text_buffer.$push("" + (self.$colorize("ERROR:", "red")) + " " + (error))
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      };;
      return self;
    }, $Todo_execute$1.$$arity = 1);
    
    Opal.def(self, '$to_s', $Todo_to_s$2 = function $$to_s() {
      var self = this, $ret_or_9 = nil;

      return $rb_plus((function() {if ($truthy(($ret_or_9 = self.text_buffer))) {
        return $ret_or_9
      } else {
        return []
      }; return nil; })().$join("\n"), "\n")
    }, $Todo_to_s$2.$$arity = 0);
    
    Opal.def(self, '$to_html', $Todo_to_html$3 = function $$to_html() {
      var self = this;

      return $rb_plus($rb_plus("<span class=\"output\">", self.$to_s().$gsub("&", "&amp;").$gsub("<", "&lt;").$gsub(">", "&gt;").$gsub(" ", "&nbsp;").$gsub("\n", "<br>").$gsub(/\e\[0m/, "</span>").$gsub(/\e\[(\d+)m/, "<span class=\"color color-\\1\">")), "</span>")
    }, $Todo_to_html$3.$$arity = 0);
    self.$private();
    
    Opal.def(self, '$usage', $Todo_usage$4 = function $$usage() {
      var $$5, $$6, self = this;

      return "" + "Usage: todo <command> <arguments>\n" + "\n" + "Commands:\n" + "* add <text>                     add new task\n" + "* start <tasknumber> [text]      mark task as started, with optional note\n" + "* done <tasknumber> [text]       mark task as completed, with optional note\n" + "* block <tasknumber> [text]      mark task as blocked, with optional note\n" + "* reset <tasknumber> [text]      reset task to new state, with optional note\n" + "* prio <tasknumber> [text]       toggle high priority flag, with optional note\n" + "* due <tasknumber> [date]        set/unset due date (in YYYY-MM-DD format)\n" + "\n" + "* append <tasknumber> <text>     append text to task title\n" + "* rename <tasknumber> <text>     rename task\n" + "* del <tasknumber>               delete task\n" + "* note <tasknumber> <text>       add note to task\n" + "* delnote <tasknumber>           delete all notes from task\n" + "\n" + "* list <regex> [regex...]        list tasks (only active tasks by default)\n" + "* show <tasknumber>              show all task details\n" + "* help                           this help screen\n" + "\n" + "With list command the following pre-defined regex patterns can be also used:\n" + (self.queries.$keys().$join(", ")) + "\n" + "\n" + "Due dates can be also added via tags in task title: \"due:YYYY-MM-DD\"\n" + "\n" + "Legend:\n" + ($send($send($$($nesting, 'STATES'), 'select', [], ($$5 = function(k, v){var self = $$5.$$s == null ? this : $$5.$$s;

      
        
        if (k == null) {
          k = nil;
        };
        
        if (v == null) {
          v = nil;
        };
        return k['$!=']("default");}, $$5.$$s = self, $$5.$$arity = 2, $$5)), 'map', [], ($$6 = function(k, v){var self = $$6.$$s == null ? this : $$6.$$s;

      
        
        if (k == null) {
          k = nil;
        };
        
        if (v == null) {
          v = nil;
        };
        return "" + (k) + " " + (v);}, $$6.$$s = self, $$6.$$arity = 2, $$6)).$join(", ")) + ", priority " + ($$($nesting, 'PRIORITY_FLAG')) + "\n" + "\n" + "Local storage: " + ($$($nesting, 'TODO_FILE')) + "\n"
    }, $Todo_usage$4.$$arity = 0);
    
    Opal.def(self, '$setup', $Todo_setup$7 = function $$setup() {
      var $$8, $$9, $$10, self = this, next_7_days = nil, due_dates_for_queries = nil;

      
      self.today = $$($nesting, 'Date').$parse($$($nesting, 'Date').$today().$strftime($$($nesting, 'DATE_FORMAT')));
      next_7_days = $send($range(0, 6, false), 'map', [], ($$8 = function(day){var self = $$8.$$s == null ? this : $$8.$$s;
        if (self.today == null) self.today = nil;

      
        
        if (day == null) {
          day = nil;
        };
        return $rb_plus(self.today, day);}, $$8.$$s = self, $$8.$$arity = 1, $$8));
      self.due_date_days = $send(next_7_days, 'map', [], ($$9 = function(day){var self = $$9.$$s == null ? this : $$9.$$s;

      
        
        if (day == null) {
          day = nil;
        };
        return day.$strftime("%A").$downcase();}, $$9.$$s = self, $$9.$$arity = 1, $$9));
      due_dates_for_queries = $send(next_7_days, 'map', [], ($$10 = function(day){var self = $$10.$$s == null ? this : $$10.$$s;

      
        
        if (day == null) {
          day = nil;
        };
        return day.$strftime($$($nesting, 'DATE_FORMAT'));}, $$10.$$s = self, $$10.$$arity = 1, $$10));
      return (self.queries = $hash2([":active", ":done", ":blocked", ":started", ":new", ":all", ":today", ":tomorrow", ":next7days"], {":active": "state=(new|started|blocked)", ":done": "state=done", ":blocked": "state=blocked", ":started": "state=started", ":new": "state=new", ":all": "state=\\w+", ":today": "" + "due=" + (due_dates_for_queries['$[]'](0)), ":tomorrow": "" + "due=" + (due_dates_for_queries['$[]'](1)), ":next7days": "" + "due=(" + (due_dates_for_queries.$join("|")) + ")"}));
    }, $Todo_setup$7.$$arity = 0);
    
    Opal.def(self, '$load_tasks', $Todo_load_tasks$11 = function $$load_tasks(item_to_check) {
      var $$12, self = this, count = nil, tasks = nil, todo_jsonl = nil, $ret_or_10 = nil;

      
      
      if (item_to_check == null) {
        item_to_check = nil;
      };
      count = 0;
      tasks = $hash2([], {});
      todo_jsonl = window.localStorage.getItem($$($nesting, 'TODO_FILE')) || '';
      if ($truthy(todo_jsonl['$empty?']()['$!']())) {
        $send(todo_jsonl.$split("\n"), 'each', [], ($$12 = function(line){var self = $$12.$$s == null ? this : $$12.$$s, $writer = nil;

        
          
          if (line == null) {
            line = nil;
          };
          if (line.$strip()['$==']("")) {
            return nil;};
          count = $rb_plus(count, 1);
          
          $writer = [count, $$($nesting, 'JSON').$parse(line.$chomp(), $hash2(["symbolize_names"], {"symbolize_names": true}))];
          $send(tasks, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];;}, $$12.$$s = self, $$12.$$arity = 1, $$12))};
      if ($truthy((function() {if ($truthy(($ret_or_10 = item_to_check))) {
        return tasks['$has_key?'](item_to_check)['$!']()
      } else {
        return $ret_or_10
      }; return nil; })())) {
        self.$raise("" + (item_to_check) + ": No such todo")};
      return tasks;
    }, $Todo_load_tasks$11.$$arity = -1);
    
    Opal.def(self, '$write_tasks', $Todo_write_tasks$13 = function $$write_tasks(tasks) {
      var $$14, self = this, todo_jsonl = nil;

      
      todo_jsonl = $rb_plus($send(tasks.$keys().$sort(), 'map', [], ($$14 = function(key){var self = $$14.$$s == null ? this : $$14.$$s;

      
        
        if (key == null) {
          key = nil;
        };
        return $$($nesting, 'JSON').$generate(tasks['$[]'](key));}, $$14.$$s = self, $$14.$$arity = 1, $$14)).$join("\n"), "\n");
      return window.localStorage.setItem($$($nesting, 'TODO_FILE'), todo_jsonl);
    }, $Todo_write_tasks$13.$$arity = 1);
    
    Opal.def(self, '$postprocess_tags', $Todo_postprocess_tags$15 = function $$postprocess_tags(task) {
      var self = this, match_data = nil, $writer = nil;

      
      match_data = task['$[]']("title").$match($$($nesting, 'DUE_DATE_TAG_PATTERN'));
      if ($truthy(match_data)) {
        
        
        $writer = ["title", task['$[]']("title").$gsub($$($nesting, 'DUE_DATE_TAG_PATTERN'), "")];
        $send(task, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = ["due", self.$convert_due_date(match_data['$[]'](2))];
        $send(task, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;};
      if ($truthy(task['$[]']("title")['$empty?']())) {
        return self.$raise("title must not be empty")
      } else {
        return nil
      };
    }, $Todo_postprocess_tags$15.$$arity = 1);
    
    Opal.def(self, '$add', $Todo_add$16 = function $$add(text) {
      var self = this, task = nil, todo_jsonl = nil;

      
      task = $hash2(["state", "title", "modified"], {"state": "new", "title": text, "modified": self.today.$strftime($$($nesting, 'DATE_FORMAT'))});
      self.$postprocess_tags(task);
      todo_jsonl = window.localStorage.getItem($$($nesting, 'TODO_FILE')) || '';
      todo_jsonl = $rb_plus(todo_jsonl, $rb_plus($$($nesting, 'JSON').$generate(task), "\n"));
      window.localStorage.setItem($$($nesting, 'TODO_FILE'), todo_jsonl);
      return self.$list();
    }, $Todo_add$16.$$arity = 1);
    
    Opal.def(self, '$append', $Todo_append$17 = function $$append(item, text) {
      var self = this, tasks = nil, $writer = nil;

      
      
      if (text == null) {
        text = "";
      };
      tasks = self.$load_tasks(item);
      
      $writer = ["title", [tasks['$[]'](item)['$[]']("title"), text].$join(" ")];
      $send(tasks['$[]'](item), '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      
      $writer = ["modified", self.today.$strftime($$($nesting, 'DATE_FORMAT'))];
      $send(tasks['$[]'](item), '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      self.$postprocess_tags(tasks['$[]'](item));
      self.$write_tasks(tasks);
      return self.$list(tasks);
    }, $Todo_append$17.$$arity = -2);
    
    Opal.def(self, '$rename', $Todo_rename$18 = function $$rename(item, text) {
      var self = this, tasks = nil, $writer = nil;

      
      tasks = self.$load_tasks(item);
      
      $writer = ["title", text];
      $send(tasks['$[]'](item), '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      
      $writer = ["modified", self.today.$strftime($$($nesting, 'DATE_FORMAT'))];
      $send(tasks['$[]'](item), '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      self.$postprocess_tags(tasks['$[]'](item));
      self.$write_tasks(tasks);
      return self.$list(tasks);
    }, $Todo_rename$18.$$arity = 2);
    
    Opal.def(self, '$delete', $Todo_delete$19 = function(item) {
      var self = this, tasks = nil;

      
      tasks = self.$load_tasks(item);
      tasks.$delete(item);
      self.$write_tasks(tasks);
      return self.$list();
    }, $Todo_delete$19.$$arity = 1);
    
    Opal.def(self, '$change_state', $Todo_change_state$20 = function $$change_state(item, state, note) {
      var self = this, tasks = nil, $writer = nil, $ret_or_11 = nil, $logical_op_recvr_tmp_1 = nil, $ret_or_12 = nil;

      
      
      if (note == null) {
        note = nil;
      };
      tasks = self.$load_tasks(item);
      
      $writer = ["state", state];
      $send(tasks['$[]'](item), '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      
      $writer = ["modified", self.today.$strftime($$($nesting, 'DATE_FORMAT'))];
      $send(tasks['$[]'](item), '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      if ($truthy((function() {if ($truthy(($ret_or_11 = note['$nil?']()['$!']()))) {
        return note['$empty?']()['$!']()
      } else {
        return $ret_or_11
      }; return nil; })())) {
        
        
        $logical_op_recvr_tmp_1 = tasks['$[]'](item);
        if ($truthy(($ret_or_12 = $logical_op_recvr_tmp_1['$[]']("note")))) {
          $ret_or_12
        } else {
          
          $writer = ["note", []];
          $send($logical_op_recvr_tmp_1, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        };;
        tasks['$[]'](item)['$[]']("note").$push(note);};
      self.$write_tasks(tasks);
      return self.$list(tasks);
    }, $Todo_change_state$20.$$arity = -3);
    
    Opal.def(self, '$set_priority', $Todo_set_priority$21 = function $$set_priority(item, note) {
      var self = this, tasks = nil, $writer = nil, $ret_or_13 = nil, $logical_op_recvr_tmp_2 = nil, $ret_or_14 = nil;

      
      
      if (note == null) {
        note = nil;
      };
      tasks = self.$load_tasks(item);
      
      $writer = ["priority", tasks['$[]'](item)['$[]']("priority")['$!']()];
      $send(tasks['$[]'](item), '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      if ($truthy(tasks['$[]'](item)['$[]']("priority")['$!']())) {
        tasks['$[]'](item).$delete("priority")};
      
      $writer = ["modified", self.today.$strftime($$($nesting, 'DATE_FORMAT'))];
      $send(tasks['$[]'](item), '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      if ($truthy((function() {if ($truthy(($ret_or_13 = note['$nil?']()['$!']()))) {
        return note['$empty?']()['$!']()
      } else {
        return $ret_or_13
      }; return nil; })())) {
        
        
        $logical_op_recvr_tmp_2 = tasks['$[]'](item);
        if ($truthy(($ret_or_14 = $logical_op_recvr_tmp_2['$[]']("note")))) {
          $ret_or_14
        } else {
          
          $writer = ["note", []];
          $send($logical_op_recvr_tmp_2, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        };;
        tasks['$[]'](item)['$[]']("note").$push(note);};
      self.$write_tasks(tasks);
      return self.$list(tasks);
    }, $Todo_set_priority$21.$$arity = -2);
    
    Opal.def(self, '$due_date', $Todo_due_date$22 = function $$due_date(item, date) {
      var self = this, tasks = nil, $writer = nil;

      
      
      if (date == null) {
        date = "";
      };
      tasks = self.$load_tasks(item);
      
      $writer = ["due", self.$convert_due_date(date)];
      $send(tasks['$[]'](item), '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      if ($truthy(tasks['$[]'](item)['$[]']("due")['$nil?']())) {
        tasks['$[]'](item).$delete("due")};
      
      $writer = ["modified", self.today.$strftime($$($nesting, 'DATE_FORMAT'))];
      $send(tasks['$[]'](item), '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      self.$write_tasks(tasks);
      return self.$list(tasks);
    }, $Todo_due_date$22.$$arity = -2);
    
    Opal.def(self, '$list', $Todo_list$23 = function $$list(tasks, patterns) {
      var $$24, $$26, $$27, self = this, items = nil, $ret_or_15 = nil, task_indent = nil, $ret_or_16 = nil;

      
      
      if (tasks == null) {
        tasks = nil;
      };
      
      if (patterns == null) {
        patterns = nil;
      };
      items = $hash2([], {});
      tasks = (function() {if ($truthy(($ret_or_15 = tasks))) {
        return $ret_or_15
      } else {
        return self.$load_tasks()
      }; return nil; })();
      task_indent = [tasks.$keys().$max().$to_s().$size(), 4].$max();
      patterns = (function() {if ($truthy((function() {if ($truthy(($ret_or_16 = patterns['$nil?']()))) {
        return $ret_or_16
      } else {
        return patterns['$empty?']()
      }; return nil; })())) {
        return [self.queries['$[]'](":active")]
      } else {
        return patterns
      }; return nil; })();
      $send(tasks, 'each', [], ($$24 = function(num, task){var self = $$24.$$s == null ? this : $$24.$$s, $$25, normalized_task = nil, match = nil, $writer = nil;

      
        
        if (num == null) {
          num = nil;
        };
        
        if (task == null) {
          task = nil;
        };
        normalized_task = "" + "state=" + (task['$[]']("state")) + " due=" + (task['$[]']("due")) + " " + (task['$[]']("title"));
        match = true;
        $send(patterns, 'each', [], ($$25 = function(pattern){var self = $$25.$$s == null ? this : $$25.$$s, $ret_or_17 = nil;
          if (self.queries == null) self.queries = nil;

        
          
          if (pattern == null) {
            pattern = nil;
          };
          if ($truthy(Opal.regexp([(function() {if ($truthy(($ret_or_17 = self.queries['$[]'](pattern)))) {
            return $ret_or_17
          } else {
            return pattern
          }; return nil; })()], 'i').$match(normalized_task))) {
            return nil
          } else {
            return (match = false)
          };}, $$25.$$s = self, $$25.$$arity = 1, $$25));
        if ($truthy(match)) {
          
          $writer = [num, task];
          $send(items, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        } else {
          return nil
        };}, $$24.$$s = self, $$24.$$arity = 2, $$24));
      items = $send(items, 'sort_by', [], ($$26 = function(num, task){var self = $$26.$$s == null ? this : $$26.$$s, $ret_or_18 = nil, $ret_or_19 = nil, $ret_or_20 = nil;

      
        
        if (num == null) {
          num = nil;
        };
        
        if (task == null) {
          task = nil;
        };
        return [(function() {if ($truthy((function() {if ($truthy(($ret_or_18 = task['$[]']("priority")))) {
          return task['$[]']("state")['$!=']("done")
        } else {
          return $ret_or_18
        }; return nil; })())) {
          return 0
        } else {
          return 1
        }; return nil; })(), $$($nesting, 'ORDER')['$[]']((function() {if ($truthy(($ret_or_19 = task['$[]']("state")))) {
          return $ret_or_19
        } else {
          return "default"
        }; return nil; })()), (function() {if ($truthy(($ret_or_20 = task['$[]']("due")))) {
          return $ret_or_20
        } else {
          return "n/a"
        }; return nil; })(), num];}, $$26.$$s = self, $$26.$$arity = 2, $$26));
      $send(items, 'each', [], ($$27 = function(num, task){var self = $$27.$$s == null ? this : $$27.$$s, $$28, state = nil, $ret_or_21 = nil, color = nil, display_state = nil, title = nil, priority_flag = nil, due_date = nil, $ret_or_22 = nil, date_diff = nil, $ret_or_23 = nil, $ret_or_24 = nil;
        if (self.today == null) self.today = nil;
        if (self.due_date_days == null) self.due_date_days = nil;
        if (self.text_buffer == null) self.text_buffer = nil;

      
        
        if (num == null) {
          num = nil;
        };
        
        if (task == null) {
          task = nil;
        };
        state = (function() {if ($truthy(($ret_or_21 = task['$[]']("state")))) {
          return $ret_or_21
        } else {
          return "default"
        }; return nil; })();
        color = $$($nesting, 'COLORS')['$[]'](state);
        display_state = self.$colorize($$($nesting, 'STATES')['$[]'](state), color);
        title = $send(task['$[]']("title"), 'gsub', [$$($nesting, 'CONTEXT_TAG_PATTERN')], ($$28 = function(tag){var self = $$28.$$s == null ? this : $$28.$$s;

        
          
          if (tag == null) {
            tag = nil;
          };
          return $rb_plus((function() {if ($truthy(tag['$start_with?'](" "))) {
            return " "
          } else {
            return ""
          }; return nil; })(), self.$colorize(tag.$strip(), "cyan"));}, $$28.$$s = self, $$28.$$arity = 1, $$28));
        priority_flag = (function() {if ($truthy(task['$[]']("priority"))) {
          return self.$colorize($$($nesting, 'PRIORITY_FLAG'), "red")
        } else {
          return " "
        }; return nil; })();
        due_date = "";
        if ($truthy((function() {if ($truthy(($ret_or_22 = task['$[]']("due")))) {
          return state['$!=']("done")
        } else {
          return $ret_or_22
        }; return nil; })())) {
          
          date_diff = $rb_minus($$($nesting, 'Date').$parse(task['$[]']("due")), self.today).$to_i();
          if ($truthy($rb_lt(date_diff, 0))) {
            due_date = self.$colorize("" + "(" + (date_diff.$abs()) + "d overdue)", "red")
          } else if ($truthy((function() {if ($truthy(($ret_or_23 = date_diff['$=='](0)))) {
            return $ret_or_23
          } else {
            return date_diff['$=='](1)
          }; return nil; })())) {
            due_date = self.$colorize("" + "(" + ($$($nesting, 'DUE_DATE_DAYS_SIMPLE')['$[]'](date_diff)) + ")", "yellow")
          } else if ($truthy($rb_gt(date_diff, 1))) {
            due_date = self.$colorize("" + "(" + ((function() {if ($truthy(($ret_or_24 = self.due_date_days['$[]'](date_diff)))) {
              return $ret_or_24
            } else {
              return task['$[]']("due")
            }; return nil; })()) + ")", "magenta")};
          due_date = $rb_plus(" ", due_date);};
        return self.text_buffer.$push("" + (num.$to_s().$rjust(task_indent, " ")) + ":" + (priority_flag) + (display_state) + " " + (title) + (due_date));}, $$27.$$s = self, $$27.$$arity = 2, $$27));
      if ($truthy(items['$empty?']())) {
        return self.text_buffer.$push("No todos found")
      } else {
        return nil
      };
    }, $Todo_list$23.$$arity = -1);
    
    Opal.def(self, '$add_note', $Todo_add_note$29 = function $$add_note(item, text) {
      var self = this, tasks = nil, $logical_op_recvr_tmp_3 = nil, $ret_or_25 = nil, $writer = nil;

      
      tasks = self.$load_tasks(item);
      
      $logical_op_recvr_tmp_3 = tasks['$[]'](item);
      if ($truthy(($ret_or_25 = $logical_op_recvr_tmp_3['$[]']("note")))) {
        $ret_or_25
      } else {
        
        $writer = ["note", []];
        $send($logical_op_recvr_tmp_3, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };;
      tasks['$[]'](item)['$[]']("note").$push(text);
      
      $writer = ["modified", self.today.$strftime($$($nesting, 'DATE_FORMAT'))];
      $send(tasks['$[]'](item), '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      self.$write_tasks(tasks);
      return self.$show(item);
    }, $Todo_add_note$29.$$arity = 2);
    
    Opal.def(self, '$delete_note', $Todo_delete_note$30 = function $$delete_note(item) {
      var self = this, tasks = nil, $writer = nil;

      
      tasks = self.$load_tasks(item);
      tasks['$[]'](item).$delete("note");
      
      $writer = ["modified", self.today.$strftime($$($nesting, 'DATE_FORMAT'))];
      $send(tasks['$[]'](item), '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      self.$write_tasks(tasks);
      return self.$show(item);
    }, $Todo_delete_note$30.$$arity = 1);
    
    Opal.def(self, '$show', $Todo_show$31 = function $$show(item) {
      var $$32, self = this, tasks = nil;

      
      tasks = self.$load_tasks(item);
      return $send(tasks['$[]'](item), 'each', [], ($$32 = function(key, value){var self = $$32.$$s == null ? this : $$32.$$s, val = nil;
        if (self.text_buffer == null) self.text_buffer = nil;

      
        
        if (key == null) {
          key = nil;
        };
        
        if (value == null) {
          value = nil;
        };
        val = (function() {if ($truthy(value['$kind_of?']($$($nesting, 'Array')))) {
          return $rb_plus("\n", value.$join("\n"))
        } else {
          return value
        }; return nil; })();
        return self.text_buffer.$push("" + (self.$colorize($rb_plus(key.$to_s().$rjust(10, " "), ":"), "cyan")) + " " + (val));}, $$32.$$s = self, $$32.$$arity = 2, $$32));
    }, $Todo_show$31.$$arity = 1);
    
    Opal.def(self, '$colorize', $Todo_colorize$33 = function $$colorize(text, color) {
      var self = this;

      return "" + "\e[" + ($$($nesting, 'COLOR_CODES')['$[]'](color)) + "m" + (text) + "\e[0m"
    }, $Todo_colorize$33.$$arity = 2);
    return (Opal.def(self, '$convert_due_date', $Todo_convert_due_date$34 = function $$convert_due_date(date) {
      var $$35, self = this, due = nil, day_index = nil, $ret_or_26 = nil, $ret_or_27 = nil, $ret_or_28 = nil;

      
      
      if (date == null) {
        date = "";
      };
      due = nil;
      day_index = (function() {if ($truthy(($ret_or_26 = (function() {if ($truthy(($ret_or_27 = self.due_date_days.$index(date.$to_s().$downcase())))) {
        return $ret_or_27
      } else {
        return $$($nesting, 'DUE_DATE_DAYS_SIMPLE').$index(date.$to_s().$downcase())
      }; return nil; })()))) {
        return $ret_or_26
      } else {
        return $send(self.due_date_days, 'map', [], ($$35 = function(day){var self = $$35.$$s == null ? this : $$35.$$s;

        
          
          if (day == null) {
            day = nil;
          };
          return day['$[]']($range(0, 2, false));}, $$35.$$s = self, $$35.$$arity = 1, $$35)).$index(date.$to_s().$downcase())
      }; return nil; })();
      if ($truthy(day_index)) {
        due = $rb_plus(self.today, day_index).$strftime($$($nesting, 'DATE_FORMAT'))
      } else {
        due = (function() {if ($truthy((function() {if ($truthy(($ret_or_28 = date['$nil?']()))) {
          return $ret_or_28
        } else {
          return date['$empty?']()
        }; return nil; })())) {
          return nil
        } else {
          return $$($nesting, 'Date').$parse(date).$strftime($$($nesting, 'DATE_FORMAT'))
        }; return nil; })()
      };
      return due;
    }, $Todo_convert_due_date$34.$$arity = -1), nil) && 'convert_due_date';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.1.1 */
(function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var $$1, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $send = Opal.send, todo = nil, default_callback = nil;

  Opal.add_stubs(['$require', '$new', '$lambda', '$to_html', '$execute', '$+']);
  
  self.$require("./todo.rb");
  todo = $$($nesting, 'Todo').$new();
  default_callback = $send(self, 'lambda', [], ($$1 = function(terminal, command, params){var self = $$1.$$s == null ? this : $$1.$$s;

  
    
    if (terminal == null) {
      terminal = nil;
    };
    
    if (command == null) {
      command = nil;
    };
    
    if (params == null) {
      params = nil;
    };
    
  try {
    var output = todo.$execute($rb_plus([command], params)).$to_html();
    terminal.output(output);
  } catch (error) {
    terminal.output('<span class="output"><span class="color color-31">ERROR:</span> ' + escapeHtml(error) + '</span>');
  }
  ;}, $$1.$$s = self, $$1.$$arity = 3, $$1));
  
var escapeHtml = function(obj) {
  return (obj || '').toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
};

var term = new VanillaTerminal({
  'welcome': '<u>todo list manager</u> REPL v0.1.21<br>Type "help" for more information.<br><br>',
  'defaultCallback': default_callback,
  'prompt': 'todo',
  'commands': {
    'cls': function(terminal) {
      terminal.clear();
    },
    'wipe': function(terminal) {
      terminal.prompt('Are you sure remove all your todo data? y/n', function(value) {
        if (value.trim().toUpperCase() === 'Y') {
          localStorage.removeItem($$$($$($nesting, 'Todo'), 'TODO_FILE'));
          terminal.history = [];
          terminal.historyCursor = 0;
          terminal.output('todo data wiped.');
        }
      });
    }
  }
});

try {
  term.output(todo.$execute(["list"]).$to_html());
} catch (error) {
  term.output('<span class="output"><span class="color color-31">ERROR:</span> ' + escapeHtml(error) + '</span>');
}
;
})(Opal);

/* Generated by Opal 1.1.1 */
(function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$exit']);
  return $$($nesting, 'Kernel').$exit()
})(Opal);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3J1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGdsb2JhbF9vYmplY3QpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gQG5vdGVcbiAgLy8gICBBIGZldyBjb252ZW50aW9ucyBmb3IgdGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmaWxlOlxuICAvLyAgIDEuIEFsd2F5cyB1c2UgXCIvL1wiIChpbiBjb250cmFzdCB3aXRoIFwiLyoqL1wiKVxuICAvLyAgIDIuIFRoZSBzeW50YXggdXNlZCBpcyBZYXJkb2MgKHlhcmRvYy5vcmcpLCB3aGljaCBpcyBpbnRlbmRlZCBmb3IgUnVieSAoc2UgYmVsb3cpXG4gIC8vICAgMy4gYEBwYXJhbWAgYW5kIGBAcmV0dXJuYCB0eXBlcyBzaG91bGQgYmUgcHJlY2VkZWQgYnkgYEpTLmAgd2hlbiByZWZlcnJpbmcgdG9cbiAgLy8gICAgICBKYXZhU2NyaXB0IGNvbnN0cnVjdG9ycyAoZS5nLiBgSlMuRnVuY3Rpb25gKSBvdGhlcndpc2UgUnVieSBpcyBhc3N1bWVkLlxuICAvLyAgIDQuIGBuaWxgIGFuZCBgbnVsbGAgYmVpbmcgdW5hbWJpZ3VvdXMgcmVmZXIgdG8gdGhlIHJlc3BlY3RpdmVcbiAgLy8gICAgICBvYmplY3RzL3ZhbHVlcyBpbiBSdWJ5IGFuZCBKYXZhU2NyaXB0XG4gIC8vICAgNS4gVGhpcyBpcyBzdGlsbCBXSVAgOikgc28gcGxlYXNlIGdpdmUgZmVlZGJhY2sgYW5kIHN1Z2dlc3Rpb25zIG9uIGhvd1xuICAvLyAgICAgIHRvIGltcHJvdmUgb3IgZm9yIGFsdGVybmF0aXZlIHNvbHV0aW9uc1xuICAvL1xuICAvLyAgIFRoZSB3YXkgdGhlIGNvZGUgaXMgZGlnZXN0ZWQgYmVmb3JlIGdvaW5nIHRocm91Z2ggWWFyZG9jIGlzIGEgc2VjcmV0IGtlcHRcbiAgLy8gICBpbiB0aGUgZG9jcyByZXBvIChodHRwczovL2dpdGh1Yi5jb20vb3BhbC9kb2NzL3RyZWUvbWFzdGVyKS5cblxuICB2YXIgY29uc29sZTtcblxuICAvLyBEZXRlY3QgdGhlIGdsb2JhbCBvYmplY3RcbiAgaWYgKHR5cGVvZihnbG9iYWxUaGlzKSAhPT0gJ3VuZGVmaW5lZCcpIHsgZ2xvYmFsX29iamVjdCA9IGdsb2JhbFRoaXM7IH1cbiAgZWxzZSBpZiAodHlwZW9mKGdsb2JhbCkgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSBnbG9iYWw7IH1cbiAgZWxzZSBpZiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSB3aW5kb3c7IH1cblxuICAvLyBTZXR1cCBhIGR1bW15IGNvbnNvbGUgb2JqZWN0IGlmIG1pc3NpbmdcbiAgaWYgKHR5cGVvZihnbG9iYWxfb2JqZWN0LmNvbnNvbGUpID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnNvbGUgPSBnbG9iYWxfb2JqZWN0LmNvbnNvbGU7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsX29iamVjdC5jb25zb2xlID09IG51bGwpIHtcbiAgICBjb25zb2xlID0gZ2xvYmFsX29iamVjdC5jb25zb2xlID0ge307XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZSA9IHt9O1xuICB9XG5cbiAgaWYgKCEoJ2xvZycgaW4gY29uc29sZSkpIHsgY29uc29sZS5sb2cgPSBmdW5jdGlvbiAoKSB7fTsgfVxuICBpZiAoISgnd2FybicgaW4gY29uc29sZSkpIHsgY29uc29sZS53YXJuID0gY29uc29sZS5sb2c7IH1cblxuICBpZiAodHlwZW9mKGdsb2JhbF9vYmplY3QuT3BhbCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS53YXJuKCdPcGFsIGFscmVhZHkgbG9hZGVkLiBMb2FkaW5nIHR3aWNlIGNhbiBjYXVzZSB0cm91YmxlcywgcGxlYXNlIGZpeCB5b3VyIHNldHVwLicpO1xuICAgIHJldHVybiBnbG9iYWxfb2JqZWN0Lk9wYWw7XG4gIH1cblxuICB2YXIgbmlsO1xuXG4gIC8vIFRoZSBhY3R1YWwgY2xhc3MgZm9yIEJhc2ljT2JqZWN0XG4gIHZhciBCYXNpY09iamVjdDtcblxuICAvLyBUaGUgYWN0dWFsIE9iamVjdCBjbGFzcy5cbiAgLy8gVGhlIGxlYWRpbmcgdW5kZXJzY29yZSBpcyB0byBhdm9pZCBjb25mdXNpb24gd2l0aCB3aW5kb3cuT2JqZWN0KClcbiAgdmFyIF9PYmplY3Q7XG5cbiAgLy8gVGhlIGFjdHVhbCBNb2R1bGUgY2xhc3NcbiAgdmFyIE1vZHVsZTtcblxuICAvLyBUaGUgYWN0dWFsIENsYXNzIGNsYXNzXG4gIHZhciBDbGFzcztcblxuICAvLyBUaGUgT3BhbCBvYmplY3QgdGhhdCBpcyBleHBvc2VkIGdsb2JhbGx5XG4gIHZhciBPcGFsID0gZ2xvYmFsX29iamVjdC5PcGFsID0ge307XG5cbiAgLy8gVGhpcyBpcyBhIHVzZWZ1bCByZWZlcmVuY2UgdG8gZ2xvYmFsIG9iamVjdCBpbnNpZGUgcnVieSBmaWxlc1xuICBPcGFsLmdsb2JhbCA9IGdsb2JhbF9vYmplY3Q7XG4gIGdsb2JhbF9vYmplY3QuT3BhbCA9IE9wYWw7XG5cbiAgLy8gQ29uZmlndXJlIHJ1bnRpbWUgYmVoYXZpb3Igd2l0aCByZWdhcmRzIHRvIHJlcXVpcmUgYW5kIHVuc3VwcG9ydGVkIGZlYXR1cmVzXG4gIE9wYWwuY29uZmlnID0ge1xuICAgIG1pc3NpbmdfcmVxdWlyZV9zZXZlcml0eTogJ2Vycm9yJywgICAgICAgIC8vIGVycm9yLCB3YXJuaW5nLCBpZ25vcmVcbiAgICB1bnN1cHBvcnRlZF9mZWF0dXJlc19zZXZlcml0eTogJ3dhcm5pbmcnLCAvLyBlcnJvciwgd2FybmluZywgaWdub3JlXG4gICAgZW5hYmxlX3N0YWNrX3RyYWNlOiB0cnVlICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSwgZmFsc2VcbiAgfTtcblxuICAvLyBNaW5pZnkgY29tbW9uIGZ1bmN0aW9uIGNhbGxzXG4gIHZhciAkaGFzX293biAgID0gT2JqZWN0Lmhhc093blByb3BlcnR5O1xuICB2YXIgJGJpbmQgICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuICB2YXIgJHNldF9wcm90byA9IE9iamVjdC5zZXRQcm90b3R5cGVPZjtcbiAgdmFyICRzbGljZSAgICAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gIHZhciAkc3BsaWNlICAgID0gQXJyYXkucHJvdG90eXBlLnNwbGljZTtcblxuICAvLyBOaWwgb2JqZWN0IGlkIGlzIGFsd2F5cyA0XG4gIHZhciBuaWxfaWQgPSA0O1xuXG4gIC8vIEdlbmVyYXRlcyBldmVuIHNlcXVlbnRpYWwgbnVtYmVycyBncmVhdGVyIHRoYW4gNFxuICAvLyAobmlsX2lkKSB0byBzZXJ2ZSBhcyB1bmlxdWUgaWRzIGZvciBydWJ5IG9iamVjdHNcbiAgdmFyIHVuaXF1ZV9pZCA9IG5pbF9pZDtcblxuICAvLyBSZXR1cm4gbmV4dCB1bmlxdWUgaWRcbiAgT3BhbC51aWQgPSBmdW5jdGlvbigpIHtcbiAgICB1bmlxdWVfaWQgKz0gMjtcbiAgICByZXR1cm4gdW5pcXVlX2lkO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIG9yIGFzc2lnbiB0aGUgaWQgb2YgYW4gb2JqZWN0XG4gIE9wYWwuaWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLiQkaXNfbnVtYmVyKSByZXR1cm4gKG9iaiAqIDIpKzE7XG4gICAgaWYgKG9iai4kJGlkICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBvYmouJCRpZDtcbiAgICB9XG4gICAgJGRlZmluZVByb3BlcnR5KG9iaiwgJyQkaWQnLCBPcGFsLnVpZCgpKTtcbiAgICByZXR1cm4gb2JqLiQkaWQ7XG4gIH07XG5cbiAgLy8gR2xvYmFscyB0YWJsZVxuICBPcGFsLmd2YXJzID0ge307XG5cbiAgLy8gRXhpdCBmdW5jdGlvbiwgdGhpcyBzaG91bGQgYmUgcmVwbGFjZWQgYnkgcGxhdGZvcm0gc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cbiAgLy8gKFNlZSBub2RlanMgYW5kIGNocm9tZSBmb3IgZXhhbXBsZXMpXG4gIE9wYWwuZXhpdCA9IGZ1bmN0aW9uKHN0YXR1cykgeyBpZiAoT3BhbC5ndmFycy5ERUJVRykgY29uc29sZS5sb2coJ0V4aXRlZCB3aXRoIHN0YXR1cyAnK3N0YXR1cyk7IH07XG5cbiAgLy8ga2VlcHMgdHJhY2sgb2YgZXhjZXB0aW9ucyBmb3IgJCFcbiAgT3BhbC5leGNlcHRpb25zID0gW107XG5cbiAgLy8gQHByaXZhdGVcbiAgLy8gUG9wcyBhbiBleGNlcHRpb24gZnJvbSB0aGUgc3RhY2sgYW5kIHVwZGF0ZXMgYCQhYC5cbiAgT3BhbC5wb3BfZXhjZXB0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgT3BhbC5ndmFyc1tcIiFcIl0gPSBPcGFsLmV4Y2VwdGlvbnMucG9wKCkgfHwgbmlsO1xuICB9O1xuXG4gIC8vIEluc3BlY3QgYW55IGtpbmQgb2Ygb2JqZWN0LCBpbmNsdWRpbmcgbm9uIFJ1Ynkgb25lc1xuICBPcGFsLmluc3BlY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoIW9iai4kJGNsYXNzKSB7XG4gICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG9iai4kaW5zcGVjdCgpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiAkZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBpbml0aWFsVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mKG9iamVjdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3I6XG4gICAgICAvLyAgIHMgPSBcInN0cmluZ1wiXG4gICAgICAvLyAgIGRlZiBzLm07IGVuZFxuICAgICAgLy8gU3RyaW5nIGNsYXNzIGlzIHRoZSBvbmx5IGNsYXNzIHRoYXQ6XG4gICAgICAvLyArIGNvbXBpbGVzIHRvIEpTIHByaW1pdGl2ZVxuICAgICAgLy8gKyBhbGxvd3MgbWV0aG9kIGRlZmluaXRpb24gZGlyZWN0bHkgb24gaW5zdGFuY2VzXG4gICAgICAvLyBudW1iZXJzLCB0cnVlLCBmYWxzZSBhbmQgbnVsbCBkbyBub3Qgc3VwcG9ydCBpdC5cbiAgICAgIG9iamVjdFtuYW1lXSA9IGluaXRpYWxWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICB2YWx1ZTogaW5pdGlhbFZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgT3BhbC5kZWZpbmVQcm9wZXJ0eSA9ICRkZWZpbmVQcm9wZXJ0eTtcblxuICBPcGFsLnNsaWNlID0gJHNsaWNlO1xuXG5cbiAgLy8gSGVscGVyc1xuICAvLyAtLS0tLVxuXG4gIE9wYWwudHJ1dGh5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuICh2YWwgIT09IG5pbCAmJiB2YWwgIT0gbnVsbCAmJiAoIXZhbC4kJGlzX2Jvb2xlYW4gfHwgdmFsID09IHRydWUpKTtcbiAgfTtcblxuICBPcGFsLmZhbHN5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuICh2YWwgPT09IG5pbCB8fCB2YWwgPT0gbnVsbCB8fCAodmFsLiQkaXNfYm9vbGVhbiAmJiB2YWwgPT0gZmFsc2UpKVxuICB9O1xuXG4gIE9wYWwudHlwZV9lcnJvciA9IGZ1bmN0aW9uKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBjb2VyY2VkKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0LiQkY2xhc3M7XG5cbiAgICBpZiAoY29lcmNlZCAmJiBtZXRob2QpIHtcbiAgICAgIGNvZXJjZWQgPSBjb2VyY2VkLiQkY2xhc3M7XG4gICAgICByZXR1cm4gT3BhbC5UeXBlRXJyb3IuJG5ldyhcbiAgICAgICAgXCJjYW4ndCBjb252ZXJ0IFwiICsgb2JqZWN0ICsgXCIgaW50byBcIiArIHR5cGUgK1xuICAgICAgICBcIiAoXCIgKyBvYmplY3QgKyBcIiNcIiArIG1ldGhvZCArIFwiIGdpdmVzIFwiICsgY29lcmNlZCArIFwiKVwiXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLlR5cGVFcnJvci4kbmV3KFxuICAgICAgICBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgXCIgKyBvYmplY3QgKyBcIiBpbnRvIFwiICsgdHlwZVxuICAgICAgKVxuICAgIH1cbiAgfTtcblxuICBPcGFsLmNvZXJjZV90byA9IGZ1bmN0aW9uKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBhcmdzKSB7XG4gICAgaWYgKHR5cGVbJyQ9PT0nXShvYmplY3QpKSByZXR1cm4gb2JqZWN0O1xuXG4gICAgaWYgKCFvYmplY3RbJyRyZXNwb25kX3RvPyddKG1ldGhvZCkpIHtcbiAgICAgIHRocm93IE9wYWwudHlwZV9lcnJvcihvYmplY3QsIHR5cGUpO1xuICAgIH1cblxuICAgIGlmIChhcmdzID09IG51bGwpIGFyZ3MgPSBbXTtcbiAgICByZXR1cm4gT3BhbC5zZW5kKG9iamVjdCwgbWV0aG9kLCBhcmdzKTtcbiAgfVxuXG4gIE9wYWwucmVzcG9uZF90byA9IGZ1bmN0aW9uKG9iaiwganNpZCwgaW5jbHVkZV9hbGwpIHtcbiAgICBpZiAob2JqID09IG51bGwgfHwgIW9iai4kJGNsYXNzKSByZXR1cm4gZmFsc2U7XG4gICAgaW5jbHVkZV9hbGwgPSAhIWluY2x1ZGVfYWxsO1xuICAgIHZhciBib2R5ID0gb2JqW2pzaWRdO1xuXG4gICAgaWYgKG9ialsnJHJlc3BvbmRfdG8/J10uJCRwcmlzdGluZSkge1xuICAgICAgaWYgKG9ialsnJHJlc3BvbmRfdG9fbWlzc2luZz8nXS4kJHByaXN0aW5lKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YoYm9keSkgPT09IFwiZnVuY3Rpb25cIiAmJiAhYm9keS4kJHN0dWI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5zZW5kKG9iaiwgb2JqWyckcmVzcG9uZF90b19taXNzaW5nPyddLCBbanNpZC5zdWJzdHIoMSksIGluY2x1ZGVfYWxsXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLnNlbmQob2JqLCBvYmpbJyRyZXNwb25kX3RvPyddLCBbanNpZC5zdWJzdHIoMSksIGluY2x1ZGVfYWxsXSk7XG4gICAgfVxuICB9XG5cblxuICAvLyBDb25zdGFudHNcbiAgLy8gLS0tLS0tLS0tXG4gIC8vXG4gIC8vIEZvciBmdXR1cmUgcmVmZXJlbmNlOlxuICAvLyAtIFRoZSBSYWlscyBhdXRvbG9hZGluZyBndWlkZSAoaHR0cDovL2d1aWRlcy5ydWJ5b25yYWlscy5vcmcvdjUuMC9hdXRvbG9hZGluZ19hbmRfcmVsb2FkaW5nX2NvbnN0YW50cy5odG1sKVxuICAvLyAtIEBDb25yYWRJcndpbidzIDIwMTIgcG9zdCBvbiDigJxFdmVyeXRoaW5nIHlvdSBldmVyIHdhbnRlZCB0byBrbm93IGFib3V0IGNvbnN0YW50IGxvb2t1cCBpbiBSdWJ54oCdIChodHRwOi8vY2lydy5pbi9ibG9nL2NvbnN0YW50LWxvb2t1cC5odG1sKVxuICAvL1xuICAvLyBMZWdlbmQgb2YgTVJJIGNvbmNlcHRzL25hbWVzOlxuICAvLyAtIGNvbnN0YW50IHJlZmVyZW5jZSAoY3JlZik6IHRoZSBtb2R1bGUvY2xhc3MgdGhhdCBhY3RzIGFzIGEgbmFtZXNwYWNlXG4gIC8vIC0gbmVzdGluZzogdGhlIG5hbWVzcGFjZXMgd3JhcHBpbmcgdGhlIGN1cnJlbnQgc2NvcGUsIGUuZy4gbmVzdGluZyBpbnNpZGVcbiAgLy8gICAgICAgICAgICBgbW9kdWxlIEE7IG1vZHVsZSBCOjpDOyBlbmQ7IGVuZGAgaXMgYFtCOjpDLCBBXWBcblxuICAvLyBHZXQgdGhlIGNvbnN0YW50IGluIHRoZSBzY29wZSBvZiB0aGUgY3VycmVudCBjcmVmXG4gIGZ1bmN0aW9uIGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpIHtcbiAgICBpZiAoY3JlZikgcmV0dXJuIGNyZWYuJCRjb25zdFtuYW1lXTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIG5lc3RpbmcgYXJyYXkgbG9va2luZyBmb3IgdGhlIGNvbnN0YW50XG4gIGZ1bmN0aW9uIGNvbnN0X2xvb2t1cF9uZXN0aW5nKG5lc3RpbmcsIG5hbWUpIHtcbiAgICB2YXIgaSwgaWksIGNvbnN0YW50O1xuXG4gICAgaWYgKG5lc3RpbmcubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAvLyBJZiB0aGUgbmVzdGluZyBpcyBub3QgZW1wdHkgdGhlIGNvbnN0YW50IGlzIGxvb2tlZCB1cCBpbiBpdHMgZWxlbWVudHNcbiAgICAvLyBhbmQgaW4gb3JkZXIuIFRoZSBhbmNlc3RvcnMgb2YgdGhvc2UgZWxlbWVudHMgYXJlIGlnbm9yZWQuXG4gICAgZm9yIChpID0gMCwgaWkgPSBuZXN0aW5nLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0YW50ID0gbmVzdGluZ1tpXS4kJGNvbnN0W25hbWVdO1xuICAgICAgaWYgKGNvbnN0YW50ICE9IG51bGwpIHJldHVybiBjb25zdGFudDtcbiAgICB9XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSBhbmNlc3RvcnMgY2hhaW4gbG9va2luZyBmb3IgdGhlIGNvbnN0YW50XG4gIGZ1bmN0aW9uIGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoY3JlZiwgbmFtZSkge1xuICAgIHZhciBpLCBpaSwgYW5jZXN0b3JzO1xuXG4gICAgaWYgKGNyZWYgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMoY3JlZik7XG5cbiAgICBmb3IgKGkgPSAwLCBpaSA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpZiAoYW5jZXN0b3JzW2ldLiQkY29uc3QgJiYgJGhhc19vd24uY2FsbChhbmNlc3RvcnNbaV0uJCRjb25zdCwgbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9yc1tpXS4kJGNvbnN0W25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdhbGsgdXAgT2JqZWN0J3MgYW5jZXN0b3JzIGNoYWluIGxvb2tpbmcgZm9yIHRoZSBjb25zdGFudCxcbiAgLy8gYnV0IG9ubHkgaWYgY3JlZiBpcyBtaXNzaW5nIG9yIGEgbW9kdWxlLlxuICBmdW5jdGlvbiBjb25zdF9sb29rdXBfT2JqZWN0KGNyZWYsIG5hbWUpIHtcbiAgICBpZiAoY3JlZiA9PSBudWxsIHx8IGNyZWYuJCRpc19tb2R1bGUpIHtcbiAgICAgIHJldHVybiBjb25zdF9sb29rdXBfYW5jZXN0b3JzKF9PYmplY3QsIG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGwgY29uc3RfbWlzc2luZyBpZiBub3RoaW5nIGVsc2Ugd29ya2VkXG4gIGZ1bmN0aW9uIGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKSB7XG4gICAgaWYgKCFza2lwX21pc3NpbmcpIHtcbiAgICAgIHJldHVybiAoY3JlZiB8fCBfT2JqZWN0KS4kY29uc3RfbWlzc2luZyhuYW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBMb29rIGZvciB0aGUgY29uc3RhbnQganVzdCBpbiB0aGUgY3VycmVudCBjcmVmIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYFxuICBPcGFsLmNvbnN0X2dldF9sb2NhbCA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZykge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBpZiAoY3JlZiA9PSBudWxsKSByZXR1cm47XG5cbiAgICBpZiAoY3JlZiA9PT0gJzo6JykgY3JlZiA9IF9PYmplY3Q7XG5cbiAgICBpZiAoIWNyZWYuJCRpc19tb2R1bGUgJiYgIWNyZWYuJCRpc19jbGFzcykge1xuICAgICAgdGhyb3cgbmV3IE9wYWwuVHlwZUVycm9yKGNyZWYudG9TdHJpbmcoKSArIFwiIGlzIG5vdCBhIGNsYXNzL21vZHVsZVwiKTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBjb25zdF9nZXRfbmFtZShjcmVmLCBuYW1lKTsgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXN1bHQgPSBjb25zdF9taXNzaW5nKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZyk7IGlmIChyZXN1bHQgIT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBMb29rIGZvciB0aGUgY29uc3RhbnQgcmVsYXRpdmUgdG8gYSBjcmVmIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYCAod2hlbiB0aGVcbiAgLy8gY29uc3RhbnQgaXMgcHJlZml4ZWQgYnkgYDo6YCkuXG4gIE9wYWwuY29uc3RfZ2V0X3F1YWxpZmllZCA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZykge1xuICAgIHZhciByZXN1bHQsIGNhY2hlLCBjYWNoZWQsIGN1cnJlbnRfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbjtcblxuICAgIGlmIChjcmVmID09IG51bGwpIHJldHVybjtcblxuICAgIGlmIChjcmVmID09PSAnOjonKSBjcmVmID0gX09iamVjdDtcblxuICAgIGlmICghY3JlZi4kJGlzX21vZHVsZSAmJiAhY3JlZi4kJGlzX2NsYXNzKSB7XG4gICAgICB0aHJvdyBuZXcgT3BhbC5UeXBlRXJyb3IoY3JlZi50b1N0cmluZygpICsgXCIgaXMgbm90IGEgY2xhc3MvbW9kdWxlXCIpO1xuICAgIH1cblxuICAgIGlmICgoY2FjaGUgPSBjcmVmLiQkY29uc3RfY2FjaGUpID09IG51bGwpIHtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShjcmVmLCAnJCRjb25zdF9jYWNoZScsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgY2FjaGUgPSBjcmVmLiQkY29uc3RfY2FjaGU7XG4gICAgfVxuICAgIGNhY2hlZCA9IGNhY2hlW25hbWVdO1xuXG4gICAgaWYgKGNhY2hlZCA9PSBudWxsIHx8IGNhY2hlZFswXSAhPT0gY3VycmVudF92ZXJzaW9uKSB7XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpKSAgICAgICAgICAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhjcmVmLCBuYW1lKSkgICAgICAhPSBudWxsKTtcbiAgICAgIGNhY2hlW25hbWVdID0gW2N1cnJlbnRfdmVyc2lvbiwgcmVzdWx0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY2FjaGVkWzFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKTtcbiAgfTtcblxuICAvLyBJbml0aWFsaXplIHRoZSB0b3AgbGV2ZWwgY29uc3RhbnQgY2FjaGUgZ2VuZXJhdGlvbiBjb3VudGVyXG4gIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbiA9IDE7XG5cbiAgLy8gTG9vayBmb3IgdGhlIGNvbnN0YW50IGluIHRoZSBvcGVuIHVzaW5nIHRoZSBjdXJyZW50IG5lc3RpbmcgYW5kIHRoZSBuZWFyZXN0XG4gIC8vIGNyZWYgYW5jZXN0b3JzIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYCAod2hlbiB0aGUgY29uc3RhbnQgaGFzIG5vIDo6IHByZWZpeCkuXG4gIE9wYWwuY29uc3RfZ2V0X3JlbGF0aXZlID0gZnVuY3Rpb24obmVzdGluZywgbmFtZSwgc2tpcF9taXNzaW5nKSB7XG4gICAgdmFyIGNyZWYgPSBuZXN0aW5nWzBdLCByZXN1bHQsIGN1cnJlbnRfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbiwgY2FjaGUsIGNhY2hlZDtcblxuICAgIGlmICgoY2FjaGUgPSBuZXN0aW5nLiQkY29uc3RfY2FjaGUpID09IG51bGwpIHtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShuZXN0aW5nLCAnJCRjb25zdF9jYWNoZScsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgY2FjaGUgPSBuZXN0aW5nLiQkY29uc3RfY2FjaGU7XG4gICAgfVxuICAgIGNhY2hlZCA9IGNhY2hlW25hbWVdO1xuXG4gICAgaWYgKGNhY2hlZCA9PSBudWxsIHx8IGNhY2hlZFswXSAhPT0gY3VycmVudF92ZXJzaW9uKSB7XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpKSAgICAgICAgICAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX25lc3RpbmcobmVzdGluZywgbmFtZSkpICAgICAhPSBudWxsKSB8fFxuICAgICAgKChyZXN1bHQgPSBjb25zdF9sb29rdXBfYW5jZXN0b3JzKGNyZWYsIG5hbWUpKSAgICAgICE9IG51bGwpIHx8XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2xvb2t1cF9PYmplY3QoY3JlZiwgbmFtZSkpICAgICAgICAgIT0gbnVsbCk7XG5cbiAgICAgIGNhY2hlW25hbWVdID0gW2N1cnJlbnRfdmVyc2lvbiwgcmVzdWx0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY2FjaGVkWzFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKTtcbiAgfTtcblxuICAvLyBSZWdpc3RlciB0aGUgY29uc3RhbnQgb24gYSBjcmVmIGFuZCBvcHBvcnR1bmlzdGljYWxseSBzZXQgdGhlIG5hbWUgb2ZcbiAgLy8gdW5uYW1lZCBjbGFzc2VzL21vZHVsZXMuXG4gIE9wYWwuY29uc3Rfc2V0ID0gZnVuY3Rpb24oY3JlZiwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoY3JlZiA9PSBudWxsIHx8IGNyZWYgPT09ICc6OicpIGNyZWYgPSBfT2JqZWN0O1xuXG4gICAgaWYgKHZhbHVlLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgIGlmICh2YWx1ZS4kJG5hbWUgPT0gbnVsbCB8fCB2YWx1ZS4kJG5hbWUgPT09IG5pbCkgdmFsdWUuJCRuYW1lID0gbmFtZTtcbiAgICAgIGlmICh2YWx1ZS4kJGJhc2VfbW9kdWxlID09IG51bGwpIHZhbHVlLiQkYmFzZV9tb2R1bGUgPSBjcmVmO1xuICAgIH1cblxuICAgIGNyZWYuJCRjb25zdCA9IChjcmVmLiQkY29uc3QgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgY3JlZi4kJGNvbnN0W25hbWVdID0gdmFsdWU7XG5cbiAgICAvLyBBZGQgYSBzaG9ydCBoZWxwZXIgdG8gbmF2aWdhdGUgY29uc3RhbnRzIG1hbnVhbGx5LlxuICAgIC8vIEBleGFtcGxlXG4gICAgLy8gICBPcGFsLiQkLlJlZ2V4cC4kJC5JR05PUkVDQVNFXG4gICAgY3JlZi4kJCA9IGNyZWYuJCRjb25zdDtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuXG4gICAgLy8gRXhwb3NlIHRvcCBsZXZlbCBjb25zdGFudHMgb250byB0aGUgT3BhbCBvYmplY3RcbiAgICBpZiAoY3JlZiA9PT0gX09iamVjdCkgT3BhbFtuYW1lXSA9IHZhbHVlO1xuXG4gICAgLy8gTmFtZSBuZXcgY2xhc3MgZGlyZWN0bHkgb250byBjdXJyZW50IHNjb3BlIChPcGFsLkZvby5CYXogPSBrbGFzcylcbiAgICAkZGVmaW5lUHJvcGVydHkoY3JlZiwgbmFtZSwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIEdldCBhbGwgdGhlIGNvbnN0YW50cyByZWFjaGFibGUgZnJvbSBhIGdpdmVuIGNyZWYsIGJ5IGRlZmF1bHQgd2lsbCBpbmNsdWRlXG4gIC8vIGluaGVyaXRlZCBjb25zdGFudHMuXG4gIE9wYWwuY29uc3RhbnRzID0gZnVuY3Rpb24oY3JlZiwgaW5oZXJpdCkge1xuICAgIGlmIChpbmhlcml0ID09IG51bGwpIGluaGVyaXQgPSB0cnVlO1xuXG4gICAgdmFyIG1vZHVsZSwgbW9kdWxlcyA9IFtjcmVmXSwgaSwgaWksIGNvbnN0YW50cyA9IHt9LCBjb25zdGFudDtcblxuICAgIGlmIChpbmhlcml0KSBtb2R1bGVzID0gbW9kdWxlcy5jb25jYXQoT3BhbC5hbmNlc3RvcnMoY3JlZikpO1xuICAgIGlmIChpbmhlcml0ICYmIGNyZWYuJCRpc19tb2R1bGUpIG1vZHVsZXMgPSBtb2R1bGVzLmNvbmNhdChbT3BhbC5PYmplY3RdKS5jb25jYXQoT3BhbC5hbmNlc3RvcnMoT3BhbC5PYmplY3QpKTtcblxuICAgIGZvciAoaSA9IDAsIGlpID0gbW9kdWxlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBtb2R1bGUgPSBtb2R1bGVzW2ldO1xuXG4gICAgICAvLyBEbyBub3Qgc2hvdyBPYmplY3RzIGNvbnN0YW50cyB1bmxlc3Mgd2UncmUgcXVlcnlpbmcgT2JqZWN0IGl0c2VsZlxuICAgICAgaWYgKGNyZWYgIT09IF9PYmplY3QgJiYgbW9kdWxlID09IF9PYmplY3QpIGJyZWFrO1xuXG4gICAgICBmb3IgKGNvbnN0YW50IGluIG1vZHVsZS4kJGNvbnN0KSB7XG4gICAgICAgIGNvbnN0YW50c1tjb25zdGFudF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhjb25zdGFudHMpO1xuICB9O1xuXG4gIC8vIFJlbW92ZSBhIGNvbnN0YW50IGZyb20gYSBjcmVmLlxuICBPcGFsLmNvbnN0X3JlbW92ZSA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUpIHtcbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcblxuICAgIGlmIChjcmVmLiQkY29uc3RbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgdmFyIG9sZCA9IGNyZWYuJCRjb25zdFtuYW1lXTtcbiAgICAgIGRlbGV0ZSBjcmVmLiQkY29uc3RbbmFtZV07XG4gICAgICByZXR1cm4gb2xkO1xuICAgIH1cblxuICAgIGlmIChjcmVmLiQkYXV0b2xvYWQgIT0gbnVsbCAmJiBjcmVmLiQkYXV0b2xvYWRbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgZGVsZXRlIGNyZWYuJCRhdXRvbG9hZFtuYW1lXTtcbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuXG4gICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcImNvbnN0YW50IFwiK2NyZWYrXCI6OlwiK2NyZWYuJG5hbWUoKStcIiBub3QgZGVmaW5lZFwiKTtcbiAgfTtcblxuICAvLyBTZXR1cCBzb21lIHNob3J0Y3V0cyB0byByZWR1Y2UgY29tcGlsZWQgc2l6ZVxuICBPcGFsLiQkID0gT3BhbC5jb25zdF9nZXRfcmVsYXRpdmU7XG4gIE9wYWwuJCQkID0gT3BhbC5jb25zdF9nZXRfcXVhbGlmaWVkO1xuXG5cbiAgLy8gTW9kdWxlcyAmIENsYXNzZXNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBBIGBjbGFzcyBGb287IGVuZGAgZXhwcmVzc2lvbiBpbiBydWJ5IGlzIGNvbXBpbGVkIHRvIGNhbGwgdGhpcyBydW50aW1lXG4gIC8vIG1ldGhvZCB3aGljaCBlaXRoZXIgcmV0dXJucyBhbiBleGlzdGluZyBjbGFzcyBvZiB0aGUgZ2l2ZW4gbmFtZSwgb3IgY3JlYXRlc1xuICAvLyBhIG5ldyBjbGFzcyBpbiB0aGUgZ2l2ZW4gYGJhc2VgIHNjb3BlLlxuICAvL1xuICAvLyBJZiBhIGNvbnN0YW50IHdpdGggdGhlIGdpdmVuIG5hbWUgZXhpc3RzLCB0aGVuIHdlIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0XG4gIC8vIGl0IGlzIGEgY2xhc3MgYW5kIGFsc28gdGhhdCB0aGUgc3VwZXJjbGFzc2VzIG1hdGNoLiBJZiBlaXRoZXIgb2YgdGhlc2VcbiAgLy8gZmFpbCwgdGhlbiB3ZSByYWlzZSBhIGBUeXBlRXJyb3JgLiBOb3RlLCBgc3VwZXJjbGFzc2AgbWF5IGJlIG51bGwgaWYgb25lXG4gIC8vIHdhcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBydWJ5IGNvZGUuXG4gIC8vXG4gIC8vIFdlIHBhc3MgYSBjb25zdHJ1Y3RvciB0byB0aGlzIG1ldGhvZCBvZiB0aGUgZm9ybSBgZnVuY3Rpb24gQ2xhc3NOYW1lKCkge31gXG4gIC8vIHNpbXBseSBzbyB0aGF0IGNsYXNzZXMgc2hvdyB1cCB3aXRoIG5pY2VseSBmb3JtYXR0ZWQgbmFtZXMgaW5zaWRlIGRlYnVnZ2Vyc1xuICAvLyBpbiB0aGUgd2ViIGJyb3dzZXIgKG9yIG5vZGUvc3Byb2NrZXRzKS5cbiAgLy9cbiAgLy8gVGhlIGBzY29wZWAgaXMgdGhlIGN1cnJlbnQgYHNlbGZgIHZhbHVlIHdoZXJlIHRoZSBjbGFzcyBpcyBiZWluZyBjcmVhdGVkXG4gIC8vIGZyb20uIFdlIHVzZSB0aGlzIHRvIGdldCB0aGUgc2NvcGUgZm9yIHdoZXJlIHRoZSBjbGFzcyBzaG91bGQgYmUgY3JlYXRlZC5cbiAgLy8gSWYgYHNjb3BlYCBpcyBhbiBvYmplY3QgKG5vdCBhIGNsYXNzL21vZHVsZSksIHdlIHNpbXBsZSBnZXQgaXRzIGNsYXNzIGFuZFxuICAvLyB1c2UgdGhhdCBhcyB0aGUgc2NvcGUgaW5zdGVhZC5cbiAgLy9cbiAgLy8gQHBhcmFtIHNjb3BlICAgICAgICBbT2JqZWN0XSB3aGVyZSB0aGUgY2xhc3MgaXMgYmVpbmcgY3JlYXRlZFxuICAvLyBAcGFyYW0gc3VwZXJjbGFzcyAgW0NsYXNzLG51bGxdIHN1cGVyY2xhc3Mgb2YgdGhlIG5ldyBjbGFzcyAobWF5IGJlIG51bGwpXG4gIC8vIEBwYXJhbSBpZCAgICAgICAgICBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgY2xhc3MgdG8gYmUgY3JlYXRlZFxuICAvLyBAcGFyYW0gY29uc3RydWN0b3IgW0pTLkZ1bmN0aW9uXSBmdW5jdGlvbiB0byB1c2UgYXMgY29uc3RydWN0b3JcbiAgLy9cbiAgLy8gQHJldHVybiBuZXcgW0NsYXNzXSAgb3IgZXhpc3RpbmcgcnVieSBjbGFzc1xuICAvL1xuICBPcGFsLmFsbG9jYXRlX2NsYXNzID0gZnVuY3Rpb24obmFtZSwgc3VwZXJjbGFzcykge1xuICAgIHZhciBrbGFzcywgY29uc3RydWN0b3I7XG5cbiAgICBpZiAoc3VwZXJjbGFzcyAhPSBudWxsICYmIHN1cGVyY2xhc3MuJCRicmlkZ2UpIHtcbiAgICAgIC8vIEluaGVyaXRhbmNlIGZyb20gYnJpZGdlZCBjbGFzc2VzIHJlcXVpcmVzXG4gICAgICAvLyBjYWxsaW5nIG9yaWdpbmFsIEpTIGNvbnN0cnVjdG9yc1xuICAgICAgY29uc3RydWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSAkc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgc2VsZiA9IG5ldyAoJGJpbmQuYXBwbHkoc3VwZXJjbGFzcy4kJGNvbnN0cnVjdG9yLCBbbnVsbF0uY29uY2F0KGFyZ3MpKSkoKTtcblxuICAgICAgICAvLyBhbmQgcmVwbGFjaW5nIGEgX19wcm90b19fIG1hbnVhbGx5XG4gICAgICAgICRzZXRfcHJvdG8oc2VsZiwga2xhc3MuJCRwcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3RydWN0b3IgPSBmdW5jdGlvbigpe307XG4gICAgfVxuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgJ2Rpc3BsYXlOYW1lJywgJzo6JytuYW1lKTtcbiAgICB9XG5cbiAgICBrbGFzcyA9IGNvbnN0cnVjdG9yO1xuXG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRuYW1lJywgbmFtZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRjb25zdHJ1Y3RvcicsIGNvbnN0cnVjdG9yKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJHByb3RvdHlwZScsIGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRjb25zdCcsIHt9KTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGlzX2NsYXNzJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRpc19hX21vZHVsZScsIHRydWUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkc3VwZXInLCBzdXBlcmNsYXNzKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGN2YXJzJywge30pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkb3duX2luY2x1ZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRvd25fcHJlcGVuZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRhbmNlc3RvcnMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbicsIG51bGwpO1xuXG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLiQkcHJvdG90eXBlLCAnJCRjbGFzcycsIGtsYXNzKTtcblxuICAgIC8vIEJ5IGRlZmF1bHQgaWYgdGhlcmUgYXJlIG5vIHNpbmdsZXRvbiBjbGFzcyBtZXRob2RzXG4gICAgLy8gX19wcm90b19fIGlzIENsYXNzLnByb3RvdHlwZVxuICAgIC8vIExhdGVyIHNpbmdsZXRvbiBtZXRob2RzIGdlbmVyYXRlIGEgc2luZ2xldG9uX2NsYXNzXG4gICAgLy8gYW5kIGluamVjdCBpdCBpbnRvIGFuY2VzdG9ycyBjaGFpblxuICAgIGlmIChPcGFsLkNsYXNzKSB7XG4gICAgICAkc2V0X3Byb3RvKGtsYXNzLCBPcGFsLkNsYXNzLnByb3RvdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHN1cGVyY2xhc3MgIT0gbnVsbCkge1xuICAgICAgJHNldF9wcm90byhrbGFzcy4kJHByb3RvdHlwZSwgc3VwZXJjbGFzcy4kJHByb3RvdHlwZSk7XG5cbiAgICAgIGlmIChzdXBlcmNsYXNzLiQkbWV0YSkge1xuICAgICAgICAvLyBJZiBzdXBlcmNsYXNzIGhhcyBtZXRhY2xhc3MgdGhlbiB3ZSBoYXZlIGV4cGxpY2l0ZWx5IGluaGVyaXQgaXQuXG4gICAgICAgIE9wYWwuYnVpbGRfY2xhc3Nfc2luZ2xldG9uX2NsYXNzKGtsYXNzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga2xhc3M7XG4gIH07XG5cblxuICBmdW5jdGlvbiBmaW5kX2V4aXN0aW5nX2NsYXNzKHNjb3BlLCBuYW1lKSB7XG4gICAgLy8gVHJ5IHRvIGZpbmQgdGhlIGNsYXNzIGluIHRoZSBjdXJyZW50IHNjb3BlXG4gICAgdmFyIGtsYXNzID0gY29uc3RfZ2V0X25hbWUoc2NvcGUsIG5hbWUpO1xuXG4gICAgLy8gSWYgdGhlIGNsYXNzIGV4aXN0cyBpbiB0aGUgc2NvcGUsIHRoZW4gd2UgbXVzdCB1c2UgdGhhdFxuICAgIGlmIChrbGFzcykge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBleGlzdGluZyBjb25zdGFudCBpcyBhIGNsYXNzLCBvciByYWlzZSBlcnJvclxuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzKSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcobmFtZSArIFwiIGlzIG5vdCBhIGNsYXNzXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5zdXJlU3VwZXJjbGFzc01hdGNoKGtsYXNzLCBzdXBlcmNsYXNzKSB7XG4gICAgaWYgKGtsYXNzLiQkc3VwZXIgIT09IHN1cGVyY2xhc3MpIHtcbiAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJzdXBlcmNsYXNzIG1pc21hdGNoIGZvciBjbGFzcyBcIiArIGtsYXNzLiQkbmFtZSk7XG4gICAgfVxuICB9XG5cbiAgT3BhbC5rbGFzcyA9IGZ1bmN0aW9uKHNjb3BlLCBzdXBlcmNsYXNzLCBuYW1lKSB7XG4gICAgdmFyIGJyaWRnZWQ7XG5cbiAgICBpZiAoc2NvcGUgPT0gbnVsbCkge1xuICAgICAgLy8gR2xvYmFsIHNjb3BlXG4gICAgICBzY29wZSA9IF9PYmplY3Q7XG4gICAgfSBlbHNlIGlmICghc2NvcGUuJCRpc19jbGFzcyAmJiAhc2NvcGUuJCRpc19tb2R1bGUpIHtcbiAgICAgIC8vIFNjb3BlIGlzIGFuIG9iamVjdCwgdXNlIGl0cyBjbGFzc1xuICAgICAgc2NvcGUgPSBzY29wZS4kJGNsYXNzO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBzdXBlcmNsYXNzIGlzIG5vdCBhbiBPcGFsLWdlbmVyYXRlZCBjbGFzcyB0aGVuIHdlJ3JlIGJyaWRnaW5nIGEgbmF0aXZlIEpTIGNsYXNzXG4gICAgaWYgKHN1cGVyY2xhc3MgIT0gbnVsbCAmJiAhc3VwZXJjbGFzcy5oYXNPd25Qcm9wZXJ0eSgnJCRpc19jbGFzcycpKSB7XG4gICAgICBicmlkZ2VkID0gc3VwZXJjbGFzcztcbiAgICAgIHN1cGVyY2xhc3MgPSBfT2JqZWN0O1xuICAgIH1cblxuICAgIHZhciBrbGFzcyA9IGZpbmRfZXhpc3RpbmdfY2xhc3Moc2NvcGUsIG5hbWUpO1xuXG4gICAgaWYgKGtsYXNzKSB7XG4gICAgICBpZiAoc3VwZXJjbGFzcykge1xuICAgICAgICAvLyBNYWtlIHN1cmUgZXhpc3RpbmcgY2xhc3MgaGFzIHNhbWUgc3VwZXJjbGFzc1xuICAgICAgICBlbnN1cmVTdXBlcmNsYXNzTWF0Y2goa2xhc3MsIHN1cGVyY2xhc3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cblxuICAgIC8vIENsYXNzIGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBhIG5ldyBvbmUgd2l0aCBnaXZlbiBzdXBlcmNsYXNzLi4uXG5cbiAgICAvLyBOb3Qgc3BlY2lmeWluZyBhIHN1cGVyY2xhc3MgbWVhbnMgd2UgY2FuIGFzc3VtZSBpdCB0byBiZSBPYmplY3RcbiAgICBpZiAoc3VwZXJjbGFzcyA9PSBudWxsKSB7XG4gICAgICBzdXBlcmNsYXNzID0gX09iamVjdDtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdGhlIGNsYXNzIG9iamVjdCAoaW5zdGFuY2Ugb2YgQ2xhc3MpXG4gICAga2xhc3MgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKG5hbWUsIHN1cGVyY2xhc3MpO1xuICAgIE9wYWwuY29uc3Rfc2V0KHNjb3BlLCBuYW1lLCBrbGFzcyk7XG5cbiAgICAvLyBDYWxsIC5pbmhlcml0ZWQoKSBob29rIHdpdGggbmV3IGNsYXNzIG9uIHRoZSBzdXBlcmNsYXNzXG4gICAgaWYgKHN1cGVyY2xhc3MuJGluaGVyaXRlZCkge1xuICAgICAgc3VwZXJjbGFzcy4kaW5oZXJpdGVkKGtsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAoYnJpZGdlZCkge1xuICAgICAgT3BhbC5icmlkZ2UoYnJpZGdlZCwga2xhc3MpO1xuICAgIH1cblxuICAgIHJldHVybiBrbGFzcztcbiAgfTtcblxuICAvLyBEZWZpbmUgbmV3IG1vZHVsZSAob3IgcmV0dXJuIGV4aXN0aW5nIG1vZHVsZSkuIFRoZSBnaXZlbiBgc2NvcGVgIGlzIGJhc2ljYWxseVxuICAvLyB0aGUgY3VycmVudCBgc2VsZmAgdmFsdWUgdGhlIGBtb2R1bGVgIHN0YXRlbWVudCB3YXMgZGVmaW5lZCBpbi4gSWYgdGhpcyBpc1xuICAvLyBhIHJ1YnkgbW9kdWxlIG9yIGNsYXNzLCB0aGVuIGl0IGlzIHVzZWQsIG90aGVyd2lzZSBpZiB0aGUgc2NvcGUgaXMgYSBydWJ5XG4gIC8vIG9iamVjdCB0aGVuIHRoYXQgb2JqZWN0cyByZWFsIHJ1YnkgY2xhc3MgaXMgdXNlZCAoZS5nLiBpZiB0aGUgc2NvcGUgaXMgdGhlXG4gIC8vIG1haW4gb2JqZWN0LCB0aGVuIHRoZSB0b3AgbGV2ZWwgYE9iamVjdGAgY2xhc3MgaXMgdXNlZCBhcyB0aGUgc2NvcGUpLlxuICAvL1xuICAvLyBJZiBhIG1vZHVsZSBvZiB0aGUgZ2l2ZW4gbmFtZSBpcyBhbHJlYWR5IGRlZmluZWQgaW4gdGhlIHNjb3BlLCB0aGVuIHRoYXRcbiAgLy8gaW5zdGFuY2UgaXMganVzdCByZXR1cm5lZC5cbiAgLy9cbiAgLy8gSWYgdGhlcmUgaXMgYSBjbGFzcyBvZiB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGUgc2NvcGUsIHRoZW4gYW4gZXJyb3IgaXNcbiAgLy8gZ2VuZXJhdGVkIGluc3RlYWQgKGNhbm5vdCBoYXZlIGEgY2xhc3MgYW5kIG1vZHVsZSBvZiBzYW1lIG5hbWUgaW4gc2FtZSBzY29wZSkuXG4gIC8vXG4gIC8vIE90aGVyd2lzZSwgYSBuZXcgbW9kdWxlIGlzIGNyZWF0ZWQgaW4gdGhlIHNjb3BlIHdpdGggdGhlIGdpdmVuIG5hbWUsIGFuZCB0aGF0XG4gIC8vIG5ldyBpbnN0YW5jZSBpcyByZXR1cm5lZCBiYWNrICh0byBiZSByZWZlcmVuY2VkIGF0IHJ1bnRpbWUpLlxuICAvL1xuICAvLyBAcGFyYW0gIHNjb3BlIFtNb2R1bGUsIENsYXNzXSBjbGFzcyBvciBtb2R1bGUgdGhpcyBkZWZpbml0aW9uIGlzIGluc2lkZVxuICAvLyBAcGFyYW0gIGlkICAgW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIG5ldyAob3IgZXhpc3RpbmcpIG1vZHVsZVxuICAvL1xuICAvLyBAcmV0dXJuIFtNb2R1bGVdXG4gIE9wYWwuYWxsb2NhdGVfbW9kdWxlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCl7fTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgJGRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnZGlzcGxheU5hbWUnLCBuYW1lKycuJCRjb25zdHJ1Y3RvcicpO1xuICAgIH1cblxuICAgIHZhciBtb2R1bGUgPSBjb25zdHJ1Y3RvcjtcblxuICAgIGlmIChuYW1lKVxuICAgICAgJGRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnZGlzcGxheU5hbWUnLCBuYW1lKycuY29uc3RydWN0b3InKTtcblxuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJG5hbWUnLCBuYW1lKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnJCRwcm90b3R5cGUnLCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGNvbnN0Jywge30pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGlzX21vZHVsZScsIHRydWUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGlzX2FfbW9kdWxlJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkY3ZhcnMnLCB7fSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkaWNsYXNzZXMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkb3duX2luY2x1ZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkb3duX3ByZXBlbmRlZF9tb2R1bGVzJywgW10pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGFuY2VzdG9ycycsIFttb2R1bGVdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbicsIG51bGwpO1xuXG4gICAgJHNldF9wcm90byhtb2R1bGUsIE9wYWwuTW9kdWxlLnByb3RvdHlwZSk7XG5cbiAgICByZXR1cm4gbW9kdWxlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZpbmRfZXhpc3RpbmdfbW9kdWxlKHNjb3BlLCBuYW1lKSB7XG4gICAgdmFyIG1vZHVsZSA9IGNvbnN0X2dldF9uYW1lKHNjb3BlLCBuYW1lKTtcbiAgICBpZiAobW9kdWxlID09IG51bGwgJiYgc2NvcGUgPT09IF9PYmplY3QpIG1vZHVsZSA9IGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoX09iamVjdCwgbmFtZSk7XG5cbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICBpZiAoIW1vZHVsZS4kJGlzX21vZHVsZSAmJiBtb2R1bGUgIT09IF9PYmplY3QpIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhuYW1lICsgXCIgaXMgbm90IGEgbW9kdWxlXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtb2R1bGU7XG4gIH1cblxuICBPcGFsLm1vZHVsZSA9IGZ1bmN0aW9uKHNjb3BlLCBuYW1lKSB7XG4gICAgdmFyIG1vZHVsZTtcblxuICAgIGlmIChzY29wZSA9PSBudWxsKSB7XG4gICAgICAvLyBHbG9iYWwgc2NvcGVcbiAgICAgIHNjb3BlID0gX09iamVjdDtcbiAgICB9IGVsc2UgaWYgKCFzY29wZS4kJGlzX2NsYXNzICYmICFzY29wZS4kJGlzX21vZHVsZSkge1xuICAgICAgLy8gU2NvcGUgaXMgYW4gb2JqZWN0LCB1c2UgaXRzIGNsYXNzXG4gICAgICBzY29wZSA9IHNjb3BlLiQkY2xhc3M7XG4gICAgfVxuXG4gICAgbW9kdWxlID0gZmluZF9leGlzdGluZ19tb2R1bGUoc2NvcGUsIG5hbWUpO1xuXG4gICAgaWYgKG1vZHVsZSkge1xuICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9XG5cbiAgICAvLyBNb2R1bGUgZG9lc250IGV4aXN0LCBjcmVhdGUgYSBuZXcgb25lLi4uXG4gICAgbW9kdWxlID0gT3BhbC5hbGxvY2F0ZV9tb2R1bGUobmFtZSk7XG4gICAgT3BhbC5jb25zdF9zZXQoc2NvcGUsIG5hbWUsIG1vZHVsZSk7XG5cbiAgICByZXR1cm4gbW9kdWxlO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgc2luZ2xldG9uIGNsYXNzIGZvciB0aGUgcGFzc2VkIG9iamVjdC5cbiAgLy9cbiAgLy8gSWYgdGhlIGdpdmVuIG9iamVjdCBhbHJlZHkgaGFzIGEgc2luZ2xldG9uIGNsYXNzLCB0aGVuIGl0IHdpbGwgYmUgc3RvcmVkIG9uXG4gIC8vIHRoZSBvYmplY3QgYXMgdGhlIGAkJG1ldGFgIHByb3BlcnR5LiBJZiB0aGlzIGV4aXN0cywgdGhlbiBpdCBpcyBzaW1wbHlcbiAgLy8gcmV0dXJuZWQgYmFjay5cbiAgLy9cbiAgLy8gT3RoZXJ3aXNlLCBhIG5ldyBzaW5nbGV0b24gb2JqZWN0IGZvciB0aGUgY2xhc3Mgb3Igb2JqZWN0IGlzIGNyZWF0ZWQsIHNldCBvblxuICAvLyB0aGUgb2JqZWN0IGF0IGAkJG1ldGFgIGZvciBmdXR1cmUgdXNlLCBhbmQgdGhlbiByZXR1cm5lZC5cbiAgLy9cbiAgLy8gQHBhcmFtIG9iamVjdCBbT2JqZWN0XSB0aGUgcnVieSBvYmplY3RcbiAgLy8gQHJldHVybiBbQ2xhc3NdIHRoZSBzaW5nbGV0b24gY2xhc3MgZm9yIG9iamVjdFxuICBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0LiQkbWV0YSkge1xuICAgICAgcmV0dXJuIG9iamVjdC4kJG1ldGE7XG4gICAgfVxuXG4gICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eSgnJCRpc19jbGFzcycpKSB7XG4gICAgICByZXR1cm4gT3BhbC5idWlsZF9jbGFzc19zaW5nbGV0b25fY2xhc3Mob2JqZWN0KTtcbiAgICB9IGVsc2UgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eSgnJCRpc19tb2R1bGUnKSkge1xuICAgICAgcmV0dXJuIE9wYWwuYnVpbGRfbW9kdWxlX3NpbmdsZXRvbl9jbGFzcyhvYmplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT3BhbC5idWlsZF9vYmplY3Rfc2luZ2xldG9uX2NsYXNzKG9iamVjdCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEJ1aWxkIHRoZSBzaW5nbGV0b24gY2xhc3MgZm9yIGFuIGV4aXN0aW5nIGNsYXNzLiBDbGFzcyBvYmplY3QgYXJlIGJ1aWx0XG4gIC8vIHdpdGggdGhlaXIgc2luZ2xldG9uIGNsYXNzIGFscmVhZHkgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiBhbmQgaW5oZXJpdGluZ1xuICAvLyBmcm9tIHRoZWlyIHN1cGVyY2xhc3Mgb2JqZWN0ICh1cCB0byBgQ2xhc3NgIGl0c2VsZikuXG4gIC8vXG4gIC8vIE5PVEU6IEFjdHVhbGx5IGluIE1SSSBhIGNsYXNzJyBzaW5nbGV0b24gY2xhc3MgaW5oZXJpdHMgZnJvbSBpdHNcbiAgLy8gc3VwZXJjbGFzcycgc2luZ2xldG9uIGNsYXNzIHdoaWNoIGluIHR1cm4gaW5oZXJpdHMgZnJvbSBDbGFzcy5cbiAgLy9cbiAgLy8gQHBhcmFtIGtsYXNzIFtDbGFzc11cbiAgLy8gQHJldHVybiBbQ2xhc3NdXG4gIE9wYWwuYnVpbGRfY2xhc3Nfc2luZ2xldG9uX2NsYXNzID0gZnVuY3Rpb24oa2xhc3MpIHtcbiAgICB2YXIgc3VwZXJjbGFzcywgbWV0YTtcblxuICAgIGlmIChrbGFzcy4kJG1ldGEpIHtcbiAgICAgIHJldHVybiBrbGFzcy4kJG1ldGE7XG4gICAgfVxuXG4gICAgLy8gVGhlIHNpbmdsZXRvbl9jbGFzcyBzdXBlcmNsYXNzIGlzIHRoZSBzaW5nbGV0b25fY2xhc3Mgb2YgaXRzIHN1cGVyY2xhc3M7XG4gICAgLy8gYnV0IEJhc2ljT2JqZWN0IGhhcyBubyBzdXBlcmNsYXNzIChpdHMgYCQkc3VwZXJgIGlzIG51bGwpLCB0aHVzIHdlXG4gICAgLy8gZmFsbGJhY2sgb24gYENsYXNzYC5cbiAgICBzdXBlcmNsYXNzID0ga2xhc3MgPT09IEJhc2ljT2JqZWN0ID8gQ2xhc3MgOiBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Moa2xhc3MuJCRzdXBlcik7XG5cbiAgICBtZXRhID0gT3BhbC5hbGxvY2F0ZV9jbGFzcyhudWxsLCBzdXBlcmNsYXNzLCBmdW5jdGlvbigpe30pO1xuXG4gICAgJGRlZmluZVByb3BlcnR5KG1ldGEsICckJGlzX3NpbmdsZXRvbicsIHRydWUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtZXRhLCAnJCRzaW5nbGV0b25fb2YnLCBrbGFzcyk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRtZXRhJywgbWV0YSk7XG4gICAgJHNldF9wcm90byhrbGFzcywgbWV0YS4kJHByb3RvdHlwZSk7XG4gICAgLy8gUmVzdG9yaW5nIENsYXNzTmFtZS5jbGFzc1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkY2xhc3MnLCBPcGFsLkNsYXNzKTtcblxuICAgIHJldHVybiBtZXRhO1xuICB9O1xuXG4gIE9wYWwuYnVpbGRfbW9kdWxlX3NpbmdsZXRvbl9jbGFzcyA9IGZ1bmN0aW9uKG1vZCkge1xuICAgIGlmIChtb2QuJCRtZXRhKSB7XG4gICAgICByZXR1cm4gbW9kLiQkbWV0YTtcbiAgICB9XG5cbiAgICB2YXIgbWV0YSA9IE9wYWwuYWxsb2NhdGVfY2xhc3MobnVsbCwgT3BhbC5Nb2R1bGUsIGZ1bmN0aW9uKCl7fSk7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkobWV0YSwgJyQkaXNfc2luZ2xldG9uJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1ldGEsICckJHNpbmdsZXRvbl9vZicsIG1vZCk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZCwgJyQkbWV0YScsIG1ldGEpO1xuICAgICRzZXRfcHJvdG8obW9kLCBtZXRhLiQkcHJvdG90eXBlKTtcbiAgICAvLyBSZXN0b3JpbmcgTW9kdWxlTmFtZS5jbGFzc1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2QsICckJGNsYXNzJywgT3BhbC5Nb2R1bGUpO1xuXG4gICAgcmV0dXJuIG1ldGE7XG4gIH07XG5cbiAgLy8gQnVpbGQgdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3IgYSBSdWJ5IChub24gY2xhc3MpIE9iamVjdC5cbiAgLy9cbiAgLy8gQHBhcmFtIG9iamVjdCBbT2JqZWN0XVxuICAvLyBAcmV0dXJuIFtDbGFzc11cbiAgT3BhbC5idWlsZF9vYmplY3Rfc2luZ2xldG9uX2NsYXNzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIHN1cGVyY2xhc3MgPSBvYmplY3QuJCRjbGFzcyxcbiAgICAgICAga2xhc3MgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKG5pbCwgc3VwZXJjbGFzcywgZnVuY3Rpb24oKXt9KTtcblxuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkaXNfc2luZ2xldG9uJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRzaW5nbGV0b25fb2YnLCBvYmplY3QpO1xuXG4gICAgZGVsZXRlIGtsYXNzLiQkcHJvdG90eXBlLiQkY2xhc3M7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnJCRtZXRhJywga2xhc3MpO1xuXG4gICAgJHNldF9wcm90byhvYmplY3QsIG9iamVjdC4kJG1ldGEuJCRwcm90b3R5cGUpO1xuXG4gICAgcmV0dXJuIGtsYXNzO1xuICB9O1xuXG4gIE9wYWwuaXNfbWV0aG9kID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiAocHJvcFswXSA9PT0gJyQnICYmIHByb3BbMV0gIT09ICckJyk7XG4gIH07XG5cbiAgT3BhbC5pbnN0YW5jZV9tZXRob2RzID0gZnVuY3Rpb24obW9kKSB7XG4gICAgdmFyIGV4Y2x1ZGUgPSBbXSwgcmVzdWx0cyA9IFtdLCBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhtb2QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV0sXG4gICAgICAgICAgcHJvdG8gPSBhbmNlc3Rvci4kJHByb3RvdHlwZTtcblxuICAgICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byk7XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBsbCA9IHByb3BzLmxlbmd0aDsgaiA8IGxsOyBqKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcblxuICAgICAgICBpZiAoT3BhbC5pc19tZXRob2QocHJvcCkpIHtcbiAgICAgICAgICB2YXIgbWV0aG9kX25hbWUgPSBwcm9wLnNsaWNlKDEpLFxuICAgICAgICAgICAgICBtZXRob2QgPSBwcm90b1twcm9wXTtcblxuICAgICAgICAgIGlmIChtZXRob2QuJCRzdHViICYmIGV4Y2x1ZGUuaW5kZXhPZihtZXRob2RfbmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICBleGNsdWRlLnB1c2gobWV0aG9kX25hbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghbWV0aG9kLiQkc3R1YiAmJiByZXN1bHRzLmluZGV4T2YobWV0aG9kX25hbWUpID09PSAtMSAmJiBleGNsdWRlLmluZGV4T2YobWV0aG9kX25hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG1ldGhvZF9uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzID0gZnVuY3Rpb24obW9kKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgcHJvdG8gPSBtb2QuJCRwcm90b3R5cGU7XG5cbiAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgIH1cblxuICAgIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBwcm9wcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcblxuICAgICAgaWYgKE9wYWwuaXNfbWV0aG9kKHByb3ApKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBwcm90b1twcm9wXTtcblxuICAgICAgICBpZiAoIW1ldGhvZC4kJHN0dWIpIHtcbiAgICAgICAgICB2YXIgbWV0aG9kX25hbWUgPSBwcm9wLnNsaWNlKDEpO1xuICAgICAgICAgIHJlc3VsdHMucHVzaChtZXRob2RfbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICBPcGFsLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gT3BhbC5pbnN0YW5jZV9tZXRob2RzKE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmopKTtcbiAgfTtcblxuICBPcGFsLm93bl9tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMoT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG9iaikpO1xuICB9O1xuXG4gIE9wYWwucmVjZWl2ZXJfbWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBtb2QgPSBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKTtcbiAgICB2YXIgc2luZ2xldG9uX21ldGhvZHMgPSBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKG1vZCk7XG4gICAgdmFyIGluc3RhbmNlX21ldGhvZHMgPSBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKG1vZC4kJHN1cGVyKTtcbiAgICByZXR1cm4gc2luZ2xldG9uX21ldGhvZHMuY29uY2F0KGluc3RhbmNlX21ldGhvZHMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHBhaXJzIG9mIG5hbWVzL3ZhbHVlc1xuICAvLyBmb3IgYWxsIGNsYXNzIHZhcmlhYmxlcyBkZWZpbmVkIGluIHByb3ZpZGVkICttb2R1bGUrXG4gIC8vIGFuZCBpdHMgYW5jZXN0b3JzLlxuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEByZXR1cm4gW09iamVjdF1cbiAgT3BhbC5jbGFzc192YXJpYWJsZXMgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMobW9kdWxlKSxcbiAgICAgICAgaSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICBmb3IgKGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGFuY2VzdG9yID0gYW5jZXN0b3JzW2ldO1xuXG4gICAgICBmb3IgKHZhciBjdmFyIGluIGFuY2VzdG9yLiQkY3ZhcnMpIHtcbiAgICAgICAgcmVzdWx0W2N2YXJdID0gYW5jZXN0b3IuJCRjdmFyc1tjdmFyXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFNldHMgY2xhc3MgdmFyaWFibGUgd2l0aCBzcGVjaWZpZWQgK25hbWUrIHRvICt2YWx1ZStcbiAgLy8gaW4gcHJvdmlkZWQgK21vZHVsZStcbiAgLy9cbiAgLy8gQHBhcmFtIG1vZHVsZSBbTW9kdWxlXVxuICAvLyBAcGFyYW0gbmFtZSBbU3RyaW5nXVxuICAvLyBAcGFyYW0gdmFsdWUgW09iamVjdF1cbiAgT3BhbC5jbGFzc192YXJpYWJsZV9zZXQgPSBmdW5jdGlvbihtb2R1bGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZSksXG4gICAgICAgIGksIGxlbmd0aCA9IGFuY2VzdG9ycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGggLSAyOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGFuY2VzdG9yID0gYW5jZXN0b3JzW2ldO1xuXG4gICAgICBpZiAoJGhhc19vd24uY2FsbChhbmNlc3Rvci4kJGN2YXJzLCBuYW1lKSkge1xuICAgICAgICBhbmNlc3Rvci4kJGN2YXJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuJCRjdmFyc1tuYW1lXSA9IHZhbHVlO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGlzUm9vdChwcm90bykge1xuICAgIHJldHVybiBwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRpY2xhc3MnKSAmJiBwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRyb290Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBvd25faW5jbHVkZWRfbW9kdWxlcyhtb2R1bGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sIG1vZCwgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlLiQkcHJvdG90eXBlKTtcblxuICAgIHdoaWxlIChwcm90bykge1xuICAgICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGNsYXNzJykpIHtcbiAgICAgICAgLy8gc3VwZXJjbGFzc1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG1vZCA9IHByb3RvVG9Nb2R1bGUocHJvdG8pO1xuICAgICAgaWYgKG1vZCkge1xuICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgfVxuICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBvd25fcHJlcGVuZGVkX21vZHVsZXMobW9kdWxlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLCBtb2QsIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZS4kJHByb3RvdHlwZSk7XG5cbiAgICBpZiAobW9kdWxlLiQkcHJvdG90eXBlLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgIHdoaWxlIChwcm90bykge1xuICAgICAgICBpZiAocHJvdG8gPT09IG1vZHVsZS4kJHByb3RvdHlwZS4kJGRlZmluZV9tZXRob2RzX29uKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBtb2QgPSBwcm90b1RvTW9kdWxlKHByb3RvKTtcbiAgICAgICAgaWYgKG1vZCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKG1vZCk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG5cbiAgLy8gVGhlIGFjdHVhbCBpbmNsdXNpb24gb2YgYSBtb2R1bGUgaW50byBhIGNsYXNzLlxuICAvL1xuICAvLyAjIyBDbGFzcyBgJCRwYXJlbnRgIGFuZCBgaWNsYXNzYFxuICAvL1xuICAvLyBUbyBoYW5kbGUgYHN1cGVyYCBjYWxscywgZXZlcnkgY2xhc3MgaGFzIGEgYCQkcGFyZW50YC4gVGhpcyBwYXJlbnQgaXNcbiAgLy8gdXNlZCB0byByZXNvbHZlIHRoZSBuZXh0IGNsYXNzIGZvciBhIHN1cGVyIGNhbGwuIEEgbm9ybWFsIGNsYXNzIHdvdWxkXG4gIC8vIGhhdmUgdGhpcyBwb2ludCB0byBpdHMgc3VwZXJjbGFzcy4gSG93ZXZlciwgaWYgYSBjbGFzcyBpbmNsdWRlcyBhIG1vZHVsZVxuICAvLyB0aGVuIHRoaXMgd291bGQgbmVlZCB0byB0YWtlIGludG8gYWNjb3VudCB0aGUgbW9kdWxlLiBUaGUgbW9kdWxlIHdvdWxkXG4gIC8vIGFsc28gaGF2ZSB0byB0aGVuIHBvaW50IGl0cyBgJCRwYXJlbnRgIHRvIHRoZSBhY3R1YWwgc3VwZXJjbGFzcy4gV2VcbiAgLy8gY2Fubm90IG1vZGlmeSBtb2R1bGVzIGxpa2UgdGhpcywgYmVjYXVzZSBpdCBtaWdodCBiZSBpbmNsdWRlZCBpbiBtb3JlXG4gIC8vIHRoZW4gb25lIGNsYXNzLiBUbyBmaXggdGhpcywgd2UgYWN0dWFsbHkgaW5zZXJ0IGFuIGBpY2xhc3NgIGFzIHRoZSBjbGFzcydcbiAgLy8gYCQkcGFyZW50YCB3aGljaCBjYW4gdGhlbiBwb2ludCB0byB0aGUgc3VwZXJjbGFzcy4gVGhlIGBpY2xhc3NgIGFjdHMgYXNcbiAgLy8gYSBwcm94eSB0byB0aGUgYWN0dWFsIG1vZHVsZSwgc28gdGhlIGBzdXBlcmAgY2hhaW4gY2FuIHRoZW4gc2VhcmNoIGl0IGZvclxuICAvLyB0aGUgcmVxdWlyZWQgbWV0aG9kLlxuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdIHRoZSBtb2R1bGUgdG8gaW5jbHVkZVxuICAvLyBAcGFyYW0gaW5jbHVkZXIgW01vZHVsZV0gdGhlIHRhcmdldCBjbGFzcyB0byBpbmNsdWRlIG1vZHVsZSBpbnRvXG4gIC8vIEByZXR1cm4gW251bGxdXG4gIE9wYWwuYXBwZW5kX2ZlYXR1cmVzID0gZnVuY3Rpb24obW9kdWxlLCBpbmNsdWRlcikge1xuICAgIHZhciBtb2R1bGVfYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMobW9kdWxlKTtcbiAgICB2YXIgaWNsYXNzZXMgPSBbXTtcblxuICAgIGlmIChtb2R1bGVfYW5jZXN0b3JzLmluZGV4T2YoaW5jbHVkZXIpICE9PSAtMSkge1xuICAgICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoJ2N5Y2xpYyBpbmNsdWRlIGRldGVjdGVkJyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG1vZHVsZV9hbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IG1vZHVsZV9hbmNlc3RvcnNbaV0sIGljbGFzcyA9IGNyZWF0ZV9pY2xhc3MoYW5jZXN0b3IpO1xuICAgICAgJGRlZmluZVByb3BlcnR5KGljbGFzcywgJyQkaW5jbHVkZWQnLCB0cnVlKTtcbiAgICAgIGljbGFzc2VzLnB1c2goaWNsYXNzKTtcbiAgICB9XG4gICAgdmFyIGluY2x1ZGVyX2FuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKGluY2x1ZGVyKSxcbiAgICAgICAgY2hhaW4gPSBjaGFpbl9pY2xhc3NlcyhpY2xhc3NlcyksXG4gICAgICAgIHN0YXJ0X2NoYWluX2FmdGVyLFxuICAgICAgICBlbmRfY2hhaW5fb247XG5cbiAgICBpZiAoaW5jbHVkZXJfYW5jZXN0b3JzLmluZGV4T2YobW9kdWxlKSA9PT0gLTEpIHtcbiAgICAgIC8vIGZpcnN0IHRpbWUgaW5jbHVkZVxuXG4gICAgICAvLyBpbmNsdWRlciAtPiBjaGFpbi5maXJzdCAtPiAuLi5jaGFpbi4uLiAtPiBjaGFpbi5sYXN0IC0+IGluY2x1ZGVyLnBhcmVudFxuICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIgPSBpbmNsdWRlci4kJHByb3RvdHlwZTtcbiAgICAgIGVuZF9jaGFpbl9vbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpbmNsdWRlci4kJHByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBtb2R1bGUgaGFzIGJlZW4gYWxyZWFkeSBpbmNsdWRlZCxcbiAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gcHV0IGl0IGludG8gdGhlIGFuY2VzdG9ycyBjaGFpbiBhZ2FpbixcbiAgICAgIC8vIGJ1dCB0aGlzIG1vZHVsZSBtYXkgaGF2ZSBuZXcgaW5jbHVkZWQgbW9kdWxlcy5cbiAgICAgIC8vIElmIGl0J3MgdHJ1ZSB3ZSBuZWVkIHRvIGNvcHkgdGhlbS5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgc2ltcGxlc3Qgd2F5IGlzIHRvIHJlcGxhY2UgYW5jZXN0b3JzIGNoYWluIGZyb21cbiAgICAgIC8vICAgICAgICAgIHBhcmVudFxuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgIGBtb2R1bGVgIGljbGFzcyAoaGFzIGEgJCRyb290IGZsYWcpXG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICAgLi4ucHJldmlvcyBjaGFpbiBvZiBtb2R1bGUuaW5jbHVkZWRfbW9kdWxlcyAuLi5cbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gIFwibmV4dCBhbmNlc3RvclwiIChoYXMgYSAkJHJvb3QgZmxhZyBvciBpcyBhIHJlYWwgY2xhc3MpXG4gICAgICAvL1xuICAgICAgLy8gdG9cbiAgICAgIC8vICAgICAgICAgIHBhcmVudFxuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgICBgbW9kdWxlYCBpY2xhc3MgKGhhcyBhICQkcm9vdCBmbGFnKVxuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgIC4uLnJlZ2VuZXJhdGVkIGNoYWluIG9mIG1vZHVsZS5pbmNsdWRlZF9tb2R1bGVzXG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICAgXCJuZXh0IGFuY2VzdG9yXCIgKGhhcyBhICQkcm9vdCBmbGFnIG9yIGlzIGEgcmVhbCBjbGFzcylcbiAgICAgIC8vXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGFyZSBubyBpbnRlcm1lZGlhdGUgY2xhc3NlcyBiZXR3ZWVuIGBwYXJlbnRgIGFuZCBgbmV4dCBhbmNlc3RvcmAuXG4gICAgICAvLyBJdCBkb2Vzbid0IGJyZWFrIGFueSBwcm90b3R5cGVzIG9mIG90aGVyIG9iamVjdHMgYXMgd2UgZG9uJ3QgY2hhbmdlIGNsYXNzIHJlZmVyZW5jZXMuXG5cbiAgICAgIHZhciBwcm90byA9IGluY2x1ZGVyLiQkcHJvdG90eXBlLCBwYXJlbnQgPSBwcm90bywgbW9kdWxlX2ljbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXJlbnQpO1xuXG4gICAgICB3aGlsZSAobW9kdWxlX2ljbGFzcyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc1Jvb3QobW9kdWxlX2ljbGFzcykgJiYgbW9kdWxlX2ljbGFzcy4kJG1vZHVsZSA9PT0gbW9kdWxlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQgPSBtb2R1bGVfaWNsYXNzO1xuICAgICAgICBtb2R1bGVfaWNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZV9pY2xhc3MpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dF9hbmNlc3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGVfaWNsYXNzKTtcblxuICAgICAgLy8gc2tpcCBub24tcm9vdCBpY2xhc3NlcyAodGhhdCB3ZXJlIHJlY3Vyc2l2ZWx5IGluY2x1ZGVkKVxuICAgICAgd2hpbGUgKG5leHRfYW5jZXN0b3IuaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJykgJiYgIWlzUm9vdChuZXh0X2FuY2VzdG9yKSkge1xuICAgICAgICBuZXh0X2FuY2VzdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5leHRfYW5jZXN0b3IpO1xuICAgICAgfVxuXG4gICAgICBzdGFydF9jaGFpbl9hZnRlciA9IHBhcmVudDtcbiAgICAgIGVuZF9jaGFpbl9vbiA9IG5leHRfYW5jZXN0b3I7XG4gICAgfVxuXG4gICAgJHNldF9wcm90byhzdGFydF9jaGFpbl9hZnRlciwgY2hhaW4uZmlyc3QpO1xuICAgICRzZXRfcHJvdG8oY2hhaW4ubGFzdCwgZW5kX2NoYWluX29uKTtcblxuICAgIC8vIHJlY2FsY3VsYXRlIG93bl9pbmNsdWRlZF9tb2R1bGVzIGNhY2hlXG4gICAgaW5jbHVkZXIuJCRvd25faW5jbHVkZWRfbW9kdWxlcyA9IG93bl9pbmNsdWRlZF9tb2R1bGVzKGluY2x1ZGVyKTtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuICB9O1xuXG4gIE9wYWwucHJlcGVuZF9mZWF0dXJlcyA9IGZ1bmN0aW9uKG1vZHVsZSwgcHJlcGVuZGVyKSB7XG4gICAgLy8gSGVyZSB3ZSBjaGFuZ2UgdGhlIGFuY2VzdG9ycyBjaGFpbiBmcm9tXG4gICAgLy9cbiAgICAvLyAgIHByZXBlbmRlclxuICAgIC8vICAgICAgfFxuICAgIC8vICAgIHBhcmVudFxuICAgIC8vXG4gICAgLy8gdG86XG4gICAgLy9cbiAgICAvLyBkdW1teShwcmVwZW5kZXIpXG4gICAgLy8gICAgICB8XG4gICAgLy8gIGljbGFzcyhtb2R1bGUpXG4gICAgLy8gICAgICB8XG4gICAgLy8gaWNsYXNzKHByZXBlbmRlcilcbiAgICAvLyAgICAgIHxcbiAgICAvLyAgICBwYXJlbnRcbiAgICB2YXIgbW9kdWxlX2FuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZSk7XG4gICAgdmFyIGljbGFzc2VzID0gW107XG5cbiAgICBpZiAobW9kdWxlX2FuY2VzdG9ycy5pbmRleE9mKHByZXBlbmRlcikgIT09IC0xKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldygnY3ljbGljIHByZXBlbmQgZGV0ZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbW9kdWxlX2FuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFuY2VzdG9yID0gbW9kdWxlX2FuY2VzdG9yc1tpXSwgaWNsYXNzID0gY3JlYXRlX2ljbGFzcyhhbmNlc3Rvcik7XG4gICAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCAnJCRwcmVwZW5kZWQnLCB0cnVlKTtcbiAgICAgIGljbGFzc2VzLnB1c2goaWNsYXNzKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhaW4gPSBjaGFpbl9pY2xhc3NlcyhpY2xhc3NlcyksXG4gICAgICAgIGR1bW15X3ByZXBlbmRlciA9IHByZXBlbmRlci4kJHByb3RvdHlwZSxcbiAgICAgICAgcHJldmlvdXNfcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGR1bW15X3ByZXBlbmRlciksXG4gICAgICAgIHByZXBlbmRlcl9pY2xhc3MsXG4gICAgICAgIHN0YXJ0X2NoYWluX2FmdGVyLFxuICAgICAgICBlbmRfY2hhaW5fb247XG5cbiAgICBpZiAoZHVtbXlfcHJlcGVuZGVyLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgIC8vIFRoZSBtb2R1bGUgYWxyZWFkeSBoYXMgc29tZSBwcmVwZW5kZWQgbW9kdWxlc1xuICAgICAgLy8gd2hpY2ggbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIHRvIG1ha2UgaXQgXCJkdW1teVwiXG4gICAgICBwcmVwZW5kZXJfaWNsYXNzID0gZHVtbXlfcHJlcGVuZGVyLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1ha2luZyB0aGUgbW9kdWxlIFwiZHVtbXlcIlxuICAgICAgcHJlcGVuZGVyX2ljbGFzcyA9IGNyZWF0ZV9kdW1teV9pY2xhc3MocHJlcGVuZGVyKTtcbiAgICAgIGZsdXNoX21ldGhvZHNfaW4ocHJlcGVuZGVyKTtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShkdW1teV9wcmVwZW5kZXIsICckJGR1bW15JywgdHJ1ZSk7XG4gICAgICAkZGVmaW5lUHJvcGVydHkoZHVtbXlfcHJlcGVuZGVyLCAnJCRkZWZpbmVfbWV0aG9kc19vbicsIHByZXBlbmRlcl9pY2xhc3MpO1xuXG4gICAgICAvLyBDb252ZXJ0aW5nXG4gICAgICAvLyAgIGR1bW15KHByZXBlbmRlcikgLT4gcHJldmlvdXNfcGFyZW50XG4gICAgICAvLyB0b1xuICAgICAgLy8gICBkdW1teShwcmVwZW5kZXIpIC0+IGljbGFzcyhwcmVwZW5kZXIpIC0+IHByZXZpb3VzX3BhcmVudFxuICAgICAgJHNldF9wcm90byhkdW1teV9wcmVwZW5kZXIsIHByZXBlbmRlcl9pY2xhc3MpO1xuICAgICAgJHNldF9wcm90byhwcmVwZW5kZXJfaWNsYXNzLCBwcmV2aW91c19wYXJlbnQpO1xuICAgIH1cblxuICAgIHZhciBwcmVwZW5kZXJfYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMocHJlcGVuZGVyKTtcblxuICAgIGlmIChwcmVwZW5kZXJfYW5jZXN0b3JzLmluZGV4T2YobW9kdWxlKSA9PT0gLTEpIHtcbiAgICAgIC8vIGZpcnN0IHRpbWUgcHJlcGVuZFxuXG4gICAgICBzdGFydF9jaGFpbl9hZnRlciA9IGR1bW15X3ByZXBlbmRlcjtcblxuICAgICAgLy8gbmV4dCAkJHJvb3Qgb3IgcHJlcGVuZGVyX2ljbGFzcyBvciBub24tJCRpY2xhc3NcbiAgICAgIGVuZF9jaGFpbl9vbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihkdW1teV9wcmVwZW5kZXIpO1xuICAgICAgd2hpbGUgKGVuZF9jaGFpbl9vbiAhPSBudWxsKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBlbmRfY2hhaW5fb24uaGFzT3duUHJvcGVydHkoJyQkcm9vdCcpIHx8XG4gICAgICAgICAgZW5kX2NoYWluX29uID09PSBwcmVwZW5kZXJfaWNsYXNzIHx8XG4gICAgICAgICAgIWVuZF9jaGFpbl9vbi5oYXNPd25Qcm9wZXJ0eSgnJCRpY2xhc3MnKVxuICAgICAgICApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGVuZF9jaGFpbl9vbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihlbmRfY2hhaW5fb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBPcGFsLlJ1bnRpbWVFcnJvci4kbmV3KFwiUHJlcGVuZGluZyBhIG1vZHVsZSBtdWx0aXBsZSB0aW1lcyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cblxuICAgICRzZXRfcHJvdG8oc3RhcnRfY2hhaW5fYWZ0ZXIsIGNoYWluLmZpcnN0KTtcbiAgICAkc2V0X3Byb3RvKGNoYWluLmxhc3QsIGVuZF9jaGFpbl9vbik7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBvd25fcHJlcGVuZGVkX21vZHVsZXMgY2FjaGVcbiAgICBwcmVwZW5kZXIuJCRvd25fcHJlcGVuZGVkX21vZHVsZXMgPSBvd25fcHJlcGVuZGVkX21vZHVsZXMocHJlcGVuZGVyKTtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZsdXNoX21ldGhvZHNfaW4obW9kdWxlKSB7XG4gICAgdmFyIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlLFxuICAgICAgICBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAoT3BhbC5pc19tZXRob2QocHJvcCkpIHtcbiAgICAgICAgZGVsZXRlIHByb3RvW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZV9pY2xhc3MobW9kdWxlKSB7XG4gICAgdmFyIGljbGFzcyA9IGNyZWF0ZV9kdW1teV9pY2xhc3MobW9kdWxlKTtcblxuICAgIGlmIChtb2R1bGUuJCRpc19tb2R1bGUpIHtcbiAgICAgIG1vZHVsZS4kJGljbGFzc2VzLnB1c2goaWNsYXNzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWNsYXNzO1xuICB9XG5cbiAgLy8gRHVtbXkgaWNsYXNzIGRvZXNuJ3QgcmVjZWl2ZSB1cGRhdGVzIHdoZW4gdGhlIG1vZHVsZSBnZXRzIGEgbmV3IG1ldGhvZC5cbiAgZnVuY3Rpb24gY3JlYXRlX2R1bW15X2ljbGFzcyhtb2R1bGUpIHtcbiAgICB2YXIgaWNsYXNzID0ge30sXG4gICAgICAgIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlO1xuXG4gICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgIHByb3RvID0gcHJvdG8uJCRkZWZpbmVfbWV0aG9kc19vbjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShpY2xhc3MsIHByb3AsIHByb3RvW3Byb3BdKTtcbiAgICB9XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCAnJCRpY2xhc3MnLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCAnJCRtb2R1bGUnLCBtb2R1bGUpO1xuXG4gICAgcmV0dXJuIGljbGFzcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYWluX2ljbGFzc2VzKGljbGFzc2VzKSB7XG4gICAgdmFyIGxlbmd0aCA9IGljbGFzc2VzLmxlbmd0aCwgZmlyc3QgPSBpY2xhc3Nlc1swXTtcblxuICAgICRkZWZpbmVQcm9wZXJ0eShmaXJzdCwgJyQkcm9vdCcsIHRydWUpO1xuXG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHsgZmlyc3Q6IGZpcnN0LCBsYXN0OiBmaXJzdCB9O1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91cyA9IGZpcnN0O1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1cnJlbnQgPSBpY2xhc3Nlc1tpXTtcbiAgICAgICRzZXRfcHJvdG8ocHJldmlvdXMsIGN1cnJlbnQpO1xuICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIH1cblxuXG4gICAgcmV0dXJuIHsgZmlyc3Q6IGljbGFzc2VzWzBdLCBsYXN0OiBpY2xhc3Nlc1tsZW5ndGggLSAxXSB9O1xuICB9XG5cbiAgLy8gRm9yIHBlcmZvcm1hbmNlLCBzb21lIGNvcmUgUnVieSBjbGFzc2VzIGFyZSB0b2xsLWZyZWUgYnJpZGdlZCB0byB0aGVpclxuICAvLyBuYXRpdmUgSmF2YVNjcmlwdCBjb3VudGVycGFydHMgKGUuZy4gYSBSdWJ5IEFycmF5IGlzIGEgSmF2YVNjcmlwdCBBcnJheSkuXG4gIC8vXG4gIC8vIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2V0dXAgYSBuYXRpdmUgY29uc3RydWN0b3IgKGUuZy4gQXJyYXkpLCB0byBoYXZlXG4gIC8vIGl0cyBwcm90b3R5cGUgYWN0IGxpa2UgYSBub3JtYWwgUnVieSBjbGFzcy4gRmlyc3RseSwgYSBuZXcgUnVieSBjbGFzcyBpc1xuICAvLyBjcmVhdGVkIHVzaW5nIHRoZSBuYXRpdmUgY29uc3RydWN0b3Igc28gdGhhdCBpdHMgcHJvdG90eXBlIGlzIHNldCBhcyB0aGVcbiAgLy8gdGFyZ2V0IGZvciB0aGUgbmV3IGNsYXNzLiBOb3RlOiBhbGwgYnJpZGdlZCBjbGFzc2VzIGFyZSBzZXQgdG8gaW5oZXJpdFxuICAvLyBmcm9tIE9iamVjdC5cbiAgLy9cbiAgLy8gRXhhbXBsZTpcbiAgLy9cbiAgLy8gICAgT3BhbC5icmlkZ2Uoc2VsZiwgRnVuY3Rpb24pO1xuICAvL1xuICAvLyBAcGFyYW0ga2xhc3MgICAgICAgW0NsYXNzXSB0aGUgUnVieSBjbGFzcyB0byBicmlkZ2VcbiAgLy8gQHBhcmFtIGNvbnN0cnVjdG9yIFtKUy5GdW5jdGlvbl0gbmF0aXZlIEphdmFTY3JpcHQgY29uc3RydWN0b3IgdG8gdXNlXG4gIC8vIEByZXR1cm4gW0NsYXNzXSByZXR1cm5zIHRoZSBwYXNzZWQgUnVieSBjbGFzc1xuICAvL1xuICBPcGFsLmJyaWRnZSA9IGZ1bmN0aW9uKG5hdGl2ZV9rbGFzcywga2xhc3MpIHtcbiAgICBpZiAobmF0aXZlX2tsYXNzLmhhc093blByb3BlcnR5KCckJGJyaWRnZScpKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcImFscmVhZHkgYnJpZGdlZFwiKTtcbiAgICB9XG5cbiAgICAvLyBjb25zdHJ1Y3RvciBpcyBhIEpTIGZ1bmN0aW9uIHdpdGggYSBwcm90b3R5cGUgY2hhaW4gbGlrZTpcbiAgICAvLyAtIGNvbnN0cnVjdG9yXG4gICAgLy8gICAtIHN1cGVyXG4gICAgLy9cbiAgICAvLyBXaGF0IHdlIG5lZWQgdG8gZG8gaXMgdG8gaW5qZWN0IG91ciBjbGFzcyAod2l0aCBpdHMgcHJvdG90eXBlIGNoYWluKVxuICAgIC8vIGJldHdlZW4gY29uc3RydWN0b3IgYW5kIHN1cGVyLiBGb3IgZXhhbXBsZSwgYWZ0ZXIgaW5qZWN0aW5nIDo6T2JqZWN0XG4gICAgLy8gaW50byBKUyBTdHJpbmcgd2UgZ2V0OlxuICAgIC8vXG4gICAgLy8gLSBjb25zdHJ1Y3RvciAod2luZG93LlN0cmluZylcbiAgICAvLyAgIC0gT3BhbC5PYmplY3RcbiAgICAvLyAgICAgLSBPcGFsLktlcm5lbFxuICAgIC8vICAgICAgIC0gT3BhbC5CYXNpY09iamVjdFxuICAgIC8vICAgICAgICAgLSBzdXBlciAod2luZG93Lk9iamVjdClcbiAgICAvLyAgICAgICAgICAgLSBudWxsXG4gICAgLy9cbiAgICAkZGVmaW5lUHJvcGVydHkobmF0aXZlX2tsYXNzLCAnJCRicmlkZ2UnLCBrbGFzcyk7XG4gICAgJHNldF9wcm90byhuYXRpdmVfa2xhc3MucHJvdG90eXBlLCAoa2xhc3MuJCRzdXBlciB8fCBPcGFsLk9iamVjdCkuJCRwcm90b3R5cGUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkcHJvdG90eXBlJywgbmF0aXZlX2tsYXNzLnByb3RvdHlwZSk7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MuJCRwcm90b3R5cGUsICckJGNsYXNzJywga2xhc3MpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkY29uc3RydWN0b3InLCBuYXRpdmVfa2xhc3MpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkYnJpZGdlJywgdHJ1ZSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHJvdG9Ub01vZHVsZShwcm90bykge1xuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRpY2xhc3MnKSkge1xuICAgICAgcmV0dXJuIHByb3RvLiQkbW9kdWxlO1xuICAgIH0gZWxzZSBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkY2xhc3MnKSkge1xuICAgICAgcmV0dXJuIHByb3RvLiQkY2xhc3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb3duX2FuY2VzdG9ycyhtb2R1bGUpIHtcbiAgICByZXR1cm4gbW9kdWxlLiQkb3duX3ByZXBlbmRlZF9tb2R1bGVzLmNvbmNhdChbbW9kdWxlXSkuY29uY2F0KG1vZHVsZS4kJG93bl9pbmNsdWRlZF9tb2R1bGVzKTtcbiAgfVxuXG4gIC8vIFRoZSBBcnJheSBvZiBhbmNlc3RvcnMgZm9yIGEgZ2l2ZW4gbW9kdWxlL2NsYXNzXG4gIE9wYWwuYW5jZXN0b3JzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgaWYgKCFtb2R1bGUpIHsgcmV0dXJuIFtdOyB9XG5cbiAgICBpZiAobW9kdWxlLiQkYW5jZXN0b3JzX2NhY2hlX3ZlcnNpb24gPT09IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbikge1xuICAgICAgcmV0dXJuIG1vZHVsZS4kJGFuY2VzdG9ycztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gW10sIGksIG1vZHMsIGxlbmd0aDtcblxuICAgIGZvciAoaSA9IDAsIG1vZHMgPSBvd25fYW5jZXN0b3JzKG1vZHVsZSksIGxlbmd0aCA9IG1vZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKG1vZHNbaV0pO1xuICAgIH1cblxuICAgIGlmIChtb2R1bGUuJCRzdXBlcikge1xuICAgICAgZm9yIChpID0gMCwgbW9kcyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZS4kJHN1cGVyKSwgbGVuZ3RoID0gbW9kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChtb2RzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbjtcbiAgICBtb2R1bGUuJCRhbmNlc3RvcnMgPSByZXN1bHQ7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIE9wYWwuaW5jbHVkZWRfbW9kdWxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kID0gbnVsbCwgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlLiQkcHJvdG90eXBlKTtcblxuICAgIGZvciAoOyBwcm90byAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pOyBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykpIHtcbiAgICAgIG1vZCA9IHByb3RvVG9Nb2R1bGUocHJvdG8pO1xuICAgICAgaWYgKG1vZCAmJiBtb2QuJCRpc19tb2R1bGUgJiYgcHJvdG8uJCRpY2xhc3MgJiYgcHJvdG8uJCRpbmNsdWRlZCkge1xuICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblxuICAvLyBNZXRob2QgTWlzc2luZ1xuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIE1ldGhvZHMgc3R1YnMgYXJlIHVzZWQgdG8gZmFjaWxpdGF0ZSBtZXRob2RfbWlzc2luZyBpbiBvcGFsLiBBIHN0dWIgaXMgYVxuICAvLyBwbGFjZWhvbGRlciBmdW5jdGlvbiB3aGljaCBqdXN0IGNhbGxzIGBtZXRob2RfbWlzc2luZ2Agb24gdGhlIHJlY2VpdmVyLlxuICAvLyBJZiBubyBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBhY3R1YWxseSBkZWZpbmVkIG9uIGFuIG9iamVjdCwgdGhlbiBpdFxuICAvLyBpcyBvYnZpb3VzIHRvIHNheSB0aGF0IHRoZSBzdHViIHdpbGwgYmUgY2FsbGVkIGluc3RlYWQsIGFuZCB0aGVuIGluIHR1cm5cbiAgLy8gbWV0aG9kX21pc3Npbmcgd2lsbCBiZSBjYWxsZWQuXG4gIC8vXG4gIC8vIFdoZW4gYSBmaWxlIGluIHJ1YnkgZ2V0cyBjb21waWxlZCB0byBqYXZhc2NyaXB0LCBpdCBpbmNsdWRlcyBhIGNhbGwgdG9cbiAgLy8gdGhpcyBmdW5jdGlvbiB3aGljaCBhZGRzIHN0dWJzIGZvciBldmVyeSBtZXRob2QgbmFtZSBpbiB0aGUgY29tcGlsZWQgZmlsZS5cbiAgLy8gSXQgc2hvdWxkIHRoZW4gYmUgc2FmZSB0byBhc3N1bWUgdGhhdCBtZXRob2RfbWlzc2luZyB3aWxsIHdvcmsgZm9yIGFueVxuICAvLyBtZXRob2QgY2FsbCBkZXRlY3RlZC5cbiAgLy9cbiAgLy8gTWV0aG9kIHN0dWJzIGFyZSBhZGRlZCB0byB0aGUgQmFzaWNPYmplY3QgcHJvdG90eXBlLCB3aGljaCBldmVyeSBvdGhlclxuICAvLyBydWJ5IG9iamVjdCBpbmhlcml0cywgc28gYWxsIG9iamVjdHMgc2hvdWxkIGhhbmRsZSBtZXRob2QgbWlzc2luZy4gQSBzdHViXG4gIC8vIGlzIG9ubHkgYWRkZWQgaWYgdGhlIGdpdmVuIHByb3BlcnR5IG5hbWUgKG1ldGhvZCBuYW1lKSBpcyBub3QgYWxyZWFkeVxuICAvLyBkZWZpbmVkLlxuICAvL1xuICAvLyBOb3RlOiBhbGwgcnVieSBtZXRob2RzIGhhdmUgYSBgJGAgcHJlZml4IGluIGphdmFzY3JpcHQsIHNvIGFsbCBzdHVicyB3aWxsXG4gIC8vIGhhdmUgdGhpcyBwcmVmaXggYXMgd2VsbCAodG8gbWFrZSB0aGlzIG1ldGhvZCBtb3JlIHBlcmZvcm1hbnQpLlxuICAvL1xuICAvLyAgICBPcGFsLmFkZF9zdHVicyhbXCIkZm9vXCIsIFwiJGJhclwiLCBcIiRiYXo9XCJdKTtcbiAgLy9cbiAgLy8gQWxsIHN0dWIgZnVuY3Rpb25zIHdpbGwgaGF2ZSBhIHByaXZhdGUgYCQkc3R1YmAgcHJvcGVydHkgc2V0IHRvIHRydWUgc29cbiAgLy8gdGhhdCBvdGhlciBpbnRlcm5hbCBtZXRob2RzIGNhbiBkZXRlY3QgaWYgYSBtZXRob2QgaXMganVzdCBhIHN0dWIgb3Igbm90LlxuICAvLyBgS2VybmVsI3Jlc3BvbmRfdG8/YCB1c2VzIHRoaXMgcHJvcGVydHkgdG8gZGV0ZWN0IGEgbWV0aG9kcyBwcmVzZW5jZS5cbiAgLy9cbiAgLy8gQHBhcmFtIHN0dWJzIFtBcnJheV0gYW4gYXJyYXkgb2YgbWV0aG9kIHN0dWJzIHRvIGFkZFxuICAvLyBAcmV0dXJuIFt1bmRlZmluZWRdXG4gIE9wYWwuYWRkX3N0dWJzID0gZnVuY3Rpb24oc3R1YnMpIHtcbiAgICB2YXIgcHJvdG8gPSBPcGFsLkJhc2ljT2JqZWN0LiQkcHJvdG90eXBlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0dWJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3R1YiA9IHN0dWJzW2ldLCBleGlzdGluZ19tZXRob2QgPSBwcm90b1tzdHViXTtcblxuICAgICAgaWYgKGV4aXN0aW5nX21ldGhvZCA9PSBudWxsIHx8IGV4aXN0aW5nX21ldGhvZC4kJHN0dWIpIHtcbiAgICAgICAgT3BhbC5hZGRfc3R1Yl9mb3IocHJvdG8sIHN0dWIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBBZGQgYSBtZXRob2RfbWlzc2luZyBzdHViIGZ1bmN0aW9uIHRvIHRoZSBnaXZlbiBwcm90b3R5cGUgZm9yIHRoZVxuICAvLyBnaXZlbiBuYW1lLlxuICAvL1xuICAvLyBAcGFyYW0gcHJvdG90eXBlIFtQcm90b3R5cGVdIHRoZSB0YXJnZXQgcHJvdG90eXBlXG4gIC8vIEBwYXJhbSBzdHViIFtTdHJpbmddIHN0dWIgbmFtZSB0byBhZGQgKGUuZy4gXCIkZm9vXCIpXG4gIC8vIEByZXR1cm4gW3VuZGVmaW5lZF1cbiAgT3BhbC5hZGRfc3R1Yl9mb3IgPSBmdW5jdGlvbihwcm90b3R5cGUsIHN0dWIpIHtcbiAgICB2YXIgbWV0aG9kX21pc3Npbmdfc3R1YiA9IE9wYWwuc3R1Yl9mb3Ioc3R1Yik7XG4gICAgJGRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgc3R1YiwgbWV0aG9kX21pc3Npbmdfc3R1Yik7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgdGhlIG1ldGhvZF9taXNzaW5nIHN0dWIgZm9yIGEgZ2l2ZW4gbWV0aG9kIG5hbWUuXG4gIC8vXG4gIC8vIEBwYXJhbSBtZXRob2RfbmFtZSBbU3RyaW5nXSBUaGUganMtbmFtZSBvZiB0aGUgbWV0aG9kIHRvIHN0dWIgKGUuZy4gXCIkZm9vXCIpXG4gIC8vIEByZXR1cm4gW3VuZGVmaW5lZF1cbiAgT3BhbC5zdHViX2ZvciA9IGZ1bmN0aW9uKG1ldGhvZF9uYW1lKSB7XG5cbiAgICBmdW5jdGlvbiBtZXRob2RfbWlzc2luZ19zdHViKCkge1xuICAgICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuXG4gICAgICAvLyBDb3B5IGFueSBnaXZlbiBibG9jayBvbnRvIHRoZSBtZXRob2RfbWlzc2luZyBkaXNwYXRjaGVyXG4gICAgICB0aGlzLiRtZXRob2RfbWlzc2luZy4kJHAgPSBtZXRob2RfbWlzc2luZ19zdHViLiQkcDtcblxuICAgICAgLy8gU2V0IGJsb2NrIHByb3BlcnR5IHRvIG51bGwgcmVhZHkgZm9yIHRoZSBuZXh0IGNhbGwgKHN0b3AgZmFsc2UtcG9zaXRpdmVzKVxuICAgICAgbWV0aG9kX21pc3Npbmdfc3R1Yi4kJHAgPSBudWxsO1xuXG4gICAgICAvLyBjYWxsIG1ldGhvZCBtaXNzaW5nIHdpdGggY29ycmVjdCBhcmdzIChyZW1vdmUgJyQnIHByZWZpeCBvbiBtZXRob2QgbmFtZSlcbiAgICAgIHZhciBhcmdzX2FyeSA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmdzX2FyeS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgYXJnc19hcnlbaV0gPSBhcmd1bWVudHNbaV07IH1cblxuICAgICAgcmV0dXJuIHRoaXMuJG1ldGhvZF9taXNzaW5nLmFwcGx5KHRoaXMsIFttZXRob2RfbmFtZS5zbGljZSgxKV0uY29uY2F0KGFyZ3NfYXJ5KSk7XG4gICAgfVxuXG4gICAgbWV0aG9kX21pc3Npbmdfc3R1Yi4kJHN0dWIgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG1ldGhvZF9taXNzaW5nX3N0dWI7XG4gIH07XG5cblxuICAvLyBNZXRob2RzXG4gIC8vIC0tLS0tLS1cblxuICAvLyBBcml0eSBjb3VudCBlcnJvciBkaXNwYXRjaGVyIGZvciBtZXRob2RzXG4gIC8vXG4gIC8vIEBwYXJhbSBhY3R1YWwgW0ZpeG51bV0gbnVtYmVyIG9mIGFyZ3VtZW50cyBnaXZlbiB0byBtZXRob2RcbiAgLy8gQHBhcmFtIGV4cGVjdGVkIFtGaXhudW1dIGV4cGVjdGVkIG51bWJlciBvZiBhcmd1bWVudHNcbiAgLy8gQHBhcmFtIG9iamVjdCBbT2JqZWN0XSBvd25lciBvZiB0aGUgbWV0aG9kICttZXRoK1xuICAvLyBAcGFyYW0gbWV0aCBbU3RyaW5nXSBtZXRob2QgbmFtZSB0aGF0IGdvdCB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzXG4gIC8vIEByYWlzZSBbQXJndW1lbnRFcnJvcl1cbiAgT3BhbC5hYyA9IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIG9iamVjdCwgbWV0aCkge1xuICAgIHZhciBpbnNwZWN0ID0gJyc7XG4gICAgaWYgKG9iamVjdC4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICBpbnNwZWN0ICs9IG9iamVjdC4kJG5hbWUgKyAnLic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaW5zcGVjdCArPSBvYmplY3QuJCRjbGFzcy4kJG5hbWUgKyAnIyc7XG4gICAgfVxuICAgIGluc3BlY3QgKz0gbWV0aDtcblxuICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdbJyArIGluc3BlY3QgKyAnXSB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzKCcgKyBhY3R1YWwgKyAnIGZvciAnICsgZXhwZWN0ZWQgKyAnKScpO1xuICB9O1xuXG4gIC8vIEFyaXR5IGNvdW50IGVycm9yIGRpc3BhdGNoZXIgZm9yIGJsb2Nrc1xuICAvL1xuICAvLyBAcGFyYW0gYWN0dWFsIFtGaXhudW1dIG51bWJlciBvZiBhcmd1bWVudHMgZ2l2ZW4gdG8gYmxvY2tcbiAgLy8gQHBhcmFtIGV4cGVjdGVkIFtGaXhudW1dIGV4cGVjdGVkIG51bWJlciBvZiBhcmd1bWVudHNcbiAgLy8gQHBhcmFtIGNvbnRleHQgW09iamVjdF0gY29udGV4dCBvZiB0aGUgYmxvY2sgZGVmaW5pdGlvblxuICAvLyBAcmFpc2UgW0FyZ3VtZW50RXJyb3JdXG4gIE9wYWwuYmxvY2tfYWMgPSBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBjb250ZXh0KSB7XG4gICAgdmFyIGluc3BlY3QgPSBcImBibG9jayBpbiBcIiArIGNvbnRleHQgKyBcIidcIjtcblxuICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KGluc3BlY3QgKyAnOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgnICsgYWN0dWFsICsgJyBmb3IgJyArIGV4cGVjdGVkICsgJyknKTtcbiAgfTtcblxuICAvLyBTdXBlciBkaXNwYXRjaGVyXG4gIE9wYWwuZmluZF9zdXBlcl9kaXNwYXRjaGVyID0gZnVuY3Rpb24ob2JqLCBtaWQsIGN1cnJlbnRfZnVuYywgZGVmY2hlY2ssIGFsbG93X3N0dWJzKSB7XG4gICAgdmFyIGpzaWQgPSAnJCcgKyBtaWQsIGFuY2VzdG9ycywgc3VwZXJfbWV0aG9kO1xuXG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSgnJCRtZXRhJykpIHtcbiAgICAgIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG9iai4kJG1ldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhvYmouJCRjbGFzcyk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRfaW5kZXggPSBhbmNlc3RvcnMuaW5kZXhPZihjdXJyZW50X2Z1bmMuJCRvd25lcik7XG5cbiAgICBmb3IgKHZhciBpID0gY3VycmVudF9pbmRleCArIDE7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXSxcbiAgICAgICAgICBwcm90byA9IGFuY2VzdG9yLiQkcHJvdG90eXBlO1xuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eShqc2lkKSkge1xuICAgICAgICBzdXBlcl9tZXRob2QgPSBwcm90b1tqc2lkXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFkZWZjaGVjayAmJiBzdXBlcl9tZXRob2QgJiYgc3VwZXJfbWV0aG9kLiQkc3R1YiAmJiBvYmouJG1ldGhvZF9taXNzaW5nLiQkcHJpc3RpbmUpIHtcbiAgICAgIC8vIG1ldGhvZF9taXNzaW5nIGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgZGVmaW5lZFxuICAgICAgdGhyb3cgT3BhbC5Ob01ldGhvZEVycm9yLiRuZXcoJ3N1cGVyOiBubyBzdXBlcmNsYXNzIG1ldGhvZCBgJyttaWQrXCInIGZvciBcIitvYmosIG1pZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChzdXBlcl9tZXRob2QuJCRzdHViICYmICFhbGxvd19zdHVicykgPyBudWxsIDogc3VwZXJfbWV0aG9kO1xuICB9O1xuXG4gIC8vIEl0ZXIgZGlzcGF0Y2hlciBmb3Igc3VwZXIgaW4gYSBibG9ja1xuICBPcGFsLmZpbmRfaXRlcl9zdXBlcl9kaXNwYXRjaGVyID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBjdXJyZW50X2Z1bmMsIGRlZmNoZWNrLCBpbXBsaWNpdCkge1xuICAgIHZhciBjYWxsX2pzaWQgPSBqc2lkO1xuXG4gICAgaWYgKCFjdXJyZW50X2Z1bmMpIHtcbiAgICAgIHRocm93IE9wYWwuUnVudGltZUVycm9yLiRuZXcoXCJzdXBlciBjYWxsZWQgb3V0c2lkZSBvZiBtZXRob2RcIik7XG4gICAgfVxuXG4gICAgaWYgKGltcGxpY2l0ICYmIGN1cnJlbnRfZnVuYy4kJGRlZmluZV9tZXRoKSB7XG4gICAgICB0aHJvdyBPcGFsLlJ1bnRpbWVFcnJvci4kbmV3KFwiaW1wbGljaXQgYXJndW1lbnQgcGFzc2luZyBvZiBzdXBlciBmcm9tIG1ldGhvZCBkZWZpbmVkIGJ5IGRlZmluZV9tZXRob2QoKSBpcyBub3Qgc3VwcG9ydGVkLiBTcGVjaWZ5IGFsbCBhcmd1bWVudHMgZXhwbGljaXRseVwiKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudF9mdW5jLiQkZGVmKSB7XG4gICAgICBjYWxsX2pzaWQgPSBjdXJyZW50X2Z1bmMuJCRqc2lkO1xuICAgIH1cblxuICAgIHJldHVybiBPcGFsLmZpbmRfc3VwZXJfZGlzcGF0Y2hlcihvYmosIGNhbGxfanNpZCwgY3VycmVudF9mdW5jLCBkZWZjaGVjayk7XG4gIH07XG5cbiAgLy8gVXNlZCB0byByZXR1cm4gYXMgYW4gZXhwcmVzc2lvbi4gU29tZXRpbWVzLCB3ZSBjYW4ndCBzaW1wbHkgcmV0dXJuIGZyb21cbiAgLy8gYSBqYXZhc2NyaXB0IGZ1bmN0aW9uIGFzIGlmIHdlIHdlcmUgYSBtZXRob2QsIGFzIHRoZSByZXR1cm4gaXMgdXNlZCBhc1xuICAvLyBhbiBleHByZXNzaW9uLCBvciBldmVuIGluc2lkZSBhIGJsb2NrIHdoaWNoIG11c3QgXCJyZXR1cm5cIiB0byB0aGUgb3V0ZXJcbiAgLy8gbWV0aG9kLiBUaGlzIGhlbHBlciBzaW1wbHkgdGhyb3dzIGFuIGVycm9yIHdoaWNoIGlzIHRoZW4gY2F1Z2h0IGJ5IHRoZVxuICAvLyBtZXRob2QuIFRoaXMgYXBwcm9hY2ggaXMgZXhwZW5zaXZlLCBzbyBpdCBpcyBvbmx5IHVzZWQgd2hlbiBhYnNvbHV0ZWx5XG4gIC8vIG5lZWRlZC5cbiAgLy9cbiAgT3BhbC5yZXQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICBPcGFsLnJldHVybmVyLiR2ID0gdmFsO1xuICAgIHRocm93IE9wYWwucmV0dXJuZXI7XG4gIH07XG5cbiAgLy8gVXNlZCB0byBicmVhayBvdXQgb2YgYSBibG9jay5cbiAgT3BhbC5icmsgPSBmdW5jdGlvbih2YWwsIGJyZWFrZXIpIHtcbiAgICBicmVha2VyLiR2ID0gdmFsO1xuICAgIHRocm93IGJyZWFrZXI7XG4gIH07XG5cbiAgLy8gQnVpbGRzIGEgbmV3IHVuaXF1ZSBicmVha2VyLCB0aGlzIGlzIHRvIGF2b2lkIG11bHRpcGxlIG5lc3RlZCBicmVha3MgdG8gZ2V0XG4gIC8vIGluIHRoZSB3YXkgb2YgZWFjaCBvdGhlci5cbiAgT3BhbC5uZXdfYnJrID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcigndW5leHBlY3RlZCBicmVhaycpO1xuICB9O1xuXG4gIC8vIGhhbmRsZXMgeWllbGQgY2FsbHMgZm9yIDEgeWllbGRlZCBhcmdcbiAgT3BhbC55aWVsZDEgPSBmdW5jdGlvbihibG9jaywgYXJnKSB7XG4gICAgaWYgKHR5cGVvZihibG9jaykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgT3BhbC5Mb2NhbEp1bXBFcnJvci4kbmV3KFwibm8gYmxvY2sgZ2l2ZW5cIik7XG4gICAgfVxuXG4gICAgdmFyIGhhc19tbGhzID0gYmxvY2suJCRoYXNfdG9wX2xldmVsX21saHNfYXJnLFxuICAgICAgICBoYXNfdHJhaWxpbmdfY29tbWEgPSBibG9jay4kJGhhc190cmFpbGluZ19jb21tYV9pbl9hcmdzO1xuXG4gICAgaWYgKGJsb2NrLmxlbmd0aCA+IDEgfHwgKChoYXNfbWxocyB8fCBoYXNfdHJhaWxpbmdfY29tbWEpICYmIGJsb2NrLmxlbmd0aCA9PT0gMSkpIHtcbiAgICAgIGFyZyA9IE9wYWwudG9fYXJ5KGFyZyk7XG4gICAgfVxuXG4gICAgaWYgKChibG9jay5sZW5ndGggPiAxIHx8IChoYXNfdHJhaWxpbmdfY29tbWEgJiYgYmxvY2subGVuZ3RoID09PSAxKSkgJiYgYXJnLiQkaXNfYXJyYXkpIHtcbiAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBibG9jayhhcmcpO1xuICAgIH1cbiAgfTtcblxuICAvLyBoYW5kbGVzIHlpZWxkIGZvciA+IDEgeWllbGRlZCBhcmdcbiAgT3BhbC55aWVsZFggPSBmdW5jdGlvbihibG9jaywgYXJncykge1xuICAgIGlmICh0eXBlb2YoYmxvY2spICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IE9wYWwuTG9jYWxKdW1wRXJyb3IuJG5ldyhcIm5vIGJsb2NrIGdpdmVuXCIpO1xuICAgIH1cblxuICAgIGlmIChibG9jay5sZW5ndGggPiAxICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoYXJnc1swXS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmdzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFyZ3MuJCRpc19hcnJheSkge1xuICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmdzX2FyeS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgYXJnc19hcnlbaV0gPSBhcmdzW2ldOyB9XG5cbiAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmdzX2FyeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJsb2NrLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9O1xuXG4gIC8vIEZpbmRzIHRoZSBjb3JyZXNwb25kaW5nIGV4Y2VwdGlvbiBtYXRjaCBpbiBjYW5kaWRhdGVzLiAgRWFjaCBjYW5kaWRhdGUgY2FuXG4gIC8vIGJlIGEgdmFsdWUsIG9yIGFuIGFycmF5IG9mIHZhbHVlcy4gIFJldHVybnMgbnVsbCBpZiBub3QgZm91bmQuXG4gIE9wYWwucmVzY3VlID0gZnVuY3Rpb24oZXhjZXB0aW9uLCBjYW5kaWRhdGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1tpXTtcblxuICAgICAgaWYgKGNhbmRpZGF0ZS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBPcGFsLnJlc2N1ZShleGNlcHRpb24sIGNhbmRpZGF0ZSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZSA9PT0gT3BhbC5KUy5FcnJvcikge1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY2FuZGlkYXRlWyckPT09J10oZXhjZXB0aW9uKSkge1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIE9wYWwuaXNfYSA9IGZ1bmN0aW9uKG9iamVjdCwga2xhc3MpIHtcbiAgICBpZiAoa2xhc3MgIT0gbnVsbCAmJiBvYmplY3QuJCRtZXRhID09PSBrbGFzcyB8fCBvYmplY3QuJCRjbGFzcyA9PT0ga2xhc3MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvYmplY3QuJCRpc19udW1iZXIgJiYga2xhc3MuJCRpc19udW1iZXJfY2xhc3MpIHtcbiAgICAgIHJldHVybiAoa2xhc3MuJCRpc19pbnRlZ2VyX2NsYXNzKSA/IChvYmplY3QgJSAxKSA9PT0gMCA6IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGksIGxlbmd0aCwgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMob2JqZWN0LiQkaXNfY2xhc3MgPyBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqZWN0KSA6IChvYmplY3QuJCRtZXRhIHx8IG9iamVjdC4kJGNsYXNzKSk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhbmNlc3RvcnNbaV0gPT09IGtsYXNzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBIZWxwZXJzIGZvciBleHRyYWN0aW5nIGt3c3BsYXRzXG4gIC8vIFVzZWQgZm9yOiB7ICoqaCB9XG4gIE9wYWwudG9faGFzaCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLiQkaXNfaGFzaCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVsnJHJlc3BvbmRfdG8/J10oJ3RvX2hhc2gnLCB0cnVlKSkge1xuICAgICAgdmFyIGhhc2ggPSB2YWx1ZS4kdG9faGFzaCgpO1xuICAgICAgaWYgKGhhc2guJCRpc19oYXNoKSB7XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJDYW4ndCBjb252ZXJ0IFwiICsgdmFsdWUuJCRjbGFzcyArXG4gICAgICAgICAgXCIgdG8gSGFzaCAoXCIgKyB2YWx1ZS4kJGNsYXNzICsgXCIjdG9faGFzaCBnaXZlcyBcIiArIGhhc2guJCRjbGFzcyArIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiBcIiArIHZhbHVlLiQkY2xhc3MgKyBcIiBpbnRvIEhhc2hcIik7XG4gICAgfVxuICB9O1xuXG4gIC8vIEhlbHBlcnMgZm9yIGltcGxlbWVudGluZyBtdWx0aXBsZSBhc3NpZ25tZW50XG4gIC8vIE91ciBjb2RlIGZvciBleHRyYWN0aW5nIHRoZSB2YWx1ZXMgYW5kIGFzc2lnbmluZyB0aGVtIG9ubHkgd29ya3MgaWYgdGhlXG4gIC8vIHJldHVybiB2YWx1ZSBpcyBhIEpTIGFycmF5LlxuICAvLyBTbyBpZiB3ZSBnZXQgYW4gQXJyYXkgc3ViY2xhc3MsIGV4dHJhY3QgdGhlIHdyYXBwZWQgSlMgYXJyYXkgZnJvbSBpdFxuXG4gIC8vIFVzZWQgZm9yOiBhLCBiID0gc29tZXRoaW5nIChubyBzcGxhdClcbiAgT3BhbC50b19hcnkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS4kJGlzX2FycmF5KSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlWyckcmVzcG9uZF90bz8nXSgndG9fYXJ5JywgdHJ1ZSkpIHtcbiAgICAgIHZhciBhcnkgPSB2YWx1ZS4kdG9fYXJ5KCk7XG4gICAgICBpZiAoYXJ5ID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcnkuJCRpc19hcnJheSkge1xuICAgICAgICByZXR1cm4gYXJ5O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJDYW4ndCBjb252ZXJ0IFwiICsgdmFsdWUuJCRjbGFzcyArXG4gICAgICAgICAgXCIgdG8gQXJyYXkgKFwiICsgdmFsdWUuJCRjbGFzcyArIFwiI3RvX2FyeSBnaXZlcyBcIiArIGFyeS4kJGNsYXNzICsgXCIpXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgIH1cbiAgfTtcblxuICAvLyBVc2VkIGZvcjogYSwgYiA9ICpzb21ldGhpbmcgKHdpdGggc3BsYXQpXG4gIE9wYWwudG9fYSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLiQkaXNfYXJyYXkpIHtcbiAgICAgIC8vIEEgc3BsYXR0ZWQgYXJyYXkgbXVzdCBiZSBjb3BpZWRcbiAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVsnJHJlc3BvbmRfdG8/J10oJ3RvX2EnLCB0cnVlKSkge1xuICAgICAgdmFyIGFyeSA9IHZhbHVlLiR0b19hKCk7XG4gICAgICBpZiAoYXJ5ID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcnkuJCRpc19hcnJheSkge1xuICAgICAgICByZXR1cm4gYXJ5O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJDYW4ndCBjb252ZXJ0IFwiICsgdmFsdWUuJCRjbGFzcyArXG4gICAgICAgICAgXCIgdG8gQXJyYXkgKFwiICsgdmFsdWUuJCRjbGFzcyArIFwiI3RvX2EgZ2l2ZXMgXCIgKyBhcnkuJCRjbGFzcyArIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCBmb3IgZXh0cmFjdGluZyBrZXl3b3JkIGFyZ3VtZW50cyBmcm9tIGFyZ3VtZW50cyBwYXNzZWQgdG9cbiAgLy8gSlMgZnVuY3Rpb24uIElmIHByb3ZpZGVkICthcmd1bWVudHMrIGxpc3QgZG9lc24ndCBoYXZlIGEgSGFzaFxuICAvLyBhcyBhIGxhc3QgaXRlbSwgcmV0dXJucyBhIGJsYW5rIEhhc2guXG4gIC8vXG4gIC8vIEBwYXJhbSBwYXJhbWV0ZXJzIFtBcnJheV1cbiAgLy8gQHJldHVybiBbSGFzaF1cbiAgLy9cbiAgT3BhbC5leHRyYWN0X2t3YXJncyA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcbiAgICB2YXIga3dhcmdzID0gcGFyYW1ldGVyc1twYXJhbWV0ZXJzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChrd2FyZ3MgIT0gbnVsbCAmJiBPcGFsLnJlc3BvbmRfdG8oa3dhcmdzLCAnJHRvX2hhc2gnLCB0cnVlKSkge1xuICAgICAgJHNwbGljZS5jYWxsKHBhcmFtZXRlcnMsIHBhcmFtZXRlcnMubGVuZ3RoIC0gMSwgMSk7XG4gICAgICByZXR1cm4ga3dhcmdzLiR0b19oYXNoKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIE9wYWwuaGFzaDIoW10sIHt9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCB0byBnZXQgYSBsaXN0IG9mIHJlc3Qga2V5d29yZCBhcmd1bWVudHMuIE1ldGhvZCB0YWtlcyB0aGUgZ2l2ZW5cbiAgLy8ga2V5d29yZCBhcmdzLCBpLmUuIHRoZSBoYXNoIGxpdGVyYWwgcGFzc2VkIHRvIHRoZSBtZXRob2QgY29udGFpbmluZyBhbGxcbiAgLy8ga2V5d29yZCBhcmd1ZW1udHMgcGFzc2VkIHRvIG1ldGhvZCwgYXMgd2VsbCBhcyB0aGUgdXNlZCBhcmdzIHdoaWNoIGFyZVxuICAvLyB0aGUgbmFtZXMgb2YgcmVxdWlyZWQgYW5kIG9wdGlvbmFsIGFyZ3VtZW50cyBkZWZpbmVkLiBUaGlzIG1ldGhvZCB0aGVuXG4gIC8vIGp1c3QgcmV0dXJucyBhbGwga2V5L3ZhbHVlIHBhaXJzIHdoaWNoIGhhdmUgbm90IGJlZW4gdXNlZCwgaW4gYSBuZXdcbiAgLy8gaGFzaCBsaXRlcmFsLlxuICAvL1xuICAvLyBAcGFyYW0gZ2l2ZW5fYXJncyBbSGFzaF0gYWxsIGt3YXJncyBnaXZlbiB0byBtZXRob2RcbiAgLy8gQHBhcmFtIHVzZWRfYXJncyBbT2JqZWN0PFN0cmluZzogdHJ1ZT5dIGFsbCBrZXlzIHVzZWQgYXMgbmFtZWQga3dhcmdzXG4gIC8vIEByZXR1cm4gW0hhc2hdXG4gIC8vXG4gIE9wYWwua3dyZXN0YXJncyA9IGZ1bmN0aW9uKGdpdmVuX2FyZ3MsIHVzZWRfYXJncykge1xuICAgIHZhciBrZXlzICAgICAgPSBbXSxcbiAgICAgICAgbWFwICAgICAgID0ge30sXG4gICAgICAgIGtleSAgICAgICAgICAgLFxuICAgICAgICBnaXZlbl9tYXAgPSBnaXZlbl9hcmdzLiQkc21hcDtcblxuICAgIGZvciAoa2V5IGluIGdpdmVuX21hcCkge1xuICAgICAgaWYgKCF1c2VkX2FyZ3Nba2V5XSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgbWFwW2tleV0gPSBnaXZlbl9tYXBba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5oYXNoMihrZXlzLCBtYXApO1xuICB9O1xuXG4gIC8vIENhbGxzIHBhc3NlZCBtZXRob2Qgb24gYSBydWJ5IG9iamVjdCB3aXRoIGFyZ3VtZW50cyBhbmQgYmxvY2s6XG4gIC8vXG4gIC8vIENhbiB0YWtlIGEgbWV0aG9kIG9yIGEgbWV0aG9kIG5hbWUuXG4gIC8vXG4gIC8vIDEuIFdoZW4gbWV0aG9kIG5hbWUgZ2V0cyBwYXNzZWQgaXQgaW52b2tlcyBpdCBieSBpdHMgbmFtZVxuICAvLyAgICBhbmQgY2FsbHMgJ21ldGhvZF9taXNzaW5nJyB3aGVuIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhpcyBtZXRob2QuXG4gIC8vICAgIFVzZWQgaW50ZXJuYWxseSBieSBPcGFsIHRvIGludm9rZSBtZXRob2QgdGhhdCB0YWtlcyBhIGJsb2NrIG9yIGEgc3BsYXQuXG4gIC8vIDIuIFdoZW4gbWV0aG9kIChpLmUuIG1ldGhvZCBib2R5KSBnZXRzIHBhc3NlZCwgaXQgZG9lc24ndCB0cmlnZ2VyICdtZXRob2RfbWlzc2luZydcbiAgLy8gICAgYmVjYXVzZSBpdCBkb2Vzbid0IGtub3cgdGhlIG5hbWUgb2YgdGhlIGFjdHVhbCBtZXRob2QuXG4gIC8vICAgIFVzZWQgaW50ZXJuYWxseSBieSBPcGFsIHRvIGludm9rZSAnc3VwZXInLlxuICAvL1xuICAvLyBAZXhhbXBsZVxuICAvLyAgIHZhciBteV9hcnJheSA9IFsxLCAyLCAzLCA0XVxuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgJ2xlbmd0aCcpICAgICAgICAgICAgICAgICAgICAjID0+IDRcbiAgLy8gICBPcGFsLnNlbmQobXlfYXJyYXksIG15X2FycmF5LiRsZW5ndGgpICAgICAgICAgICAgIyA9PiA0XG4gIC8vXG4gIC8vICAgT3BhbC5zZW5kKG15X2FycmF5LCAncmV2ZXJzZSEnKSAgICAgICAgICAgICAgICAgICMgPT4gWzQsIDMsIDIsIDFdXG4gIC8vICAgT3BhbC5zZW5kKG15X2FycmF5LCBteV9hcnJheVsnJHJldmVyc2UhJ10nKSAgICAgICMgPT4gWzQsIDMsIDIsIDFdXG4gIC8vXG4gIC8vIEBwYXJhbSByZWN2IFtPYmplY3RdIHJ1Ynkgb2JqZWN0XG4gIC8vIEBwYXJhbSBtZXRob2QgW0Z1bmN0aW9uLCBTdHJpbmddIG1ldGhvZCBib2R5IG9yIG5hbWUgb2YgdGhlIG1ldGhvZFxuICAvLyBAcGFyYW0gYXJncyBbQXJyYXldIGFyZ3VtZW50cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBtZXRob2QgY2FsbFxuICAvLyBAcGFyYW0gYmxvY2sgW0Z1bmN0aW9uXSBydWJ5IGJsb2NrXG4gIC8vIEByZXR1cm4gW09iamVjdF0gcmV0dXJuaW5nIHZhbHVlIG9mIHRoZSBtZXRob2QgY2FsbFxuICBPcGFsLnNlbmQgPSBmdW5jdGlvbihyZWN2LCBtZXRob2QsIGFyZ3MsIGJsb2NrKSB7XG4gICAgdmFyIGJvZHk7XG5cbiAgICBpZiAodHlwZW9mKG1ldGhvZCkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJvZHkgPSBtZXRob2Q7XG4gICAgICBtZXRob2QgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mKG1ldGhvZCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBib2R5ID0gcmVjdlsnJCcrbWV0aG9kXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcIlBhc3NlZCBtZXRob2Qgc2hvdWxkIGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9wYWwuc2VuZDIocmVjdiwgYm9keSwgbWV0aG9kLCBhcmdzLCBibG9jayk7XG4gIH07XG5cbiAgT3BhbC5zZW5kMiA9IGZ1bmN0aW9uKHJlY3YsIGJvZHksIG1ldGhvZCwgYXJncywgYmxvY2spIHtcbiAgICBpZiAoYm9keSA9PSBudWxsICYmIG1ldGhvZCAhPSBudWxsICYmIHJlY3YuJG1ldGhvZF9taXNzaW5nKSB7XG4gICAgICBib2R5ID0gcmVjdi4kbWV0aG9kX21pc3Npbmc7XG4gICAgICBhcmdzID0gW21ldGhvZF0uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIGJvZHkuJCRwID0gYmxvY2s7XG4gICAgcmV0dXJuIGJvZHkuYXBwbHkocmVjdiwgYXJncyk7XG4gIH07XG5cbiAgT3BhbC5sYW1iZGEgPSBmdW5jdGlvbihibG9jaykge1xuICAgIGJsb2NrLiQkaXNfbGFtYmRhID0gdHJ1ZTtcbiAgICByZXR1cm4gYmxvY2s7XG4gIH07XG5cbiAgLy8gVXNlZCB0byBkZWZpbmUgbWV0aG9kcyBvbiBhbiBvYmplY3QuIFRoaXMgaXMgYSBoZWxwZXIgbWV0aG9kLCB1c2VkIGJ5IHRoZVxuICAvLyBjb21waWxlZCBzb3VyY2UgdG8gZGVmaW5lIG1ldGhvZHMgb24gc3BlY2lhbCBjYXNlIG9iamVjdHMgd2hlbiB0aGUgY29tcGlsZXJcbiAgLy8gY2FuIG5vdCBkZXRlcm1pbmUgdGhlIGRlc3RpbmF0aW9uIG9iamVjdCwgb3IgdGhlIG9iamVjdCBpcyBhIE1vZHVsZVxuICAvLyBpbnN0YW5jZS4gVGhpcyBjYW4gZ2V0IGNhbGxlZCBieSBgTW9kdWxlI2RlZmluZV9tZXRob2RgIGFzIHdlbGwuXG4gIC8vXG4gIC8vICMjIE1vZHVsZXNcbiAgLy9cbiAgLy8gQW55IG1ldGhvZCBkZWZpbmVkIG9uIGEgbW9kdWxlIHdpbGwgY29tZSB0aHJvdWdoIHRoaXMgcnVudGltZSBoZWxwZXIuXG4gIC8vIFRoZSBtZXRob2QgaXMgYWRkZWQgdG8gdGhlIG1vZHVsZSBib2R5LCBhbmQgdGhlIG93bmVyIG9mIHRoZSBtZXRob2QgaXNcbiAgLy8gc2V0IHRvIGJlIHRoZSBtb2R1bGUgaXRzZWxmLiBUaGlzIGlzIHVzZWQgbGF0ZXIgd2hlbiBjaG9vc2luZyB3aGljaFxuICAvLyBtZXRob2Qgc2hvdWxkIHNob3cgb24gYSBjbGFzcyBpZiBtb3JlIHRoYW4gMSBpbmNsdWRlZCBtb2R1bGVzIGRlZmluZVxuICAvLyB0aGUgc2FtZSBtZXRob2QuIEZpbmFsbHksIGlmIHRoZSBtb2R1bGUgaXMgaW4gYG1vZHVsZV9mdW5jdGlvbmAgbW9kZSxcbiAgLy8gdGhlbiB0aGUgbWV0aG9kIGlzIGFsc28gZGVmaW5lZCBvbnRvIHRoZSBtb2R1bGUgaXRzZWxmLlxuICAvL1xuICAvLyAjIyBDbGFzc2VzXG4gIC8vXG4gIC8vIFRoaXMgaGVscGVyIHdpbGwgb25seSBiZSBjYWxsZWQgZm9yIGNsYXNzZXMgd2hlbiBhIG1ldGhvZCBpcyBiZWluZ1xuICAvLyBkZWZpbmVkIGluZGlyZWN0bHk7IGVpdGhlciB0aHJvdWdoIGBNb2R1bGUjZGVmaW5lX21ldGhvZGAsIG9yIGJ5IGFcbiAgLy8gbGl0ZXJhbCBgZGVmYCBtZXRob2QgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBvciBgY2xhc3NfZXZhbGAgYm9keS4gSW5cbiAgLy8gZWl0aGVyIGNhc2UsIHRoZSBtZXRob2QgaXMgc2ltcGx5IGFkZGVkIHRvIHRoZSBjbGFzcycgcHJvdG90eXBlLiBBIHNwZWNpYWxcbiAgLy8gZXhjZXB0aW9uIGV4aXN0cyBmb3IgYEJhc2ljT2JqZWN0YCBhbmQgYE9iamVjdGAuIFRoZXNlIHR3byBjbGFzc2VzIGFyZVxuICAvLyBzcGVjaWFsIGJlY2F1c2UgdGhleSBhcmUgdXNlZCBpbiB0b2xsLWZyZWUgYnJpZGdlZCBjbGFzc2VzLiBJbiBlYWNoIG9mXG4gIC8vIHRoZXNlIHR3byBjYXNlcywgZXh0cmEgd29yayBpcyByZXF1aXJlZCB0byBkZWZpbmUgdGhlIG1ldGhvZHMgb24gdG9sbC1mcmVlXG4gIC8vIGJyaWRnZWQgY2xhc3MnIHByb3RvdHlwZXMgYXMgd2VsbC5cbiAgLy9cbiAgLy8gIyMgT2JqZWN0c1xuICAvL1xuICAvLyBJZiBhIHNpbXBsZSBydWJ5IG9iamVjdCBpcyB0aGUgb2JqZWN0LCB0aGVuIHRoZSBtZXRob2QgaXMgc2ltcGx5IGp1c3RcbiAgLy8gZGVmaW5lZCBvbiB0aGUgb2JqZWN0IGFzIGEgc2luZ2xldG9uIG1ldGhvZC4gVGhpcyB3b3VsZCBiZSB0aGUgY2FzZSB3aGVuXG4gIC8vIGEgbWV0aG9kIGlzIGRlZmluZWQgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBibG9jay5cbiAgLy9cbiAgLy8gQHBhcmFtIG9iaiAgW09iamVjdCwgQ2xhc3NdIHRoZSBhY3R1YWwgb2JqIHRvIGRlZmluZSBtZXRob2QgZm9yXG4gIC8vIEBwYXJhbSBqc2lkIFtTdHJpbmddIHRoZSBKYXZhU2NyaXB0IGZyaWVuZGx5IG1ldGhvZCBuYW1lIChlLmcuICckZm9vJylcbiAgLy8gQHBhcmFtIGJvZHkgW0pTLkZ1bmN0aW9uXSB0aGUgbGl0ZXJhbCBKYXZhU2NyaXB0IGZ1bmN0aW9uIHVzZWQgYXMgbWV0aG9kXG4gIC8vIEByZXR1cm4gW251bGxdXG4gIC8vXG4gIE9wYWwuZGVmID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBib2R5KSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIG1ldGhvZCBkZWZpbml0aW9uIGluIHRoZVxuICAgIC8vIHRvcC1sZXZlbCBuYW1lc3BhY2VcbiAgICBpZiAob2JqID09PSBPcGFsLnRvcCkge1xuICAgICAgT3BhbC5kZWZuKE9wYWwuT2JqZWN0LCBqc2lkLCBib2R5KVxuICAgIH1cbiAgICAvLyBpZiBpbnN0YW5jZV9ldmFsIGlzIGludm9rZWQgb24gYSBtb2R1bGUvY2xhc3MsIGl0IHNldHMgaW5zdF9ldmFsX21vZFxuICAgIGVsc2UgaWYgKCFvYmouJCRldmFsICYmIG9iai4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICBPcGFsLmRlZm4ob2JqLCBqc2lkLCBib2R5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBPcGFsLmRlZnMob2JqLCBqc2lkLCBib2R5KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRGVmaW5lIG1ldGhvZCBvbiBhIG1vZHVsZSBvciBjbGFzcyAoc2VlIE9wYWwuZGVmKS5cbiAgT3BhbC5kZWZuID0gZnVuY3Rpb24obW9kdWxlLCBqc2lkLCBib2R5KSB7XG4gICAgYm9keS5kaXNwbGF5TmFtZSA9IGpzaWQ7XG4gICAgYm9keS4kJG93bmVyID0gbW9kdWxlO1xuXG4gICAgdmFyIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlO1xuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfVxuICAgICRkZWZpbmVQcm9wZXJ0eShwcm90bywganNpZCwgYm9keSk7XG5cbiAgICBpZiAobW9kdWxlLiQkaXNfbW9kdWxlKSB7XG4gICAgICBpZiAobW9kdWxlLiQkbW9kdWxlX2Z1bmN0aW9uKSB7XG4gICAgICAgIE9wYWwuZGVmcyhtb2R1bGUsIGpzaWQsIGJvZHkpXG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpY2xhc3NlcyA9IG1vZHVsZS4kJGljbGFzc2VzLCBsZW5ndGggPSBpY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWNsYXNzID0gaWNsYXNzZXNbaV07XG4gICAgICAgICRkZWZpbmVQcm9wZXJ0eShpY2xhc3MsIGpzaWQsIGJvZHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaW5nbGV0b25fb2YgPSBtb2R1bGUuJCRzaW5nbGV0b25fb2Y7XG4gICAgaWYgKG1vZHVsZS4kbWV0aG9kX2FkZGVkICYmICFtb2R1bGUuJG1ldGhvZF9hZGRlZC4kJHN0dWIgJiYgIXNpbmdsZXRvbl9vZikge1xuICAgICAgbW9kdWxlLiRtZXRob2RfYWRkZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzaW5nbGV0b25fb2YgJiYgc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkICYmICFzaW5nbGV0b25fb2YuJHNpbmdsZXRvbl9tZXRob2RfYWRkZWQuJCRzdHViKSB7XG4gICAgICBzaW5nbGV0b25fb2YuJHNpbmdsZXRvbl9tZXRob2RfYWRkZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBEZWZpbmUgYSBzaW5nbGV0b24gbWV0aG9kIG9uIHRoZSBnaXZlbiBvYmplY3QgKHNlZSBPcGFsLmRlZikuXG4gIE9wYWwuZGVmcyA9IGZ1bmN0aW9uKG9iaiwganNpZCwgYm9keSkge1xuICAgIGlmIChvYmouJCRpc19zdHJpbmcgfHwgb2JqLiQkaXNfbnVtYmVyKSB7XG4gICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiY2FuJ3QgZGVmaW5lIHNpbmdsZXRvblwiKTtcbiAgICB9XG4gICAgT3BhbC5kZWZuKE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmopLCBqc2lkLCBib2R5KVxuICB9O1xuXG4gIC8vIENhbGxlZCBmcm9tICNyZW1vdmVfbWV0aG9kLlxuICBPcGFsLnJkZWYgPSBmdW5jdGlvbihvYmosIGpzaWQpIHtcbiAgICBpZiAoISRoYXNfb3duLmNhbGwob2JqLiQkcHJvdG90eXBlLCBqc2lkKSkge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcIm1ldGhvZCAnXCIgKyBqc2lkLnN1YnN0cigxKSArIFwiJyBub3QgZGVmaW5lZCBpbiBcIiArIG9iai4kbmFtZSgpKTtcbiAgICB9XG5cbiAgICBkZWxldGUgb2JqLiQkcHJvdG90eXBlW2pzaWRdO1xuXG4gICAgaWYgKG9iai4kJGlzX3NpbmdsZXRvbikge1xuICAgICAgaWYgKG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF9yZW1vdmVkICYmICFvYmouJCRwcm90b3R5cGUuJHNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChvYmouJG1ldGhvZF9yZW1vdmVkICYmICFvYmouJG1ldGhvZF9yZW1vdmVkLiQkc3R1Yikge1xuICAgICAgICBvYmouJG1ldGhvZF9yZW1vdmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGZyb20gI3VuZGVmX21ldGhvZC5cbiAgT3BhbC51ZGVmID0gZnVuY3Rpb24ob2JqLCBqc2lkKSB7XG4gICAgaWYgKCFvYmouJCRwcm90b3R5cGVbanNpZF0gfHwgb2JqLiQkcHJvdG90eXBlW2pzaWRdLiQkc3R1Yikge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcIm1ldGhvZCAnXCIgKyBqc2lkLnN1YnN0cigxKSArIFwiJyBub3QgZGVmaW5lZCBpbiBcIiArIG9iai4kbmFtZSgpKTtcbiAgICB9XG5cbiAgICBPcGFsLmFkZF9zdHViX2ZvcihvYmouJCRwcm90b3R5cGUsIGpzaWQpO1xuXG4gICAgaWYgKG9iai4kJGlzX3NpbmdsZXRvbikge1xuICAgICAgaWYgKG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQgJiYgIW9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQuJCRzdHViKSB7XG4gICAgICAgIG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChvYmouJG1ldGhvZF91bmRlZmluZWQgJiYgIW9iai4kbWV0aG9kX3VuZGVmaW5lZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiRtZXRob2RfdW5kZWZpbmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNfbWV0aG9kX2JvZHkoYm9keSkge1xuICAgIHJldHVybiAodHlwZW9mKGJvZHkpID09PSBcImZ1bmN0aW9uXCIgJiYgIWJvZHkuJCRzdHViKTtcbiAgfVxuXG4gIE9wYWwuYWxpYXMgPSBmdW5jdGlvbihvYmosIG5hbWUsIG9sZCkge1xuICAgIHZhciBpZCAgICAgPSAnJCcgKyBuYW1lLFxuICAgICAgICBvbGRfaWQgPSAnJCcgKyBvbGQsXG4gICAgICAgIGJvZHkgICA9IG9iai4kJHByb3RvdHlwZVsnJCcgKyBvbGRdLFxuICAgICAgICBhbGlhcztcblxuICAgIC8vIFdoZW4gcnVubmluZyBpbnNpZGUgI2luc3RhbmNlX2V2YWwgdGhlIGFsaWFzIHJlZmVycyB0byBjbGFzcyBtZXRob2RzLlxuICAgIGlmIChvYmouJCRldmFsKSB7XG4gICAgICByZXR1cm4gT3BhbC5hbGlhcyhPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSwgbmFtZSwgb2xkKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBvYmouJCRzdXBlcjtcblxuICAgICAgd2hpbGUgKHR5cGVvZihib2R5KSAhPT0gXCJmdW5jdGlvblwiICYmIGFuY2VzdG9yKSB7XG4gICAgICAgIGJvZHkgICAgID0gYW5jZXN0b3Jbb2xkX2lkXTtcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci4kJHN1cGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpICYmIG9iai4kJGlzX21vZHVsZSkge1xuICAgICAgICAvLyB0cnkgdG8gbG9vayBpbnRvIE9iamVjdFxuICAgICAgICBib2R5ID0gT3BhbC5PYmplY3QuJCRwcm90b3R5cGVbb2xkX2lkXVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpKSB7XG4gICAgICAgIHRocm93IE9wYWwuTmFtZUVycm9yLiRuZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGBcIiArIG9sZCArIFwiJyBmb3IgY2xhc3MgYFwiICsgb2JqLiRuYW1lKCkgKyBcIidcIilcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgYm9keSBpcyBpdHNlbGYgYW4gYWxpYXMgdXNlIHRoZSBvcmlnaW5hbCBib2R5XG4gICAgLy8gdG8ga2VlcCB0aGUgbWF4IGRlcHRoIGF0IDEuXG4gICAgaWYgKGJvZHkuJCRhbGlhc19vZikgYm9keSA9IGJvZHkuJCRhbGlhc19vZjtcblxuICAgIC8vIFdlIG5lZWQgYSB3cmFwcGVyIGJlY2F1c2Ugb3RoZXJ3aXNlIHByb3BlcnRpZXNcbiAgICAvLyB3b3VsZCBiZSBvdmVyd3JpdHRlbiBvbiB0aGUgb3JpZ2luYWwgYm9keS5cbiAgICBhbGlhcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJsb2NrID0gYWxpYXMuJCRwLCBhcmdzLCBpLCBpaTtcblxuICAgICAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgIGZvcihpID0gMCwgaWkgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT0gbnVsbCkgeyBhbGlhcy4kJHAgPSBudWxsIH1cblxuICAgICAgcmV0dXJuIE9wYWwuc2VuZCh0aGlzLCBib2R5LCBhcmdzLCBibG9jayk7XG4gICAgfTtcblxuICAgIC8vIEFzc2lnbiB0aGUgJ2xlbmd0aCcgdmFsdWUgd2l0aCBkZWZpbmVQcm9wZXJ0eSBiZWNhdXNlXG4gICAgLy8gaW4gc3RyaWN0IG1vZGUgdGhlIHByb3BlcnR5IGlzIG5vdCB3cml0YWJsZS5cbiAgICAvLyBJdCBkb2Vzbid0IHdvcmsgaW4gb2xkZXIgYnJvd3NlcnMgKGxpa2UgQ2hyb21lIDM4KSwgd2hlcmVcbiAgICAvLyBhbiBleGNlcHRpb24gaXMgdGhyb3duIGJyZWFraW5nIE9wYWwgYWx0b2dldGhlci5cbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFsaWFzLCAnbGVuZ3RoJywgeyB2YWx1ZTogYm9keS5sZW5ndGggfSk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIFRyeSB0byBtYWtlIHRoZSBicm93c2VyIHBpY2sgdGhlIHJpZ2h0IG5hbWVcbiAgICBhbGlhcy5kaXNwbGF5TmFtZSAgICAgICA9IG5hbWU7XG5cbiAgICBhbGlhcy4kJGFyaXR5ICAgICAgICAgICA9IGJvZHkuJCRhcml0eTtcbiAgICBhbGlhcy4kJHBhcmFtZXRlcnMgICAgICA9IGJvZHkuJCRwYXJhbWV0ZXJzO1xuICAgIGFsaWFzLiQkc291cmNlX2xvY2F0aW9uID0gYm9keS4kJHNvdXJjZV9sb2NhdGlvbjtcbiAgICBhbGlhcy4kJGFsaWFzX29mICAgICAgICA9IGJvZHk7XG4gICAgYWxpYXMuJCRhbGlhc19uYW1lICAgICAgPSBuYW1lO1xuXG4gICAgT3BhbC5kZWZuKG9iaiwgaWQsIGFsaWFzKTtcblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgT3BhbC5hbGlhc19uYXRpdmUgPSBmdW5jdGlvbihvYmosIG5hbWUsIG5hdGl2ZV9uYW1lKSB7XG4gICAgdmFyIGlkICAgPSAnJCcgKyBuYW1lLFxuICAgICAgICBib2R5ID0gb2JqLiQkcHJvdG90eXBlW25hdGl2ZV9uYW1lXTtcblxuICAgIGlmICh0eXBlb2YoYm9keSkgIT09IFwiZnVuY3Rpb25cIiB8fCBib2R5LiQkc3R1Yikge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcInVuZGVmaW5lZCBuYXRpdmUgbWV0aG9kIGBcIiArIG5hdGl2ZV9uYW1lICsgXCInIGZvciBjbGFzcyBgXCIgKyBvYmouJG5hbWUoKSArIFwiJ1wiKVxuICAgIH1cblxuICAgIE9wYWwuZGVmbihvYmosIGlkLCBib2R5KTtcblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cblxuICAvLyBIYXNoZXNcbiAgLy8gLS0tLS0tXG5cbiAgT3BhbC5oYXNoX2luaXQgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgaGFzaC4kJHNtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGhhc2guJCRtYXAgID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBoYXNoLiQka2V5cyA9IFtdO1xuICB9O1xuXG4gIE9wYWwuaGFzaF9jbG9uZSA9IGZ1bmN0aW9uKGZyb21faGFzaCwgdG9faGFzaCkge1xuICAgIHRvX2hhc2guJCRub25lID0gZnJvbV9oYXNoLiQkbm9uZTtcbiAgICB0b19oYXNoLiQkcHJvYyA9IGZyb21faGFzaC4kJHByb2M7XG5cbiAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IGZyb21faGFzaC4kJGtleXMsIHNtYXAgPSBmcm9tX2hhc2guJCRzbWFwLCBsZW4gPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gc21hcFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICB9XG5cbiAgICAgIE9wYWwuaGFzaF9wdXQodG9faGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwuaGFzaF9wdXQgPSBmdW5jdGlvbihoYXNoLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgaWYgKCEkaGFzX293bi5jYWxsKGhhc2guJCRzbWFwLCBrZXkpKSB7XG4gICAgICAgIGhhc2guJCRrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICAgIGhhc2guJCRzbWFwW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIga2V5X2hhc2gsIGJ1Y2tldCwgbGFzdF9idWNrZXQ7XG4gICAga2V5X2hhc2ggPSBoYXNoLiQkYnlfaWRlbnRpdHkgPyBPcGFsLmlkKGtleSkgOiBrZXkuJGhhc2goKTtcblxuICAgIGlmICghJGhhc19vd24uY2FsbChoYXNoLiQkbWFwLCBrZXlfaGFzaCkpIHtcbiAgICAgIGJ1Y2tldCA9IHtrZXk6IGtleSwga2V5X2hhc2g6IGtleV9oYXNoLCB2YWx1ZTogdmFsdWV9O1xuICAgICAgaGFzaC4kJGtleXMucHVzaChidWNrZXQpO1xuICAgICAgaGFzaC4kJG1hcFtrZXlfaGFzaF0gPSBidWNrZXQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYnVja2V0ID0gaGFzaC4kJG1hcFtrZXlfaGFzaF07XG5cbiAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICBpZiAoa2V5ID09PSBidWNrZXQua2V5IHx8IGtleVsnJGVxbD8nXShidWNrZXQua2V5KSkge1xuICAgICAgICBsYXN0X2J1Y2tldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnVja2V0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGFzdF9idWNrZXQgPSBidWNrZXQ7XG4gICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICB9XG5cbiAgICBpZiAobGFzdF9idWNrZXQpIHtcbiAgICAgIGJ1Y2tldCA9IHtrZXk6IGtleSwga2V5X2hhc2g6IGtleV9oYXNoLCB2YWx1ZTogdmFsdWV9O1xuICAgICAgaGFzaC4kJGtleXMucHVzaChidWNrZXQpO1xuICAgICAgbGFzdF9idWNrZXQubmV4dCA9IGJ1Y2tldDtcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX2dldCA9IGZ1bmN0aW9uKGhhc2gsIGtleSkge1xuICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgIGlmICgkaGFzX293bi5jYWxsKGhhc2guJCRzbWFwLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBoYXNoLiQkc21hcFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXlfaGFzaCwgYnVja2V0O1xuICAgIGtleV9oYXNoID0gaGFzaC4kJGJ5X2lkZW50aXR5ID8gT3BhbC5pZChrZXkpIDoga2V5LiRoYXNoKCk7XG5cbiAgICBpZiAoJGhhc19vd24uY2FsbChoYXNoLiQkbWFwLCBrZXlfaGFzaCkpIHtcbiAgICAgIGJ1Y2tldCA9IGhhc2guJCRtYXBba2V5X2hhc2hdO1xuXG4gICAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICAgIGlmIChrZXkgPT09IGJ1Y2tldC5rZXkgfHwga2V5WyckZXFsPyddKGJ1Y2tldC5rZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGJ1Y2tldC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX2RlbGV0ZSA9IGZ1bmN0aW9uKGhhc2gsIGtleSkge1xuICAgIHZhciBpLCBrZXlzID0gaGFzaC4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCB2YWx1ZTtcblxuICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiKSBrZXkgPSBrZXkudmFsdWVPZigpO1xuXG4gICAgICBpZiAoISRoYXNfb3duLmNhbGwoaGFzaC4kJHNtYXAsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGtleXNbaV0gPT09IGtleSkge1xuICAgICAgICAgIGtleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gaGFzaC4kJHNtYXBba2V5XTtcbiAgICAgIGRlbGV0ZSBoYXNoLiQkc21hcFtrZXldO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBrZXlfaGFzaCA9IGtleS4kaGFzaCgpO1xuXG4gICAgaWYgKCEkaGFzX293bi5jYWxsKGhhc2guJCRtYXAsIGtleV9oYXNoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBidWNrZXQgPSBoYXNoLiQkbWFwW2tleV9oYXNoXSwgbGFzdF9idWNrZXQ7XG5cbiAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICBpZiAoa2V5ID09PSBidWNrZXQua2V5IHx8IGtleVsnJGVxbD8nXShidWNrZXQua2V5KSkge1xuICAgICAgICB2YWx1ZSA9IGJ1Y2tldC52YWx1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoa2V5c1tpXSA9PT0gYnVja2V0KSB7XG4gICAgICAgICAgICBrZXlzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0X2J1Y2tldCAmJiBidWNrZXQubmV4dCkge1xuICAgICAgICAgIGxhc3RfYnVja2V0Lm5leHQgPSBidWNrZXQubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYXN0X2J1Y2tldCkge1xuICAgICAgICAgIGRlbGV0ZSBsYXN0X2J1Y2tldC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ1Y2tldC5uZXh0KSB7XG4gICAgICAgICAgaGFzaC4kJG1hcFtrZXlfaGFzaF0gPSBidWNrZXQubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgaGFzaC4kJG1hcFtrZXlfaGFzaF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBsYXN0X2J1Y2tldCA9IGJ1Y2tldDtcbiAgICAgIGJ1Y2tldCA9IGJ1Y2tldC5uZXh0O1xuICAgIH1cbiAgfTtcblxuICBPcGFsLmhhc2hfcmVoYXNoID0gZnVuY3Rpb24oaGFzaCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBoYXNoLiQka2V5cy5sZW5ndGgsIGtleV9oYXNoLCBidWNrZXQsIGxhc3RfYnVja2V0OyBpIDwgbGVuZ3RoOyBpKyspIHtcblxuICAgICAgaWYgKGhhc2guJCRrZXlzW2ldLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBrZXlfaGFzaCA9IGhhc2guJCRrZXlzW2ldLmtleS4kaGFzaCgpO1xuXG4gICAgICBpZiAoa2V5X2hhc2ggPT09IGhhc2guJCRrZXlzW2ldLmtleV9oYXNoKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBidWNrZXQgPSBoYXNoLiQkbWFwW2hhc2guJCRrZXlzW2ldLmtleV9oYXNoXTtcbiAgICAgIGxhc3RfYnVja2V0ID0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICAgIGlmIChidWNrZXQgPT09IGhhc2guJCRrZXlzW2ldKSB7XG4gICAgICAgICAgaWYgKGxhc3RfYnVja2V0ICYmIGJ1Y2tldC5uZXh0KSB7XG4gICAgICAgICAgICBsYXN0X2J1Y2tldC5uZXh0ID0gYnVja2V0Lm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGxhc3RfYnVja2V0KSB7XG4gICAgICAgICAgICBkZWxldGUgbGFzdF9idWNrZXQubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoYnVja2V0Lm5leHQpIHtcbiAgICAgICAgICAgIGhhc2guJCRtYXBbaGFzaC4kJGtleXNbaV0ua2V5X2hhc2hdID0gYnVja2V0Lm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGhhc2guJCRtYXBbaGFzaC4kJGtleXNbaV0ua2V5X2hhc2hdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsYXN0X2J1Y2tldCA9IGJ1Y2tldDtcbiAgICAgICAgYnVja2V0ID0gYnVja2V0Lm5leHQ7XG4gICAgICB9XG5cbiAgICAgIGhhc2guJCRrZXlzW2ldLmtleV9oYXNoID0ga2V5X2hhc2g7XG5cbiAgICAgIGlmICghJGhhc19vd24uY2FsbChoYXNoLiQkbWFwLCBrZXlfaGFzaCkpIHtcbiAgICAgICAgaGFzaC4kJG1hcFtrZXlfaGFzaF0gPSBoYXNoLiQka2V5c1tpXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJ1Y2tldCA9IGhhc2guJCRtYXBba2V5X2hhc2hdO1xuICAgICAgbGFzdF9idWNrZXQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgICAgaWYgKGJ1Y2tldCA9PT0gaGFzaC4kJGtleXNbaV0pIHtcbiAgICAgICAgICBsYXN0X2J1Y2tldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsYXN0X2J1Y2tldCA9IGJ1Y2tldDtcbiAgICAgICAgYnVja2V0ID0gYnVja2V0Lm5leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChsYXN0X2J1Y2tldCkge1xuICAgICAgICBsYXN0X2J1Y2tldC5uZXh0ID0gaGFzaC4kJGtleXNbaV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIE9wYWwuaGFzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmd1bWVudHNfbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncywgaGFzaCwgaSwgbGVuZ3RoLCBrZXksIHZhbHVlO1xuXG4gICAgaWYgKGFyZ3VtZW50c19sZW5ndGggPT09IDEgJiYgYXJndW1lbnRzWzBdLiQkaXNfaGFzaCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICB9XG5cbiAgICBoYXNoID0gbmV3IE9wYWwuSGFzaCgpO1xuICAgIE9wYWwuaGFzaF9pbml0KGhhc2gpO1xuXG4gICAgaWYgKGFyZ3VtZW50c19sZW5ndGggPT09IDEgJiYgYXJndW1lbnRzWzBdLiQkaXNfYXJyYXkpIHtcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHNbMF07XG4gICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcmdzW2ldLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KFwidmFsdWUgbm90IG9mIGxlbmd0aCAyOiBcIiArIGFyZ3NbaV0uJGluc3BlY3QoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBrZXkgPSBhcmdzW2ldWzBdO1xuICAgICAgICB2YWx1ZSA9IGFyZ3NbaV1bMV07XG5cbiAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50c19sZW5ndGggPT09IDEpIHtcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHNbMF07XG4gICAgICBmb3IgKGtleSBpbiBhcmdzKSB7XG4gICAgICAgIGlmICgkaGFzX293bi5jYWxsKGFyZ3MsIGtleSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGFyZ3Nba2V5XTtcblxuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50c19sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcIm9kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoXCIpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHNfbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHZhbHVlID0gYXJndW1lbnRzW2kgKyAxXTtcblxuICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvLyBBIGZhc3RlciBIYXNoIGNyZWF0b3IgZm9yIGhhc2hlcyB0aGF0IGp1c3QgdXNlIHN5bWJvbHMgYW5kXG4gIC8vIHN0cmluZ3MgYXMga2V5cy4gVGhlIG1hcCBhbmQga2V5cyBhcnJheSBjYW4gYmUgY29uc3RydWN0ZWQgYXRcbiAgLy8gY29tcGlsZSB0aW1lLCBzbyB0aGV5IGFyZSBqdXN0IGFkZGVkIGhlcmUgYnkgdGhlIGNvbnN0cnVjdG9yXG4gIC8vIGZ1bmN0aW9uLlxuICAvL1xuICBPcGFsLmhhc2gyID0gZnVuY3Rpb24oa2V5cywgc21hcCkge1xuICAgIHZhciBoYXNoID0gbmV3IE9wYWwuSGFzaCgpO1xuXG4gICAgaGFzaC4kJHNtYXAgPSBzbWFwO1xuICAgIGhhc2guJCRtYXAgID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBoYXNoLiQka2V5cyA9IGtleXM7XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBuZXcgcmFuZ2UgaW5zdGFuY2Ugd2l0aCBmaXJzdCBhbmQgbGFzdCB2YWx1ZXMsIGFuZCB3aGV0aGVyIHRoZVxuICAvLyByYW5nZSBleGNsdWRlcyB0aGUgbGFzdCB2YWx1ZS5cbiAgLy9cbiAgT3BhbC5yYW5nZSA9IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCBleGMpIHtcbiAgICB2YXIgcmFuZ2UgICAgICAgICA9IG5ldyBPcGFsLlJhbmdlKCk7XG4gICAgICAgIHJhbmdlLmJlZ2luICAgPSBmaXJzdDtcbiAgICAgICAgcmFuZ2UuZW5kICAgICA9IGxhc3Q7XG4gICAgICAgIHJhbmdlLmV4Y2wgICAgPSBleGM7XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBpdmFyIG5hbWUgZm9yIGEgZ2l2ZW4gbmFtZS5cbiAgLy8gTW9zdGx5IGFkZHMgYSB0cmFpbGluZyAkIHRvIHJlc2VydmVkIG5hbWVzLlxuICAvL1xuICBPcGFsLml2YXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG4gICAgICAgIG5hbWUgPT09IFwiY29uc3RydWN0b3JcIiB8fFxuICAgICAgICBuYW1lID09PSBcImRpc3BsYXlOYW1lXCIgfHxcbiAgICAgICAgbmFtZSA9PT0gXCJfX2NvdW50X19cIiB8fFxuICAgICAgICBuYW1lID09PSBcIl9fbm9TdWNoTWV0aG9kX19cIiB8fFxuICAgICAgICBuYW1lID09PSBcIl9fcGFyZW50X19cIiB8fFxuICAgICAgICBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8XG5cbiAgICAgICAgLy8gbWV0aG9kc1xuICAgICAgICBuYW1lID09PSBcImhhc093blByb3BlcnR5XCIgfHxcbiAgICAgICAgbmFtZSA9PT0gXCJ2YWx1ZU9mXCJcbiAgICAgICApXG4gICAge1xuICAgICAgcmV0dXJuIG5hbWUgKyBcIiRcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbiAgfTtcblxuXG4gIC8vIFJlZ2V4cHNcbiAgLy8gLS0tLS0tLVxuXG4gIC8vIEVzY2FwZSBSZWdleHAgc3BlY2lhbCBjaGFycyBsZXR0aW5nIHRoZSByZXN1bHRpbmcgc3RyaW5nIGJlIHVzZWQgdG8gYnVpbGRcbiAgLy8gYSBuZXcgUmVnZXhwLlxuICAvL1xuICBPcGFsLmVzY2FwZV9yZWdleHAgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLVtcXF1cXC97fSgpKis/Ll4kXFxcXHwgXSkvZywgJ1xcXFwkMScpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxuXS9nLCAnXFxcXG4nKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xccl0vZywgJ1xcXFxyJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXGZdL2csICdcXFxcZicpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx0XS9nLCAnXFxcXHQnKTtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBnbG9iYWwgUmVnZXhwIGZyb20gYSBSZWdFeHAgb2JqZWN0IGFuZCBjYWNoZSB0aGUgcmVzdWx0XG4gIC8vIG9uIHRoZSBvYmplY3QgaXRzZWxmICgkJGcgYXR0cmlidXRlKS5cbiAgLy9cbiAgT3BhbC5nbG9iYWxfcmVnZXhwID0gZnVuY3Rpb24ocGF0dGVybikge1xuICAgIGlmIChwYXR0ZXJuLmdsb2JhbCkge1xuICAgICAgcmV0dXJuIHBhdHRlcm47IC8vIFJlZ0V4cCBhbHJlYWR5IGhhcyB0aGUgZ2xvYmFsIGZsYWdcbiAgICB9XG4gICAgaWYgKHBhdHRlcm4uJCRnID09IG51bGwpIHtcbiAgICAgIHBhdHRlcm4uJCRnID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgKHBhdHRlcm4ubXVsdGlsaW5lID8gJ2dtJyA6ICdnJykgKyAocGF0dGVybi5pZ25vcmVDYXNlID8gJ2knIDogJycpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0dGVybi4kJGcubGFzdEluZGV4ID0gbnVsbDsgLy8gcmVzZXQgbGFzdEluZGV4IHByb3BlcnR5XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuLiQkZztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBnbG9iYWwgbXVsdGlsaW5lIFJlZ2V4cCBmcm9tIGEgUmVnRXhwIG9iamVjdCBhbmQgY2FjaGUgdGhlIHJlc3VsdFxuICAvLyBvbiB0aGUgb2JqZWN0IGl0c2VsZiAoJCRnbSBvciAkJGcgYXR0cmlidXRlKS5cbiAgLy9cbiAgT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChwYXR0ZXJuLm11bHRpbGluZSkge1xuICAgICAgaWYgKHBhdHRlcm4uZ2xvYmFsKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuOyAvLyBSZWdFeHAgYWxyZWFkeSBoYXMgdGhlIGdsb2JhbCBhbmQgbXVsdGlsaW5lIGZsYWdcbiAgICAgIH1cbiAgICAgIC8vIHdlIGFyZSB1c2luZyB0aGUgJCRnIGF0dHJpYnV0ZSBiZWNhdXNlIHRoZSBSZWdleHAgaXMgYWxyZWFkeSBtdWx0aWxpbmVcbiAgICAgIGlmIChwYXR0ZXJuLiQkZyAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdCA9IHBhdHRlcm4uJCRnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcGF0dGVybi4kJGcgPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCAnZ20nICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXR0ZXJuLiQkZ20gIT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gcGF0dGVybi4kJGdtO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBwYXR0ZXJuLiQkZ20gPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCAnZ20nICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSk7XG4gICAgfVxuICAgIHJlc3VsdC5sYXN0SW5kZXggPSBudWxsOyAvLyByZXNldCBsYXN0SW5kZXggcHJvcGVydHlcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbWJpbmUgbXVsdGlwbGUgcmVnZXhwIHBhcnRzIHRvZ2V0aGVyXG4gIE9wYWwucmVnZXhwID0gZnVuY3Rpb24ocGFydHMsIGZsYWdzKSB7XG4gICAgdmFyIHBhcnQ7XG4gICAgdmFyIGlnbm9yZUNhc2UgPSB0eXBlb2YgZmxhZ3MgIT09ICd1bmRlZmluZWQnICYmIGZsYWdzICYmIGZsYWdzLmluZGV4T2YoJ2knKSA+PSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKHBhcnQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgaWYgKHBhcnQuaWdub3JlQ2FzZSAhPT0gaWdub3JlQ2FzZSlcbiAgICAgICAgICBPcGFsLktlcm5lbC4kd2FybihcbiAgICAgICAgICAgIFwiaWdub3JlIGNhc2UgZG9lc24ndCBtYXRjaCBmb3IgXCIgKyBwYXJ0LnNvdXJjZS4kaW5zcGVjdCgpLFxuICAgICAgICAgICAgT3BhbC5oYXNoKHt1cGxldmVsOiAxfSlcbiAgICAgICAgICApXG5cbiAgICAgICAgcGFydCA9IHBhcnQuc291cmNlO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnQgPT09ICcnKSBwYXJ0ID0gJyg/OicgKyBwYXJ0ICsgJyknO1xuICAgICAgcGFydHNbaV0gPSBwYXJ0O1xuICAgIH1cblxuICAgIGlmIChmbGFncykge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGFydHMuam9pbignJyksIGZsYWdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGFydHMuam9pbignJykpO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXF1aXJlIHN5c3RlbVxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIE9wYWwubW9kdWxlcyAgICAgICAgID0ge307XG4gIE9wYWwubG9hZGVkX2ZlYXR1cmVzID0gWydjb3JlbGliL3J1bnRpbWUnXTtcbiAgT3BhbC5jdXJyZW50X2RpciAgICAgPSAnLic7XG4gIE9wYWwucmVxdWlyZV90YWJsZSAgID0geydjb3JlbGliL3J1bnRpbWUnOiB0cnVlfTtcblxuICBPcGFsLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICB2YXIgcGFydHMsIHBhcnQsIG5ld19wYXJ0cyA9IFtdLCBTRVBBUkFUT1IgPSAnLyc7XG5cbiAgICBpZiAoT3BhbC5jdXJyZW50X2RpciAhPT0gJy4nKSB7XG4gICAgICBwYXRoID0gT3BhbC5jdXJyZW50X2Rpci5yZXBsYWNlKC9cXC8qJC8sICcvJykgKyBwYXRoO1xuICAgIH1cblxuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL15cXC5cXC8vLCAnJyk7XG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwuKHJifG9wYWx8anMpJC8sICcnKTtcbiAgICBwYXJ0cyA9IHBhdGguc3BsaXQoU0VQQVJBVE9SKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChwYXJ0ID09PSAnJykgY29udGludWU7XG4gICAgICAocGFydCA9PT0gJy4uJykgPyBuZXdfcGFydHMucG9wKCkgOiBuZXdfcGFydHMucHVzaChwYXJ0KVxuICAgIH1cblxuICAgIHJldHVybiBuZXdfcGFydHMuam9pbihTRVBBUkFUT1IpO1xuICB9O1xuXG4gIE9wYWwubG9hZGVkID0gZnVuY3Rpb24ocGF0aHMpIHtcbiAgICB2YXIgaSwgbCwgcGF0aDtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBwYXRocy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoc1tpXSk7XG5cbiAgICAgIGlmIChPcGFsLnJlcXVpcmVfdGFibGVbcGF0aF0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIE9wYWwubG9hZGVkX2ZlYXR1cmVzLnB1c2gocGF0aCk7XG4gICAgICBPcGFsLnJlcXVpcmVfdGFibGVbcGF0aF0gPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBPcGFsLmxvYWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgcGF0aCA9IE9wYWwubm9ybWFsaXplKHBhdGgpO1xuXG4gICAgT3BhbC5sb2FkZWQoW3BhdGhdKTtcblxuICAgIHZhciBtb2R1bGUgPSBPcGFsLm1vZHVsZXNbcGF0aF07XG5cbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICBtb2R1bGUoT3BhbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNldmVyaXR5ID0gT3BhbC5jb25maWcubWlzc2luZ19yZXF1aXJlX3NldmVyaXR5O1xuICAgICAgdmFyIG1lc3NhZ2UgID0gJ2Nhbm5vdCBsb2FkIHN1Y2ggZmlsZSAtLSAnICsgcGF0aDtcblxuICAgICAgaWYgKHNldmVyaXR5ID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgaWYgKE9wYWwuTG9hZEVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgT3BhbC5Mb2FkRXJyb3IuJG5ldyhtZXNzYWdlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG1lc3NhZ2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2V2ZXJpdHkgPT09IFwid2FybmluZ1wiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogTG9hZEVycm9yOiAnICsgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgT3BhbC5yZXF1aXJlID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcblxuICAgIGlmIChPcGFsLnJlcXVpcmVfdGFibGVbcGF0aF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5sb2FkKHBhdGgpO1xuICB9O1xuXG5cbiAgLy8gU3RyaW5nc1xuICAvLyAtLS0tLS0tXG5cbiAgT3BhbC5lbmNvZGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vIFNldHMgdGhlIGVuY29kaW5nIG9uIGEgc3RyaW5nLCB3aWxsIHRyZWF0IHN0cmluZyBsaXRlcmFscyBhcyBmcm96ZW4gc3RyaW5nc1xuICAvLyByYWlzaW5nIGEgRnJvemVuRXJyb3IuXG4gIC8vIEBwYXJhbSBzdHIgW1N0cmluZ10gdGhlIHN0cmluZyBvbiB3aGljaCB0aGUgZW5jb2Rpbmcgc2hvdWxkIGJlIHNldC5cbiAgLy8gQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIGNhbm9uaWNhbCBuYW1lIG9mIHRoZSBlbmNvZGluZ1xuICBPcGFsLnNldF9lbmNvZGluZyA9IGZ1bmN0aW9uKHN0ciwgbmFtZSkge1xuICAgIGlmICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJylcbiAgICAgIHRocm93IE9wYWwuRnJvemVuRXJyb3IuJG5ldyhcImNhbid0IG1vZGlmeSBmcm96ZW4gU3RyaW5nXCIpO1xuXG4gICAgdmFyIGVuY29kaW5nID0gT3BhbC5lbmNvZGluZ3NbbmFtZV07XG5cbiAgICBpZiAoZW5jb2RpbmcgPT09IHN0ci5lbmNvZGluZykgeyByZXR1cm4gc3RyOyB9XG5cbiAgICBzdHIuZW5jb2RpbmcgPSBlbmNvZGluZztcblxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLy8gQHJldHVybnMgYSBTdHJpbmcgb2JqZWN0IHdpdGggdGhlIGVuY29kaW5nIHNldCBmcm9tIGEgc3RyaW5nIGxpdGVyYWxcbiAgT3BhbC5lbmMgPSBmdW5jdGlvbihzdHIsIG5hbWUpIHtcbiAgICB2YXIgZHVwID0gbmV3IFN0cmluZyhzdHIpO1xuICAgIE9wYWwuc2V0X2VuY29kaW5nKGR1cCwgbmFtZSk7XG4gICAgZHVwLmludGVybmFsX2VuY29kaW5nID0gZHVwLmVuY29kaW5nO1xuICAgIHJldHVybiBkdXBcbiAgfVxuXG5cbiAgLy8gSW5pdGlhbGl6YXRpb25cbiAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgZnVuY3Rpb24gJEJhc2ljT2JqZWN0KCkge31cbiAgZnVuY3Rpb24gJE9iamVjdCgpIHt9XG4gIGZ1bmN0aW9uICRNb2R1bGUoKSB7fVxuICBmdW5jdGlvbiAkQ2xhc3MoKSB7fVxuXG4gIE9wYWwuQmFzaWNPYmplY3QgPSBCYXNpY09iamVjdCA9IE9wYWwuYWxsb2NhdGVfY2xhc3MoJ0Jhc2ljT2JqZWN0JywgbnVsbCwgJEJhc2ljT2JqZWN0KTtcbiAgT3BhbC5PYmplY3QgICAgICA9IF9PYmplY3QgICAgID0gT3BhbC5hbGxvY2F0ZV9jbGFzcygnT2JqZWN0JywgT3BhbC5CYXNpY09iamVjdCwgJE9iamVjdCk7XG4gIE9wYWwuTW9kdWxlICAgICAgPSBNb2R1bGUgICAgICA9IE9wYWwuYWxsb2NhdGVfY2xhc3MoJ01vZHVsZScsIE9wYWwuT2JqZWN0LCAkTW9kdWxlKTtcbiAgT3BhbC5DbGFzcyAgICAgICA9IENsYXNzICAgICAgID0gT3BhbC5hbGxvY2F0ZV9jbGFzcygnQ2xhc3MnLCBPcGFsLk1vZHVsZSwgJENsYXNzKTtcblxuICAkc2V0X3Byb3RvKE9wYWwuQmFzaWNPYmplY3QsIE9wYWwuQ2xhc3MuJCRwcm90b3R5cGUpO1xuICAkc2V0X3Byb3RvKE9wYWwuT2JqZWN0LCBPcGFsLkNsYXNzLiQkcHJvdG90eXBlKTtcbiAgJHNldF9wcm90byhPcGFsLk1vZHVsZSwgT3BhbC5DbGFzcy4kJHByb3RvdHlwZSk7XG4gICRzZXRfcHJvdG8oT3BhbC5DbGFzcywgT3BhbC5DbGFzcy4kJHByb3RvdHlwZSk7XG5cbiAgLy8gQmFzaWNPYmplY3QgY2FuIHJlYWNoIGl0c2VsZiwgYXZvaWQgY29uc3Rfc2V0IHRvIHNraXAgdGhlICQkYmFzZV9tb2R1bGUgbG9naWNcbiAgQmFzaWNPYmplY3QuJCRjb25zdFtcIkJhc2ljT2JqZWN0XCJdID0gQmFzaWNPYmplY3Q7XG5cbiAgLy8gQXNzaWduIGJhc2ljIGNvbnN0YW50c1xuICBPcGFsLmNvbnN0X3NldChfT2JqZWN0LCBcIkJhc2ljT2JqZWN0XCIsICBCYXNpY09iamVjdCk7XG4gIE9wYWwuY29uc3Rfc2V0KF9PYmplY3QsIFwiT2JqZWN0XCIsICAgICAgIF9PYmplY3QpO1xuICBPcGFsLmNvbnN0X3NldChfT2JqZWN0LCBcIk1vZHVsZVwiLCAgICAgICBNb2R1bGUpO1xuICBPcGFsLmNvbnN0X3NldChfT2JqZWN0LCBcIkNsYXNzXCIsICAgICAgICBDbGFzcyk7XG5cbiAgLy8gRml4IGJvb3RlZCBjbGFzc2VzIHRvIGhhdmUgY29ycmVjdCAuY2xhc3MgdmFsdWVcbiAgQmFzaWNPYmplY3QuJCRjbGFzcyA9IENsYXNzO1xuICBfT2JqZWN0LiQkY2xhc3MgICAgID0gQ2xhc3M7XG4gIE1vZHVsZS4kJGNsYXNzICAgICAgPSBDbGFzcztcbiAgQ2xhc3MuJCRjbGFzcyAgICAgICA9IENsYXNzO1xuXG4gIC8vIEZvcndhcmQgLnRvU3RyaW5nKCkgdG8gI3RvX3NcbiAgJGRlZmluZVByb3BlcnR5KF9PYmplY3QuJCRwcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uKCkge1xuICAgIHZhciB0b19zID0gdGhpcy4kdG9fcygpO1xuICAgIGlmICh0b19zLiQkaXNfc3RyaW5nICYmIHR5cGVvZih0b19zKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIGEgc3RyaW5nIGNyZWF0ZWQgdXNpbmcgbmV3IFN0cmluZygnc3RyaW5nJylcbiAgICAgIHJldHVybiB0b19zLnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRvX3M7XG4gICAgfVxuICB9KTtcblxuICAvLyBNYWtlIEtlcm5lbCNyZXF1aXJlIGltbWVkaWF0ZWx5IGF2YWlsYWJsZSBhcyBpdCdzIG5lZWRlZCB0byByZXF1aXJlIGFsbCB0aGVcbiAgLy8gb3RoZXIgY29yZWxpYiBmaWxlcy5cbiAgJGRlZmluZVByb3BlcnR5KF9PYmplY3QuJCRwcm90b3R5cGUsICckcmVxdWlyZScsIE9wYWwucmVxdWlyZSk7XG5cbiAgLy8gSW5zdGFudGlhdGUgdGhlIG1haW4gb2JqZWN0XG4gIE9wYWwudG9wID0gbmV3IF9PYmplY3QoKTtcbiAgT3BhbC50b3AuJHRvX3MgPSBPcGFsLnRvcC4kaW5zcGVjdCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ21haW4nIH07XG4gIE9wYWwudG9wLiRkZWZpbmVfbWV0aG9kID0gdG9wX2RlZmluZV9tZXRob2Q7XG5cbiAgLy8gRm93YXJkIGNhbGxzIHRvIGRlZmluZV9tZXRob2Qgb24gdGhlIHRvcCBvYmplY3QgdG8gT2JqZWN0XG4gIGZ1bmN0aW9uIHRvcF9kZWZpbmVfbWV0aG9kKCkge1xuICAgIHZhciBhcmdzID0gT3BhbC5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgdmFyIGJsb2NrID0gdG9wX2RlZmluZV9tZXRob2QuJCRwO1xuICAgIHRvcF9kZWZpbmVfbWV0aG9kLiQkcCA9IG51bGw7XG4gICAgcmV0dXJuIE9wYWwuc2VuZChfT2JqZWN0LCAnZGVmaW5lX21ldGhvZCcsIGFyZ3MsIGJsb2NrKVxuICB9O1xuXG5cbiAgLy8gTmlsXG4gIGZ1bmN0aW9uICROaWxDbGFzcygpIHt9XG4gIE9wYWwuTmlsQ2xhc3MgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKCdOaWxDbGFzcycsIE9wYWwuT2JqZWN0LCAkTmlsQ2xhc3MpO1xuICBPcGFsLmNvbnN0X3NldChfT2JqZWN0LCAnTmlsQ2xhc3MnLCBPcGFsLk5pbENsYXNzKTtcbiAgbmlsID0gT3BhbC5uaWwgPSBuZXcgT3BhbC5OaWxDbGFzcygpO1xuICBuaWwuJCRpZCA9IG5pbF9pZDtcbiAgbmlsLmNhbGwgPSBuaWwuYXBwbHkgPSBmdW5jdGlvbigpIHsgdGhyb3cgT3BhbC5Mb2NhbEp1bXBFcnJvci4kbmV3KCdubyBibG9jayBnaXZlbicpOyB9O1xuXG4gIC8vIEVycm9yc1xuICBPcGFsLmJyZWFrZXIgID0gbmV3IEVycm9yKCd1bmV4cGVjdGVkIGJyZWFrIChvbGQpJyk7XG4gIE9wYWwucmV0dXJuZXIgPSBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgcmV0dXJuJyk7XG4gIFR5cGVFcnJvci4kJHN1cGVyID0gRXJyb3I7XG59KS5jYWxsKHRoaXMpO1xuT3BhbC5sb2FkZWQoW1wiY29yZWxpYi9ydW50aW1lLmpzXCJdKTsiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNJOztBQUVKO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNJO0FBQ0E7O0FBRUo7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNFOztBQUVBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVKO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7QUFDSTs7QUFFSjtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7O0FBR0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVFO0FBQ0U7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNKO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNKO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBO0FBQ0E7O0FBRUo7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0k7QUFDQTtBQUNBOztBQUVKO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNFOztBQUVBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBO0FBQ0E7O0FBRUo7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Q7QUFDSDtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ1U7QUFDQTtBQUNBO0FBQ0E7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDRTtBQUNFO0FBQ0E7QUFDRjs7QUFFRjtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBOztBQUVBOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0EifX0seyJvZmZzZXQiOnsibGluZSI6MjU0MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvaGVscGVycy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHR5cGVfZXJyb3IsIGNvZXJjZV90b1xuXG5tb2R1bGUgT3BhbFxuICBkZWYgc2VsZi5icmlkZ2UoY29uc3RydWN0b3IsIGtsYXNzKVxuICAgIGBPcGFsLmJyaWRnZShjb25zdHJ1Y3Rvciwga2xhc3MpYFxuICBlbmRcblxuICBkZWYgc2VsZi5jb2VyY2VfdG8hKG9iamVjdCwgdHlwZSwgbWV0aG9kLCAqYXJncylcbiAgICBjb2VyY2VkID0gYCRjb2VyY2VfdG8ob2JqZWN0LCB0eXBlLCBtZXRob2QsIGFyZ3MpYFxuXG4gICAgdW5sZXNzIHR5cGUgPT09IGNvZXJjZWRcbiAgICAgIHJhaXNlIGAkdHlwZV9lcnJvcihvYmplY3QsIHR5cGUsIG1ldGhvZCwgY29lcmNlZClgXG4gICAgZW5kXG5cbiAgICBjb2VyY2VkXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvZXJjZV90bz8ob2JqZWN0LCB0eXBlLCBtZXRob2QsICphcmdzKVxuICAgIHJldHVybiB1bmxlc3Mgb2JqZWN0LnJlc3BvbmRfdG8/IG1ldGhvZFxuXG4gICAgY29lcmNlZCA9IGAkY29lcmNlX3RvKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBhcmdzKWBcblxuICAgIHJldHVybiBpZiBjb2VyY2VkLm5pbD9cblxuICAgIHVubGVzcyB0eXBlID09PSBjb2VyY2VkXG4gICAgICByYWlzZSBgJHR5cGVfZXJyb3Iob2JqZWN0LCB0eXBlLCBtZXRob2QsIGNvZXJjZWQpYFxuICAgIGVuZFxuXG4gICAgY29lcmNlZFxuICBlbmRcblxuICBkZWYgc2VsZi50cnlfY29udmVydChvYmplY3QsIHR5cGUsIG1ldGhvZClcbiAgICByZXR1cm4gb2JqZWN0IGlmIHR5cGUgPT09IG9iamVjdFxuXG4gICAgaWYgb2JqZWN0LnJlc3BvbmRfdG8/IG1ldGhvZFxuICAgICAgb2JqZWN0Ll9fc2VuZF9fIG1ldGhvZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5jb21wYXJlKGEsIGIpXG4gICAgY29tcGFyZSA9IGEgPD0+IGJcblxuICAgIGlmIGBjb21wYXJlID09PSBuaWxgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3thLmNsYXNzfSB3aXRoICN7Yi5jbGFzc30gZmFpbGVkXCJcbiAgICBlbmRcblxuICAgIGNvbXBhcmVcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZGVzdHJ1Y3R1cmUoYXJncylcbiAgICAleHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJncy4kJGlzX2FycmF5KSB7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBhcmdzX2FyeSA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XG4gICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmdzX2FyeS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgYXJnc19hcnlbaV0gPSBhcmdzW2ldOyB9XG5cbiAgICAgICAgcmV0dXJuIGFyZ3NfYXJ5O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYucmVzcG9uZF90bz8ob2JqLCBtZXRob2QsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgJXh7XG4gICAgICBpZiAob2JqID09IG51bGwgfHwgIW9iai4kJGNsYXNzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvYmoucmVzcG9uZF90bz8obWV0aG9kLCBpbmNsdWRlX2FsbClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcbiAgICBuYW1lID0gT3BhbC5jb2VyY2VfdG8hKG5hbWUsIFN0cmluZywgOnRvX3N0cilcblxuICAgIHVubGVzcyBgL15AW2EtekEtWl9dW2EtekEtWjAtOV9dKj8kLy50ZXN0KG5hbWUpYFxuICAgICAgcmFpc2UgTmFtZUVycm9yLm5ldyhcIicje25hbWV9JyBpcyBub3QgYWxsb3dlZCBhcyBhbiBpbnN0YW5jZSB2YXJpYWJsZSBuYW1lXCIsIG5hbWUpXG4gICAgZW5kXG5cbiAgICBuYW1lXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG4gICAgbmFtZSA9IE9wYWwuY29lcmNlX3RvIShuYW1lLCBTdHJpbmcsIDp0b19zdHIpXG5cbiAgICBpZiBgbmFtZS5sZW5ndGggPCAzIHx8IG5hbWUuc2xpY2UoMCwyKSAhPT0gJ0BAJ2BcbiAgICAgIHJhaXNlIE5hbWVFcnJvci5uZXcoXCJgI3tuYW1lfScgaXMgbm90IGFsbG93ZWQgYXMgYSBjbGFzcyB2YXJpYWJsZSBuYW1lXCIsIG5hbWUpXG4gICAgZW5kXG5cbiAgICBuYW1lXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbnN0X25hbWUhKGNvbnN0X25hbWUpXG4gICAgY29uc3RfbmFtZSA9IE9wYWwuY29lcmNlX3RvIShjb25zdF9uYW1lLCBTdHJpbmcsIDp0b19zdHIpXG5cbiAgICBpZiBjb25zdF9uYW1lWzBdICE9IGNvbnN0X25hbWVbMF0udXBjYXNlXG4gICAgICByYWlzZSBOYW1lRXJyb3IsIFwid3JvbmcgY29uc3RhbnQgbmFtZSAje2NvbnN0X25hbWV9XCJcbiAgICBlbmRcblxuICAgIGNvbnN0X25hbWVcbiAgZW5kXG5cbiAgIyBAcHJpdmF0ZVxuICAjIE1hcmsgc29tZSBtZXRob2RzIGFzIHByaXN0aW5lIGluIG9yZGVyIHRvIGFwcGx5IG9wdGltaXphdGlvbnMgd2hlbiB0aGV5XG4gICMgYXJlIHN0aWxsIGluIHRoZWlyIG9yaWdpbmFsIGZvcm0uIFRoaXMgY291bGQgcHJvYmFibHkgYmUgbW92ZWQgdG9cbiAgIyB0aGUgYE9wYWwuZGVmKClgIEpTIEFQSSwgYnV0IGZvciBub3cgaXQgd2lsbCBzdGF5IG1hbnVhbC5cbiAgI1xuICAjIEBleGFtcGxlXG4gICNcbiAgIyAgIE9wYWwucHJpc3RpbmUgQXJyYXksIDphbGxvY2F0ZSwgOmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLCA6aW5pdGlhbGl6ZV9kdXBcbiAgI1xuICAjICAgY2xhc3MgQXJyYXlcbiAgIyAgICAgZGVmIGR1cFxuICAjICAgICAgICV4e1xuICAjICAgICAgICAgaWYgKFxuICAjICAgICAgICAgICBzZWxmLiRhbGxvY2F0ZS4kJHByaXN0aW5lICYmXG4gICMgICAgICAgICAgIHNlbGYuJGNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLiQkcHJpc3RpbmUgJiZcbiAgIyAgICAgICAgICAgc2VsZi4kaW5pdGlhbGl6ZV9kdXAuJCRwcmlzdGluZVxuICAjICAgICAgICAgKSByZXR1cm4gc2VsZi5zbGljZSgwKTtcbiAgIyAgICAgICB9XG4gICNcbiAgIyAgICAgICBzdXBlclxuICAjICAgICBlbmRcbiAgIyAgIGVuZFxuICAjXG4gICMgQHBhcmFtIG93bmVyX2NsYXNzIFtDbGFzc10gdGhlIGNsYXNzIG93bmluZyB0aGUgbWV0aG9kc1xuICAjIEBwYXJhbSBtZXRob2RfbmFtZXMgW0FycmF5PFN5bWJvbD5dIHRoZSBsaXN0IG9mIG1ldGhvZHMgbmFtZXMgdG8gbWFya1xuICAjIEByZXR1cm4gW25pbF1cbiAgZGVmIHNlbGYucHJpc3RpbmUob3duZXJfY2xhc3MsICptZXRob2RfbmFtZXMpXG4gICAgJXh7XG4gICAgICB2YXIgbWV0aG9kX25hbWUsIG1ldGhvZDtcbiAgICAgIGZvciAodmFyIGkgPSBtZXRob2RfbmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbWV0aG9kX25hbWUgPSBtZXRob2RfbmFtZXNbaV07XG4gICAgICAgIG1ldGhvZCA9IG93bmVyX2NsYXNzLiQkcHJvdG90eXBlWyckJyttZXRob2RfbmFtZV07XG5cbiAgICAgICAgaWYgKG1ldGhvZCAmJiAhbWV0aG9kLiQkc3R1Yikge1xuICAgICAgICAgIG1ldGhvZC4kJHByaXN0aW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBuaWxcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJicmlkZ2UiLCJzZWxmIiwiY29lcmNlX3RvISIsImNvZXJjZWQiLCJ0eXBlIiwiPT09IiwicmFpc2UiLCJjb2VyY2VfdG8/Iiwib2JqZWN0IiwicmVzcG9uZF90bz8iLCJtZXRob2QiLCJuaWw/IiwidHJ5X2NvbnZlcnQiLCJfX3NlbmRfXyIsImNvbXBhcmUiLCJhIiwiPD0+IiwiYiIsImNsYXNzIiwiZGVzdHJ1Y3R1cmUiLCJvYmoiLCJpbmNsdWRlX2FsbCIsImluc3RhbmNlX3ZhcmlhYmxlX25hbWUhIiwibmFtZSIsIm5ldyIsImNsYXNzX3ZhcmlhYmxlX25hbWUhIiwiY29uc3RfbmFtZSEiLCJjb25zdF9uYW1lIiwiW10iLCIwIiwiIT0iLCJ1cGNhc2UiLCJwcmlzdGluZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFFQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQUMsVUFBSUMsSUFBSkQsYUFBQUEsaUJBQUFBLGtCQUFnQixXQUFELEVBQWMsS0FBN0JBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsK0JBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsNEJBQUFBLENBQUE7QUFBQSxJQUlBRSxVQUFJRCxJQUFKQyxpQkFBQUEseUJBQUFBLFNBQW9CLE1BQUQsRUFBUyxJQUFULEVBQWUsTUFBZixFQVJyQixFQVFFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFSRjtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQVE0QyxNQUFBLGtCQVI1QztBQUFBLE1BU0lDLFVBQVcsc0NBVGY7QUFBQSxNQVdJLElBQUEsUUFBT0MsSUFBQUMsUUFBQUEsQ0FBU0YsT0FBVEUsQ0FBUCxDQUFBO0FBQUEsTUFBQTtBQUFBLFlBQ0VDLE9BQUFBLENBQU8sMENBQVBBO0FBREYsTUFBQSxDQVhKO0FBQUEsTUFlSSxPQUFBSCxPQWZKO0FBUUVELElBQUFBLENBQUFBLHFDQUFBQSxDQUpBO0FBQUEsSUFjQUssVUFBSU4sSUFBSk0saUJBQUFBLHlCQUFBQSxTQUFvQixNQUFELEVBQVMsSUFBVCxFQUFlLE1BQWYs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SUVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQXJJRjtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQXFJaUMsTUFBQSwwQkFySWpDO0FBQUE7QUF1SUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQWhKQTtBQUFBLE1BaUpJLE9BQUEsR0FqSko7QUFxSUVBLElBQUFBLENBQUFBLGdDQUFBQSxDQWpJQTtBQURGakMsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjk5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tb2R1bGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHksIGNvZXJjZV90b1xuXG5jbGFzcyBNb2R1bGVcbiAgZGVmIHNlbGYuYWxsb2NhdGVcbiAgICAleHtcbiAgICAgIHZhciBtb2R1bGUgPSBPcGFsLmFsbG9jYXRlX21vZHVsZShuaWwsIGZ1bmN0aW9uKCl7fSk7XG4gICAgICAvLyBMaW5rIHRoZSBwcm90b3R5cGUgb2YgTW9kdWxlIHN1YmNsYXNzZXNcbiAgICAgIGlmIChzZWxmICE9PSBPcGFsLk1vZHVsZSkgT2JqZWN0LnNldFByb3RvdHlwZU9mKG1vZHVsZSwgc2VsZi4kJHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgIG1vZHVsZV9ldmFsKCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/XG4gIGVuZFxuXG4gIGRlZiA9PT0ob2JqZWN0KVxuICAgIHJldHVybiBmYWxzZSBpZiBgb2JqZWN0ID09IG51bGxgXG5cbiAgICBgT3BhbC5pc19hKG9iamVjdCwgc2VsZilgXG4gIGVuZFxuXG4gIGRlZiA8KG90aGVyKVxuICAgIHVubGVzcyBNb2R1bGUgPT09IG90aGVyXG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdjb21wYXJlZCB3aXRoIG5vbiBjbGFzcy9tb2R1bGUnXG4gICAgZW5kXG5cbiAgICAjIGNsYXNzIGNhbm5vdCBiZSBhIGRlc2NlbmRhbnQgb2YgaXRzZWxmXG4gICAgJXh7XG4gICAgICB2YXIgd29ya2luZyA9IHNlbGYsXG4gICAgICAgICAgYW5jZXN0b3JzLFxuICAgICAgICAgIGksIGxlbmd0aDtcblxuICAgICAgaWYgKHdvcmtpbmcgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMoc2VsZiksIGxlbmd0aCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYW5jZXN0b3JzW2ldID09PSBvdGhlcikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG90aGVyKSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhbmNlc3RvcnNbaV0gPT09IHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PShvdGhlcilcbiAgICBlcXVhbD8ob3RoZXIpIHx8IHNlbGYgPCBvdGhlclxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICB1bmxlc3MgTW9kdWxlID09PSBvdGhlclxuICAgICAgcmFpc2UgVHlwZUVycm9yLCAnY29tcGFyZWQgd2l0aCBub24gY2xhc3MvbW9kdWxlJ1xuICAgIGVuZFxuXG4gICAgb3RoZXIgPCBzZWxmXG4gIGVuZFxuXG4gIGRlZiA+PShvdGhlcilcbiAgICBlcXVhbD8ob3RoZXIpIHx8IHNlbGYgPiBvdGhlclxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVubGVzcyBNb2R1bGUgPT09IG90aGVyXG4gICAgICByZXR1cm4gbmlsXG4gICAgZW5kXG5cbiAgICBsdCA9IHNlbGYgPCBvdGhlclxuICAgIHJldHVybiBuaWwgaWYgbHQubmlsP1xuICAgIGx0ID8gLTEgOiAxXG4gIGVuZFxuXG4gIGRlZiBhbGlhc19tZXRob2QobmV3bmFtZSwgb2xkbmFtZSlcbiAgICBuZXduYW1lID0gYCRjb2VyY2VfdG8obmV3bmFtZSwgI3tTdHJpbmd9LCAndG9fc3RyJylgXG4gICAgb2xkbmFtZSA9IGAkY29lcmNlX3RvKG9sZG5hbWUsICN7U3RyaW5nfSwgJ3RvX3N0cicpYFxuICAgIGBPcGFsLmFsaWFzKHNlbGYsIG5ld25hbWUsIG9sZG5hbWUpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYWxpYXNfbmF0aXZlKG1pZCwganNpZCA9IG1pZClcbiAgICBgT3BhbC5hbGlhc19uYXRpdmUoc2VsZiwgbWlkLCBqc2lkKWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFuY2VzdG9yc1xuICAgIGBPcGFsLmFuY2VzdG9ycyhzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGFwcGVuZF9mZWF0dXJlcyhpbmNsdWRlcilcbiAgICBgT3BhbC5hcHBlbmRfZmVhdHVyZXMoc2VsZiwgaW5jbHVkZXIpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGF0dHJfYWNjZXNzb3IoKm5hbWVzKVxuICAgIGF0dHJfcmVhZGVyKCpuYW1lcylcbiAgICBhdHRyX3dyaXRlcigqbmFtZXMpXG4gIGVuZFxuXG4gIGRlZiBhdHRyKCphcmdzKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDIgJiYgKGFyZ3NbMV0gPT09IHRydWUgfHwgYXJnc1sxXSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICN7d2FybiAnb3B0aW9uYWwgYm9vbGVhbiBhcmd1bWVudCBpcyBvYnNvbGV0ZWQnLCB1cGxldmVsOiAxfVxuXG4gICAgICAgIGFyZ3NbMV0gPyAje2F0dHJfYWNjZXNzb3IoYGFyZ3NbMF1gKX0gOiAje2F0dHJfcmVhZGVyKGBhcmdzWzBdYCl9O1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF0dHJfcmVhZGVyKCphcmdzKVxuICBlbmRcblxuICBkZWYgYXR0cl9yZWFkZXIoKm5hbWVzKVxuICAgICV4e1xuICAgICAgdmFyIHByb3RvID0gc2VsZi4kJHByb3RvdHlwZTtcblxuICAgICAgZm9yICh2YXIgaSA9IG5hbWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV0sXG4gICAgICAgICAgICBpZCAgID0gJyQnICsgbmFtZSxcbiAgICAgICAgICAgIGl2YXIgPSBPcGFsLml2YXIobmFtZSk7XG5cbiAgICAgICAgLy8gdGhlIGNsb3N1cmUgaGVyZSBpcyBuZWVkZWQgYmVjYXVzZSBuYW1lIHdpbGwgY2hhbmdlIGF0IHRoZSBuZXh0XG4gICAgICAgIC8vIGN5Y2xlLCBJIHdpc2ggd2UgY291bGQgdXNlIGxldC5cbiAgICAgICAgdmFyIGJvZHkgPSAoZnVuY3Rpb24oaXZhcikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2l2YXJdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpc1tpdmFyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KShpdmFyKTtcblxuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBpbnN0YW5jZSB2YXJpYWJsZSBhcyBuaWxcbiAgICAgICAgT3BhbC5kZWZpbmVQcm9wZXJ0eShwcm90bywgaXZhciwgbmlsKTtcblxuICAgICAgICBib2R5LiQkcGFyYW1ldGVycyA9IFtdO1xuICAgICAgICBib2R5LiQkYXJpdHkgPSAwO1xuXG4gICAgICAgIE9wYWwuZGVmbihzZWxmLCBpZCwgYm9keSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBhdHRyX3dyaXRlcigqbmFtZXMpXG4gICAgJXh7XG4gICAgICB2YXIgcHJvdG8gPSBzZWxmLiQkcHJvdG90eXBlO1xuXG4gICAgICBmb3IgKHZhciBpID0gbmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXSxcbiAgICAgICAgICAgIGlkICAgPSAnJCcgKyBuYW1lICsgJz0nLFxuICAgICAgICAgICAgaXZhciA9IE9wYWwuaXZhcihuYW1lKTtcblxuICAgICAgICAvLyB0aGUgY2xvc3VyZSBoZXJlIGlzIG5lZWRlZCBiZWNhdXNlIG5hbWUgd2lsbCBjaGFuZ2UgYXQgdGhlIG5leHRcbiAgICAgICAgLy8gY3ljbGUsIEkgd2lzaCB3ZSBjb3VsZCB1c2UgbGV0LlxuICAgICAgICB2YXIgYm9keSA9IChmdW5jdGlvbihpdmFyKXtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2l2YXJdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KShpdmFyKTtcblxuICAgICAgICBib2R5LiQkcGFyYW1ldGVycyA9IFtbJ3JlcSddXTtcbiAgICAgICAgYm9keS4kJGFyaXR5ID0gMTtcblxuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBpbnN0YW5jZSB2YXJpYWJsZSBhcyBuaWxcbiAgICAgICAgT3BhbC5kZWZpbmVQcm9wZXJ0eShwcm90bywgaXZhciwgbmlsKTtcblxuICAgICAgICBPcGFsLmRlZm4oc2VsZiwgaWQsIGJvZHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgYXV0b2xvYWQoY29uc3QsIHBhdGgpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGF1dG9sb2FkID09IG51bGwpIHNlbGYuJCRhdXRvbG9hZCA9IHt9O1xuICAgICAgT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uKys7XG4gICAgICBzZWxmLiQkYXV0b2xvYWRbI3tjb25zdH1dID0gI3twYXRofTtcbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xhc3NfdmFyaWFibGVzXG4gICAgYE9iamVjdC5rZXlzKE9wYWwuY2xhc3NfdmFyaWFibGVzKHNlbGYpKWBcbiAgZW5kXG5cbiAgZGVmIGNsYXNzX3ZhcmlhYmxlX2dldChuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG4gICAgJXh7XG4gICAgICB2YXIgdmFsdWUgPSBPcGFsLmNsYXNzX3ZhcmlhYmxlcyhzZWxmKVtuYW1lXTtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICN7cmFpc2UgTmFtZUVycm9yLm5ldyhcInVuaW5pdGlhbGl6ZWQgY2xhc3MgdmFyaWFibGUgI3tuYW1lfSBpbiAje3NlbGZ9XCIsIG5hbWUpfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNsYXNzX3ZhcmlhYmxlX3NldChuYW1lLCB2YWx1ZSlcbiAgICBuYW1lID0gT3BhbC5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgYE9wYWwuY2xhc3NfdmFyaWFibGVfc2V0KHNlbGYsIG5hbWUsIHZhbHVlKWBcbiAgZW5kXG5cbiAgZGVmIGNsYXNzX3ZhcmlhYmxlX2RlZmluZWQ/KG5hbWUpXG4gICAgbmFtZSA9IE9wYWwuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBPcGFsLmNsYXNzX3ZhcmlhYmxlcyhzZWxmKS5oYXNPd25Qcm9wZXJ0eShuYW1lKWBcbiAgZW5kXG5cbiAgZGVmIHJlbW92ZV9jbGFzc192YXJpYWJsZShuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIGlmIChPcGFsLmhhc093blByb3BlcnR5LmNhbGwoc2VsZi4kJGN2YXJzLCBuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLiQkY3ZhcnNbbmFtZV07XG4gICAgICAgIGRlbGV0ZSBzZWxmLiQkY3ZhcnNbbmFtZV07XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICN7cmFpc2UgTmFtZUVycm9yLCBcImNhbm5vdCByZW1vdmUgI3tuYW1lfSBmb3IgI3tzZWxmfVwifVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbnN0YW50cyhpbmhlcml0ID0gdHJ1ZSlcbiAgICBgT3BhbC5jb25zdGFudHMoc2VsZiwgaW5oZXJpdClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbnN0YW50cyhpbmhlcml0ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGluaGVyaXQgPT0gbnVsbCkge1xuICAgICAgICB2YXIgbmVzdGluZyA9IChzZWxmLiQkbmVzdGluZyB8fCBbXSkuY29uY2F0KE9wYWwuT2JqZWN0KSxcbiAgICAgICAgICAgIGNvbnN0YW50LCBjb25zdGFudHMgPSB7fSxcbiAgICAgICAgICAgIGksIGlpO1xuXG4gICAgICAgIGZvcihpID0gMCwgaWkgPSBuZXN0aW5nLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICBmb3IgKGNvbnN0YW50IGluIG5lc3RpbmdbaV0uJCRjb25zdCkge1xuICAgICAgICAgICAgY29uc3RhbnRzW2NvbnN0YW50XSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhjb25zdGFudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuY29uc3RhbnRzKHNlbGYsIGluaGVyaXQpXG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5uZXN0aW5nXG4gICAgYHNlbGYuJCRuZXN0aW5nIHx8IFtdYFxuICBlbmRcblxuICAjIGNoZWNrIGZvciBjb25zdGFudCB3aXRoaW4gY3VycmVudCBzY29wZVxuICAjIGlmIGluaGVyaXQgaXMgdHJ1ZSBvciBzZWxmIGlzIE9iamVjdCwgd2lsbCBhbHNvIGNoZWNrIGFuY2VzdG9yc1xuICBkZWYgY29uc3RfZGVmaW5lZD8obmFtZSwgaW5oZXJpdCA9IHRydWUpXG4gICAgbmFtZSA9IE9wYWwuY29uc3RfbmFtZSEobmFtZSlcblxuICAgIHJhaXNlIE5hbWVFcnJvci5uZXcoXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7bmFtZX1cIiwgbmFtZSkgdW5sZXNzIG5hbWUgPX4gT3BhbDo6Q09OU1RfTkFNRV9SRUdFWFBcblxuICAgICV4e1xuICAgICAgdmFyIG1vZHVsZSwgbW9kdWxlcyA9IFtzZWxmXSwgbW9kdWxlX2NvbnN0YW50cywgaSwgaWk7XG5cbiAgICAgIC8vIEFkZCB1cCBhbmNlc3RvcnMgaWYgaW5oZXJpdCBpcyB0cnVlXG4gICAgICBpZiAoaW5oZXJpdCkge1xuICAgICAgICBtb2R1bGVzID0gbW9kdWxlcy5jb25jYXQoT3BhbC5hbmNlc3RvcnMoc2VsZikpO1xuXG4gICAgICAgIC8vIEFkZCBPYmplY3QncyBhbmNlc3RvcnMgaWYgaXQncyBhIG1vZHVsZSDigJMgbW9kdWxlcyBoYXZlIG5vIGFuY2VzdG9ycyBvdGhlcndpc2VcbiAgICAgICAgaWYgKHNlbGYuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgICBtb2R1bGVzID0gbW9kdWxlcy5jb25jYXQoW09wYWwuT2JqZWN0XSkuY29uY2F0KE9wYWwuYW5jZXN0b3JzKE9wYWwuT2JqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgaWkgPSBtb2R1bGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgbW9kdWxlID0gbW9kdWxlc1tpXTtcbiAgICAgICAgaWYgKG1vZHVsZS4kJGNvbnN0W25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29uc3RfZ2V0KG5hbWUsIGluaGVyaXQgPSB0cnVlKVxuICAgIG5hbWUgPSBPcGFsLmNvbnN0X25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIGlmIChuYW1lLmluZGV4T2YoJzo6JykgPT09IDAgJiYgbmFtZSAhPT0gJzo6Jyl7XG4gICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIGBuYW1lLmluZGV4T2YoJzo6JykgIT0gLTEgJiYgbmFtZSAhPSAnOjonYFxuICAgICAgcmV0dXJuIG5hbWUuc3BsaXQoJzo6JykuaW5qZWN0KHNlbGYpIHsgfG8sIGN8IG8uY29uc3RfZ2V0KGMpIH1cbiAgICBlbmRcblxuICAgIHJhaXNlIE5hbWVFcnJvci5uZXcoXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7bmFtZX1cIiwgbmFtZSkgdW5sZXNzIG5hbWUgPX4gT3BhbDo6Q09OU1RfTkFNRV9SRUdFWFBcblxuICAgICV4e1xuICAgICAgaWYgKGluaGVyaXQpIHtcbiAgICAgICAgcmV0dXJuICQkKFtzZWxmXSwgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5jb25zdF9nZXRfbG9jYWwoc2VsZiwgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29uc3RfbWlzc2luZyhuYW1lKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRhdXRvbG9hZCkge1xuICAgICAgICB2YXIgZmlsZSA9IHNlbGYuJCRhdXRvbG9hZFtuYW1lXTtcblxuICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgIHNlbGYuJHJlcXVpcmUoZmlsZSk7XG5cbiAgICAgICAgICByZXR1cm4gI3tjb25zdF9nZXQgbmFtZX07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdWxsX2NvbnN0X25hbWUgPSBzZWxmID09IE9iamVjdCA/IG5hbWUgOiBcIiN7c2VsZn06OiN7bmFtZX1cIlxuXG4gICAgcmFpc2UgTmFtZUVycm9yLm5ldyhcInVuaW5pdGlhbGl6ZWQgY29uc3RhbnQgI3tmdWxsX2NvbnN0X25hbWV9XCIsIG5hbWUpXG4gIGVuZFxuXG4gIGRlZiBjb25zdF9zZXQobmFtZSwgdmFsdWUpXG4gICAgbmFtZSA9IE9wYWwuY29uc3RfbmFtZSEobmFtZSlcblxuICAgIGlmIG5hbWUgIX4gT3BhbDo6Q09OU1RfTkFNRV9SRUdFWFAgfHwgbmFtZS5zdGFydF93aXRoPygnOjonKVxuICAgICAgcmFpc2UgTmFtZUVycm9yLm5ldyhcIndyb25nIGNvbnN0YW50IG5hbWUgI3tuYW1lfVwiLCBuYW1lKVxuICAgIGVuZFxuXG4gICAgYE9wYWwuY29uc3Rfc2V0KHNlbGYsIG5hbWUsIHZhbHVlKWBcblxuICAgIHZhbHVlXG4gIGVuZFxuXG4gIGRlZiBwdWJsaWNfY29uc3RhbnQoY29uc3RfbmFtZSlcbiAgZW5kXG5cbiAgZGVmIGRlZmluZV9tZXRob2QobmFtZSwgbWV0aG9kID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYG1ldGhvZCA9PT0gdW5kZWZpbmVkICYmIGJsb2NrID09PSBuaWxgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY3JlYXRlIGEgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgIGVuZFxuXG4gICAgYmxvY2sgfHw9IGNhc2UgbWV0aG9kXG4gICAgICAgICAgICAgIHdoZW4gUHJvY1xuICAgICAgICAgICAgICAgIG1ldGhvZFxuXG4gICAgICAgICAgICAgIHdoZW4gTWV0aG9kXG4gICAgICAgICAgICAgICAgYCN7bWV0aG9kLnRvX3Byb2N9LiQkdW5ib3VuZGBcblxuICAgICAgICAgICAgICB3aGVuIFVuYm91bmRNZXRob2RcbiAgICAgICAgICAgICAgICAtPigqYXJncykge1xuICAgICAgICAgICAgICAgICAgYm91bmQgPSBtZXRob2QuYmluZChzZWxmKVxuICAgICAgICAgICAgICAgICAgYm91bmQuY2FsbCgqYXJncylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YmxvY2suY2xhc3N9IChleHBlY3RlZCBQcm9jL01ldGhvZClcIlxuICAgICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIGlkID0gJyQnICsgbmFtZTtcblxuICAgICAgYmxvY2suJCRqc2lkICAgICAgICA9IG5hbWU7XG4gICAgICBibG9jay4kJHMgICAgICAgICAgID0gbnVsbDtcbiAgICAgIGJsb2NrLiQkZGVmICAgICAgICAgPSBibG9jaztcbiAgICAgIGJsb2NrLiQkZGVmaW5lX21ldGggPSB0cnVlO1xuXG4gICAgICBPcGFsLmRlZm4oc2VsZiwgaWQsIGJsb2NrKTtcblxuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVtb3ZlX21ldGhvZCgqbmFtZXMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgT3BhbC5yZGVmKHNlbGYsIFwiJFwiICsgbmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzcz9cbiAgICBgISFzZWxmLiQkaXNfc2luZ2xldG9uYFxuICBlbmRcblxuICBkZWYgaW5jbHVkZSgqbW9kcylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSBtb2RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBtb2QgPSBtb2RzW2ldO1xuXG4gICAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Btb2RgLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgICAgfVxuXG4gICAgICAgICN7YG1vZGAuYXBwZW5kX2ZlYXR1cmVzIHNlbGZ9O1xuICAgICAgICAje2Btb2RgLmluY2x1ZGVkIHNlbGZ9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGVkX21vZHVsZXNcbiAgICBgT3BhbC5pbmNsdWRlZF9tb2R1bGVzKHNlbGYpYFxuICBlbmRcblxuICBkZWYgaW5jbHVkZT8obW9kKVxuICAgICV4e1xuICAgICAgaWYgKCFtb2QuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Btb2RgLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgIH1cblxuICAgICAgdmFyIGksIGlpLCBtb2QyLCBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhzZWxmKTtcblxuICAgICAgZm9yIChpID0gMCwgaWkgPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBtb2QyID0gYW5jZXN0b3JzW2ldO1xuICAgICAgICBpZiAobW9kMiA9PT0gbW9kICYmIG1vZDIgIT09IHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfbWV0aG9kKG5hbWUpXG4gICAgJXh7XG4gICAgICB2YXIgbWV0aCA9IHNlbGYuJCRwcm90b3R5cGVbJyQnICsgbmFtZV07XG5cbiAgICAgIGlmICghbWV0aCB8fCBtZXRoLiQkc3R1Yikge1xuICAgICAgICAje3JhaXNlIE5hbWVFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje25hbWV9JyBmb3IgY2xhc3MgYCN7c2VsZi5uYW1lfSdcIiwgbmFtZSl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tVbmJvdW5kTWV0aG9kLm5ldyhzZWxmLCBgbWV0aC4kJG93bmVyIHx8ICN7c2VsZn1gLCBgbWV0aGAsIG5hbWUpfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9tZXRob2RzKGluY2x1ZGVfc3VwZXIgPSB0cnVlKVxuICAgICV4e1xuICAgICAgaWYgKCR0cnV0aHkoI3tpbmNsdWRlX3N1cGVyfSkpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuaW5zdGFuY2VfbWV0aG9kcyhzZWxmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGVkKG1vZClcbiAgZW5kXG5cbiAgZGVmIGV4dGVuZGVkKG1vZClcbiAgZW5kXG5cbiAgZGVmIGV4dGVuZF9vYmplY3Qob2JqZWN0KVxuICBlbmRcblxuICBkZWYgbWV0aG9kX2FkZGVkKCopXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfcmVtb3ZlZCgqKVxuICBlbmRcblxuICBkZWYgbWV0aG9kX3VuZGVmaW5lZCgqKVxuICBlbmRcblxuICBkZWYgbW9kdWxlX2V2YWwoKmFyZ3MsICZibG9jaylcbiAgICBpZiBibG9jay5uaWw/ICYmIGAhIU9wYWwuY29tcGlsZWBcbiAgICAgIEtlcm5lbC5yYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMS4uMyknIHVubGVzcyAoMS4uMykuY292ZXI/IGFyZ3Muc2l6ZVxuXG4gICAgICBzdHJpbmcsIGZpbGUsIF9saW5lbm8gPSAqYXJnc1xuICAgICAgZGVmYXVsdF9ldmFsX29wdGlvbnMgPSB7IGZpbGU6IChmaWxlIHx8ICcoZXZhbCknKSwgZXZhbDogdHJ1ZSB9XG4gICAgICBjb21waWxpbmdfb3B0aW9ucyA9IF9fT1BBTF9DT01QSUxFUl9DT05GSUdfXy5tZXJnZShkZWZhdWx0X2V2YWxfb3B0aW9ucylcbiAgICAgIGNvbXBpbGVkID0gT3BhbC5jb21waWxlIHN0cmluZywgY29tcGlsaW5nX29wdGlvbnNcbiAgICAgIGJsb2NrID0gS2VybmVsLnByb2MgZG9cbiAgICAgICAgJXh7XG4gICAgICAgICAgcmV0dXJuIChmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZhbChjb21waWxlZCk7XG4gICAgICAgICAgfSkoc2VsZilcbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZWxzaWYgYXJncy5hbnk/XG4gICAgICBLZXJuZWwucmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2FyZ3Muc2l6ZX0gZm9yIDApXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcblxcbiAgTk9URTpJZiB5b3Ugd2FudCB0byBlbmFibGUgcGFzc2luZyBhIFN0cmluZyBhcmd1bWVudCBwbGVhc2UgYWRkIFxcXCJyZXF1aXJlICdvcGFsLXBhcnNlcidcXFwiIHRvIHlvdXIgc2NyaXB0XFxuXCJcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIG9sZCA9IGJsb2NrLiQkcyxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGJsb2NrLiQkcyA9IG51bGw7XG4gICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBbc2VsZl0pO1xuICAgICAgYmxvY2suJCRzID0gb2xkO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgY2xhc3NfZXZhbCBtb2R1bGVfZXZhbFxuXG4gIGRlZiBtb2R1bGVfZXhlYygqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgI3tyYWlzZSBMb2NhbEp1bXBFcnJvciwgJ25vIGJsb2NrIGdpdmVuJ31cbiAgICAgIH1cblxuICAgICAgdmFyIGJsb2NrX3NlbGYgPSBibG9jay4kJHMsIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGJsb2NrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgYmxvY2suJCRzID0gYmxvY2tfc2VsZjtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGNsYXNzX2V4ZWMgbW9kdWxlX2V4ZWNcblxuICBkZWYgbWV0aG9kX2RlZmluZWQ/KG1ldGhvZClcbiAgICAleHtcbiAgICAgIHZhciBib2R5ID0gc2VsZi4kJHByb3RvdHlwZVsnJCcgKyBtZXRob2RdO1xuICAgICAgcmV0dXJuICghIWJvZHkpICYmICFib2R5LiQkc3R1YjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtb2R1bGVfZnVuY3Rpb24oKm1ldGhvZHMpXG4gICAgJXh7XG4gICAgICBpZiAobWV0aG9kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VsZi4kJG1vZHVsZV9mdW5jdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbWV0aCA9IG1ldGhvZHNbaV0sXG4gICAgICAgICAgICAgIGlkICAgPSAnJCcgKyBtZXRoLFxuICAgICAgICAgICAgICBmdW5jID0gc2VsZi4kJHByb3RvdHlwZVtpZF07XG5cbiAgICAgICAgICBPcGFsLmRlZnMoc2VsZiwgaWQsIGZ1bmMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5hbWVcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkZnVsbF9uYW1lKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkZnVsbF9uYW1lO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sIGJhc2UgPSBzZWxmO1xuXG4gICAgICB3aGlsZSAoYmFzZSkge1xuICAgICAgICAvLyBHaXZlIHVwIGlmIGFueSBvZiB0aGUgYW5jZXN0b3JzIGlzIHVubmFtZWRcbiAgICAgICAgaWYgKGJhc2UuJCRuYW1lID09PSBuaWwgfHwgYmFzZS4kJG5hbWUgPT0gbnVsbCkgcmV0dXJuIG5pbDtcblxuICAgICAgICByZXN1bHQudW5zaGlmdChiYXNlLiQkbmFtZSk7XG5cbiAgICAgICAgYmFzZSA9IGJhc2UuJCRiYXNlX21vZHVsZTtcblxuICAgICAgICBpZiAoYmFzZSA9PT0gT3BhbC5PYmplY3QpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGZ1bGxfbmFtZSA9IHJlc3VsdC5qb2luKCc6OicpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHByZXBlbmQoKm1vZHMpXG4gICAgJXh7XG4gICAgICBpZiAobW9kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoZ2l2ZW4gMCwgZXhwZWN0ZWQgMSspJ31cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IG1vZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG1vZCA9IG1vZHNbaV07XG5cbiAgICAgICAgaWYgKCFtb2QuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YG1vZGAuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgI3tgbW9kYC5wcmVwZW5kX2ZlYXR1cmVzIHNlbGZ9O1xuICAgICAgICAje2Btb2RgLnByZXBlbmRlZCBzZWxmfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwcmVwZW5kX2ZlYXR1cmVzKHByZXBlbmRlcilcbiAgICAleHtcbiAgICAgIGlmICghc2VsZi4kJGlzX21vZHVsZSkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7c2VsZi5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICB9XG5cbiAgICAgIE9wYWwucHJlcGVuZF9mZWF0dXJlcyhzZWxmLCBwcmVwZW5kZXIpXG4gICAgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHByZXBlbmRlZChtb2QpXG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfY29uc3QobmFtZSlcbiAgICBgT3BhbC5jb25zdF9yZW1vdmUoc2VsZiwgbmFtZSlgXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgYE9wYWwuTW9kdWxlLiRuYW1lLmNhbGwoc2VsZilgIHx8IFwiIzwje2BzZWxmLiQkaXNfbW9kdWxlID8gJ01vZHVsZScgOiAnQ2xhc3MnYH06MHgje19faWRfXy50b19zKDE2KX0+XCJcbiAgZW5kXG5cbiAgZGVmIHVuZGVmX21ldGhvZCgqbmFtZXMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgT3BhbC51ZGVmKHNlbGYsIFwiJFwiICsgbmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlc1xuICAgIGNvbnN0cyA9IGNvbnN0YW50c1xuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHNlbGYpIHtcbiAgICAgICAgaWYgKHNlbGYuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgbmFtZS5jaGFyQXQoMCkgIT09ICckJyAmJiBuYW1lICE9PSAnY29uc3RydWN0b3InICYmICEje2NvbnN0cy5pbmNsdWRlPyhgbmFtZWApfSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCdAJyArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgY29weSA9IHN1cGVyXG4gICAgY29weS5jb3B5X2NsYXNzX3ZhcmlhYmxlcyhzZWxmKVxuICAgIGNvcHkuY29weV9jb25zdGFudHMoc2VsZilcbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBjb3B5X2NsYXNzX3ZhcmlhYmxlcyhvdGhlcilcbiAgICAleHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gb3RoZXIuJCRjdmFycykge1xuICAgICAgICBzZWxmLiQkY3ZhcnNbbmFtZV0gPSBvdGhlci4kJGN2YXJzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvcHlfY29uc3RhbnRzKG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIG5hbWUsIG90aGVyX2NvbnN0YW50cyA9IG90aGVyLiQkY29uc3Q7XG5cbiAgICAgIGZvciAobmFtZSBpbiBvdGhlcl9jb25zdGFudHMpIHtcbiAgICAgICAgT3BhbC5jb25zdF9zZXQoc2VsZiwgbmFtZSwgb3RoZXJfY29uc3RhbnRzW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJhbGxvY2F0ZSIsInNlbGYiLCJpbml0aWFsaXplIiwiYmxvY2tfZ2l2ZW4/IiwibW9kdWxlX2V2YWwiLCJibG9jayIsIj09PSIsIjwiLCJvdGhlciIsInJhaXNlIiwiPD0iLCIkcmV0X29yXzEiLCJlcXVhbD8iLCI+IiwiPj0iLCIkcmV0X29yXzIiLCI8PT4iLCJsdCIsIm5pbD8iLCItMSIsIjEiLCJhbGlhc19tZXRob2QiLCJuZXduYW1lIiwib2xkbmFtZSIsImFsaWFzX25hdGl2ZSIsIm1pZCIsImFuY2VzdG9ycyIsImFwcGVuZF9mZWF0dXJlcyIsImF0dHJfYWNjZXNzb3IiLCJhdHRyX3JlYWRlciIsIm5hbWVzIiwiYXR0cl93cml0ZXIiLCJhdHRyIiwid2FybiIsImFyZ3MiLCJhdXRvbG9hZCIsImNvbnN0JCIsInBhdGgiLCJjbGFzc192YXJpYWJsZXMiLCJjbGFzc192YXJpYWJsZV9nZXQiLCJuYW1lIiwiY2xhc3NfdmFyaWFibGVfbmFtZSEiLCJuZXciLCJjbGFzc192YXJpYWJsZV9zZXQiLCJjbGFzc192YXJpYWJsZV9kZWZpbmVkPyIsInJlbW92ZV9jbGFzc192YXJpYWJsZSIsImNvbnN0YW50cyIsIm5lc3RpbmciLCJjb25zdF9kZWZpbmVkPyIsImNvbnN0X25hbWUhIiwiPX4iLCJjb25zdF9nZXQiLCJpbmplY3QiLCJzcGxpdCIsIm8iLCJjIiwiY29uc3RfbWlzc2luZyIsImZ1bGxfY29uc3RfbmFtZSIsIj09IiwiY29uc3Rfc2V0IiwiJHJldF9vcl8zIiwiIX4iLCJzdGFydF93aXRoPyIsInZhbHVlIiwicHVibGljX2NvbnN0YW50IiwiZGVmaW5lX21ldGhvZCIsIiRyZXRfb3JfNCIsIm1ldGhvZCIsInRvX3Byb2MiLCJib3VuZCIsImJpbmQiLCJjYWxsIiwicmVtb3ZlX21ldGhvZCIsInNpbmdsZXRvbl9jbGFzcz8iLCJpbmNsdWRlIiwiaW5jbHVkZWQiLCJpbmNsdWRlZF9tb2R1bGVzIiwiaW5jbHVkZT8iLCJpbnN0YW5jZV9tZXRob2QiLCJpbnN0YW5jZV9tZXRob2RzIiwiaW5jbHVkZV9zdXBlciIsImV4dGVuZGVkIiwiZXh0ZW5kX29iamVjdCIsIm1ldGhvZF9hZGRlZCIsIm1ldGhvZF9yZW1vdmVkIiwibWV0aG9kX3VuZGVmaW5lZCIsIiRyZXRfb3JfNSIsIjMiLCJjb3Zlcj8iLCJzaXplIiwic3RyaW5nIiwiZmlsZSIsIl9saW5lbm8iLCJkZWZhdWx0X2V2YWxfb3B0aW9ucyIsIiRyZXRfb3JfNiIsImNvbXBpbGluZ19vcHRpb25zIiwiX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fIiwibWVyZ2UiLCJjb21waWxlZCIsImNvbXBpbGUiLCJwcm9jIiwiYW55PyIsIm1vZHVsZV9leGVjIiwibWV0aG9kX2RlZmluZWQ/IiwibW9kdWxlX2Z1bmN0aW9uIiwicHJlcGVuZCIsInByZXBlbmRfZmVhdHVyZXMiLCJwcmVwZW5kZWQiLCJyZW1vdmVfY29uc3QiLCJ0b19zIiwiJHJldF9vcl83IiwiX19pZF9fIiwiMTYiLCJ1bmRlZl9tZXRob2QiLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJjb25zdHMiLCJkdXAiLCJjb3B5IiwiY29weV9jbGFzc192YXJpYWJsZXMiLCJjb3B5X2NvbnN0YW50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7RUFFQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQUMsVUFBSUMsSUFBSkQsZUFBQUEscUJBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkVBLElBQUFBLENBQUFBLGdDQUFBQSxDQUFBO0FBQUE7QUFTQUUsSUFBQUEsOEJBQUFBLHVCQUFBQSxzQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBYkY7QUFhaUIsTUFBQSwyQ0FiakI7QUFBQSxNQWNJLElBQXVCQyxlQUF2QjtBQUFBLFFBQUEsT0FBQUMsVUFBQUEsZUFBQUEsRUFBQUEsRUFBQUEsRUFBYUMsZ0JBQWJEO0FBQUEsTUFBQTtBQUFBO0FBQUEsTUFBQSxDQWRKO0FBYUVGLElBQUFBLENBQUFBLGtDQUFBQSxDQVRBO0FBQUE7QUFhQUksSUFBQUEsdUJBQUFBLHNCQUFBQSxTQUFRLE1BQVJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUEsSUFBQSxRQUFpQixjQUFqQixDQUFBO0FBQUEsUUFBQSxPQUFPLEtBQVAsQ0FBQTtBQUFBLE1BRUEsT0FBQyx1QkFBRCxDQUZBO0FBREZBLElBQUFBLENBQUFBLGlDQUFBQSxDQWJBO0FBQUE7QUFtQkFDLElBQUFBLHFCQUFBQSxnQkFBQUEsU0FBTSxLQUFOQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFD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bHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NsYXNzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvbW9kdWxlJ1xuXG5jbGFzcyBDbGFzc1xuICBkZWYgc2VsZi5uZXcoc3VwZXJjbGFzcyA9IE9iamVjdCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKCFzdXBlcmNsYXNzLiQkaXNfY2xhc3MpIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcInN1cGVyY2xhc3MgbXVzdCBiZSBhIENsYXNzXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIga2xhc3MgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKG5pbCwgc3VwZXJjbGFzcyk7XG4gICAgICBzdXBlcmNsYXNzLiRpbmhlcml0ZWQoa2xhc3MpO1xuICAgICAgI3tga2xhc3NgLmNsYXNzX2V2YWwoJmJsb2NrKSBpZiBibG9ja19naXZlbj99XG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYWxsb2NhdGVcbiAgICAleHtcbiAgICAgIHZhciBvYmogPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKCk7XG4gICAgICBvYmouJCRpZCA9IE9wYWwudWlkKCk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluaGVyaXRlZChjbHMpXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2R1cChvcmlnaW5hbClcbiAgICBpbml0aWFsaXplX2NvcHkob3JpZ2luYWwpXG4gICAgJXh7XG4gICAgICBzZWxmLiQkbmFtZSA9IG51bGw7XG4gICAgICBzZWxmLiQkZnVsbF9uYW1lID0gbnVsbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBuZXcoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBvYmplY3QgPSAje2FsbG9jYXRlfTtcbiAgICAgIE9wYWwuc2VuZChvYmplY3QsIG9iamVjdC4kaW5pdGlhbGl6ZSwgYXJncywgYmxvY2spO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzdXBlcmNsYXNzXG4gICAgYHNlbGYuJCRzdXBlciB8fCBuaWxgXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgJXh7XG4gICAgICB2YXIgc2luZ2xldG9uX29mID0gc2VsZi4kJHNpbmdsZXRvbl9vZjtcblxuICAgICAgaWYgKHNpbmdsZXRvbl9vZiAmJiBzaW5nbGV0b25fb2YuJCRpc19hX21vZHVsZSkge1xuICAgICAgICByZXR1cm4gI3tcIiM8Q2xhc3M6I3tgc2luZ2xldG9uX29mYC5uYW1lfT5cIn07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzaW5nbGV0b25fb2YpIHtcbiAgICAgICAgLy8gYSBzaW5nbGV0b24gY2xhc3MgY3JlYXRlZCBmcm9tIGFuIG9iamVjdFxuICAgICAgICByZXR1cm4gI3tcIiM8Q2xhc3M6Izwje2BzaW5nbGV0b25fb2YuJCRjbGFzc2AubmFtZX06MHgje2BPcGFsLmlkKHNpbmdsZXRvbl9vZilgLnRvX3MoMTYpfT4+XCJ9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tzdXBlcigpfTtcbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwibmV3Iiwic2VsZiIsImJsb2NrX2dpdmVuPyIsImNsYXNzX2V2YWwiLCJibG9jayIsImFsbG9jYXRlIiwiaW5oZXJpdGVkIiwiaW5pdGlhbGl6ZV9kdXAiLCJpbml0aWFsaXplX2NvcHkiLCJvcmlnaW5hbCIsInN1cGVyY2xhc3MiLCJ0b19zIiwibmFtZSIsIjE2Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQUFBO0FBQUEsRUFFQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQUMsVUFBSUMsSUFBSkQsVUFBQUEsZUFBQUEsU0FBYSxVQUFiQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUFKRjtBQUlvQyxNQUFBLG1DQUpwQztBQUFBO0FBSWUsTUFBQTtBQUFBLE1BQUEsZUFBYSxzQkFBYjtBQUFBLE1BQUEsQ0FKZjtBQUFBO0FBTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFRLGFBQUEsSUFBOEJFLGVBQTlCO0FBQUEsUUFBQSxPQUFBQyxNQUFBLENBQUMsS0FBRCxDQUFBQSxjQUFBQSxFQUFBQSxFQUFBQSxFQUFvQkMsZ0JBQXBCRDtBQUFBLE1BQUE7QUFBQTtBQUFBLE1BQUEsQ0FBQTtBQUNSO0FBQ0EsSUFkQTtBQUlFSCxJQUFBQSxDQUFBQSwyQkFBQUEsQ0FBQTtBQUFBO0FBYUFLLElBQUFBLDRCQUFBQSxvQkFBQUEsb0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBTEVBLElBQUFBLENBQUFBLCtCQUFBQSxDQWJBO0FBQUE7QUFxQkFDLElBQUFBLDZCQUFBQSxxQkFBQUEscUJBQWMsR0FBZEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BekJGLE9BQUE7QUF5QkVBLElBQUFBLENBQUFBLGdDQUFBQSxDQXJCQTtBQUFBO0FBd0JBQyxJQUFBQSxrQ0FBQUEsMEJBQUFBLDBCQUFtQixRQUFuQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsVUFBQUMsaUJBQUFBLENBQWdCQyxRQUFoQkQsQ0FBQTtBQUFBO0FBRUo7QUFDQTtBQUNBLElBSkk7QUFERkQsSUFBQUEsQ0FBQUEscUNBQUFBLENBeEJBO0FBQUE7QUFnQ0FQLElBQUFBLHVCQUFBQSxlQUFBQSxTQXBDRixFQW9DRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBcENGO0FBb0NpQixNQUFBLG1DQXBDakI7QUFBQTtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQW9DVSxNQUFBLGtCQXBDVjtBQUFBO0FBc0NBLHVCQUFxQkssVUFBQUEsQ0FBQUEsQ0FBUztBQUM5QjtBQUNBO0FBQ0EsSUF6Q0E7QUFvQ0VMLElBQUFBLENBQUFBLDJCQUFBQSxDQWhDQTtBQUFBO0FBd0NBVSxJQUFBQSw4QkFBQUEsc0JBQUFBLHNCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFDLG1CQUFEO0FBREZBLElBQUFBLENBQUFBLGlDQUFBQSxDQXhDQTtBQUFBLElBNENBLE9BQUFDLENBQUFBLHdCQUFBQSxnQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQUVGOztBQUVBO0FBQ0EsZUFBaUIsRUFBQSxHQUFBLFVBQUEsR0FBQSxDQUFXLENBQUMsWUFBRCxDQUFBQyxNQUFBQSxDQUFBQSxDQUFYLENBQUEsR0FBQSxHQUFrQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxlQUFpQixFQUFBLEdBQUEsWUFBQSxHQUFBLENBQWEsQ0FBQyxvQkFBRCxDQUFBQSxNQUFBQSxDQUFBQSxDQUFiLENBQUEsR0FBQSxLQUFBLEdBQUEsQ0FBOEMsQ0FBQyxxQkFBRCxDQUFBRCxNQUFBQSxDQUE2QkUsRUFBN0JGLENBQTlDLENBQUEsR0FBQSxJQUFtRjtBQUNwRzs7QUFFQSxhQUFlLFdBQUEsRUFBQSxvRUFBQSxRQUFBLEVBQUEsRUFBQSxNQUFBLENBQVE7QUFDdkI7QUFiRUEsSUFBQUEsQ0FBQUEsMkJBQUFBLENBQUFBLGdCQTVDQTtBQURGWixFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQUZBOzsifX0seyJvZmZzZXQiOnsibGluZSI6Mzc4NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvYmFzaWNfb2JqZWN0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEJhc2ljT2JqZWN0XG4gIGRlZiBpbml0aWFsaXplKCopXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgc2VsZiA9PT0gb3RoZXJgXG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIHNlbGYgPT0gb3RoZXJcbiAgZW5kXG5cbiAgYWxpYXMgZXF1YWw/ID09XG5cbiAgZGVmIF9faWRfX1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRpZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkaWQ7XG4gICAgICB9XG4gICAgICBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYsICckJGlkJywgT3BhbC51aWQoKSk7XG4gICAgICByZXR1cm4gc2VsZi4kJGlkO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIF9fc2VuZF9fKHN5bWJvbCwgKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBmdW5jID0gc2VsZlsnJCcgKyBzeW1ib2xdXG5cbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICAgZnVuYy4kJHAgPSBibG9jaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBzZWxmLiRtZXRob2RfbWlzc2luZy4kJHAgPSBibG9jaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJG1ldGhvZF9taXNzaW5nLmFwcGx5KHNlbGYsIFtzeW1ib2xdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgIVxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiAhPShvdGhlcilcbiAgICAhKHNlbGYgPT0gb3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9ldmFsKCphcmdzLCAmYmxvY2spXG4gICAgaWYgYmxvY2submlsPyAmJiBgISFPcGFsLmNvbXBpbGVgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxLi4zKScgdW5sZXNzICgxLi4zKS5jb3Zlcj8gYXJncy5zaXplXG5cbiAgICAgIHN0cmluZywgZmlsZSwgX2xpbmVubyA9ICphcmdzXG4gICAgICBkZWZhdWx0X2V2YWxfb3B0aW9ucyA9IHsgZmlsZTogKGZpbGUgfHwgJyhldmFsKScpLCBldmFsOiB0cnVlIH1cbiAgICAgIGNvbXBpbGluZ19vcHRpb25zID0gX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fLm1lcmdlKGRlZmF1bHRfZXZhbF9vcHRpb25zKVxuICAgICAgY29tcGlsZWQgPSA6Ok9wYWwuY29tcGlsZSBzdHJpbmcsIGNvbXBpbGluZ19vcHRpb25zXG4gICAgICBibG9jayA9IDo6S2VybmVsLnByb2MgZG9cbiAgICAgICAgJXh7XG4gICAgICAgICAgcmV0dXJuIChmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZhbChjb21waWxlZCk7XG4gICAgICAgICAgfSkoc2VsZilcbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZWxzaWYgYXJncy5hbnk/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLnNpemV9IGZvciAwKVwiXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBvbGQgPSBibG9jay4kJHMsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBibG9jay4kJHMgPSBudWxsO1xuXG4gICAgICAvLyBOZWVkIHRvIHBhc3MgJCRldmFsIHNvIHRoYXQgbWV0aG9kIGRlZmluaXRpb25zIGtub3cgaWYgdGhpcyBpc1xuICAgICAgLy8gYmVpbmcgZG9uZSBvbiBhIGNsYXNzL21vZHVsZS4gQ2Fubm90IGJlIGNvbXBpbGVyIGRyaXZlbiBzaW5jZVxuICAgICAgLy8gc2VuZCg6aW5zdGFuY2VfZXZhbCkgbmVlZHMgdG8gd29yay5cbiAgICAgIGlmIChzZWxmLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgICAgc2VsZi4kJGV2YWwgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IGJsb2NrLmNhbGwoc2VsZiwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgc2VsZi4kJGV2YWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGJsb2NrLmNhbGwoc2VsZiwgc2VsZik7XG4gICAgICB9XG5cbiAgICAgIGJsb2NrLiQkcyA9IG9sZDtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9leGVjKCphcmdzLCAmYmxvY2spXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nIHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgYmxvY2tfc2VsZiA9IGJsb2NrLiQkcyxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGJsb2NrLiQkcyA9IG51bGw7XG5cbiAgICAgIGlmIChzZWxmLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgICAgc2VsZi4kJGV2YWwgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IGJsb2NrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgIHNlbGYuJCRldmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgYmxvY2suJCRzID0gYmxvY2tfc2VsZjtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fbWV0aG9kX2FkZGVkKCopXG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQoKilcbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9tZXRob2RfdW5kZWZpbmVkKCopXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfbWlzc2luZyhzeW1ib2wsICphcmdzLCAmYmxvY2spXG4gICAgbWVzc2FnZSA9IGlmIGBzZWxmLiRpbnNwZWN0ICYmICFzZWxmLiRpbnNwZWN0LiQkc3R1YmBcbiAgICAgICAgICAgICAgICBcInVuZGVmaW5lZCBtZXRob2QgYCN7c3ltYm9sfScgZm9yICN7aW5zcGVjdH06I3tgc2VsZi4kJGNsYXNzYH1cIlxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgXCJ1bmRlZmluZWQgbWV0aG9kIGAje3N5bWJvbH0nIGZvciAje2BzZWxmLiQkY2xhc3NgfVwiXG4gICAgICAgICAgICAgIGVuZFxuXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOb01ldGhvZEVycm9yLm5ldyhtZXNzYWdlLCBzeW1ib2wpXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG1ldGhvZF9uYW1lLCBpbmNsdWRlX2FsbCA9IGZhbHNlKVxuICAgIGZhbHNlXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJpbml0aWFsaXplIiwiPT0iLCJlcWw/Iiwic2VsZiIsIm90aGVyIiwiX19pZF9fIiwiX19zZW5kX18iLCIhIiwiIT0iLCJpbnN0YW5jZV9ldmFsIiwiJHJldF9vcl8xIiwiYmxvY2siLCJuaWw/IiwiMSIsIjMiLCJjb3Zlcj8iLCJhcmdzIiwic2l6ZSIsInJhaXNlIiwic3RyaW5nIiwiZmlsZSIsIl9saW5lbm8iLCJkZWZhdWx0X2V2YWxfb3B0aW9ucyIsIiRyZXRfb3JfMiIsImNvbXBpbGluZ19vcHRpb25zIiwiX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fIiwibWVyZ2UiLCJjb21waWxlZCIsImNvbXBpbGUiLCJwcm9jIiwiYW55PyIsImluc3RhbmNlX2V4ZWMiLCJzaW5nbGV0b25fbWV0aG9kX2FkZGVkIiwic2luZ2xldG9uX21ldGhvZF9yZW1vdmVkIiwic2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQiLCJtZXRob2RfbWlzc2luZyIsIm1lc3NhZ2UiLCJzeW1ib2wiLCJpbnNwZWN0IiwibmV3IiwicmVzcG9uZF90b19taXNzaW5nPyJdLCJtYXBwaW5ncyI6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LFNBQUFBLENBQUFBLENBQXBDLENBQUEsR0FBQSxHQUFBLEdBQUEsQ0FBZ0QsWUFBaEQ7QUFERixNQUFBO0FBQUEsUUFHRSxPQUFBLEVBQUEsR0FBQSxvQkFBQSxHQUFBLENBQXFCRCxNQUFyQixDQUFBLEdBQUEsUUFBQSxHQUFBLENBQXFDLFlBQXJDO0FBSEYsTUFBQSxDQUFBLGtCQTFJZDtBQUFBLE1BZ0pJLE9BQUEsSUFBQSxJQUFBLFdBQUFuQixPQUFBQSxDQUFlLElBQUEsSUFBQSxrQkFBQXFCLEtBQUFBLENBQW9CSCxTQUFTQyxNQUE3QkUsQ0FBZnJCLENBaEpKO0FBeUlFaUIsSUFBQUEsQ0FBQUEsNkNBQUFBLENBdklBO0FBQUEsSUFpSkEsT0FBQUssQ0FBQUEsdUNBQUFBLDBDQUFBQSxTQUF3QixXQUFELEVBQWMsV0FBckNBO0FBQUFBLE1BQUFBOztBQUFBQTtBQW5KRjtBQW1KdUMsTUFBQTtBQUFBLE1BQUEsZ0JBQWMsS0FBZDtBQUFBLE1BQUEsQ0FuSnZDO0FBQUEsTUFvSkksT0FBQSxLQXBKSjtBQW1KRUEsSUFBQUEsQ0FBQUEsc0RBQUFBLENBQUFBLCtCQWpKQTtBQURGekMsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MDQxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9rZXJuZWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHksIGNvZXJjZV90bywgcmVzcG9uZF90b1xuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBtZXRob2RfbWlzc2luZyhzeW1ib2wsICphcmdzLCAmYmxvY2spXG4gICAgcmFpc2UgTm9NZXRob2RFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje3N5bWJvbH0nIGZvciAje2luc3BlY3R9XCIsIHN5bWJvbCwgYXJncylcbiAgZW5kXG5cbiAgZGVmID1+KG9iailcbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgIX4ob2JqKVxuICAgICEoc2VsZiA9fiBvYmopXG4gIGVuZFxuXG4gIGRlZiA9PT0ob3RoZXIpXG4gICAgb2JqZWN0X2lkID09IG90aGVyLm9iamVjdF9pZCB8fCBzZWxmID09IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgJXh7XG4gICAgICAvLyBzZXQgZ3VhcmQgZm9yIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgc2VsZi4kJGNvbXBhcmFibGUgPSB0cnVlO1xuXG4gICAgICB2YXIgeCA9ICN7c2VsZiA9PSBvdGhlcn07XG5cbiAgICAgIGlmICh4ICYmIHggIT09IG5pbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtZXRob2QobmFtZSlcbiAgICAleHtcbiAgICAgIHZhciBtZXRoID0gc2VsZlsnJCcgKyBuYW1lXTtcblxuICAgICAgaWYgKCFtZXRoIHx8IG1ldGguJCRzdHViKSB7XG4gICAgICAgICN7cmFpc2UgTmFtZUVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYCN7bmFtZX0nIGZvciBjbGFzcyBgI3tzZWxmLmNsYXNzfSdcIiwgbmFtZSl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tNZXRob2QubmV3KHNlbGYsIGBtZXRoLiQkb3duZXIgfHwgI3tzZWxmLmNsYXNzfWAsIGBtZXRoYCwgbmFtZSl9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1ldGhvZHMoYWxsID0gdHJ1ZSlcbiAgICAleHtcbiAgICAgIGlmICgkdHJ1dGh5KCN7YWxsfSkpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwubWV0aG9kcyhzZWxmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLm93bl9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHB1YmxpY19tZXRob2RzKGFsbCA9IHRydWUpXG4gICAgJXh7XG4gICAgICBpZiAoJHRydXRoeSgje2FsbH0pKSB7XG4gICAgICAgIHJldHVybiBPcGFsLm1ldGhvZHMoc2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5yZWNlaXZlcl9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEFycmF5KG9iamVjdClcbiAgICAleHtcbiAgICAgIHZhciBjb2VyY2VkO1xuXG4gICAgICBpZiAob2JqZWN0ID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cblxuICAgICAgY29lcmNlZCA9ICN7T3BhbC5jb2VyY2VfdG8/KG9iamVjdCwgQXJyYXksIDp0b19hcnkpfTtcbiAgICAgIGlmIChjb2VyY2VkICE9PSBuaWwpIHsgcmV0dXJuIGNvZXJjZWQ7IH1cblxuICAgICAgY29lcmNlZCA9ICN7T3BhbC5jb2VyY2VfdG8/KG9iamVjdCwgQXJyYXksIDp0b19hKX07XG4gICAgICBpZiAoY29lcmNlZCAhPT0gbmlsKSB7IHJldHVybiBjb2VyY2VkOyB9XG5cbiAgICAgIHJldHVybiBbb2JqZWN0XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhdF9leGl0KCZibG9jaylcbiAgICAkX19hdF9leGl0X18gfHw9IFtdXG4gICAgJF9fYXRfZXhpdF9fIDw8IGJsb2NrXG4gICAgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIGNhbGxlcihzdGFydCA9IDEsIGxlbmd0aCA9IG5pbClcbiAgICAleHtcbiAgICAgIHZhciBzdGFjaywgcmVzdWx0XG5cbiAgICAgIHN0YWNrID0gKG5ldyBFcnJvcigpLnN0YWNrIHx8IFwiXCIpLnNwbGl0KFwiXFxuXCIpXG4gICAgICByZXN1bHQgPSBbXVxuXG4gICAgICAvLyBTa2lwIHRoZSBpbml0aWFsIGxpbmUgKFwiRXJyb3I6XCIpIGFuZCBLZXJuZWwjY2FsbGVyIHdpdGggaT0zXG4gICAgICBmb3IgKHZhciBpID0gMywgaWkgPSBzdGFjay5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGlmICghc3RhY2tbaV0ubWF0Y2goXCJydW50aW1lLmpzXCIpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc3RhY2tbaV0ucmVwbGFjZSgvXiAqXFx3KyArLywgJycpKVxuICAgICAgICAgIGlmIChsZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA9PSBsZW5ndGgpIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbGFzc1xuICAgIGBzZWxmLiQkY2xhc3NgXG4gIGVuZFxuXG4gIGRlZiBjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3RoZXIpLCBpLCBpaSwgbmFtZTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0ga2V5cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBrZXlzW2ldO1xuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgIT09ICckJyAmJiBvdGhlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHNlbGZbbmFtZV0gPSBvdGhlcltuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvcHlfc2luZ2xldG9uX21ldGhvZHMob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbmFtZSwgbmFtZXMsIGxlbmd0aDtcblxuICAgICAgaWYgKG90aGVyLmhhc093blByb3BlcnR5KCckJG1ldGEnKSkge1xuICAgICAgICB2YXIgb3RoZXJfc2luZ2xldG9uX2NsYXNzID0gT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG90aGVyKTtcbiAgICAgICAgdmFyIHNlbGZfc2luZ2xldG9uX2NsYXNzID0gT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKHNlbGYpO1xuICAgICAgICBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG90aGVyX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZSk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgaWYgKE9wYWwuaXNfbWV0aG9kKG5hbWUpKSB7XG4gICAgICAgICAgICBzZWxmX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZVtuYW1lXSA9IG90aGVyX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZVtuYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmX3NpbmdsZXRvbl9jbGFzcy4kJGNvbnN0ID0gT2JqZWN0LmFzc2lnbih7fSwgb3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkY29uc3QpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoXG4gICAgICAgICAgc2VsZl9zaW5nbGV0b25fY2xhc3MuJCRwcm90b3R5cGUsXG4gICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKG90aGVyX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvdGhlciksIGxlbmd0aCA9IG5hbWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSAnJCcgJiYgbmFtZS5jaGFyQXQoMSkgIT09ICckJyAmJiBvdGhlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHNlbGZbbmFtZV0gPSBvdGhlcltuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNsb25lKGZyZWV6ZTogdHJ1ZSlcbiAgICBjb3B5ID0gc2VsZi5jbGFzcy5hbGxvY2F0ZVxuXG4gICAgY29weS5jb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyhzZWxmKVxuICAgIGNvcHkuY29weV9zaW5nbGV0b25fbWV0aG9kcyhzZWxmKVxuICAgIGNvcHkuaW5pdGlhbGl6ZV9jbG9uZShzZWxmKVxuXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9jbG9uZShvdGhlcilcbiAgICBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBkZWZpbmVfc2luZ2xldG9uX21ldGhvZChuYW1lLCBtZXRob2QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBzaW5nbGV0b25fY2xhc3MuZGVmaW5lX21ldGhvZChuYW1lLCBtZXRob2QsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIGNvcHkgPSBzZWxmLmNsYXNzLmFsbG9jYXRlXG5cbiAgICBjb3B5LmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2R1cChzZWxmKVxuXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9kdXAob3RoZXIpXG4gICAgaW5pdGlhbGl6ZV9jb3B5KG90aGVyKVxuICBlbmRcblxuICBkZWYgZW51bV9mb3IobWV0aG9kID0gOmVhY2gsICphcmdzLCAmYmxvY2spXG4gICAgRW51bWVyYXRvci5mb3Ioc2VsZiwgbWV0aG9kLCAqYXJncywgJmJsb2NrKVxuICBlbmRcblxuICBhbGlhcyB0b19lbnVtIGVudW1fZm9yXG5cbiAgZGVmIGVxdWFsPyhvdGhlcilcbiAgICBgc2VsZiA9PT0gb3RoZXJgXG4gIGVuZFxuXG4gIGRlZiBleGl0KHN0YXR1cyA9IHRydWUpXG4gICAgJF9fYXRfZXhpdF9fIHx8PSBbXVxuXG4gICAgdW50aWwgJF9fYXRfZXhpdF9fLmVtcHR5P1xuICAgICAgYmxvY2sgPSAkX19hdF9leGl0X18ucG9wXG4gICAgICBibG9jay5jYWxsXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChzdGF0dXMuJCRpc19ib29sZWFuKSB7XG4gICAgICAgIHN0YXR1cyA9IHN0YXR1cyA/IDAgOiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzID0gJGNvZXJjZV90byhzdGF0dXMsICN7SW50ZWdlcn0sICd0b19pbnQnKVxuICAgICAgfVxuXG4gICAgICBPcGFsLmV4aXQoc3RhdHVzKTtcbiAgICB9XG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBleHRlbmQoKm1vZHMpXG4gICAgJXh7XG4gICAgICB2YXIgc2luZ2xldG9uID0gI3tzaW5nbGV0b25fY2xhc3N9O1xuXG4gICAgICBmb3IgKHZhciBpID0gbW9kcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbW9kID0gbW9kc1tpXTtcblxuICAgICAgICBpZiAoIW1vZC4kJGlzX21vZHVsZSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICAgIH1cblxuICAgICAgICAje2Btb2RgLmFwcGVuZF9mZWF0dXJlcyBgc2luZ2xldG9uYH07XG4gICAgICAgICN7YG1vZGAuZXh0ZW5kX29iamVjdCBzZWxmfTtcbiAgICAgICAgI3tgbW9kYC5leHRlbmRlZCBzZWxmfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgX19pZF9fXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgdG9fc1xuICBlbmRcblxuICBkZWYgaW5zdGFuY2Vfb2Y/KGtsYXNzKVxuICAgICV4e1xuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzICYmICFrbGFzcy4kJGlzX21vZHVsZSkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ2NsYXNzIG9yIG1vZHVsZSByZXF1aXJlZCd9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNsYXNzID09PSBrbGFzcztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZV9kZWZpbmVkPyhuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmluc3RhbmNlX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICBgT3BhbC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGYsIG5hbWUuc3Vic3RyKDEpKWBcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlX2dldChuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmluc3RhbmNlX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIHZhciBpdmFyID0gc2VsZltPcGFsLml2YXIobmFtZS5zdWJzdHIoMSkpXTtcblxuICAgICAgcmV0dXJuIGl2YXIgPT0gbnVsbCA/IG5pbCA6IGl2YXI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVfc2V0KG5hbWUsIHZhbHVlKVxuICAgIG5hbWUgPSBPcGFsLmluc3RhbmNlX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICBgc2VsZltPcGFsLml2YXIobmFtZS5zdWJzdHIoMSkpXSA9IHZhbHVlYFxuICBlbmRcblxuICBkZWYgcmVtb3ZlX2luc3RhbmNlX3ZhcmlhYmxlKG5hbWUpXG4gICAgbmFtZSA9IE9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgICV4e1xuICAgICAgdmFyIGtleSA9IE9wYWwuaXZhcihuYW1lLnN1YnN0cigxKSksXG4gICAgICAgICAgdmFsO1xuICAgICAgaWYgKHNlbGYuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YWwgPSBzZWxmW2tleV07XG4gICAgICAgIGRlbGV0ZSBzZWxmW2tleV07XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmFpc2UgTmFtZUVycm9yLCBcImluc3RhbmNlIHZhcmlhYmxlICN7bmFtZX0gbm90IGRlZmluZWRcIlxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIGl2YXI7XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gc2VsZikge1xuICAgICAgICBpZiAoc2VsZi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBuYW1lLmNoYXJBdCgwKSAhPT0gJyQnKSB7XG4gICAgICAgICAgaWYgKG5hbWUuc3Vic3RyKC0xKSA9PT0gJyQnKSB7XG4gICAgICAgICAgICBpdmFyID0gbmFtZS5zbGljZSgwLCBuYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdmFyID0gbmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2goJ0AnICsgaXZhcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBJbnRlZ2VyKHZhbHVlLCBiYXNlID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIGksIHN0ciwgYmFzZV9kaWdpdHM7XG5cbiAgICAgIGlmICghdmFsdWUuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgaWYgKGJhc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2Jhc2Ugc3BlY2lmaWVkIGZvciBub24gc3RyaW5nIHZhbHVlJ31cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgbmlsIGludG8gSW50ZWdlclwifVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS4kJGlzX251bWJlcikge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkgfHwgdmFsdWUgPT09IC1JbmZpbml0eSB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICN7cmFpc2UgRmxvYXREb21haW5FcnJvciwgdmFsdWV9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyg6dG9faW50KX0pIHtcbiAgICAgICAgICBpID0gI3t2YWx1ZS50b19pbnR9O1xuICAgICAgICAgIGlmIChpICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gI3tPcGFsLmNvZXJjZV90byEodmFsdWUsIEludGVnZXIsIDp0b19pKX07XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gXCIwXCIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChiYXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYmFzZSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlID0gJGNvZXJjZV90byhiYXNlLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGlmIChiYXNlID09PSAxIHx8IGJhc2UgPCAwIHx8IGJhc2UgPiAzNikge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhZGl4ICN7YmFzZX1cIn1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdHIgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFxcZClfKD89XFxkKS9nLCAnJDEnKTtcblxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL14oXFxzKlsrLV0/KSgwW2JvZHhdPykvLCBmdW5jdGlvbiAoXywgaGVhZCwgZmxhZykge1xuICAgICAgICBzd2l0Y2ggKGZsYWcpIHtcbiAgICAgICAgY2FzZSAnMGInOlxuICAgICAgICAgIGlmIChiYXNlID09PSAwIHx8IGJhc2UgPT09IDIpIHtcbiAgICAgICAgICAgIGJhc2UgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgY2FzZSAnMG8nOlxuICAgICAgICAgIGlmIChiYXNlID09PSAwIHx8IGJhc2UgPT09IDgpIHtcbiAgICAgICAgICAgIGJhc2UgPSA4O1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICcwZCc6XG4gICAgICAgICAgaWYgKGJhc2UgPT09IDAgfHwgYmFzZSA9PT0gMTApIHtcbiAgICAgICAgICAgIGJhc2UgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnMHgnOlxuICAgICAgICAgIGlmIChiYXNlID09PSAwIHx8IGJhc2UgPT09IDE2KSB7XG4gICAgICAgICAgICBiYXNlID0gMTY7XG4gICAgICAgICAgICByZXR1cm4gaGVhZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgdmFsdWUgZm9yIEludGVnZXIoKTogXFxcIiN7dmFsdWV9XFxcIlwifVxuICAgICAgfSk7XG5cbiAgICAgIGJhc2UgPSAoYmFzZSA9PT0gMCA/IDEwIDogYmFzZSk7XG5cbiAgICAgIGJhc2VfZGlnaXRzID0gJzAtJyArIChiYXNlIDw9IDEwID8gYmFzZSAtIDEgOiAnOWEtJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyAoYmFzZSAtIDExKSkpO1xuXG4gICAgICBpZiAoIShuZXcgUmVnRXhwKCdeXFxcXHMqWystXT9bJyArIGJhc2VfZGlnaXRzICsgJ10rXFxcXHMqJCcpKS50ZXN0KHN0cikpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgdmFsdWUgZm9yIEludGVnZXIoKTogXFxcIiN7dmFsdWV9XFxcIlwifVxuICAgICAgfVxuXG4gICAgICBpID0gcGFyc2VJbnQoc3RyLCBiYXNlKTtcblxuICAgICAgaWYgKGlzTmFOKGkpKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHZhbHVlIGZvciBJbnRlZ2VyKCk6IFxcXCIje3ZhbHVlfVxcXCJcIn1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgRmxvYXQodmFsdWUpXG4gICAgJXh7XG4gICAgICB2YXIgc3RyO1xuXG4gICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IG5pbCBpbnRvIEZsb2F0XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS4kJGlzX3N0cmluZykge1xuICAgICAgICBzdHIgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csICckMScpO1xuXG4gICAgICAgIC8vU3BlY2lhbCBjYXNlIGZvciBoZXggc3RyaW5ncyBvbmx5OlxuICAgICAgICBpZiAoL15cXHMqWy0rXT8wW3hYXVswLTlhLWZBLUZdK1xccyokLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICByZXR1cm4gI3tJbnRlZ2VyKGBzdHJgKX07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIS9eXFxzKlstK10/WzAtOV0qXFwuP1swLTldKyhbZUVdWy0rXT9bMC05XSspP1xccyokLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCB2YWx1ZSBmb3IgRmxvYXQoKTogXFxcIiN7dmFsdWV9XFxcIlwifVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7T3BhbC5jb2VyY2VfdG8hKHZhbHVlLCBGbG9hdCwgOnRvX2YpfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBIYXNoKGFyZylcbiAgICByZXR1cm4ge30gaWYgYXJnLm5pbD8gfHwgYXJnID09IFtdXG4gICAgcmV0dXJuIGFyZyBpZiBIYXNoID09PSBhcmdcbiAgICBPcGFsLmNvZXJjZV90byEoYXJnLCBIYXNoLCA6dG9faGFzaClcbiAgZW5kXG5cbiAgZGVmIGlzX2E/KGtsYXNzKVxuICAgICV4e1xuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzICYmICFrbGFzcy4kJGlzX21vZHVsZSkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ2NsYXNzIG9yIG1vZHVsZSByZXF1aXJlZCd9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gT3BhbC5pc19hKHNlbGYsIGtsYXNzKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpdHNlbGZcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIGtpbmRfb2Y/IGlzX2E/XG5cbiAgZGVmIGxhbWJkYSgmYmxvY2spXG4gICAgYE9wYWwubGFtYmRhKGJsb2NrKWBcbiAgZW5kXG5cbiAgZGVmIGxvYWQoZmlsZSlcbiAgICBmaWxlID0gT3BhbC5jb2VyY2VfdG8hKGZpbGUsIFN0cmluZywgOnRvX3N0cilcbiAgICBgT3BhbC5sb2FkKCN7ZmlsZX0pYFxuICBlbmRcblxuICBkZWYgbG9vcFxuICAgIHJldHVybiBlbnVtX2Zvcig6bG9vcCkgeyBGbG9hdDo6SU5GSU5JVFkgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICB3aGlsZSB0cnVlXG4gICAgICBiZWdpblxuICAgICAgICB5aWVsZFxuICAgICAgcmVzY3VlIFN0b3BJdGVyYXRpb24gPT4gZVxuICAgICAgICByZXR1cm4gZS5yZXN1bHRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbmlsP1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cblxuICBkZWYgcHJpbnRmKCphcmdzKVxuICAgIGlmIGFyZ3MuYW55P1xuICAgICAgcHJpbnQgZm9ybWF0KCphcmdzKVxuICAgIGVuZFxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBwcm9jKCZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjcmVhdGUgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgIGVuZFxuXG4gICAgYGJsb2NrLiQkaXNfbGFtYmRhID0gZmFsc2VgXG4gICAgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIHB1dHMoKnN0cnMpXG4gICAgJHN0ZG91dC5wdXRzKCpzdHJzKVxuICBlbmRcblxuICBkZWYgcCgqYXJncylcbiAgICBhcmdzLmVhY2ggeyB8b2JqfCAkc3Rkb3V0LnB1dHMgb2JqLmluc3BlY3QgfVxuXG4gICAgYXJncy5sZW5ndGggPD0gMSA/IGFyZ3NbMF0gOiBhcmdzXG4gIGVuZFxuXG4gIGRlZiBwcmludCgqc3RycylcbiAgICAkc3Rkb3V0LnByaW50KCpzdHJzKVxuICBlbmRcblxuICBkZWYgd2Fybigqc3RycywgdXBsZXZlbDogbmlsKVxuICAgIGlmIHVwbGV2ZWxcbiAgICAgIHVwbGV2ZWwgPSBPcGFsLmNvZXJjZV90byEodXBsZXZlbCwgSW50ZWdlciwgOnRvX3N0cilcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwibmVnYXRpdmUgbGV2ZWwgKCN7dXBsZXZlbH0pXCIgaWYgdXBsZXZlbCA8IDBcbiAgICAgIGxvY2F0aW9uID0gY2FsbGVyKHVwbGV2ZWwgKyAyLCAxKS5maXJzdFxuICAgICAgbG9jYXRpb24gPSBcIiN7bG9jYXRpb259OiBcIiBpZiBsb2NhdGlvblxuICAgICAgc3RycyA9IHN0cnMubWFwIHsgfHN8IFwiI3tsb2NhdGlvbn13YXJuaW5nOiAje3N9XCIgfVxuICAgIGVuZFxuXG4gICAgJHN0ZGVyci5wdXRzKCpzdHJzKSB1bmxlc3MgJFZFUkJPU0UubmlsPyB8fCBzdHJzLmVtcHR5P1xuICBlbmRcblxuICBkZWYgcmFpc2UoZXhjZXB0aW9uID0gdW5kZWZpbmVkLCBzdHJpbmcgPSBuaWwsIF9iYWNrdHJhY2UgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoZXhjZXB0aW9uID09IG51bGwgJiYgI3skIX0gIT09IG5pbCkge1xuICAgICAgICB0aHJvdyAjeyQhfTtcbiAgICAgIH1cbiAgICAgIGlmIChleGNlcHRpb24gPT0gbnVsbCkge1xuICAgICAgICBleGNlcHRpb24gPSAje1J1bnRpbWVFcnJvci5uZXd9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZXhjZXB0aW9uLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7UnVudGltZUVycm9yLm5ldyBleGNlcHRpb259O1xuICAgICAgfVxuICAgICAgLy8gdXNpbmcgcmVzcG9uZF90bz8gYW5kIG5vdCBhbiB1bmRlZmluZWQgY2hlY2sgdG8gYXZvaWQgbWV0aG9kX21pc3NpbmcgbWF0Y2hpbmcgYXMgdHJ1ZVxuICAgICAgZWxzZSBpZiAoZXhjZXB0aW9uLiQkaXNfY2xhc3MgJiYgI3tleGNlcHRpb24ucmVzcG9uZF90bz8oOmV4Y2VwdGlvbil9KSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7ZXhjZXB0aW9uLmV4Y2VwdGlvbiBzdHJpbmd9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3tleGNlcHRpb24uaXNfYT8oRXhjZXB0aW9uKX0pIHtcbiAgICAgICAgLy8gZXhjZXB0aW9uIGlzIGZpbmVcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBleGNlcHRpb24gPSAje1R5cGVFcnJvci5uZXcgJ2V4Y2VwdGlvbiBjbGFzcy9vYmplY3QgZXhwZWN0ZWQnfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7JCF9ICE9PSBuaWwpIHtcbiAgICAgICAgT3BhbC5leGNlcHRpb25zLnB1c2goI3skIX0pO1xuICAgICAgfVxuXG4gICAgICAjeyQhfSA9IGV4Y2VwdGlvbjtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZmFpbCByYWlzZVxuXG4gIGRlZiByYW5kKG1heCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gI3tSYW5kb206OkRFRkFVTFQucmFuZH07XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXguJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKG1heCA8IDApIHtcbiAgICAgICAgICBtYXggPSBNYXRoLmFicyhtYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heCAlIDEgIT09IDApIHtcbiAgICAgICAgICBtYXggPSBtYXguJHRvX2koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXggPT09IDApIHtcbiAgICAgICAgICBtYXggPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgUmFuZG9tOjpERUZBVUxULnJhbmQobWF4KVxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90bz8obmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICAleHtcbiAgICAgIHZhciBib2R5ID0gc2VsZlsnJCcgKyBuYW1lXTtcblxuICAgICAgaWYgKHR5cGVvZihib2R5KSA9PT0gXCJmdW5jdGlvblwiICYmICFib2R5LiQkc3R1Yikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGZbJyRyZXNwb25kX3RvX21pc3Npbmc/J10uJCRwcmlzdGluZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tyZXNwb25kX3RvX21pc3Npbmc/KG5hbWUsIGluY2x1ZGVfYWxsKX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90b19taXNzaW5nPyhtZXRob2RfbmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICBmYWxzZVxuICBlbmRcblxuICBPcGFsLnByaXN0aW5lKHNlbGYsIDpyZXNwb25kX3RvPywgOnJlc3BvbmRfdG9fbWlzc2luZz8pXG5cbiAgZGVmIHJlcXVpcmUoZmlsZSlcbiAgICBmaWxlID0gT3BhbC5jb2VyY2VfdG8hKGZpbGUsIFN0cmluZywgOnRvX3N0cilcbiAgICBgT3BhbC5yZXF1aXJlKCN7ZmlsZX0pYFxuICBlbmRcblxuICBkZWYgcmVxdWlyZV9yZWxhdGl2ZShmaWxlKVxuICAgIE9wYWwudHJ5X2NvbnZlcnQhKGZpbGUsIFN0cmluZywgOnRvX3N0cilcbiAgICBmaWxlID0gRmlsZS5leHBhbmRfcGF0aCBGaWxlLmpvaW4oYE9wYWwuY3VycmVudF9maWxlYCwgJy4uJywgZmlsZSlcblxuICAgIGBPcGFsLnJlcXVpcmUoI3tmaWxlfSlgXG4gIGVuZFxuXG4gICMgYHBhdGhgIHNob3VsZCBiZSB0aGUgZnVsbCBwYXRoIHRvIGJlIGZvdW5kIGluIHJlZ2lzdGVyZWQgbW9kdWxlcyAoYE9wYWwubW9kdWxlc2ApXG4gIGRlZiByZXF1aXJlX3RyZWUocGF0aClcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgcGF0aCA9ICN7RmlsZS5leHBhbmRfcGF0aChwYXRoKX1cbiAgICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcbiAgICAgIGlmIChwYXRoID09PSAnLicpIHBhdGggPSAnJztcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gT3BhbC5tb2R1bGVzKSB7XG4gICAgICAgIGlmICgje2BuYW1lYC5zdGFydF93aXRoPyhwYXRoKX0pIHtcbiAgICAgICAgICByZXN1bHQucHVzaChbbmFtZSwgT3BhbC5yZXF1aXJlKG5hbWUpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHNlbmQgICAgICAgIF9fc2VuZF9fXG4gIGFsaWFzIHB1YmxpY19zZW5kIF9fc2VuZF9fXG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIGBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Moc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBzbGVlcChzZWNvbmRzID0gbmlsKVxuICAgICV4e1xuICAgICAgaWYgKHNlY29uZHMgPT09IG5pbCkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IE5pbENsYXNzIGludG8gdGltZSBpbnRlcnZhbFwifVxuICAgICAgfVxuICAgICAgaWYgKCFzZWNvbmRzLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWNvbmRzLmNsYXNzfSBpbnRvIHRpbWUgaW50ZXJ2YWxcIn1cbiAgICAgIH1cbiAgICAgIGlmIChzZWNvbmRzIDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd0aW1lIGludGVydmFsIG11c3QgYmUgcG9zaXRpdmUnfVxuICAgICAgfVxuICAgICAgdmFyIGdldF90aW1lID0gT3BhbC5nbG9iYWwucGVyZm9ybWFuY2UgP1xuICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCl9IDpcbiAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIG5ldyBEYXRlKCl9XG5cbiAgICAgIHZhciB0ID0gZ2V0X3RpbWUoKTtcbiAgICAgIHdoaWxlIChnZXRfdGltZSgpIC0gdCA8PSBzZWNvbmRzICogMTAwMCk7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChzZWNvbmRzKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzcmFuZChzZWVkID0gUmFuZG9tLm5ld19zZWVkKVxuICAgIFJhbmRvbS5zcmFuZChzZWVkKVxuICBlbmRcblxuICBkZWYgU3RyaW5nKHN0cilcbiAgICBPcGFsLmNvZXJjZV90bz8oc3RyLCBTdHJpbmcsIDp0b19zdHIpIHx8XG4gICAgICBPcGFsLmNvZXJjZV90byEoc3RyLCBTdHJpbmcsIDp0b19zKVxuICBlbmRcblxuICBkZWYgdGFwKCZibG9jaylcbiAgICB5aWVsZCBzZWxmXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiM8I3tzZWxmLmNsYXNzfToweCN7X19pZF9fLnRvX3MoMTYpfT5cIlxuICBlbmRcblxuICBkZWYgY2F0Y2goc3ltKVxuICAgIHlpZWxkXG4gIHJlc2N1ZSBVbmNhdWdodFRocm93RXJyb3IgPT4gZVxuICAgIHJldHVybiBlLmFyZyBpZiBlLnN5bSA9PSBzeW1cbiAgICByYWlzZVxuICBlbmRcblxuICBkZWYgdGhyb3coKmFyZ3MpXG4gICAgcmFpc2UgVW5jYXVnaHRUaHJvd0Vycm9yLCBhcmdzXG4gIGVuZFxuXG4gICMgYmFzaWMgaW1wbGVtZW50YXRpb24gb2Ygb3BlbiwgZGVsZWdhdGUgdG8gRmlsZS5vcGVuXG4gIGRlZiBvcGVuKCphcmdzLCAmYmxvY2spXG4gICAgRmlsZS5vcGVuKCphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB5aWVsZF9zZWxmXG4gICAgcmV0dXJuIGVudW1fZm9yKDp5aWVsZF9zZWxmKSB7IDEgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgeWllbGQgc2VsZlxuICBlbmRcblxuICBhbGlhcyB0aGVuIHlpZWxkX3NlbGZcblxuICBPcGFsLnByaXN0aW5lKHNlbGYsIDptZXRob2RfbWlzc2luZylcbmVuZFxuXG5jbGFzcyBPYmplY3RcbiAgaW5jbHVkZSBLZXJuZWxcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsIm1ldGhvZF9taXNzaW5nIiwicmFpc2UiLCJuZXciLCJzeW1ib2wiLCJpbnNwZWN0IiwiYXJncyIsIj1+IiwiIX4iLCJzZWxmIiwib2JqIiwiISIsIj09PSIsIiRyZXRfb3JfMSIsIm9iamVjdF9pZCIsIj09Iiwib3RoZXIiLCI8PT4iLCJtZXRob2QiLCJuYW1lIiwiY2xhc3MiLCJtZXRob2RzIiwiYWxsIiwicHVibGljX21ldGhvZHMiLCJBcnJheSIsImNvZXJjZV90bz8iLCJvYmplY3QiLCJhdF9leGl0IiwiJF9fYXRfZXhpdF9fIiwiJHJldF9vcl8yIiwiPDwiLCJibG9jayIsImNhbGxlciIsIjEiLCJjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyIsImNvcHlfc2luZ2xldG9uX21ldGhvZHMiLCJjbG9uZSIsImNvcHkiLCJhbGxvY2F0ZSIsImluaXRpYWxpemVfY2xvbmUiLCJpbml0aWFsaXplX2NvcHkiLCJkZWZpbmVfc2luZ2xldG9uX21ldGhvZCIsImRlZmluZV9tZXRob2QiLCJzaW5nbGV0b25fY2xhc3MiLCJkdXAiLCJpbml0aWFsaXplX2R1cCIsImVudW1fZm9yIiwiZm9yIiwiZXF1YWw/IiwiZXhpdCIsIiRyZXRfb3JfMyIsImVtcHR5PyIsInBvcCIsImNhbGwiLCJleHRlbmQiLCJhcHBlbmRfZmVhdHVyZXMiLCJleHRlbmRfb2JqZWN0IiwiZXh0ZW5kZWQiLCJoYXNoIiwiX19pZF9fIiwidG9fcyIsImluc3RhbmNlX29mPyIsImluc3RhbmNlX3ZhcmlhYmxlX2RlZmluZWQ/IiwiaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEiLCJpbnN0YW5jZV92YXJpYWJsZV9nZXQiLCJpbnN0YW5jZV92YXJpYWJsZV9zZXQiLCJyZW1vdmVfaW5zdGFuY2VfdmFyaWFibGUiLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJJbnRlZ2VyIiwidmFsdWUiLCJyZXNwb25kX3RvPyIsInRvX2ludCIsImNvZXJjZV90byEiLCJiYXNlIiwiRmxvYXQiLCJIYXNoIiwiJHJldF9vcl80IiwiYXJnIiwibmlsPyIsImlzX2E/IiwiaXRzZWxmIiwibGFtYmRhIiwibG9hZCIsImZpbGUiLCJsb29wIiwiYmxvY2tfZ2l2ZW4/IiwiZSIsInJlc3VsdCIsInByaW50ZiIsImFueT8iLCJwcmludCIsImZvcm1hdCIsInByb2MiLCJwdXRzIiwiJHN0ZG91dCIsInN0cnMiLCJwIiwiZWFjaCIsIjw9IiwibGVuZ3RoIiwiW10iLCIwIiwid2FybiIsInVwbGV2ZWwiLCI8IiwibG9jYXRpb24iLCIrIiwiMiIsImZpcnN0IiwibWFwIiwicyIsIiRyZXRfb3JfNSIsIiRWRVJCT1NFIiwiJHN0ZGVyciIsIiQhIiwiZXhjZXB0aW9uIiwic3RyaW5nIiwicmFuZCIsIm1heCIsInJlc3BvbmRfdG9fbWlzc2luZz8iLCJpbmNsdWRlX2FsbCIsInByaXN0aW5lIiwicmVxdWlyZSIsInJlcXVpcmVfcmVsYXRpdmUiLCJ0cnlfY29udmVydCEiLCJleHBhbmRfcGF0aCIsImpvaW4iLCJyZXF1aXJlX3RyZWUiLCJwYXRoIiwic3RhcnRfd2l0aD8iLCJzbGVlcCIsInNlY29uZHMiLCJzcmFuZCIsIm5ld19zZWVkIiwic2VlZCIsIlN0cmluZyIsIiRyZXRfb3JfNiIsInN0ciIsInRhcCIsInRvX3Byb2MiLCIxNiIsImNhdGNoIiwic3ltIiwidGhyb3ciLCJvcGVuIiwieWllbGRfc2VsZiIsImluY2x1ZGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUVBLEVBQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRTtBQUFBQyxJQUFBQSxrQ0FBQUEsMkJBQUFBLDBCQUFtQixNQUFELEVBSnBCLEVBSUVBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQUpGO0FBSW9DLE1BQUEsK0NBSnBDO0FBQUE7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUFJNkIsTUFBQSxrQkFKN0I7QUFBQSxNQUtJLFdBQUFDLE9BQUFBLENBQU0sNkJBQUFDLEtBQUFBLENBQWtCLEVBQUEsR0FBQSxvQkFBQSxHQUFBLENBQXFCQyxNQUFyQixDQUFBLEdBQUEsUUFBQSxHQUFBLEtBQW9DQyxTQUFBQSxDQUFBQSxDQUFwQyxHQUErQ0QsUUFBUUUsSUFBekVILENBQU5ELENBTEo7QUFJRUQsSUFBQUEsQ0FBQUEsdUNBQUFBLENBQUE7QUFBQTtBQUlBTSxJQUFBQSxzQkFBQUEsc0JBQUFBLFNBQU8sR0FBUEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQTtBQURGQSxJQUFBQSxDQUFBQSxpQ0FBQUEsQ0FKQTtBQUFBO0FBUUFDLElBQUFBLHNCQUFBQSx3QkFBQUEsU0FBTyxHQUFQQTtBQUFB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QUFBLENBQUFBLG1DQUFBQSxDQTlyQkE7QUFBQSxJQW1zQkEsaUJBQU0sTUFBTixFQUFXLFlBQVgsQ0Fuc0JBO0FBQUEsSUFxc0JBLG9CQUFBeEIsVUFBQUEsQ0FBY2hILE1BQU0sZ0JBQXBCZ0gsQ0Fyc0JBO0FBREZ6SCxFQUFBQSxHQUFBQSxXQUFBQSxXQUFBO0FBQUEsRUF5c0JBLE9BQUFvQjtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0UsV0FBQThILFNBQUFBLENBQVEsc0JBQVJBO0FBREY5SCxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQXpzQkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo1MTUxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lcnJvci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBFeGNlcHRpb24gPCBgRXJyb3JgXG4gICMgYHZhciBLZXJuZWwkcmFpc2UgPSAje0tlcm5lbH0uJHJhaXNlYFxuICBgdmFyIHN0YWNrX3RyYWNlX2xpbWl0YFxuXG4gIGRlZiBzZWxmLm5ldygqYXJncylcbiAgICAleHtcbiAgICAgIHZhciBtZXNzYWdlICAgPSAoYXJncy5sZW5ndGggPiAwKSA/IGFyZ3NbMF0gOiBuaWw7XG4gICAgICB2YXIgZXJyb3IgICAgID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcihtZXNzYWdlKTtcbiAgICAgIGVycm9yLm5hbWUgICAgPSBzZWxmLiQkbmFtZTtcbiAgICAgIGVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgT3BhbC5zZW5kKGVycm9yLCBlcnJvci4kaW5pdGlhbGl6ZSwgYXJncyk7XG5cbiAgICAgIC8vIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKCkgd2lsbCB1c2UgLm5hbWUgYW5kIC50b1N0cmluZyB0byBidWlsZCB0aGVcbiAgICAgIC8vIGZpcnN0IGxpbmUgb2YgdGhlIHN0YWNrIHRyYWNlIHNvIGl0IG11c3QgYmUgY2FsbGVkIGFmdGVyIHRoZSBlcnJvclxuICAgICAgLy8gaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAgICAvLyBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjYueC9kb2NzL2FwaS9lcnJvcnMuaHRtbFxuICAgICAgaWYgKE9wYWwuY29uZmlnLmVuYWJsZV9zdGFja190cmFjZSAmJiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAvLyBQYXNzaW5nIEtlcm5lbC5yYWlzZSB3aWxsIGN1dCB0aGUgc3RhY2sgdHJhY2UgZnJvbSB0aGF0IHBvaW50IGFib3ZlXG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yLCBzdGFja190cmFjZV9saW1pdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gIGVuZFxuICBgc3RhY2tfdHJhY2VfbGltaXQgPSBzZWxmLiRuZXdgXG5cbiAgZGVmIHNlbGYuZXhjZXB0aW9uKCphcmdzKVxuICAgIG5ldygqYXJncylcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoKmFyZ3MpXG4gICAgIyB1c2luZyBzZWxmLm1lc3NhZ2UgYWthIEBtZXNzYWdlIHRvIHJldGFpbiBjb21wYXRpYmlsaXR5IHdpdGggbmF0aXZlIGV4Y2VwdGlvbidzIG1lc3NhZ2UgcHJvcGVydHlcbiAgICBgc2VsZi5tZXNzYWdlID0gKGFyZ3MubGVuZ3RoID4gMCkgPyBhcmdzWzBdIDogbmlsYFxuICBlbmRcblxuICBkZWYgYmFja3RyYWNlXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi5iYWNrdHJhY2UpIHtcbiAgICAgICAgLy8gbmlsIGlzIGEgdmFsaWQgYmFja3RyYWNlXG4gICAgICAgIHJldHVybiBzZWxmLmJhY2t0cmFjZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJhY2t0cmFjZSA9IHNlbGYuc3RhY2s7XG5cbiAgICAgIGlmICh0eXBlb2YoYmFja3RyYWNlKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGJhY2t0cmFjZS5zcGxpdChcIlxcblwiKS5zbGljZSgwLCAxNSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChiYWNrdHJhY2UpIHtcbiAgICAgICAgcmV0dXJuIGJhY2t0cmFjZS5zbGljZSgwLCAxNSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBleGNlcHRpb24oc3RyID0gbmlsKVxuICAgICV4e1xuICAgICAgaWYgKHN0ciA9PT0gbmlsIHx8IHNlbGYgPT09IHN0cikge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsb25lZCA9ICN7Y2xvbmV9O1xuICAgICAgY2xvbmVkLm1lc3NhZ2UgPSBzdHI7XG4gICAgICBjbG9uZWQuc3RhY2sgPSBzZWxmLnN0YWNrO1xuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG4gIGVuZFxuXG4gICMgbm90IHVzaW5nIGFsaWFzIG1lc3NhZ2UgdG9fcyBiZWNhdXNlIHlvdSBuZWVkIHRvIGJlIGFibGUgdG8gb3ZlcnJpZGUgdG9fcyBhbmQgaGF2ZSBtZXNzYWdlIHVzZSBvdmVycmlkZGVuIG1ldGhvZCwgd29uJ3Qgd29yayB3aXRoIGFsaWFzXG4gIGRlZiBtZXNzYWdlXG4gICAgdG9fc1xuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIGFzX3N0ciA9IHRvX3NcbiAgICBhc19zdHIuZW1wdHk/ID8gc2VsZi5jbGFzcy50b19zIDogXCIjPCN7c2VsZi5jbGFzcy50b19zfTogI3t0b19zfT5cIlxuICBlbmRcblxuICBkZWYgc2V0X2JhY2t0cmFjZShiYWNrdHJhY2UpXG4gICAgJXh7XG4gICAgICB2YXIgdmFsaWQgPSB0cnVlLCBpLCBpaTtcblxuICAgICAgaWYgKGJhY2t0cmFjZSA9PT0gbmlsKSB7XG4gICAgICAgIHNlbGYuYmFja3RyYWNlID0gbmlsO1xuICAgICAgICBzZWxmLnN0YWNrID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKGJhY2t0cmFjZS4kJGlzX3N0cmluZykge1xuICAgICAgICBzZWxmLmJhY2t0cmFjZSA9IFtiYWNrdHJhY2VdO1xuICAgICAgICBzZWxmLnN0YWNrID0gYmFja3RyYWNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJhY2t0cmFjZS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBiYWNrdHJhY2UubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFiYWNrdHJhY2VbaV0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdiYWNrdHJhY2UgbXVzdCBiZSBBcnJheSBvZiBTdHJpbmcnfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5iYWNrdHJhY2UgPSBiYWNrdHJhY2U7XG4gICAgICAgIHNlbGYuc3RhY2sgPSBiYWNrdHJhY2Uuam9pbignXFxuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYWNrdHJhY2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgICMgdXNpbmcgc2VsZi5tZXNzYWdlIGFrYSBAbWVzc2FnZSB0byByZXRhaW4gY29tcGF0aWJpbGl0eSB3aXRoIG5hdGl2ZSBleGNlcHRpb24ncyBtZXNzYWdlIHByb3BlcnR5XG4gICAgKEBtZXNzYWdlICYmIEBtZXNzYWdlLnRvX3MpIHx8IHNlbGYuY2xhc3MudG9fc1xuICBlbmRcbmVuZFxuXG4jIGtlZXAgdGhlIGluZGVudGF0aW9uLCBpdCBtYWtlcyB0aGUgZXhjZXB0aW9uIGhpZXJhcmNoeSBjbGVhclxuY2xhc3MgU2NyaXB0RXJyb3IgICAgICAgPCBFeGNlcHRpb247IGVuZFxuY2xhc3MgU3ludGF4RXJyb3IgICAgICAgICA8IFNjcmlwdEVycm9yOyBlbmRcbmNsYXNzIExvYWRFcnJvciAgICAgICAgICAgPCBTY3JpcHRFcnJvcjsgZW5kXG5jbGFzcyBOb3RJbXBsZW1lbnRlZEVycm9yIDwgU2NyaXB0RXJyb3I7IGVuZFxuXG5jbGFzcyBTeXN0ZW1FeGl0ICAgICAgICA8IEV4Y2VwdGlvbjsgZW5kXG5jbGFzcyBOb01lbW9yeUVycm9yICAgICA8IEV4Y2VwdGlvbjsgZW5kXG5jbGFzcyBTaWduYWxFeGNlcHRpb24gICA8IEV4Y2VwdGlvbjsgZW5kXG5jbGFzcyBJbnRlcnJ1cHQgICAgICAgICA8IEV4Y2VwdGlvbjsgZW5kXG5jbGFzcyBTZWN1cml0eUVycm9yICAgICA8IEV4Y2VwdGlvbjsgZW5kXG5cbmNsYXNzIFN0YW5kYXJkRXJyb3IgICAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIEVuY29kaW5nRXJyb3IgICAgICAgPCBTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIFplcm9EaXZpc2lvbkVycm9yICAgPCBTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIE5hbWVFcnJvciAgICAgICAgICAgPCBTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIE5vTWV0aG9kRXJyb3IgICAgICAgICA8IE5hbWVFcnJvcjsgZW5kXG5jbGFzcyBSdW50aW1lRXJyb3IgICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBGcm96ZW5FcnJvciAgICAgICAgICAgPCBSdW50aW1lRXJyb3I7IGVuZFxuY2xhc3MgTG9jYWxKdW1wRXJyb3IgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgVHlwZUVycm9yICAgICAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgQXJndW1lbnRFcnJvciAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgSW5kZXhFcnJvciAgICAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgU3RvcEl0ZXJhdGlvbiAgICAgICAgIDwgSW5kZXhFcnJvcjsgZW5kXG5jbGFzcyBLZXlFcnJvciAgICAgICAgICAgICAgPCBJbmRleEVycm9yOyBlbmRcbmNsYXNzIFJhbmdlRXJyb3IgICAgICAgICAgPCBTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIEZsb2F0RG9tYWluRXJyb3IgICAgICA8IFJhbmdlRXJyb3I7IGVuZFxuY2xhc3MgSU9FcnJvciAgICAgICAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgU3lzdGVtQ2FsbEVycm9yICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuXG5tb2R1bGUgRXJybm9cbiAgY2xhc3MgRUlOVkFMICAgICAgICAgICAgICA8IFN5c3RlbUNhbGxFcnJvclxuICAgIGRlZiBzZWxmLm5ldyhuYW1lID0gbmlsKVxuICAgICAgbWVzc2FnZSA9ICdJbnZhbGlkIGFyZ3VtZW50J1xuICAgICAgbWVzc2FnZSArPSBcIiAtICN7bmFtZX1cIiBpZiBuYW1lXG4gICAgICBzdXBlcihtZXNzYWdlKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyBVbmNhdWdodFRocm93RXJyb3IgPCBBcmd1bWVudEVycm9yXG4gIGF0dHJfcmVhZGVyIDpzeW0sIDphcmdcblxuICBkZWYgaW5pdGlhbGl6ZShhcmdzKVxuICAgIEBzeW0gPSBhcmdzWzBdXG4gICAgQGFyZyA9IGFyZ3NbMV0gaWYgYXJncy5sZW5ndGggPiAxXG5cbiAgICBzdXBlcihcInVuY2F1Z2h0IHRocm93ICN7QHN5bS5pbnNwZWN0fVwiKVxuICBlbmRcbmVuZFxuXG5jbGFzcyBOYW1lRXJyb3JcbiAgYXR0cl9yZWFkZXIgOm5hbWVcblxuICBkZWYgaW5pdGlhbGl6ZShtZXNzYWdlLCBuYW1lID0gbmlsKVxuICAgIHN1cGVyIG1lc3NhZ2VcbiAgICBAbmFtZSA9IG5hbWVcbiAgZW5kXG5lbmRcblxuY2xhc3MgTm9NZXRob2RFcnJvclxuICBhdHRyX3JlYWRlciA6YXJnc1xuXG4gIGRlZiBpbml0aWFsaXplKG1lc3NhZ2UsIG5hbWUgPSBuaWwsIGFyZ3MgPSBbXSlcbiAgICBzdXBlciBtZXNzYWdlLCBuYW1lXG4gICAgQGFyZ3MgPSBhcmdzXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFN0b3BJdGVyYXRpb25cbiAgYXR0cl9yZWFkZXIgOnJlc3VsdFxuZW5kXG5cbmNsYXNzIEtleUVycm9yXG4gIGRlZiBpbml0aWFsaXplKG1lc3NhZ2UsIHJlY2VpdmVyOiBuaWwsIGtleTogbmlsKVxuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgQHJlY2VpdmVyID0gcmVjZWl2ZXJcbiAgICBAa2V5ID0ga2V5XG4gIGVuZFxuXG4gIGRlZiByZWNlaXZlclxuICAgIEByZWNlaXZlciB8fCByYWlzZShBcmd1bWVudEVycm9yLCAnbm8gcmVjZWl2ZXIgaXMgYXZhaWxhYmxlJylcbiAgZW5kXG5cbiAgZGVmIGtleVxuICAgIEBrZXkgfHwgcmFpc2UoQXJndW1lbnRFcnJvciwgJ25vIGtleSBpcyBhdmFpbGFibGUnKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgSlNcbiAgY2xhc3MgRXJyb3JcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsIm5ldyIsInNlbGYiLCJleGNlcHRpb24iLCJhcmdzIiwiaW5pdGlhbGl6ZSIsImJhY2t0cmFjZSIsImNsb25lIiwibWVzc2FnZSIsInRvX3MiLCJpbnNwZWN0IiwiYXNfc3RyIiwiZW1wdHk/Iiwic2V0X2JhY2t0cmFjZSIsInJhaXNlIiwiJHJldF9vcl8xIiwiJHJldF9vcl8yIiwiQG1lc3NhZ2UiLCJtb2R1bGUiLCJuYW1lIiwiKyIsImF0dHJfcmVhZGVyIiwiQHN5bSIsIltdIiwiMCIsIj4iLCJsZW5ndGgiLCIxIiwiQGFyZyIsIkBuYW1lIiwiQGFyZ3MiLCJAcmVjZWl2ZXIiLCJyZWNlaXZlciIsIkBrZXkiLCJrZXkiLCIkcmV0X29yXzMiLCIkcmV0X29yXzQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLEVBQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFBQUE7QUFFRSxJQUFDLHFCQUFE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T0FBQUEsQ0FBTSwrQkFBZSwwQkFBckJBO0FBQWIsTUFBQTtBQURGa0IsSUFBQUEsQ0FBQUEsbUNBQUFBLENBTkE7QUFBQSxJQVVBLE9BQUFFLENBQUFBLHVCQUFBQSxtQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsSUFBQSxRQTVNSkUsQ0FBQUEsWUE0TUlILFFBNU1KRyxDQTRNSSxDQUFBO0FBQUEsUUE1TUosT0FBQTtBQTRNSSxNQUFBO0FBQUEsUUFBUSxXQUFBdEIsT0FBQUEsQ0FBTSwrQkFBZSxxQkFBckJBO0FBQVIsTUFBQTtBQURGb0IsSUFBQUEsQ0FBQUEsOEJBQUFBLENBQUFBLGVBVkE7QUFERmxDLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBL0xBO0FBQUEsRUErTUEsT0FBQWtCO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRWxCO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUE7QUFBQUEsSUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFERmtCLEVBQUFBLEdBQUFBLFdBQUFBLFdBL01BOzsifX0seyJvZmZzZXQiOnsibGluZSI6NTY3NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvY29uc3RhbnRzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIlJVQllfUExBVEZPUk0gICAgICAgPSAnb3BhbCdcblJVQllfRU5HSU5FICAgICAgICAgPSAnb3BhbCdcblJVQllfVkVSU0lPTiAgICAgICAgPSAnMy4wLjAnXG5SVUJZX0VOR0lORV9WRVJTSU9OID0gJzEuMS4xJ1xuUlVCWV9SRUxFQVNFX0RBVEUgICA9ICcyMDIxLTAyLTIzJ1xuUlVCWV9QQVRDSExFVkVMICAgICA9IDBcblJVQllfUkVWSVNJT04gICAgICAgPSAnMCdcblJVQllfQ09QWVJJR0hUICAgICAgPSAnb3BhbCAtIENvcHlyaWdodCAoQykgMjAxMy0yMDIxIEFkYW0gQmV5bm9uIGFuZCB0aGUgT3BhbCBjb250cmlidXRvcnMnXG5SVUJZX0RFU0NSSVBUSU9OICAgID0gXCJvcGFsICN7UlVCWV9FTkdJTkVfVkVSU0lPTn0gKCN7UlVCWV9SRUxFQVNFX0RBVEV9IHJldmlzaW9uICN7UlVCWV9SRVZJU0lPTn0pXCJcbiJdLCJuYW1lcyI6WyIwIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBLEVBQUEsNkNBQXNCLE1BQXRCLENBQUE7QUFBQSxFQUNBLDJDQUFzQixNQUF0QixDQURBO0FBQUEsRUFFQSw0Q0FBc0IsT0FBdEIsQ0FGQTtBQUFBLEVBR0EsbURBQXNCLE9BQXRCLENBSEE7QUFBQSxFQUlBLGlEQUFzQixZQUF0QixDQUpBO0FBQUEsRUFLQSwrQ0FBc0JBLENBQXRCLENBTEE7QUFBQSxFQU1BLDZDQUFzQixHQUF0QixDQU5BO0FBQUEsRUFPQSw4Q0FBc0Isc0VBQXRCLENBUEE7QUFBQSxFQVFBLE9BQUEsZ0RBQXNCLEVBQUEsR0FBQSxPQUFBLEdBQUEsQ0FBUSxtQ0FBUixDQUFBLEdBQUEsSUFBQSxHQUFBLENBQWdDLGlDQUFoQyxDQUFBLEdBQUEsWUFBQSxHQUFBLENBQThELDZCQUE5RCxDQUFBLEdBQUEsR0FBdEIsQ0FSQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjU2OTIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGFsL2Jhc2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9ydW50aW1lJ1xucmVxdWlyZSAnY29yZWxpYi9oZWxwZXJzJ1xucmVxdWlyZSAnY29yZWxpYi9tb2R1bGUnXG5yZXF1aXJlICdjb3JlbGliL2NsYXNzJ1xucmVxdWlyZSAnY29yZWxpYi9iYXNpY19vYmplY3QnXG5yZXF1aXJlICdjb3JlbGliL2tlcm5lbCdcbnJlcXVpcmUgJ2NvcmVsaWIvZXJyb3InXG5cbnJlcXVpcmUgJ2NvcmVsaWIvY29uc3RhbnRzJ1xuIl0sIm5hbWVzIjpbInJlcXVpcmUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsaUJBQVJBLENBQUE7QUFBQSxNQUNBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQURBO0FBQUEsTUFFQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FGQTtBQUFBLE1BR0FBLFNBQUFBLENBQVEsZUFBUkEsQ0FIQTtBQUFBLE1BSUFBLFNBQUFBLENBQVEsc0JBQVJBLENBSkE7QUFBQSxNQUtBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQUxBO0FBQUEsTUFNQUEsU0FBQUEsQ0FBUSxlQUFSQSxDQU5BO0FBQUEsRUFRQSxXQUFBQSxTQUFBQSxDQUFRLG1CQUFSQSxDQVJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6NTcwOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbmlsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIE5pbENsYXNzXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkbWV0YSA9ICN7c2VsZn1gXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuICBlbmRcblxuICBkZWYgIVxuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmICYob3RoZXIpXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgYG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsYFxuICBlbmRcblxuICBkZWYgXihvdGhlcilcbiAgICBgb3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWxgXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgb3RoZXIgPT09IG5pbGBcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgICduaWwnXG4gIGVuZFxuXG4gIGRlZiBuaWw/XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX2NsYXNzXG4gICAgTmlsQ2xhc3NcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBbXVxuICBlbmRcblxuICBkZWYgdG9faFxuICAgIGBPcGFsLmhhc2goKWBcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICAwXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2YgdG9faVxuXG4gIGRlZiB0b19zXG4gICAgJydcbiAgZW5kXG5cbiAgZGVmIHRvX2NcbiAgICBDb21wbGV4Lm5ldygwLCAwKVxuICBlbmRcblxuICBkZWYgcmF0aW9uYWxpemUoKmFyZ3MpXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciBpZiBhcmdzLmxlbmd0aCA+IDFcbiAgICBSYXRpb25hbCgwLCAxKVxuICBlbmRcblxuICBkZWYgdG9fclxuICAgIFJhdGlvbmFsKDAsIDEpXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICBbXVxuICBlbmRcbmVuZFxuXG5OSUwgPSBuaWxcbiJdLCJuYW1lcyI6WyJjbGFzcyIsInNlbGYiLCJhbGxvY2F0ZSIsInJhaXNlIiwibmFtZSIsIiEiLCImIiwifCIsIl4iLCI9PSIsImR1cCIsImNsb25lIiwiaW5zcGVjdCIsIm5pbD8iLCJzaW5nbGV0b25fY2xhc3MiLCJ0b19hIiwidG9faCIsInRvX2kiLCIwIiwidG9fcyIsInRvX2MiLCJuZXciLCJyYXRpb25hbGl6ZSIsIj4iLCJhcmdzIiwibGVuZ3RoIiwiMSIsIlJhdGlvbmFsIiwidG9fciIsImluc3RhbmNlX3ZhcmlhYmxlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUMsMEJBQTRCQyxJQUE3QjtBQUFBLElBRUE7QUFBQSxNQUFBOztBQUFBO0FBQ0U7QUFBQUMsTUFBQUEsNEJBQUFBLGNBQUFB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RUFDLElBQUFBLHdCQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsdUJBQUFDLEtBQUFBLENBQVlILEdBQUdBLENBQWZHO0FBREZELElBQUFBLENBQUFBLCtCQUFBQSxDQXBFQTtBQUFBO0FBd0VBRSxJQUFBQSwrQkFBQUEsMkJBQUFBLHVCQTFFRixFQTBFRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBMUVGO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBMEVrQixNQUFBLGtCQTFFbEI7QUFBQSxNQTJFSSxJQUFBLFFBQXVCQyxPQUFBQyxJQUFBQyxRQUFBQSxDQUFBQSxDQUFBRixFQUFjRyxDQUFkSCxDQUF2QixDQUFBO0FBQUEsWUFBQXBCLE9BQUFBLENBQU0sNkJBQU5BLENBQUEsQ0EzRUo7QUFBQSxNQTRFSSxXQUFBd0IsVUFBQUEsQ0FBU1QsR0FBR1EsQ0FBWkMsQ0E1RUo7QUEwRUVMLElBQUFBLENBQUFBLHVDQUFBQSxDQXhFQTtBQUFBO0FBNkVBTSxJQUFBQSx3QkFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxXQUFBRCxVQUFBQSxDQUFTVCxHQUFHUSxDQUFaQztBQURGQyxJQUFBQSxDQUFBQSwrQkFBQUEsQ0E3RUE7QUFBQSxJQWlGQSxPQUFBQyxDQUFBQSxzQ0FBQUEsa0NBQUFBLDhCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBO0FBREZBLElBQUFBLENBQUFBLDZDQUFBQSxDQUFBQSw4QkFqRkE7QUFERjdCLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBQUE7QUFBQSxFQXVGQSxPQUFBLG1DQUFNLEdBQU4sQ0F2RkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo1ODcwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9ib29sZWFuLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEJvb2xlYW4gPCBgQm9vbGVhbmBcbiAgYE9wYWwuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfYm9vbGVhbicsIHRydWUpYFxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCAnJCRtZXRhJywgI3tzZWxmfSlgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuICBlbmRcblxuICBkZWYgX19pZF9fXG4gICAgYHNlbGYudmFsdWVPZigpID8gMiA6IDBgXG4gIGVuZFxuXG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cblxuICBkZWYgIVxuICAgIGBzZWxmICE9IHRydWVgXG4gIGVuZFxuXG4gIGRlZiAmKG90aGVyKVxuICAgIGAoc2VsZiA9PSB0cnVlKSA/IChvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbCkgOiBmYWxzZWBcbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID8gdHJ1ZSA6IChvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbClgXG4gIGVuZFxuXG4gIGRlZiBeKG90aGVyKVxuICAgIGAoc2VsZiA9PSB0cnVlKSA/IChvdGhlciA9PT0gZmFsc2UgfHwgb3RoZXIgPT09IG5pbCkgOiAob3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWwpYFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID09PSBvdGhlci52YWx1ZU9mKClgXG4gIGVuZFxuXG4gIGFsaWFzIGVxdWFsPyA9PVxuICBhbGlhcyBlcWw/ID09XG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIEJvb2xlYW5cbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPyAndHJ1ZScgOiAnZmFsc2UnYFxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIHNlbGZcbiAgZW5kXG5lbmRcblxuVHJ1ZUNsYXNzICA9IEJvb2xlYW5cbkZhbHNlQ2xhc3MgPSBCb29sZWFuXG5cblRSVUUgID0gdHJ1ZVxuRkFMU0UgPSBmYWxzZVxuIl0sIm5hbWVzIjpbImNsYXNzIiwic2VsZiIsImFsbG9jYXRlIiwicmFpc2UiLCJuYW1lIiwiX19pZF9fIiwiISIsIiYiLCJ8IiwiXiIsIj09Iiwic2luZ2xldG9uX2NsYXNzIiwidG9fcyIsImR1cCIsImNsb25lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxFQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQywyREFBRDtBQUFBLElBQ0MsZ0RBQWtEQyxJQUFLLENBRHhEO0FBQUEsSUFHQTtBQUFBLE1BQUE7O0FBQUE7QUFDRTtBQUFBQyxNQUFBQSw0QkFBQUEsY0FBQUEsb0JBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLFdBQUFDLE9BQUFBLENBQU0sMkJBQVcsRUFBQSxHQUFBLDBCQUFBLEdBQUEsS0FBMkJDLE1BQUFBLENBQUFBLENBQTNCLENBQWpCRDtBQURGRCxNQUFBQSxDQUFBQSx5QkFBQUEsQ0FBQTtBQUFBOztBQUlBLE1BQUEsc0JBQU0sS0FBTjtpQkFKQTtBQURGLElBQUEsNEJBQVNELElBQVQsWUFIQTtBQUFBO0FBV0FJLElBQUFBLDBCQUFBQSxvQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsc0JBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBWEE7QUFBQSxJQWVBLGlCQUFNLFdBQU4sRUFBZ0IsUUFBaEIsQ0FmQTtBQUFBO0FBaUJBQyxJQUFBQSxxQkFBQUEsbUJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsWUFBRDtBQURGQSxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FqQkE7QUFBQTtBQXFCQUMsSUFBQUEscUJBQUFBLGVBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQywyREFBRDtBQURGQSxJQUFBQSxDQUFBQSwwQkFBQUEsQ0FyQkE7QUFBQTtBQXlCQUMsSUFBQUEscUJBQUFBLGVBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQywwREFBRDtBQURGQSxJQUFBQSxDQUFBQSwwQkFBQUEsQ0F6QkE7QUFBQTtBQTZCQUMsSUFBQUEscUJBQUFBLGVBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyx3RkFBRDtBQURGQSxJQUFBQSxDQUFBQSwwQkFBQUEsQ0E3QkE7QUFBQTtBQWlDQUMsSUFBQUEsc0JBQUFBLG9CQUFBQSxTQUFPLEtBQVBBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsa0NBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBakNBO0FBQUEsSUFxQ0EsaUJBQU0sUUFBTixFQUFhLElBQWIsQ0FyQ0E7QUFBQSxJQXNDQSxpQkFBTSxNQUFOLEVBQVcsSUFBWCxDQXRDQTtBQUFBO0FBd0NBQyxJQUFBQSxtQ0FBQUEsNkJBQUFBLDJCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBO0FBREZBLElBQUFBLENBQUFBLHdDQUFBQSxDQXhDQTtBQUFBO0FBNENBQyxJQUFBQSx3QkFBQUEsa0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFDLGlDQUFEO0FBREZBLElBQUFBLENBQUFBLDZCQUFBQSxDQTVDQTtBQUFBO0FBZ0RBQyxJQUFBQSx1QkFBQUEsa0JBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFaO0FBREZZLElBQUFBLENBQUFBLDZCQUFBQSxDQWhEQTtBQUFBLElBb0RBLE9BQUFDLENBQUFBLHlCQUFBQSxvQkFBQUEsaUJBdERGLE9Bc0RFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUF0REY7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxDQUFBO0FBQUE7QUFzRFksTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBLFdBQVE7QUFBUixNQUFBLENBdERaO0FBQUEsTUF1REksT0FBQWIsSUF2REo7QUFzREVhLElBQUFBLENBQUFBLGdDQUFBQSxDQUFBQSxpQkFwREE7QUFERmQsRUFBQUEsR0FBQUEsV0FBQUEsRUFBaUIsT0FBakJBLFdBQUE7QUFBQSxFQTBEQSx5Q0FBYSx1QkFBYixDQTFEQTtBQUFBLEVBMkRBLDBDQUFhLHVCQUFiLENBM0RBO0FBQUEsRUE2REEsb0NBQVEsSUFBUixDQTdEQTtBQUFBLEVBOERBLE9BQUEscUNBQVEsS0FBUixDQTlEQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjU5ODAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbXBhcmFibGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBmYWxzeVxuXG5tb2R1bGUgQ29tcGFyYWJsZVxuICAleHtcbiAgICBmdW5jdGlvbiBub3JtYWxpemUod2hhdCkge1xuICAgICAgaWYgKE9wYWwuaXNfYSh3aGF0LCBPcGFsLkludGVnZXIpKSB7IHJldHVybiB3aGF0OyB9XG5cbiAgICAgIGlmICgje2B3aGF0YCA+IDB9KSB7IHJldHVybiAxOyB9XG4gICAgICBpZiAoI3tgd2hhdGAgPCAwfSkgeyByZXR1cm4gLTE7IH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZhaWxfY29tcGFyaXNvbihsaHMsIHJocykge1xuICAgICAgdmFyIGNsYXNzX25hbWU7XG4gICAgICAje1xuICAgICAgICBjYXNlIGByaHNgXG4gICAgICAgIHdoZW4gbmlsLCB0cnVlLCBmYWxzZSwgSW50ZWdlciwgRmxvYXRcbiAgICAgICAgICBgY2xhc3NfbmFtZSA9IHJocy4kaW5zcGVjdCgpYFxuICAgICAgICBlbHNlXG4gICAgICAgICAgYGNsYXNzX25hbWUgPSByaHMuJCRjbGFzc2BcbiAgICAgICAgZW5kXG4gICAgICB9XG4gICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje2BsaHNgLmNsYXNzfSB3aXRoICN7YGNsYXNzX25hbWVgfSBmYWlsZWRcIn1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbXBfb3JfZmFpbChsaHMsIHJocykge1xuICAgICAgdmFyIGNtcCA9ICN7YGxoc2AgPD0+IGByaHNgfTtcbiAgICAgIGlmICgkZmFsc3koY21wKSkgZmFpbF9jb21wYXJpc29uKGxocywgcmhzKTtcbiAgICAgIHJldHVybiBub3JtYWxpemUoY21wKTtcbiAgICB9XG4gIH1cblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIHRydWUgaWYgZXF1YWw/KG90aGVyKVxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZltcIiQ8PT5cIl0gPT0gT3BhbC5LZXJuZWxbXCIkPD0+XCJdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgZm9yIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgaWYgKHNlbGYuJCRjb21wYXJhYmxlKSB7XG4gICAgICAgIGRlbGV0ZSBzZWxmLiQkY29tcGFyYWJsZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgY21wID0gKHNlbGYgPD0+IG90aGVyKVxuXG4gICAgYG5vcm1hbGl6ZShjbXApID09IDBgXG4gIGVuZFxuXG4gIGRlZiA+KG90aGVyKVxuICAgIGBjbXBfb3JfZmFpbChzZWxmLCBvdGhlcikgPiAwYFxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgYGNtcF9vcl9mYWlsKHNlbGYsIG90aGVyKSA+PSAwYFxuICBlbmRcblxuICBkZWYgPChvdGhlcilcbiAgICBgY21wX29yX2ZhaWwoc2VsZiwgb3RoZXIpIDwgMGBcbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgIGBjbXBfb3JfZmFpbChzZWxmLCBvdGhlcikgPD0gMGBcbiAgZW5kXG5cbiAgZGVmIGJldHdlZW4/KG1pbiwgbWF4KVxuICAgIHJldHVybiBmYWxzZSBpZiBzZWxmIDwgbWluXG4gICAgcmV0dXJuIGZhbHNlIGlmIHNlbGYgPiBtYXhcbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBjbGFtcChtaW4sIG1heCA9IG5pbClcbiAgICAleHtcbiAgICAgIHZhciBjLCBleGNsO1xuXG4gICAgICBpZiAobWF4ID09PSBuaWwpIHtcbiAgICAgICAgLy8gV2UgYXJlIGRlYWxpbmcgd2l0aCBhIG5ldyBSdWJ5IDIuNyBiZWhhdmlvdXIgdGhhdCB3ZSBhcmUgYWJsZSB0b1xuICAgICAgICAvLyBwcm92aWRlIGEgc2luZ2xlIFJhbmdlIGFyZ3VtZW50IGluc3RlYWQgb2YgMiBDb21wYXJhYmxlcy5cblxuICAgICAgICBpZiAoIU9wYWwuaXNfYShtaW4sIE9wYWwuUmFuZ2UpKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje21pbi5jbGFzc30gKGV4cGVjdGVkIFJhbmdlKVwifVxuICAgICAgICB9XG5cbiAgICAgICAgZXhjbCA9IG1pbi5leGNsO1xuICAgICAgICBtYXggPSBtaW4uZW5kO1xuICAgICAgICBtaW4gPSBtaW4uYmVnaW47XG5cbiAgICAgICAgaWYgKG1heCAhPT0gbmlsICYmIGV4Y2wpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdjYW5ub3QgY2xhbXAgd2l0aCBhbiBleGNsdXNpdmUgcmFuZ2UnfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW4gIT09IG5pbCAmJiBtYXggIT09IG5pbCAmJiBjbXBfb3JfZmFpbChtaW4sIG1heCkgPiAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ21pbiBhcmd1bWVudCBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXggYXJndW1lbnQnfVxuICAgICAgfVxuXG4gICAgICBpZiAobWluICE9PSBuaWwpIHtcbiAgICAgICAgYyA9IGNtcF9vcl9mYWlsKHNlbGYsIG1pbik7XG5cbiAgICAgICAgaWYgKGMgPT0gMCkgcmV0dXJuIHNlbGY7XG4gICAgICAgIGlmIChjIDwgMCkgcmV0dXJuIG1pbjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heCAhPT0gbmlsKSB7XG4gICAgICAgIGMgPSBjbXBfb3JfZmFpbChzZWxmLCBtYXgpO1xuXG4gICAgICAgIGlmIChjID4gMCkgcmV0dXJuIG1heDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsIj4iLCIwIiwiPCIsInJhaXNlIiwiY2xhc3MiLCI8PT4iLCI9PSIsImVxdWFsPyIsIm90aGVyIiwiY21wIiwic2VsZiIsIj49IiwiPD0iLCJiZXR3ZWVuPyIsIm1pbiIsIm1heCIsImNsYW1wIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztFQUVBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRTtBQUNGO0FBQ0E7O0FBRUEsVUFBWUMsT0FBQyxJQUFEQSxFQUFTQyxDQUFURCxDQUFXO0FBQ3ZCLFVBQVlFLE9BQUMsSUFBREEsRUFBU0QsQ0FBVEMsQ0FBVztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUNRLGFBQUEsUUFBTSxHQUFOO0FBQUEsSUFDQSxJQUFLLGtCQUFMLElBQVUsbUJBQVYsSUFBZ0Isb0JBQWhCLElBQXVCLHNDQUF2QixJQUFnQyxvQ0FBaEMsR0FDRSxPQUFDLDJCQUFELENBREY7QUFEQSxJQUFBLE1BSUUsT0FBQyx3QkFBRCxDQUpGLENBQUE7QUFPUixVQUFRQyxPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSxnQkFBQSxHQUFBLENBQWlCLENBQUMsR0FBRCxDQUFBQyxPQUFBQSxDQUFBQSxDQUFqQixDQUFBLEdBQUEsUUFBQSxHQUFBLENBQXNDLFVBQXRDLENBQUEsR0FBQSxTQUFyQkQ7QUFDUjs7QUFFQTtBQUNBLGdCQUFrQixDQUFDLEdBQUQsQ0FBQUUsUUFBQUEsQ0FBVyxHQUFYQSxDQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxFQTNCRTtBQUFBO0FBNkJBQyxJQUFBQSxzQkFBQUEsdUJBQUFBLFNBQU8sS0FBUEE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQSxJQUFBLFlBQWVDLFdBQUFBLENBQU9DLEtBQVBELENBQWYsQ0FBQTtBQUFBLFFBQUEsT0FBTyxJQUFQLENBQUE7QUFBQTtBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFaSTtBQUFBLE1BY0EsSUFBQSxRQUFvQkUsQ0FBQUEsTUFBT0MsSUFBQUwsUUFBQUEsQ0FBU0csS0FBVEgsQ0FBUEksQ0FBcEIsQ0FBQTtBQUFBLE1BQUE7QUFBQSxRQUFBLE9BQU87QUFBUCxNQUFBLENBZEE7QUFBQSxNQWdCQSxPQUFDLG1CQUFELENBaEJBO0FBREZILElBQUFBLENBQUFBLGtDQUFBQSxDQTdCQTtBQUFBO0FBaURBTixJQUFBQSxxQkFBQUEsb0JBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyw0QkFBRDtBQURGQSxJQUFBQSxDQUFBQSwrQkFBQUEsQ0FqREE7QUFBQTtBQXFEQVcsSUFBQUEsc0JBQUFBLHVCQUFBQSxTQUFPLEtBQVBBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsNkJBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsa0NBQUFBLENBckRBO0FBQUE7QUF5REFULElBQUFBLHFCQUFBQSxvQkFBQUEsU0FBTSxLQUFOQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFDLDRCQUFEO0FBREZBLElBQUFBLENBQUFBLCtCQUFBQSxDQXpEQTtBQUFBO0FBNkRBVSxJQUFBQSxzQkFBQUEsdUJBQUFBLFNBQU8sS0FBUEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyw2QkFBRDtBQURGQSxJQUFBQSxDQUFBQSxrQ0FBQUEsQ0E3REE7QUFBQTtBQWlFQUMsSUFBQUEsNEJBQUFBLDZCQUFBQSxTQUFhLEdBQUQsRUFBTSxHQUFsQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQSxJQUFnQlgsT0FBQVEsSUFBQVIsRUFBT1ksR0FBUFosQ0FBaEI7QUFBQSxRQUFBLE9BQU8sS0FBUCxDQUFBO0FBQUEsTUFDQSxJQUFnQkYsT0FBQVUsSUFBQVYsRUFBT2UsR0FBUGYsQ0FBaEI7QUFBQSxRQUFBLE9BQU8sS0FBUCxDQURBO0FBQUEsTUFFQSxPQUFBLElBRkE7QUFERmEsSUFBQUEsQ0FBQUEsd0NBQUFBLENBakVBO0FBQUE7QUF1RUFHLElBQUFBLHlCQUFBQSxzQkFBQUEsaUJBQVUsR0FBRCxFQUFNLEdBQWZBO0FBQUFBLE1BQUFBOztBQUFBQTtBQTNFRjtBQTJFaUIsTUFBQTtBQUFBLE1BQUEsUUFBTSxHQUFOO0FBQUEsTUFBQSxDQTNFakI7QUFBQTtBQTZFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFZYixPQUFBQSxDQUFNLDJCQUFXLEVBQUEsR0FBQSxzQkFBQSxHQUFBLENBQXVCVyxHQUFBVixPQUFBQSxDQUFBQSxDQUF2QixDQUFBLEdBQUEsbUJBQWpCRDtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQVlBLE9BQUFBLENBQU0sK0JBQWUsc0NBQXJCQTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFVQSxPQUFBQSxDQUFNLCtCQUFlLGdEQUFyQkE7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQWxIQTtBQTJFRWEsSUFBQUEsQ0FBQUEsa0NBQUFBLENBdkVBO0FBREZqQixFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjYxMzEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JlZ2V4cC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGNvZXJjZV90b1xuXG5jbGFzcyBSZWdleHBFcnJvciA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuXG5jbGFzcyBSZWdleHAgPCBgUmVnRXhwYFxuICBJR05PUkVDQVNFID0gMVxuICBFWFRFTkRFRCA9IDJcbiAgTVVMVElMSU5FID0gNFxuXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsICckJGlzX3JlZ2V4cCcsIHRydWUpYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIGFsbG9jYXRlZCA9IHN1cGVyXG4gICAgICBgI3thbGxvY2F0ZWR9LnVuaW5pdGlhbGl6ZWQgPSB0cnVlYFxuICAgICAgYWxsb2NhdGVkXG4gICAgZW5kXG5cbiAgICBkZWYgZXNjYXBlKHN0cmluZylcbiAgICAgIGBPcGFsLmVzY2FwZV9yZWdleHAoc3RyaW5nKWBcbiAgICBlbmRcblxuICAgIGRlZiBsYXN0X21hdGNoKG4gPSBuaWwpXG4gICAgICBpZiBuLm5pbD9cbiAgICAgICAgJH5cbiAgICAgIGVsc2VcbiAgICAgICAgJH5bbl1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYWxpYXMgcXVvdGUgZXNjYXBlXG5cbiAgICBkZWYgdW5pb24oKnBhcnRzKVxuICAgICAgJXh7XG4gICAgICAgIHZhciBpc19maXJzdF9wYXJ0X2FycmF5LCBxdW90ZWRfdmFsaWRhdGVkLCBwYXJ0LCBvcHRpb25zLCBlYWNoX3BhcnRfb3B0aW9ucztcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIC8oPyEpLztcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gZmFzdCBpZiB0aGVyZSdzIG9ubHkgb25lIGVsZW1lbnRcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PSAxICYmIHBhcnRzWzBdLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvdmVyIHRoZSAyIGFycmF5cyBwYXNzZWQgYXMgYXJndW1lbnRzIGNhc2VcbiAgICAgICAgaXNfZmlyc3RfcGFydF9hcnJheSA9IHBhcnRzWzBdLiQkaXNfYXJyYXk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxICYmIGlzX2ZpcnN0X3BhcnRfYXJyYXkpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ25vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgQXJyYXkgaW50byBTdHJpbmcnfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRlYWwgd2l0aCBzcGxhdCBpc3N1ZXMgKHJlbGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9pc3N1ZXMvODU4KVxuICAgICAgICBpZiAoaXNfZmlyc3RfcGFydF9hcnJheSkge1xuICAgICAgICAgIHBhcnRzID0gcGFydHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICBpZiAocGFydC4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZC5wdXNoKCN7ZXNjYXBlKGBwYXJ0YCl9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocGFydC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgICAgZWFjaF9wYXJ0X29wdGlvbnMgPSAje2BwYXJ0YC5vcHRpb25zfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9IHVuZGVmaW5lZCAmJiBvcHRpb25zICE9IGVhY2hfcGFydF9vcHRpb25zKSB7XG4gICAgICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAnQWxsIGV4cHJlc3Npb25zIG11c3QgdXNlIHRoZSBzYW1lIG9wdGlvbnMnfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucyA9IGVhY2hfcGFydF9vcHRpb25zO1xuICAgICAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZC5wdXNoKCcoJytwYXJ0LnNvdXJjZSsnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHF1b3RlZF92YWxpZGF0ZWQucHVzaCgje2VzY2FwZShgcGFydGAudG9fc3RyKX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgIyBUYWtlIGFkdmFudGFnZSBvZiBsb2dpYyB0aGF0IGNhbiBwYXJzZSBvcHRpb25zIGZyb20gSlMgUmVnZXhcbiAgICAgIG5ldyhgcXVvdGVkX3ZhbGlkYXRlZGAuam9pbignfCcpLCBgb3B0aW9uc2ApXG4gICAgZW5kXG5cbiAgICBkZWYgbmV3KHJlZ2V4cCwgb3B0aW9ucyA9IHVuZGVmaW5lZClcbiAgICAgICV4e1xuICAgICAgICBpZiAocmVnZXhwLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2V4cCA9ICN7T3BhbC5jb2VyY2VfdG8hKHJlZ2V4cCwgU3RyaW5nLCA6dG9fc3RyKX07XG5cbiAgICAgICAgaWYgKHJlZ2V4cC5jaGFyQXQocmVnZXhwLmxlbmd0aCAtIDEpID09PSAnXFxcXCcgJiYgcmVnZXhwLmNoYXJBdChyZWdleHAubGVuZ3RoIC0gMikgIT09ICdcXFxcJykge1xuICAgICAgICAgICN7cmFpc2UgUmVnZXhwRXJyb3IsIFwidG9vIHNob3J0IGVzY2FwZSBzZXF1ZW5jZTogLyN7cmVnZXhwfS9cIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgI3shb3B0aW9uc30pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgICB2YXIgdGVtcCA9ICcnO1xuICAgICAgICAgIGlmICgje0lHTk9SRUNBU0V9ICYgb3B0aW9ucykgeyB0ZW1wICs9ICdpJzsgfVxuICAgICAgICAgIGlmICgje01VTFRJTElORX0gICYgb3B0aW9ucykgeyB0ZW1wICs9ICdtJzsgfVxuICAgICAgICAgIG9wdGlvbnMgPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMgPSAnaSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHAsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgYWxpYXMgY29tcGlsZSBuZXdcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGBvdGhlciBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBzZWxmLnRvU3RyaW5nKCkgPT09IG90aGVyLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiA9PT0oc3RyaW5nKVxuICAgIGAje21hdGNoKE9wYWwuY29lcmNlX3RvPyhzdHJpbmcsIFN0cmluZywgOnRvX3N0cikpfSAhPT0gbmlsYFxuICBlbmRcblxuICBkZWYgPX4oc3RyaW5nKVxuICAgIG1hdGNoKHN0cmluZykgJiYgJH4uYmVnaW4oMClcbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuXG4gIGRlZiBpbnNwZWN0XG4gICAgIyBVc2UgYSByZWdleHAgdG8gZXh0cmFjdCB0aGUgcmVndWxhciBleHByZXNzaW9uIGFuZCB0aGUgb3B0aW9uYWwgbW9kZSBtb2RpZmllcnMgZnJvbSB0aGUgc3RyaW5nLlxuICAgICMgSW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiwgZXNjYXBlIGFueSBmcm9udCBzbGFzaCAobm90IGFscmVhZHkgZXNjYXBlZCkgd2l0aCBhIGJhY2tzbGFzaC5cbiAgICAleHtcbiAgICAgIHZhciByZWdleHBfZm9ybWF0ID0gL15cXC8oLiopXFwvKFteXFwvXSopJC87XG4gICAgICB2YXIgdmFsdWUgPSBzZWxmLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbWF0Y2hlcyA9IHJlZ2V4cF9mb3JtYXQuZXhlYyh2YWx1ZSk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICB2YXIgcmVnZXhwX3BhdHRlcm4gPSBtYXRjaGVzWzFdO1xuICAgICAgICB2YXIgcmVnZXhwX2ZsYWdzID0gbWF0Y2hlc1syXTtcbiAgICAgICAgdmFyIGNoYXJzID0gcmVnZXhwX3BhdHRlcm4uc3BsaXQoJycpO1xuICAgICAgICB2YXIgY2hhcnNfbGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY2hhcl9lc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIHZhciByZWdleHBfcGF0dGVybl9lc2NhcGVkID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnNfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY3VycmVudF9jaGFyID0gY2hhcnNbaV07XG4gICAgICAgICAgaWYgKCFjaGFyX2VzY2FwZWQgJiYgY3VycmVudF9jaGFyID09ICcvJykge1xuICAgICAgICAgICAgcmVnZXhwX3BhdHRlcm5fZXNjYXBlZCA9IHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQuY29uY2F0KCdcXFxcJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQgPSByZWdleHBfcGF0dGVybl9lc2NhcGVkLmNvbmNhdChjdXJyZW50X2NoYXIpO1xuICAgICAgICAgIGlmIChjdXJyZW50X2NoYXIgPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBpZiAoY2hhcl9lc2NhcGVkKSB7XG4gICAgICAgICAgICAgIC8vIGRvZXMgbm90IG92ZXIgZXNjYXBlXG4gICAgICAgICAgICAgIGNoYXJfZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hhcl9lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hhcl9lc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnLycgKyByZWdleHBfcGF0dGVybl9lc2NhcGVkICsgJy8nICsgcmVnZXhwX2ZsYWdzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1hdGNoKHN0cmluZywgcG9zID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICAgIHZhciBtID0gc2VsZi5leGVjKCRjb2VyY2VfdG8oc3RyaW5nLCAje1N0cmluZ30sICd0b19zdHInKSk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgI3skfiA9IE1hdGNoRGF0YS5uZXcoYHNlbGZgLCBgbWApfTtcbiAgICAgICAgICByZXR1cm4gYmxvY2sgPT09IG5pbCA/ICN7JH59IDogI3t5aWVsZCAkfn07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBvcyA9ICRjb2VyY2VfdG8ocG9zLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChzdHJpbmcgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9ICRjb2VyY2VfdG8oc3RyaW5nLCAje1N0cmluZ30sICd0b19zdHInKTtcblxuICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgcG9zICs9IHN0cmluZy5sZW5ndGg7XG4gICAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGdsb2JhbCBSZWdFeHAgbWFpbnRhaW5zIHN0YXRlLCBzbyBub3QgdXNpbmcgc2VsZi90aGlzXG4gICAgICB2YXIgbWQsIHJlID0gT3BhbC5nbG9iYWxfcmVnZXhwKHNlbGYpO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBtZCA9IHJlLmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgaWYgKG1kID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZC5pbmRleCA+PSBwb3MpIHtcbiAgICAgICAgICAjeyR+ID0gTWF0Y2hEYXRhLm5ldyhgcmVgLCBgbWRgKX07XG4gICAgICAgICAgcmV0dXJuIGJsb2NrID09PSBuaWwgPyAjeyR+fSA6ICN7eWllbGQgJH59O1xuICAgICAgICB9XG4gICAgICAgIHJlLmxhc3RJbmRleCA9IG1kLmluZGV4ICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtYXRjaD8oc3RyaW5nLCBwb3MgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZyA9PT0gbmlsID8gZmFsc2UgOiBzZWxmLnRlc3QoJGNvZXJjZV90byhzdHJpbmcsICN7U3RyaW5nfSwgJ3RvX3N0cicpKTtcbiAgICAgIH1cblxuICAgICAgcG9zID0gJGNvZXJjZV90byhwb3MsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nID0gJGNvZXJjZV90byhzdHJpbmcsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuXG4gICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgKz0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ2xvYmFsIFJlZ0V4cCBtYWludGFpbnMgc3RhdGUsIHNvIG5vdCB1c2luZyBzZWxmL3RoaXNcbiAgICAgIHZhciBtZCwgcmUgPSBPcGFsLmdsb2JhbF9yZWdleHAoc2VsZik7XG5cbiAgICAgIG1kID0gcmUuZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKG1kID09PSBudWxsIHx8IG1kLmluZGV4IDwgcG9zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIH5cbiAgICBzZWxmID1+ICRfXG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VcbiAgICBgc2VsZi5zb3VyY2VgXG4gIGVuZFxuXG4gIGRlZiBvcHRpb25zXG4gICAgIyBGbGFncyB3b3VsZCBiZSBuaWNlIHRvIHVzZSB3aXRoIHRoaXMsIGJ1dCBzdGlsbCBleHBlcmltZW50YWwgLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHAvZmxhZ3NcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLnVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICd1bmluaXRpYWxpemVkIFJlZ2V4cCd9XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgIC8vIHNob3VsZCBiZSBzdXBwb3J0ZWQgaW4gSUU2IGFjY29yZGluZyB0byBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5LzdmNXoyNnc0KHY9dnMuOTQpLmFzcHhcbiAgICAgIGlmIChzZWxmLm11bHRpbGluZSkge1xuICAgICAgICByZXN1bHQgfD0gI3tNVUxUSUxJTkV9O1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYuaWdub3JlQ2FzZSkge1xuICAgICAgICByZXN1bHQgfD0gI3tJR05PUkVDQVNFfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2FzZWZvbGQ/XG4gICAgYHNlbGYuaWdub3JlQ2FzZWBcbiAgZW5kXG5cbiAgYWxpYXMgdG9fcyBzb3VyY2VcbmVuZFxuXG5jbGFzcyBNYXRjaERhdGFcbiAgYXR0cl9yZWFkZXIgOnBvc3RfbWF0Y2gsIDpwcmVfbWF0Y2gsIDpyZWdleHAsIDpzdHJpbmdcblxuICBkZWYgaW5pdGlhbGl6ZShyZWdleHAsIG1hdGNoX2dyb3VwcylcbiAgICAkfiAgICAgICAgICA9IHNlbGZcbiAgICBAcmVnZXhwICAgICA9IHJlZ2V4cFxuICAgIEBiZWdpbiAgICAgID0gYG1hdGNoX2dyb3Vwcy5pbmRleGBcbiAgICBAc3RyaW5nICAgICA9IGBtYXRjaF9ncm91cHMuaW5wdXRgXG4gICAgQHByZV9tYXRjaCAgPSBgbWF0Y2hfZ3JvdXBzLmlucHV0LnNsaWNlKDAsIG1hdGNoX2dyb3Vwcy5pbmRleClgXG4gICAgQHBvc3RfbWF0Y2ggPSBgbWF0Y2hfZ3JvdXBzLmlucHV0LnNsaWNlKG1hdGNoX2dyb3Vwcy5pbmRleCArIG1hdGNoX2dyb3Vwc1swXS5sZW5ndGgpYFxuICAgIEBtYXRjaGVzICAgID0gW11cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG1hdGNoX2dyb3Vwcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBtYXRjaF9ncm91cHNbaV07XG5cbiAgICAgICAgaWYgKGdyb3VwID09IG51bGwpIHtcbiAgICAgICAgICAje0BtYXRjaGVzfS5wdXNoKG5pbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgI3tAbWF0Y2hlc30ucHVzaChncm91cCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXSgqYXJncylcbiAgICBAbWF0Y2hlc1sqYXJnc11cbiAgZW5kXG5cbiAgZGVmIG9mZnNldChuKVxuICAgICV4e1xuICAgICAgaWYgKG4gIT09IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnTWF0Y2hEYXRhI29mZnNldCBvbmx5IHN1cHBvcnRzIDB0aCBlbGVtZW50J31cbiAgICAgIH1cbiAgICAgIHJldHVybiBbc2VsZi5iZWdpbiwgc2VsZi5iZWdpbiArIHNlbGYubWF0Y2hlc1tuXS5sZW5ndGhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgTWF0Y2hEYXRhID09PSBvdGhlclxuXG4gICAgYHNlbGYuc3RyaW5nID09IG90aGVyLnN0cmluZ2AgJiZcbiAgICAgIGBzZWxmLnJlZ2V4cC50b1N0cmluZygpID09IG90aGVyLnJlZ2V4cC50b1N0cmluZygpYCAmJlxuICAgICAgYHNlbGYucHJlX21hdGNoID09IG90aGVyLnByZV9tYXRjaGAgJiZcbiAgICAgIGBzZWxmLnBvc3RfbWF0Y2ggPT0gb3RoZXIucG9zdF9tYXRjaGAgJiZcbiAgICAgIGBzZWxmLmJlZ2luID09IG90aGVyLmJlZ2luYFxuICBlbmRcblxuICBhbGlhcyBlcWw/ID09XG5cbiAgZGVmIGJlZ2luKG4pXG4gICAgJXh7XG4gICAgICBpZiAobiAhPT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdNYXRjaERhdGEjYmVnaW4gb25seSBzdXBwb3J0cyAwdGggZWxlbWVudCd9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5iZWdpbjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlbmQobilcbiAgICAleHtcbiAgICAgIGlmIChuICE9PSAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ01hdGNoRGF0YSNlbmQgb25seSBzdXBwb3J0cyAwdGggZWxlbWVudCd9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5iZWdpbiArIHNlbGYubWF0Y2hlc1tuXS5sZW5ndGg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2FwdHVyZXNcbiAgICBgI3tAbWF0Y2hlc30uc2xpY2UoMSlgXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gXCIjPE1hdGNoRGF0YSBcIiArICN7YCN7QG1hdGNoZXN9WzBdYC5pbnNwZWN0fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9ICN7QG1hdGNoZXN9Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0ciArPSBcIiBcIiArIGkgKyBcIjpcIiArICN7YCN7QG1hdGNoZXN9W2ldYC5pbnNwZWN0fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ciArIFwiPlwiO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGAje0BtYXRjaGVzfS5sZW5ndGhgXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5cbiAgZGVmIHRvX2FcbiAgICBAbWF0Y2hlc1xuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGAje0BtYXRjaGVzfVswXWBcbiAgZW5kXG5cbiAgZGVmIHZhbHVlc19hdCgqYXJncylcbiAgICAleHtcbiAgICAgIHZhciBpLCBhLCBpbmRleCwgdmFsdWVzID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgaWYgKGFyZ3NbaV0uJCRpc19yYW5nZSkge1xuICAgICAgICAgIGEgPSAje2BhcmdzW2ldYC50b19hfTtcbiAgICAgICAgICBhLnVuc2hpZnQoaSwgMSk7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShhcmdzLCBhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gI3tPcGFsLmNvZXJjZV90byEoYGFyZ3NbaV1gLCBJbnRlZ2VyLCA6dG9faW50KX07XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ICs9ICN7QG1hdGNoZXN9Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChuaWwpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWVzLnB1c2goI3tAbWF0Y2hlc31baW5kZXhdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCIxIiwiMiIsIjQiLCJhbGxvY2F0ZSIsImFsbG9jYXRlZCIsImVzY2FwZSIsImxhc3RfbWF0Y2giLCJuIiwibmlsPyIsIiR+IiwiW10iLCJ1bmlvbiIsInJhaXNlIiwib3B0aW9ucyIsInRvX3N0ciIsIm5ldyIsImpvaW4iLCJjb2VyY2VfdG8hIiwicmVnZXhwIiwiISIsInNlbGYiLCI9PSIsIj09PSIsIm1hdGNoIiwiY29lcmNlX3RvPyIsInN0cmluZyIsIj1+IiwiJHJldF9vcl8xIiwiYmVnaW4iLCIwIiwiaW5zcGVjdCIsIm1hdGNoPyIsIn4iLCIkXyIsInNvdXJjZSIsImNhc2Vmb2xkPyIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkByZWdleHAiLCJAYmVnaW4iLCJAc3RyaW5nIiwiQHByZV9tYXRjaCIsIkBwb3N0X21hdGNoIiwiQG1hdGNoZXMiLCJhcmdzIiwib2Zmc2V0Iiwib3RoZXIiLCIkcmV0X29yXzIiLCIkcmV0X29yXzMiLCIkcmV0X29yXzQiLCIkcmV0X29yXzUiLCJlbmQiLCJjYXB0dXJlcyIsImxlbmd0aCIsInRvX2EiLCJ0b19zIiwidmFsdWVzX2F0Il0sIm1hcHBpbmdzIjoiOzs7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LE1BQUEsa0JBM1hoQjtBQUFBO0FBNlhBOztBQUVBOztBQUVBO0FBQ0EsY0FBZ0IsQ0FBQyxPQUFELENBQUFGLE1BQUFBLENBQUFBLENBQWU7QUFDL0I7QUFDQTtBQUNBOztBQUVBLGdCQUFrQixvQkFBQXJDLGVBQUFBLENBQWlCLFNBQVUseUJBQVMsUUFBcENBLENBQTZDOztBQUUvRDtBQUNBLG1CQUFxQjBCLFlBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBc0JBLFlBQVM7QUFDL0I7O0FBRUE7QUFDQSxJQXJaQTtBQTJYRWEsSUFBQUEsQ0FBQUEsc0NBQUFBLENBQUFBLHFCQWxHQTtBQURGekQsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FyUkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo2NjYyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9zdHJpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBjb2VyY2VfdG8sIHJlc3BvbmRfdG9cblxucmVxdWlyZSAnY29yZWxpYi9jb21wYXJhYmxlJ1xucmVxdWlyZSAnY29yZWxpYi9yZWdleHAnXG5cbmNsYXNzIFN0cmluZyA8IGBTdHJpbmdgXG4gIGluY2x1ZGUgQ29tcGFyYWJsZVxuXG4gICV4e1xuICAgIE9wYWwuZGVmaW5lUHJvcGVydHkoI3tzZWxmfS4kJHByb3RvdHlwZSwgJyQkaXNfc3RyaW5nJywgdHJ1ZSk7XG5cbiAgICBPcGFsLmRlZmluZVByb3BlcnR5KCN7c2VsZn0uJCRwcm90b3R5cGUsICckJGNhc3QnLCBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHZhciBrbGFzcyA9IHRoaXMuJCRjbGFzcztcbiAgICAgIGlmIChrbGFzcy4kJGNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcga2xhc3MuJCRjb25zdHJ1Y3RvcihzdHJpbmcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGVmIF9faWRfX1xuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cblxuICBkZWYgc2VsZi50cnlfY29udmVydCh3aGF0KVxuICAgIE9wYWwuY29lcmNlX3RvPyh3aGF0LCBTdHJpbmcsIDp0b19zdHIpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5ldyhzdHIgPSAnJylcbiAgICBzdHIgPSBgJGNvZXJjZV90byhzdHIsICN7U3RyaW5nfSwgJ3RvX3N0cicpYFxuICAgIGBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKHN0cilgXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKHN0ciA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ011dGFibGUgc3RyaW5ncyBhcmUgbm90IHN1cHBvcnRlZCBpbiBPcGFsLidcbiAgZW5kXG5cbiAgZGVmICUoZGF0YSlcbiAgICBpZiBBcnJheSA9PT0gZGF0YVxuICAgICAgZm9ybWF0KHNlbGYsICpkYXRhKVxuICAgIGVsc2VcbiAgICAgIGZvcm1hdChzZWxmLCBkYXRhKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKihjb3VudClcbiAgICAleHtcbiAgICAgIGNvdW50ID0gJGNvZXJjZV90byhjb3VudCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFyZ3VtZW50J31cbiAgICAgIH1cblxuICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdCgnJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLnRvU3RyaW5nKCk7XG5cbiAgICAgIC8vIEFsbCBjcmVkaXQgZm9yIHRoZSBiaXQtdHdpZGRsaW5nIG1hZ2ljIGNvZGUgYmVsb3cgZ29lcyB0byBNb3ppbGxhXG4gICAgICAvLyBwb2x5ZmlsbCBpbXBsZW1lbnRhdGlvbiBvZiBTdHJpbmcucHJvdG90eXBlLnJlcGVhdCgpIHBvc3RlZCBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdFxuXG4gICAgICBpZiAoc3RyaW5nLmxlbmd0aCAqIGNvdW50ID49IDEgPDwgMjgpIHtcbiAgICAgICAgI3tyYWlzZSBSYW5nZUVycm9yLCAnbXVsdGlwbHkgY291bnQgbXVzdCBub3Qgb3ZlcmZsb3cgbWF4aW11bSBzdHJpbmcgc2l6ZSd9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKChjb3VudCAmIDEpID09PSAxKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBjb3VudCA+Pj49IDE7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0cmluZyArPSBzdHJpbmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgb3RoZXIgPSBgJGNvZXJjZV90bygje290aGVyfSwgI3tTdHJpbmd9LCAndG9fc3RyJylgXG5cbiAgICBgc2VsZiArICN7b3RoZXIudG9fc31gXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgaWYgb3RoZXIucmVzcG9uZF90bz8gOnRvX3N0clxuICAgICAgb3RoZXIgPSBvdGhlci50b19zdHIudG9fc1xuXG4gICAgICBgc2VsZiA+IG90aGVyID8gMSA6IChzZWxmIDwgb3RoZXIgPyAtMSA6IDApYFxuICAgIGVsc2VcbiAgICAgICV4e1xuICAgICAgICB2YXIgY21wID0gI3tvdGhlciA8PT4gc2VsZn07XG5cbiAgICAgICAgaWYgKGNtcCA9PT0gbmlsKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY21wID4gMCA/IC0xIDogKGNtcCA8IDAgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnRvU3RyaW5nKCkgPT09IG90aGVyLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAoJHJlc3BvbmRfdG8ob3RoZXIsICckdG9fc3RyJykpIHtcbiAgICAgICAgcmV0dXJuICN7b3RoZXIgPT0gc2VsZn07XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBlcWw/ID09XG4gIGFsaWFzID09PSA9PVxuXG4gIGRlZiA9fihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX3N0cmluZykge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ3R5cGUgbWlzbWF0Y2g6IFN0cmluZyBnaXZlbid9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tvdGhlciA9fiBzZWxmfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXShpbmRleCwgbGVuZ3RoID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIHNpemUgPSBzZWxmLmxlbmd0aCwgZXhjbHVkZTtcblxuICAgICAgaWYgKGluZGV4LiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgZXhjbHVkZSA9IGluZGV4LmV4Y2w7XG4gICAgICAgIGxlbmd0aCAgPSAkY29lcmNlX3RvKGluZGV4LmVuZCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgICBpbmRleCAgID0gJGNvZXJjZV90byhpbmRleC5iZWdpbiwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhpbmRleCkgPiBzaXplKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBpbmRleCArPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICBsZW5ndGggKz0gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXhjbHVkZSkge1xuICAgICAgICAgIGxlbmd0aCArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gbGVuZ3RoIC0gaW5kZXg7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYuc3Vic3RyKGluZGV4LCBsZW5ndGgpKTtcbiAgICAgIH1cblxuXG4gICAgICBpZiAoaW5kZXguJCRpc19zdHJpbmcpIHtcbiAgICAgICAgaWYgKGxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3J9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZihpbmRleCkgIT09IC0xID8gc2VsZi4kJGNhc3QoaW5kZXgpIDogbmlsO1xuICAgICAgfVxuXG5cbiAgICAgIGlmIChpbmRleC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBzZWxmLm1hdGNoKGluZGV4KTtcblxuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICAjeyR+ID0gTWF0Y2hEYXRhLm5ldyhgaW5kZXhgLCBgbWF0Y2hgKX1cblxuICAgICAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QobWF0Y2hbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gJGNvZXJjZV90byhsZW5ndGgsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCAmJiAtbGVuZ3RoIDwgbWF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KG1hdGNoW2xlbmd0aCArPSBtYXRjaC5sZW5ndGhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGggPj0gMCAmJiBsZW5ndGggPCBtYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QobWF0Y2hbbGVuZ3RoXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ICs9IHNpemU7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gc2l6ZSB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnN1YnN0cihpbmRleCwgMSkpO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPiBzaXplIHx8IGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5zdWJzdHIoaW5kZXgsIGxlbmd0aCkpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgYnl0ZXNsaWNlIFtdXG5cbiAgZGVmIGJcbiAgICBmb3JjZV9lbmNvZGluZygnYmluYXJ5JylcbiAgZW5kXG5cbiAgZGVmIGNhcGl0YWxpemVcbiAgICBgc2VsZi4kJGNhc3Qoc2VsZi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHNlbGYuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCkpYFxuICBlbmRcblxuICBkZWYgY2FzZWNtcChvdGhlcilcbiAgICByZXR1cm4gbmlsIHVubGVzcyBvdGhlci5yZXNwb25kX3RvPyg6dG9fc3RyKVxuICAgIG90aGVyID0gYCRjb2VyY2VfdG8ob3RoZXIsICN7U3RyaW5nfSwgJ3RvX3N0cicpYC50b19zXG4gICAgJXh7XG4gICAgICB2YXIgYXNjaWlfb25seSA9IC9eW1xceDAwLVxceDdGXSokLztcbiAgICAgIGlmIChhc2NpaV9vbmx5LnRlc3Qoc2VsZikgJiYgYXNjaWlfb25seS50ZXN0KG90aGVyKSkge1xuICAgICAgICBzZWxmID0gc2VsZi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBvdGhlciA9IG90aGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYgPD0+IG90aGVyXG4gIGVuZFxuXG4gIGRlZiBjYXNlY21wPyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBjbXAgPSAje2Nhc2VjbXAob3RoZXIpfTtcbiAgICAgIGlmIChjbXAgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNtcCA9PT0gMDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjZW50ZXIod2lkdGgsIHBhZHN0ciA9ICcgJylcbiAgICB3aWR0aCAgPSBgJGNvZXJjZV90bygje3dpZHRofSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgIHBhZHN0ciA9IGAkY29lcmNlX3RvKCN7cGFkc3RyfSwgI3tTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gc2VsZiBpZiBgd2lkdGggPD0gc2VsZi5sZW5ndGhgXG5cbiAgICAleHtcbiAgICAgIHZhciBsanVzdGlmaWVkID0gI3tsanVzdCAoKHdpZHRoICsgYHNlbGYubGVuZ3RoYCkgLyAyKS5jZWlsLCBwYWRzdHJ9LFxuICAgICAgICAgIHJqdXN0aWZpZWQgPSAje3JqdXN0ICgod2lkdGggKyBgc2VsZi5sZW5ndGhgKSAvIDIpLmZsb29yLCBwYWRzdHJ9O1xuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qocmp1c3RpZmllZCArIGxqdXN0aWZpZWQuc2xpY2Uoc2VsZi5sZW5ndGgpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjaGFycygmYmxvY2spXG4gICAgcmV0dXJuIGVhY2hfY2hhci50b19hIHVubGVzcyBibG9ja1xuXG4gICAgZWFjaF9jaGFyKCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGNob21wKHNlcGFyYXRvciA9ICQvKVxuICAgIHJldHVybiBzZWxmIGlmIGBzZXBhcmF0b3IgPT09IG5pbCB8fCBzZWxmLmxlbmd0aCA9PT0gMGBcblxuICAgIHNlcGFyYXRvciA9IE9wYWwuY29lcmNlX3RvIShzZXBhcmF0b3IsIFN0cmluZywgOnRvX3N0cikudG9fc1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAoc2VwYXJhdG9yID09PSBcIlxcblwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYucmVwbGFjZSgvXFxyP1xcbj8kLywgJycpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VwYXJhdG9yID09PSBcIlwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYucmVwbGFjZSgvKFxccj9cXG4pKyQvLCAnJyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWxmLmxlbmd0aCA+PSBzZXBhcmF0b3IubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0YWlsID0gc2VsZi5zdWJzdHIoc2VsZi5sZW5ndGggLSBzZXBhcmF0b3IubGVuZ3RoLCBzZXBhcmF0b3IubGVuZ3RoKTtcblxuICAgICAgICBpZiAodGFpbCA9PT0gc2VwYXJhdG9yKSB7XG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zdWJzdHIoMCwgc2VsZi5sZW5ndGggLSBzZXBhcmF0b3IubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2hvcFxuICAgICV4e1xuICAgICAgdmFyIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCByZXN1bHQ7XG5cbiAgICAgIGlmIChsZW5ndGggPD0gMSkge1xuICAgICAgICByZXN1bHQgPSBcIlwiO1xuICAgICAgfSBlbHNlIGlmIChzZWxmLmNoYXJBdChsZW5ndGggLSAxKSA9PT0gXCJcXG5cIiAmJiBzZWxmLmNoYXJBdChsZW5ndGggLSAyKSA9PT0gXCJcXHJcIikge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnN1YnN0cigwLCBsZW5ndGggLSAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYuc3Vic3RyKDAsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QocmVzdWx0KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjaHJcbiAgICBgc2VsZi5jaGFyQXQoMClgXG4gIGVuZFxuXG4gIGRlZiBjbG9uZVxuICAgIGNvcHkgPSBgbmV3IFN0cmluZyhzZWxmKWBcbiAgICBjb3B5LmNvcHlfc2luZ2xldG9uX21ldGhvZHMoc2VsZilcbiAgICBjb3B5LmluaXRpYWxpemVfY2xvbmUoc2VsZilcbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBjb3B5ID0gYG5ldyBTdHJpbmcoc2VsZilgXG4gICAgY29weS5pbml0aWFsaXplX2R1cChzZWxmKVxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGNvdW50KCpzZXRzKVxuICAgICV4e1xuICAgICAgaWYgKHNldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ0FyZ3VtZW50RXJyb3I6IHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDErKSd9XG4gICAgICB9XG4gICAgICB2YXIgY2hhcl9jbGFzcyA9IGNoYXJfY2xhc3NfZnJvbV9jaGFyX3NldHMoc2V0cyk7XG4gICAgICBpZiAoY2hhcl9jbGFzcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLmxlbmd0aCAtIHNlbGYucmVwbGFjZShuZXcgUmVnRXhwKGNoYXJfY2xhc3MsICdnJyksICcnKS5sZW5ndGg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlKCpzZXRzKVxuICAgICV4e1xuICAgICAgaWYgKHNldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ0FyZ3VtZW50RXJyb3I6IHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDErKSd9XG4gICAgICB9XG4gICAgICB2YXIgY2hhcl9jbGFzcyA9IGNoYXJfY2xhc3NfZnJvbV9jaGFyX3NldHMoc2V0cyk7XG4gICAgICBpZiAoY2hhcl9jbGFzcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnJlcGxhY2UobmV3IFJlZ0V4cChjaGFyX2NsYXNzLCAnZycpLCAnJykpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9wcmVmaXgocHJlZml4KVxuICAgICV4e1xuICAgICAgaWYgKCFwcmVmaXguJCRpc19zdHJpbmcpIHtcbiAgICAgICAgcHJlZml4ID0gJGNvZXJjZV90byhwcmVmaXgsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5zbGljZSgwLCBwcmVmaXgubGVuZ3RoKSA9PT0gcHJlZml4KSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnNsaWNlKHByZWZpeC5sZW5ndGgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9zdWZmaXgoc3VmZml4KVxuICAgICV4e1xuICAgICAgaWYgKCFzdWZmaXguJCRpc19zdHJpbmcpIHtcbiAgICAgICAgc3VmZml4ID0gJGNvZXJjZV90byhzdWZmaXgsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5zbGljZShzZWxmLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpID09PSBzdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYuc2xpY2UoMCwgc2VsZi5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkb3duY2FzZVxuICAgIGBzZWxmLiQkY2FzdChzZWxmLnRvTG93ZXJDYXNlKCkpYFxuICBlbmRcblxuICBkZWYgZWFjaF9jaGFyKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfY2hhcikgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2VsZi5jaGFyQXQoaSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfbGluZShzZXBhcmF0b3IgPSAkLywgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9saW5lLCBzZXBhcmF0b3IgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSBuaWwpIHtcbiAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIHNlbGYpO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBzZXBhcmF0b3IgPSAkY29lcmNlX3RvKHNlcGFyYXRvciwgI3tTdHJpbmd9LCAndG9fc3RyJylcblxuICAgICAgdmFyIGEsIGksIG4sIGxlbmd0aCwgY2hvbXBlZCwgdHJhaWxpbmcsIHNwbGl0dGVkO1xuXG4gICAgICBpZiAoc2VwYXJhdG9yLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmb3IgKGEgPSBzZWxmLnNwbGl0KC8oXFxuezIsfSkvKSwgaSA9IDAsIG4gPSBhLmxlbmd0aDsgaSA8IG47IGkgKz0gMikge1xuICAgICAgICAgIGlmIChhW2ldIHx8IGFbaSArIDFdKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAoYVtpXSB8fCBcIlwiKSArIChhW2kgKyAxXSB8fCBcIlwiKTtcbiAgICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzZWxmLiQkY2FzdCh2YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBjaG9tcGVkICA9ICN7Y2hvbXAoc2VwYXJhdG9yKX07XG4gICAgICB0cmFpbGluZyA9IHNlbGYubGVuZ3RoICE9IGNob21wZWQubGVuZ3RoO1xuICAgICAgc3BsaXR0ZWQgPSBjaG9tcGVkLnNwbGl0KHNlcGFyYXRvcik7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNwbGl0dGVkLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMSB8fCB0cmFpbGluZykge1xuICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzZWxmLiQkY2FzdChzcGxpdHRlZFtpXSArIHNlcGFyYXRvcikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzZWxmLiQkY2FzdChzcGxpdHRlZFtpXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgYHNlbGYubGVuZ3RoID09PSAwYFxuICBlbmRcblxuICBkZWYgZW5kX3dpdGg/KCpzdWZmaXhlcylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdWZmaXhlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3VmZml4ID0gJGNvZXJjZV90byhzdWZmaXhlc1tpXSwgI3tTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgICBpZiAoc2VsZi5sZW5ndGggPj0gc3VmZml4Lmxlbmd0aCAmJlxuICAgICAgICAgICAgc2VsZi5zdWJzdHIoc2VsZi5sZW5ndGggLSBzdWZmaXgubGVuZ3RoLCBzdWZmaXgubGVuZ3RoKSA9PSBzdWZmaXgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGFsaWFzIGVxdWFsPyA9PT1cblxuICBkZWYgZ3N1YihwYXR0ZXJuLCByZXBsYWNlbWVudCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3tlbnVtX2ZvciA6Z3N1YiwgcGF0dGVybn07XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSAnJywgbWF0Y2hfZGF0YSA9IG5pbCwgaW5kZXggPSAwLCBtYXRjaCwgX3JlcGxhY2VtZW50O1xuXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyksICdnbScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFzdEluZGV4O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc2VsZik7XG5cbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICByZXN1bHQgKz0gc2VsZi5zbGljZShpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBtYXRjaF9kYXRhID0gI3tNYXRjaERhdGEubmV3IGBwYXR0ZXJuYCwgYG1hdGNoYH07XG5cbiAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsYXN0SW5kZXggPSBwYXR0ZXJuLmxhc3RJbmRleDtcbiAgICAgICAgICBfcmVwbGFjZW1lbnQgPSBibG9jayhtYXRjaFswXSk7XG4gICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggPSBsYXN0SW5kZXg7IC8vIHNhdmUgYW5kIHJlc3RvcmUgbGFzdEluZGV4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVwbGFjZW1lbnQuJCRpc19oYXNoKSB7XG4gICAgICAgICAgX3JlcGxhY2VtZW50ID0gI3tgcmVwbGFjZW1lbnRgW2BtYXRjaFswXWBdLnRvX3N9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICghcmVwbGFjZW1lbnQuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gJGNvZXJjZV90byhyZXBsYWNlbWVudCwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9yZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LnJlcGxhY2UoLyhbXFxcXF0rKShbMC05KyZgJ10pL2csIGZ1bmN0aW9uIChvcmlnaW5hbCwgc2xhc2hlcywgY29tbWFuZCkge1xuICAgICAgICAgICAgaWYgKHNsYXNoZXMubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSBtYXRjaC5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgbWF0Y2hbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIGNhc2UgXCImXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgbWF0Y2hbMF07XG4gICAgICAgICAgICBjYXNlIFwiYFwiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICAgICAgY2FzZSBcIidcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6ICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIChtYXRjaFtjb21tYW5kXSB8fCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXR0ZXJuLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgICByZXN1bHQgKz0gKHNlbGYuc2xpY2UoaW5kZXgsIG1hdGNoLmluZGV4KSArIF9yZXBsYWNlbWVudCArIChzZWxmW21hdGNoLmluZGV4XSB8fCBcIlwiKSk7XG4gICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgKz0gKHNlbGYuc2xpY2UoaW5kZXgsIG1hdGNoLmluZGV4KSArIF9yZXBsYWNlbWVudClcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHBhdHRlcm4ubGFzdEluZGV4O1xuICAgICAgfVxuXG4gICAgICAjeyR+ID0gYG1hdGNoX2RhdGFgfVxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiBoZXhcbiAgICB0b19pIDE2XG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyhvdGhlcilcbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgb3RoZXIgPSAkY29lcmNlX3RvKG90aGVyLCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLmluZGV4T2Yob3RoZXIpICE9PSAtMTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmRleChzZWFyY2gsIG9mZnNldCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICByZWdleDtcblxuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSAkY29lcmNlX3RvKG9mZnNldCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgIG9mZnNldCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYXJjaC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICByZWdleCA9IE9wYWwuZ2xvYmFsX211bHRpbGluZV9yZWdleHAoc2VhcmNoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoc2VsZik7XG4gICAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICAjeyR+ID0gbmlsfTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID49IG9mZnNldCkge1xuICAgICAgICAgICAgI3skfiA9IE1hdGNoRGF0YS5uZXcoYHJlZ2V4YCwgYG1hdGNoYCl9XG4gICAgICAgICAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZ2V4Lmxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VhcmNoID0gJGNvZXJjZV90byhzZWFyY2gsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBpZiAoc2VhcmNoLmxlbmd0aCA9PT0gMCAmJiBvZmZzZXQgPiBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXggPSBzZWxmLmluZGV4T2Yoc2VhcmNoLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbmRleCA9PT0gLTEgPyBuaWwgOiBpbmRleDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICB2YXIgZXNjYXBhYmxlID0gL1tcXFxcXFxcIlxceDAwLVxceDFmXFx1MDA3Ri1cXHUwMDlGXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICAgICAgICBtZXRhID0ge1xuICAgICAgICAgICAgJ1xcdTAwMDcnOiAnXFxcXGEnLFxuICAgICAgICAgICAgJ1xcdTAwMWInOiAnXFxcXGUnLFxuICAgICAgICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgICAgICdcXHYnOiAnXFxcXHYnLFxuICAgICAgICAgICAgJ1wiJyA6ICdcXFxcXCInLFxuICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlc2NhcGVkID0gc2VsZi5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGNocikge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGFbY2hyXSB8fCAnXFxcXHUnICsgKCcwMDAwJyArIGNoci5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtNCk7XG4gICAgICAgICAgfSk7XG4gICAgICByZXR1cm4gJ1wiJyArIGVzY2FwZWQucmVwbGFjZSgvXFwjW1xcJFxcQFxce10vZywgJ1xcXFwkJicpICsgJ1wiJztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnRlcm5cbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBkZWYgbGluZXMoc2VwYXJhdG9yID0gJC8sICZibG9jaylcbiAgICBlID0gZWFjaF9saW5lKHNlcGFyYXRvciwgJmJsb2NrKVxuICAgIGJsb2NrID8gc2VsZiA6IGUudG9fYVxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYHNlbGYubGVuZ3RoYFxuICBlbmRcblxuICBkZWYgbGp1c3Qod2lkdGgsIHBhZHN0ciA9ICcgJylcbiAgICB3aWR0aCAgPSBgJGNvZXJjZV90bygje3dpZHRofSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgIHBhZHN0ciA9IGAkY29lcmNlX3RvKCN7cGFkc3RyfSwgI3tTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gc2VsZiBpZiBgd2lkdGggPD0gc2VsZi5sZW5ndGhgXG5cbiAgICAleHtcbiAgICAgIHZhciBpbmRleCAgPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBcIlwiO1xuXG4gICAgICB3aWR0aCAtPSBzZWxmLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCB3aWR0aCkge1xuICAgICAgICByZXN1bHQgKz0gcGFkc3RyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZiArIHJlc3VsdC5zbGljZSgwLCB3aWR0aCkpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxzdHJpcFxuICAgIGBzZWxmLnJlcGxhY2UoL15cXHMqLywgJycpYFxuICBlbmRcblxuICBkZWYgYXNjaWlfb25seT9cbiAgICAjIG5vbi1BU0NJSS1jb21wYXRpYmxlIGVuY29kaW5nIG11c3QgcmV0dXJuIGZhbHNlXG4gICAgIyBOT1RFOiBFbmNvZGluZzo6VVRGXzE2TEUgaXMgYWxzbyBub24tQVNDSUktY29tcGF0aWJsZSBlbmNvZGluZyxcbiAgICAjIGJ1dCBzaW5jZSB0aGUgZGVmYXVsdCBlbmNvZGluZyBpbiBKYXZhU2NyaXB0IGlzIFVURl8xNkxFLFxuICAgICMgd2UgY2Fubm90IHJldHVybiBmYWxzZSBvdGhlcndpc2UgdGhlIGZvbGxvd2luZyB3aWxsIChpbmNvcnJlY3RseSkgcmV0dXJuIGZhbHNlOiBcImhlbGxvXCIuYXNjaWlfb25seT9cbiAgICAjIEluIG90aGVyIHdvcmRzLCB3ZSBjYW5ub3QgdGVsbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuOlxuICAgICMgLSBcImhlbGxvXCIuZm9yY2VfZW5jb2RpbmcoXCJVVEYtMTZMRVwiKVxuICAgICMgLSBcImhlbGxvXCJcbiAgICAjIFRoZSBwcm9ibGVtIGlzIHRoYXQgXCJhc2NpaV9vbmx5XCIgc2hvdWxkIHJldHVybiBmYWxzZSBpbiB0aGUgZmlyc3QgY2FzZSBhbmQgdHJ1ZSBpbiB0aGUgc2Vjb25kIGNhc2UuXG4gICAgaWYgZW5jb2RpbmcgPT0gRW5jb2Rpbmc6OlVURl8xNkJFXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICBlbmRcbiAgICBgL15bXFx4MDAtXFx4N0ZdKiQvLnRlc3Qoc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBtYXRjaChwYXR0ZXJuLCBwb3MgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBTdHJpbmcgPT09IHBhdHRlcm4gfHwgcGF0dGVybi5yZXNwb25kX3RvPyg6dG9fc3RyKVxuICAgICAgcGF0dGVybiA9IFJlZ2V4cC5uZXcocGF0dGVybi50b19zdHIpXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgUmVnZXhwID09PSBwYXR0ZXJuXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje3BhdHRlcm4uY2xhc3N9IChleHBlY3RlZCBSZWdleHApXCJcbiAgICBlbmRcblxuICAgIHBhdHRlcm4ubWF0Y2goc2VsZiwgcG9zLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBtYXRjaD8ocGF0dGVybiwgcG9zID0gdW5kZWZpbmVkKVxuICAgIGlmIFN0cmluZyA9PT0gcGF0dGVybiB8fCBwYXR0ZXJuLnJlc3BvbmRfdG8/KDp0b19zdHIpXG4gICAgICBwYXR0ZXJuID0gUmVnZXhwLm5ldyhwYXR0ZXJuLnRvX3N0cilcbiAgICBlbmRcblxuICAgIHVubGVzcyBSZWdleHAgPT09IHBhdHRlcm5cbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7cGF0dGVybi5jbGFzc30gKGV4cGVjdGVkIFJlZ2V4cClcIlxuICAgIGVuZFxuXG4gICAgcGF0dGVybi5tYXRjaD8oc2VsZiwgcG9zKVxuICBlbmRcblxuICBkZWYgbmV4dFxuICAgICV4e1xuICAgICAgdmFyIGkgPSBzZWxmLmxlbmd0aDtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdCgnJyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc2VsZjtcbiAgICAgIHZhciBmaXJzdF9hbHBoYW51bV9jaGFyX2luZGV4ID0gc2VsZi5zZWFyY2goL1thLXpBLVowLTldLyk7XG4gICAgICB2YXIgY2FycnkgPSBmYWxzZTtcbiAgICAgIHZhciBjb2RlO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb2RlID0gc2VsZi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHxcbiAgICAgICAgICAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB8fFxuICAgICAgICAgIChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTIyKSkge1xuICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgNTc6XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gNDg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDkwOlxuICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xuICAgICAgICAgICAgY29kZSA9IDY1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMjI6XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gOTc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FycnkgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZpcnN0X2FscGhhbnVtX2NoYXJfaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMjU1KSB7XG4gICAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29kZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYXJyeSA9IGZhbHNlO1xuICAgICAgICAgICAgICBjb2RlICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSArIHJlc3VsdC5zbGljZShpICsgMSk7XG4gICAgICAgIGlmIChjYXJyeSAmJiAoaSA9PT0gMCB8fCBpID09PSBmaXJzdF9hbHBoYW51bV9jaGFyX2luZGV4KSkge1xuICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgNjU6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDk3OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyByZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyByZXN1bHQuc2xpY2UoaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhcnJ5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYXJyeSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QocmVzdWx0KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBvY3RcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgc3RyaW5nID0gc2VsZixcbiAgICAgICAgICByYWRpeCA9IDg7XG5cbiAgICAgIGlmICgvXlxccypfLy50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eKFxccypbKy1dPykoMFtib2R4XT8pKC4rKSQvaSwgZnVuY3Rpb24gKG9yaWdpbmFsLCBoZWFkLCBmbGFnLCB0YWlsKSB7XG4gICAgICAgIHN3aXRjaCAodGFpbC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgaWYgKHRhaWwuY2hhckF0KDEpID09PSAneCcgJiYgZmxhZyA9PT0gJzB4Jykge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGZsYWcpIHtcbiAgICAgICAgY2FzZSAnMGInOlxuICAgICAgICAgIHJhZGl4ID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzBvJzpcbiAgICAgICAgICByYWRpeCA9IDg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzBkJzpcbiAgICAgICAgICByYWRpeCA9IDEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcweCc6XG4gICAgICAgICAgcmFkaXggPSAxNjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICB9KTtcblxuICAgICAgcmVzdWx0ID0gcGFyc2VJbnQoc3RyaW5nLnJlcGxhY2UoL18oPyFfKS9nLCAnJyksIHJhZGl4KTtcbiAgICAgIHJldHVybiBpc05hTihyZXN1bHQpID8gMCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBvcmRcbiAgICBgc2VsZi5jaGFyQ29kZUF0KDApYFxuICBlbmRcblxuICBkZWYgcGFydGl0aW9uKHNlcClcbiAgICAleHtcbiAgICAgIHZhciBpLCBtO1xuXG4gICAgICBpZiAoc2VwLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIG0gPSBzZXAuZXhlYyhzZWxmKTtcbiAgICAgICAgaWYgKG0gPT09IG51bGwpIHtcbiAgICAgICAgICBpID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgI3tNYXRjaERhdGEubmV3IGBzZXBgLCBgbWB9O1xuICAgICAgICAgIHNlcCA9IG1bMF07XG4gICAgICAgICAgaSA9IG0uaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcCA9ICRjb2VyY2VfdG8oc2VwLCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgaSA9IHNlbGYuaW5kZXhPZihzZXApO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFtzZWxmLCAnJywgJyddO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzZWxmLnNsaWNlKDAsIGkpLFxuICAgICAgICBzZWxmLnNsaWNlKGksIGkgKyBzZXAubGVuZ3RoKSxcbiAgICAgICAgc2VsZi5zbGljZShpICsgc2VwLmxlbmd0aClcbiAgICAgIF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmV2ZXJzZVxuICAgIGBzZWxmLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJylgXG4gIGVuZFxuXG4gIGRlZiByaW5kZXgoc2VhcmNoLCBvZmZzZXQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbSwgciwgX207XG5cbiAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvZmZzZXQgPSBzZWxmLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9ICRjb2VyY2VfdG8ob2Zmc2V0LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VhcmNoLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIG0gPSBudWxsO1xuICAgICAgICByID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChzZWFyY2gpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIF9tID0gci5leGVjKHNlbGYpO1xuICAgICAgICAgIGlmIChfbSA9PT0gbnVsbCB8fCBfbS5pbmRleCA+IG9mZnNldCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG0gPSBfbTtcbiAgICAgICAgICByLmxhc3RJbmRleCA9IG0uaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtID09PSBudWxsKSB7XG4gICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICBpID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgI3tNYXRjaERhdGEubmV3IGByYCwgYG1gfTtcbiAgICAgICAgICBpID0gbS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VhcmNoID0gJGNvZXJjZV90byhzZWFyY2gsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBpID0gc2VsZi5sYXN0SW5kZXhPZihzZWFyY2gsIG9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpID09PSAtMSA/IG5pbCA6IGk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmp1c3Qod2lkdGgsIHBhZHN0ciA9ICcgJylcbiAgICB3aWR0aCAgPSBgJGNvZXJjZV90bygje3dpZHRofSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgIHBhZHN0ciA9IGAkY29lcmNlX3RvKCN7cGFkc3RyfSwgI3tTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gc2VsZiBpZiBgd2lkdGggPD0gc2VsZi5sZW5ndGhgXG5cbiAgICAleHtcbiAgICAgIHZhciBjaGFycyAgICAgPSBNYXRoLmZsb29yKHdpZHRoIC0gc2VsZi5sZW5ndGgpLFxuICAgICAgICAgIHBhdHRlcm5zICA9IE1hdGguZmxvb3IoY2hhcnMgLyBwYWRzdHIubGVuZ3RoKSxcbiAgICAgICAgICByZXN1bHQgICAgPSBBcnJheShwYXR0ZXJucyArIDEpLmpvaW4ocGFkc3RyKSxcbiAgICAgICAgICByZW1haW5pbmcgPSBjaGFycyAtIHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQgKyBwYWRzdHIuc2xpY2UoMCwgcmVtYWluaW5nKSArIHNlbGYpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJwYXJ0aXRpb24oc2VwKVxuICAgICV4e1xuICAgICAgdmFyIGksIG0sIHIsIF9tO1xuXG4gICAgICBpZiAoc2VwLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIG0gPSBudWxsO1xuICAgICAgICByID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChzZXApO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgX20gPSByLmV4ZWMoc2VsZik7XG4gICAgICAgICAgaWYgKF9tID09PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbSA9IF9tO1xuICAgICAgICAgIHIubGFzdEluZGV4ID0gbS5pbmRleCArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAje01hdGNoRGF0YS5uZXcgYHJgLCBgbWB9O1xuICAgICAgICAgIHNlcCA9IG1bMF07XG4gICAgICAgICAgaSA9IG0uaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VwID0gJGNvZXJjZV90byhzZXAsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBpID0gc2VsZi5sYXN0SW5kZXhPZihzZXApO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFsnJywgJycsIHNlbGZdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzZWxmLnNsaWNlKDAsIGkpLFxuICAgICAgICBzZWxmLnNsaWNlKGksIGkgKyBzZXAubGVuZ3RoKSxcbiAgICAgICAgc2VsZi5zbGljZShpICsgc2VwLmxlbmd0aClcbiAgICAgIF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgcnN0cmlwXG4gICAgYHNlbGYucmVwbGFjZSgvW1xcc1xcdTAwMDBdKiQvLCAnJylgXG4gIGVuZFxuXG4gIGRlZiBzY2FuKHBhdHRlcm4sICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBtYXRjaF9kYXRhID0gbmlsLFxuICAgICAgICAgIG1hdGNoO1xuXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyksICdnbScpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKG1hdGNoID0gcGF0dGVybi5leGVjKHNlbGYpKSAhPSBudWxsKSB7XG4gICAgICAgIG1hdGNoX2RhdGEgPSAje01hdGNoRGF0YS5uZXcgYHBhdHRlcm5gLCBgbWF0Y2hgfTtcbiAgICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgICBtYXRjaC5sZW5ndGggPT0gMSA/IHJlc3VsdC5wdXNoKG1hdGNoWzBdKSA6IHJlc3VsdC5wdXNoKCN7YG1hdGNoX2RhdGFgLmNhcHR1cmVzfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2gubGVuZ3RoID09IDEgPyBibG9jayhtYXRjaFswXSkgOiBibG9jay5jYWxsKHNlbGYsICN7YG1hdGNoX2RhdGFgLmNhcHR1cmVzfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdHRlcm4ubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgI3skfiA9IGBtYXRjaF9kYXRhYH1cblxuICAgICAgcmV0dXJuIChibG9jayAhPT0gbmlsID8gc2VsZiA6IHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBzaXplIGxlbmd0aFxuXG4gIGFsaWFzIHNsaWNlIFtdXG5cbiAgZGVmIHNwbGl0KHBhdHRlcm4gPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGltaXQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGltaXQgPSAje09wYWwuY29lcmNlX3RvIShsaW1pdCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAobGltaXQgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gW3NlbGZdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQgfHwgcGF0dGVybiA9PT0gbmlsKSB7XG4gICAgICAgIHBhdHRlcm4gPSAjeyQ7IHx8ICcgJ307XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLnRvU3RyaW5nKCksXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIGksIGlpO1xuXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSAnICcpIHtcbiAgICAgICAgICBwYXR0ZXJuID0gL1xccysvZ207XG4gICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL15cXHMrLywgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSwgJ2dtJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gc3RyaW5nLnNwbGl0KHBhdHRlcm4pO1xuXG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSAmJiByZXN1bHRbMF0gPT09IHN0cmluZykge1xuICAgICAgICByZXR1cm4gW3NlbGYuJCRjYXN0KHJlc3VsdFswXSldO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKGkgPSByZXN1bHQuaW5kZXhPZih1bmRlZmluZWQpKSAhPT0gLTEpIHtcbiAgICAgICAgcmVzdWx0LnNwbGljZShpLCAxKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2FzdFJlc3VsdCgpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlc3VsdFtpXSA9IHNlbGYuJCRjYXN0KHJlc3VsdFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxpbWl0ID09PSAwKSB7XG4gICAgICAgIHdoaWxlIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgICAgIHJlc3VsdC5sZW5ndGggLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBjYXN0UmVzdWx0KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0gcGF0dGVybi5leGVjKHN0cmluZyk7XG5cbiAgICAgIGlmIChsaW1pdCA8IDApIHtcbiAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsICYmIG1hdGNoWzBdID09PSAnJyAmJiBwYXR0ZXJuLnNvdXJjZS5pbmRleE9mKCcoPz0nKSA9PT0gLTEpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IG1hdGNoLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzdFJlc3VsdCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgbWF0Y2hbMF0gPT09ICcnKSB7XG4gICAgICAgIHJlc3VsdC5zcGxpY2UobGltaXQgLSAxLCByZXN1bHQubGVuZ3RoIC0gMSwgcmVzdWx0LnNsaWNlKGxpbWl0IC0gMSkuam9pbignJykpO1xuICAgICAgICBjYXN0UmVzdWx0KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW1pdCA+PSByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIGNhc3RSZXN1bHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaSA9IDA7XG4gICAgICB3aGlsZSAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgaSsrO1xuICAgICAgICBpbmRleCA9IHBhdHRlcm4ubGFzdEluZGV4O1xuICAgICAgICBpZiAoaSArIDEgPT09IGxpbWl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5zcGxpY2UobGltaXQgLSAxLCByZXN1bHQubGVuZ3RoIC0gMSwgc3RyaW5nLnNsaWNlKGluZGV4KSk7XG4gICAgICBjYXN0UmVzdWx0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNxdWVlemUoKnNldHMpXG4gICAgJXh7XG4gICAgICBpZiAoc2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYucmVwbGFjZSgvKC4pXFwxKy9nLCAnJDEnKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhcl9jbGFzcyA9IGNoYXJfY2xhc3NfZnJvbV9jaGFyX3NldHMoc2V0cyk7XG4gICAgICBpZiAoY2hhcl9jbGFzcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnJlcGxhY2UobmV3IFJlZ0V4cCgnKCcgKyBjaGFyX2NsYXNzICsgJylcXFxcMSsnLCAnZycpLCAnJDEnKSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3RhcnRfd2l0aD8oKnByZWZpeGVzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByZWZpeGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSAkY29lcmNlX3RvKHByZWZpeGVzW2ldLCAje1N0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuXG4gICAgICAgIGlmIChzZWxmLmluZGV4T2YocHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzdHJpcFxuICAgIGBzZWxmLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1tcXHNcXHUwMDAwXSokLywgJycpYFxuICBlbmRcblxuICBkZWYgc3ViKHBhdHRlcm4sIHJlcGxhY2VtZW50ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoIXBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9ICRjb2VyY2VfdG8ocGF0dGVybiwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQsIG1hdGNoID0gcGF0dGVybi5leGVjKHNlbGYpO1xuXG4gICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgcmVzdWx0ID0gc2VsZi50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgI3tNYXRjaERhdGEubmV3IGBwYXR0ZXJuYCwgYG1hdGNoYH1cblxuICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDEgZm9yIDIpJ31cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyBibG9jayhtYXRjaFswXSkgKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlcGxhY2VtZW50LiQkaXNfaGFzaCkge1xuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAje2ByZXBsYWNlbWVudGBbYG1hdGNoWzBdYF0udG9fc30gKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSAkY29lcmNlX3RvKHJlcGxhY2VtZW50LCAje1N0cmluZ30sICd0b19zdHInKTtcblxuICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQucmVwbGFjZSgvKFtcXFxcXSspKFswLTkrJmAnXSkvZywgZnVuY3Rpb24gKG9yaWdpbmFsLCBzbGFzaGVzLCBjb21tYW5kKSB7XG4gICAgICAgICAgICBpZiAoc2xhc2hlcy5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG1hdGNoLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBtYXRjaFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgY2FzZSBcIiZcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBtYXRjaFswXTtcbiAgICAgICAgICAgIGNhc2UgXCJgXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgZGVmYXVsdDogIHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgKG1hdGNoW2NvbW1hbmRdIHx8ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyByZXBsYWNlbWVudCArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc3VjYyBuZXh0XG5cbiAgZGVmIHN1bShuID0gMTYpXG4gICAgJXh7XG4gICAgICBuID0gJGNvZXJjZV90byhuLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIHZhciByZXN1bHQgPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIGkgPSAwO1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCArPSBzZWxmLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdCAmIChNYXRoLnBvdygyLCBuKSAtIDEpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN3YXBjYXNlXG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gc2VsZi5yZXBsYWNlKC8oW2Etel0rKXwoW0EtWl0rKS9nLCBmdW5jdGlvbigkMCwkMSwkMikge1xuICAgICAgICByZXR1cm4gJDEgPyAkMC50b1VwcGVyQ2FzZSgpIDogJDAudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2VsZi5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje3NlbGYuY2xhc3MubmV3IGBzdHJgfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi5jaGFyQXQoMCkgPT09ICdfJykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlRmxvYXQoc2VsZi5yZXBsYWNlKC9fL2csICcnKSk7XG5cbiAgICAgIGlmIChpc05hTihyZXN1bHQpIHx8IHJlc3VsdCA9PSBJbmZpbml0eSB8fCByZXN1bHQgPT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9faShiYXNlID0gMTApXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHN0cmluZyA9IHNlbGYudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICByYWRpeCA9ICRjb2VyY2VfdG8oYmFzZSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAocmFkaXggPT09IDEgfHwgcmFkaXggPCAwIHx8IHJhZGl4ID4gMzYpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tgcmFkaXhgfVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoL15cXHMqXy8udGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXihcXHMqWystXT8pKDBbYm9keF0/KSguKykkLywgZnVuY3Rpb24gKG9yaWdpbmFsLCBoZWFkLCBmbGFnLCB0YWlsKSB7XG4gICAgICAgIHN3aXRjaCAodGFpbC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgaWYgKHRhaWwuY2hhckF0KDEpID09PSAneCcgJiYgZmxhZyA9PT0gJzB4JyAmJiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDE2KSkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGZsYWcpIHtcbiAgICAgICAgY2FzZSAnMGInOlxuICAgICAgICAgIGlmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gMikge1xuICAgICAgICAgICAgcmFkaXggPSAyO1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzBvJzpcbiAgICAgICAgICBpZiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDgpIHtcbiAgICAgICAgICAgIHJhZGl4ID0gODtcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzBkJzpcbiAgICAgICAgICBpZiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDEwKSB7XG4gICAgICAgICAgICByYWRpeCA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMHgnOlxuICAgICAgICAgIGlmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gMTYpIHtcbiAgICAgICAgICAgIHJhZGl4ID0gMTY7XG4gICAgICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFxuICAgICAgfSk7XG5cbiAgICAgIHJlc3VsdCA9IHBhcnNlSW50KHN0cmluZy5yZXBsYWNlKC9fKD8hXykvZywgJycpLCByYWRpeCk7XG4gICAgICByZXR1cm4gaXNOYU4ocmVzdWx0KSA/IDAgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgIG1ldGhvZF9uYW1lID0gJyQnICsgYHNlbGYudmFsdWVPZigpYFxuXG4gICAgcHJvYyBkbyB8KmFyZ3MsICZibG9ja3xcbiAgICAgICV4e1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdubyByZWNlaXZlciBnaXZlbid9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjdiA9IGFyZ3NbMF07XG5cbiAgICAgICAgaWYgKHJlY3YgPT0gbnVsbCkgcmVjdiA9IG5pbDtcblxuICAgICAgICB2YXIgYm9keSA9IHJlY3ZbI3ttZXRob2RfbmFtZX1dO1xuXG4gICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgIHJldHVybiByZWN2LiRtZXRob2RfbWlzc2luZy5hcHBseShyZWN2LCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBib2R5LiQkcCA9IGJsb2NrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGJvZHkuY2FsbChyZWN2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYm9keS5hcHBseShyZWN2LCBhcmdzLnNsaWNlKDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGFsaWFzIHRvX3N0ciB0b19zXG5cbiAgYWxpYXMgdG9fc3ltIGludGVyblxuXG4gIGRlZiB0cihmcm9tLCB0bylcbiAgICAleHtcbiAgICAgIGZyb20gPSAkY29lcmNlX3RvKGZyb20sICN7U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG4gICAgICB0byA9ICRjb2VyY2VfdG8odG8sICN7U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG5cbiAgICAgIGlmIChmcm9tLmxlbmd0aCA9PSAwIHx8IGZyb20gPT09IHRvKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSwgaW5fcmFuZ2UsIGMsIGNoLCBzdGFydCwgZW5kLCBsZW5ndGg7XG4gICAgICB2YXIgc3VicyA9IHt9O1xuICAgICAgdmFyIGZyb21fY2hhcnMgPSBmcm9tLnNwbGl0KCcnKTtcbiAgICAgIHZhciBmcm9tX2xlbmd0aCA9IGZyb21fY2hhcnMubGVuZ3RoO1xuICAgICAgdmFyIHRvX2NoYXJzID0gdG8uc3BsaXQoJycpO1xuICAgICAgdmFyIHRvX2xlbmd0aCA9IHRvX2NoYXJzLmxlbmd0aDtcblxuICAgICAgdmFyIGludmVyc2UgPSBmYWxzZTtcbiAgICAgIHZhciBnbG9iYWxfc3ViID0gbnVsbDtcbiAgICAgIGlmIChmcm9tX2NoYXJzWzBdID09PSAnXicgJiYgZnJvbV9jaGFycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGludmVyc2UgPSB0cnVlO1xuICAgICAgICBmcm9tX2NoYXJzLnNoaWZ0KCk7XG4gICAgICAgIGdsb2JhbF9zdWIgPSB0b19jaGFyc1t0b19sZW5ndGggLSAxXVxuICAgICAgICBmcm9tX2xlbmd0aCAtPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnJvbV9jaGFyc19leHBhbmRlZCA9IFtdO1xuICAgICAgdmFyIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICBpbl9yYW5nZSA9IGZhbHNlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2ggPSBmcm9tX2NoYXJzW2ldO1xuICAgICAgICBpZiAobGFzdF9mcm9tID09IG51bGwpIHtcbiAgICAgICAgICBsYXN0X2Zyb20gPSBjaDtcbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICBpZiAobGFzdF9mcm9tID09PSAnLScpIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGkgPT0gZnJvbV9sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbl9yYW5nZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluX3JhbmdlKSB7XG4gICAgICAgICAgc3RhcnQgPSBsYXN0X2Zyb20uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBlbmQgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQpYH0tI3tgU3RyaW5nLmZyb21DaGFyQ29kZShlbmQpYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjID0gc3RhcnQgKyAxOyBjIDwgZW5kOyBjKyspIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICBpbl9yYW5nZSA9IG51bGw7XG4gICAgICAgICAgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZyb21fY2hhcnMgPSBmcm9tX2NoYXJzX2V4cGFuZGVkO1xuICAgICAgZnJvbV9sZW5ndGggPSBmcm9tX2NoYXJzLmxlbmd0aDtcblxuICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdWJzW2Zyb21fY2hhcnNbaV1dID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0b19sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHRvX2NoYXJzX2V4cGFuZGVkID0gW107XG4gICAgICAgICAgdmFyIGxhc3RfdG8gPSBudWxsO1xuICAgICAgICAgIGluX3JhbmdlID0gZmFsc2U7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaCA9IHRvX2NoYXJzW2ldO1xuICAgICAgICAgICAgaWYgKGxhc3RfdG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBsYXN0X3RvID0gY2g7XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgICAgICBpZiAobGFzdF90byA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpID09IHRvX2xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5fcmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbl9yYW5nZSkge1xuICAgICAgICAgICAgICBzdGFydCA9IGxhc3RfdG8uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgZW5kID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQpYH0tI3tgU3RyaW5nLmZyb21DaGFyQ29kZShlbmQpYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGMgPSBzdGFydCArIDE7IGMgPCBlbmQ7IGMrKykge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICAgIGluX3JhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgbGFzdF90byA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9fY2hhcnMgPSB0b19jaGFyc19leHBhbmRlZDtcbiAgICAgICAgICB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoX2RpZmYgPSBmcm9tX2xlbmd0aCAtIHRvX2xlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aF9kaWZmID4gMCkge1xuICAgICAgICAgIHZhciBwYWRfY2hhciA9ICh0b19sZW5ndGggPiAwID8gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV0gOiAnJyk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aF9kaWZmOyBpKyspIHtcbiAgICAgICAgICAgIHRvX2NoYXJzLnB1c2gocGFkX2NoYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRvX2NoYXJzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdfc3RyID0gJydcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2ggPSBzZWxmLmNoYXJBdChpKTtcbiAgICAgICAgdmFyIHN1YiA9IHN1YnNbY2hdO1xuICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgIG5ld19zdHIgKz0gKHN1YiA9PSBudWxsID8gZ2xvYmFsX3N1YiA6IGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBuZXdfc3RyICs9IChzdWIgIT0gbnVsbCA/IHN1YiA6IGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KG5ld19zdHIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyX3MoZnJvbSwgdG8pXG4gICAgJXh7XG4gICAgICBmcm9tID0gJGNvZXJjZV90byhmcm9tLCAje1N0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuICAgICAgdG8gPSAkY29lcmNlX3RvKHRvLCAje1N0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuXG4gICAgICBpZiAoZnJvbS5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGksIGluX3JhbmdlLCBjLCBjaCwgc3RhcnQsIGVuZCwgbGVuZ3RoO1xuICAgICAgdmFyIHN1YnMgPSB7fTtcbiAgICAgIHZhciBmcm9tX2NoYXJzID0gZnJvbS5zcGxpdCgnJyk7XG4gICAgICB2YXIgZnJvbV9sZW5ndGggPSBmcm9tX2NoYXJzLmxlbmd0aDtcbiAgICAgIHZhciB0b19jaGFycyA9IHRvLnNwbGl0KCcnKTtcbiAgICAgIHZhciB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG5cbiAgICAgIHZhciBpbnZlcnNlID0gZmFsc2U7XG4gICAgICB2YXIgZ2xvYmFsX3N1YiA9IG51bGw7XG4gICAgICBpZiAoZnJvbV9jaGFyc1swXSA9PT0gJ14nICYmIGZyb21fY2hhcnMubGVuZ3RoID4gMSkge1xuICAgICAgICBpbnZlcnNlID0gdHJ1ZTtcbiAgICAgICAgZnJvbV9jaGFycy5zaGlmdCgpO1xuICAgICAgICBnbG9iYWxfc3ViID0gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV1cbiAgICAgICAgZnJvbV9sZW5ndGggLT0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZyb21fY2hhcnNfZXhwYW5kZWQgPSBbXTtcbiAgICAgIHZhciBsYXN0X2Zyb20gPSBudWxsO1xuICAgICAgaW5fcmFuZ2UgPSBmYWxzZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoID0gZnJvbV9jaGFyc1tpXTtcbiAgICAgICAgaWYgKGxhc3RfZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdF9mcm9tID0gY2g7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgaWYgKGxhc3RfZnJvbSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpID09IGZyb21fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5fcmFuZ2UgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbl9yYW5nZSkge1xuICAgICAgICAgIHN0YXJ0ID0gbGFzdF9mcm9tLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgZW5kID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoYyA9IHN0YXJ0ICsgMTsgYyA8IGVuZDsgYysrKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgaW5fcmFuZ2UgPSBudWxsO1xuICAgICAgICAgIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmcm9tX2NoYXJzID0gZnJvbV9jaGFyc19leHBhbmRlZDtcbiAgICAgIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG5cbiAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodG9fbGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0b19jaGFyc19leHBhbmRlZCA9IFtdO1xuICAgICAgICAgIHZhciBsYXN0X3RvID0gbnVsbDtcbiAgICAgICAgICBpbl9yYW5nZSA9IGZhbHNlO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b19sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2ggPSB0b19jaGFyc1tpXTtcbiAgICAgICAgICAgIGlmIChsYXN0X2Zyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBsYXN0X2Zyb20gPSBjaDtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0X3RvID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gdG9fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbl9yYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluX3JhbmdlKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gbGFzdF9mcm9tLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChjID0gc3RhcnQgKyAxOyBjIDwgZW5kOyBjKyspIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgICBpbl9yYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9fY2hhcnMgPSB0b19jaGFyc19leHBhbmRlZDtcbiAgICAgICAgICB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoX2RpZmYgPSBmcm9tX2xlbmd0aCAtIHRvX2xlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aF9kaWZmID4gMCkge1xuICAgICAgICAgIHZhciBwYWRfY2hhciA9ICh0b19sZW5ndGggPiAwID8gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV0gOiAnJyk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aF9kaWZmOyBpKyspIHtcbiAgICAgICAgICAgIHRvX2NoYXJzLnB1c2gocGFkX2NoYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRvX2NoYXJzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbmV3X3N0ciA9ICcnXG4gICAgICB2YXIgbGFzdF9zdWJzdGl0dXRlID0gbnVsbFxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IHNlbGYuY2hhckF0KGkpO1xuICAgICAgICB2YXIgc3ViID0gc3Vic1tjaF1cbiAgICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgICBpZiAoc3ViID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsYXN0X3N1YnN0aXR1dGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBuZXdfc3RyICs9IGdsb2JhbF9zdWI7XG4gICAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3X3N0ciArPSBjaDtcbiAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChzdWIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxhc3Rfc3Vic3RpdHV0ZSA9PSBudWxsIHx8IGxhc3Rfc3Vic3RpdHV0ZSAhPT0gc3ViKSB7XG4gICAgICAgICAgICAgIG5ld19zdHIgKz0gc3ViO1xuICAgICAgICAgICAgICBsYXN0X3N1YnN0aXR1dGUgPSBzdWI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3X3N0ciArPSBjaDtcbiAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QobmV3X3N0cik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdXBjYXNlXG4gICAgYHNlbGYuJCRjYXN0KHNlbGYudG9VcHBlckNhc2UoKSlgXG4gIGVuZFxuXG4gIGRlZiB1cHRvKHN0b3AsIGV4Y2wgPSBmYWxzZSwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6dXB0bywgc3RvcCwgZXhjbCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgJXh7XG4gICAgICB2YXIgYSwgYiwgcyA9IHNlbGYudG9TdHJpbmcoKTtcblxuICAgICAgc3RvcCA9ICRjb2VyY2VfdG8oc3RvcCwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG5cbiAgICAgIGlmIChzLmxlbmd0aCA9PT0gMSAmJiBzdG9wLmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgIGEgPSBzLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGIgPSBzdG9wLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgd2hpbGUgKGEgPD0gYikge1xuICAgICAgICAgIGlmIChleGNsICYmIGEgPT09IGIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJsb2NrKFN0cmluZy5mcm9tQ2hhckNvZGUoYSkpO1xuXG4gICAgICAgICAgYSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VJbnQocywgMTApLnRvU3RyaW5nKCkgPT09IHMgJiYgcGFyc2VJbnQoc3RvcCwgMTApLnRvU3RyaW5nKCkgPT09IHN0b3ApIHtcblxuICAgICAgICBhID0gcGFyc2VJbnQocywgMTApO1xuICAgICAgICBiID0gcGFyc2VJbnQoc3RvcCwgMTApO1xuXG4gICAgICAgIHdoaWxlIChhIDw9IGIpIHtcbiAgICAgICAgICBpZiAoZXhjbCAmJiBhID09PSBiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibG9jayhhLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgYSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgd2hpbGUgKHMubGVuZ3RoIDw9IHN0b3AubGVuZ3RoICYmIHMgPD0gc3RvcCkge1xuICAgICAgICAgIGlmIChleGNsICYmIHMgPT09IHN0b3ApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJsb2NrKHMpO1xuXG4gICAgICAgICAgcyA9ICN7YHNgLnN1Y2N9O1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gY2hhcl9jbGFzc19mcm9tX2NoYXJfc2V0cyhzZXRzKSB7XG4gICAgICBmdW5jdGlvbiBleHBsb2RlX3NlcXVlbmNlc19pbl9jaGFyYWN0ZXJfc2V0KHNldCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgICBpLCBsZW4gPSBzZXQubGVuZ3RoLFxuICAgICAgICAgICAgY3Vycl9jaGFyLFxuICAgICAgICAgICAgc2tpcF9uZXh0X2Rhc2gsXG4gICAgICAgICAgICBjaGFyX2NvZGVfZnJvbSxcbiAgICAgICAgICAgIGNoYXJfY29kZV91cHRvLFxuICAgICAgICAgICAgY2hhcl9jb2RlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjdXJyX2NoYXIgPSBzZXQuY2hhckF0KGkpO1xuICAgICAgICAgIGlmIChjdXJyX2NoYXIgPT09ICctJyAmJiBpID4gMCAmJiBpIDwgKGxlbiAtIDEpICYmICFza2lwX25leHRfZGFzaCkge1xuICAgICAgICAgICAgY2hhcl9jb2RlX2Zyb20gPSBzZXQuY2hhckNvZGVBdChpIC0gMSk7XG4gICAgICAgICAgICBjaGFyX2NvZGVfdXB0byA9IHNldC5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICAgIGlmIChjaGFyX2NvZGVfZnJvbSA+IGNoYXJfY29kZV91cHRvKSB7XG4gICAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BjaGFyX2NvZGVfZnJvbWB9LSN7YGNoYXJfY29kZV91cHRvYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY2hhcl9jb2RlID0gY2hhcl9jb2RlX2Zyb20gKyAxOyBjaGFyX2NvZGUgPCBjaGFyX2NvZGVfdXB0byArIDE7IGNoYXJfY29kZSsrKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJfY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBza2lwX25leHRfZGFzaCA9IHRydWU7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNraXBfbmV4dF9kYXNoID0gKGN1cnJfY2hhciA9PT0gJ1xcXFwnKTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjdXJyX2NoYXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludGVyc2VjdGlvbihzZXRBLCBzZXRCKSB7XG4gICAgICAgIGlmIChzZXRBLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBzZXRCO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICAgIGksIGxlbiA9IHNldEEubGVuZ3RoLFxuICAgICAgICAgICAgY2hyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjaHIgPSBzZXRBLmNoYXJBdChpKTtcbiAgICAgICAgICBpZiAoc2V0Qi5pbmRleE9mKGNocikgIT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gY2hyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICB2YXIgaSwgbGVuLCBzZXQsIG5lZywgY2hyLCB0bXAsXG4gICAgICAgICAgcG9zX2ludGVyc2VjdGlvbiA9ICcnLFxuICAgICAgICAgIG5lZ19pbnRlcnNlY3Rpb24gPSAnJztcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gc2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzZXQgPSAkY29lcmNlX3RvKHNldHNbaV0sICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBuZWcgPSAoc2V0LmNoYXJBdCgwKSA9PT0gJ14nICYmIHNldC5sZW5ndGggPiAxKTtcbiAgICAgICAgc2V0ID0gZXhwbG9kZV9zZXF1ZW5jZXNfaW5fY2hhcmFjdGVyX3NldChuZWcgPyBzZXQuc2xpY2UoMSkgOiBzZXQpO1xuICAgICAgICBpZiAobmVnKSB7XG4gICAgICAgICAgbmVnX2ludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbihuZWdfaW50ZXJzZWN0aW9uLCBzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvc19pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb24ocG9zX2ludGVyc2VjdGlvbiwgc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwICYmIG5lZ19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICB0bXAgPSAnJztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9zX2ludGVyc2VjdGlvbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNociA9IHBvc19pbnRlcnNlY3Rpb24uY2hhckF0KGkpO1xuICAgICAgICAgIGlmIChuZWdfaW50ZXJzZWN0aW9uLmluZGV4T2YoY2hyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRtcCArPSBjaHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvc19pbnRlcnNlY3Rpb24gPSB0bXA7XG4gICAgICAgIG5lZ19pbnRlcnNlY3Rpb24gPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gJ1snICsgI3tSZWdleHAuZXNjYXBlKGBwb3NfaW50ZXJzZWN0aW9uYCl9ICsgJ10nO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVnX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiAnW14nICsgI3tSZWdleHAuZXNjYXBlKGBuZWdfaW50ZXJzZWN0aW9uYCl9ICsgJ10nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgW11cbiAgZW5kXG5cbiAgZGVmIHNlbGYuX2xvYWQoKmFyZ3MpXG4gICAgbmV3KCphcmdzKVxuICBlbmRcblxuICBkZWYgdW5pY29kZV9ub3JtYWxpemUoZm9ybSA9IDpuZmMpXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJJbnZhbGlkIG5vcm1hbGl6YXRpb24gZm9ybSAje2Zvcm19XCIgdW5sZXNzICVpW25mYyBuZmQgbmZrYyBuZmtkXS5pbmNsdWRlPyhmb3JtKVxuICAgIGBzZWxmLm5vcm1hbGl6ZSgje2Zvcm0udXBjYXNlfSlgXG4gIGVuZFxuXG4gIGRlZiB1bmljb2RlX25vcm1hbGl6ZWQ/KGZvcm0gPSA6bmZjKVxuICAgIHVuaWNvZGVfbm9ybWFsaXplKGZvcm0pID09IHNlbGZcbiAgZW5kXG5cbiAgZGVmIHVucGFjayhmb3JtYXQpXG4gICAgcmFpc2UgXCJUbyB1c2UgU3RyaW5nI3VucGFjaywgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvdW5wYWNrJy5cIlxuICBlbmRcblxuICBkZWYgdW5wYWNrMShmb3JtYXQpXG4gICAgcmFpc2UgXCJUbyB1c2UgU3RyaW5nI3VucGFjazEsIHlvdSBtdXN0IGZpcnN0IHJlcXVpcmUgJ2NvcmVsaWIvc3RyaW5nL3VucGFjaycuXCJcbiAgZW5kXG5lbmRcblxuU3ltYm9sID0gU3RyaW5nXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwiaW5jbHVkZSIsInNlbGYiLCJfX2lkX18iLCJ0cnlfY29udmVydCIsImNvZXJjZV90bz8iLCJ3aGF0IiwibmV3Iiwic3RyIiwiaW5pdGlhbGl6ZSIsInJhaXNlIiwiJSIsIj09PSIsImRhdGEiLCJmb3JtYXQiLCIqIiwiKyIsIm90aGVyIiwidG9fcyIsIjw9PiIsInJlc3BvbmRfdG8/IiwidG9fc3RyIiwiPT0iLCI9fiIsIltdIiwiJH4iLCJiIiwiZm9yY2VfZW5jb2RpbmciLCJjYXBpdGFsaXplIiwiY2FzZWNtcCIsImNhc2VjbXA/IiwiY2VudGVyIiwid2lkdGgiLCJwYWRzdHIiLCJlbXB0eT8iLCJsanVzdCIsIi8iLCIyIiwiY2VpbCIsInJqdXN0IiwiZmxvb3IiLCJjaGFycyIsImJsb2NrIiwiZWFjaF9jaGFyIiwidG9fYSIsImNob21wIiwiJC8iLCJzZXBhcmF0b3IiLCJjb2VyY2VfdG8hIiwiY2hvcCIsImNociIsImNsb25lIiwiY29weSIsImNvcHlfc2luZ2xldG9uX21ldGhvZHMiLCJpbml0aWFsaXplX2Nsb25lIiwiZHVwIiwiaW5pdGlhbGl6ZV9kdXAiLCJjb3VudCIsImRlbGV0ZSIsImRlbGV0ZV9wcmVmaXgiLCJkZWxldGVfc3VmZml4IiwiZG93bmNhc2UiLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsInNpemUiLCJlYWNoX2xpbmUiLCJlbmRfd2l0aD8iLCJnc3ViIiwicGF0dGVybiIsImhhc2giLCJoZXgiLCJ0b19pIiwiMTYiLCJpbmNsdWRlPyIsImluZGV4IiwiaW5zcGVjdCIsImludGVybiIsImxpbmVzIiwiZSIsImxlbmd0aCIsImxzdHJpcCIsImFzY2lpX29ubHk/IiwiZW5jb2RpbmciLCJtYXRjaCIsIiRyZXRfb3JfMSIsInBvcyIsIm1hdGNoPyIsIiRyZXRfb3JfMiIsIm5leHQiLCJvY3QiLCJvcmQiLCJwYXJ0aXRpb24iLCJyZXZlcnNlIiwicmluZGV4IiwicnBhcnRpdGlvbiIsInJzdHJpcCIsInNjYW4iLCJjYXB0dXJlcyIsInNwbGl0IiwibGltaXQiLCIkcmV0X29yXzMiLCIkOyIsInNxdWVlemUiLCJzdGFydF93aXRoPyIsInN0cmlwIiwic3ViIiwic3VtIiwic3dhcGNhc2UiLCJ0b19mIiwiMTAiLCJ0b19wcm9jIiwibWV0aG9kX25hbWUiLCJwcm9jIiwidHIiLCJ0cl9zIiwidXBjYXNlIiwidXB0byIsInN0b3AiLCJleGNsIiwic3VjYyIsImVzY2FwZSIsImluc3RhbmNlX3ZhcmlhYmxlcyIsIl9sb2FkIiwiYXJncyIsInVuaWNvZGVfbm9ybWFsaXplIiwiZm9ybSIsInVuaWNvZGVfbm9ybWFsaXplZD8iLCJ1bnBhY2siLCJ1bnBhY2sxIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFQSxNQUFBQSxTQUFBQSxDQUFRLG9CQUFSQSxDQUFBO0FBQUEsTUFDQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FEQTtBQUFBLEVBR0FDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxTQUFBQSxDQUFRLDBCQUFSQSxDQUFBO0FBQUE7QUFHRix3QkFBMEJDLElBQUs7O0FBRS9CLHdCQUEwQkEsSUFBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBYkU7QUFBQTtBQWVBQyxJQUFBQSwwQkFBQUEsbUJBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFDLGVBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsOEJBQUFBLENBZkE7QUFBQSxJQW1CQSxpQkFBTSxXQUFOLEVBQWdCLFFBQWhCLENBbkJBO0FBQUEsSUFxQkFDLFVBQUlGLElBQUpFLGtCQUFBQSx3QkFBQUEsdUJBQXFCLElBQXJCQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLG9CQUFBQyxlQUFBQSxD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QSxtQkFBWSxNQUFaQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxXQUFBdEgsT0FBQUEsQ0FBTSx3RUFBTkE7QUFERnNILElBQUFBLENBQUFBLGdDQUFBQSxDQUFBQSxtQkExeURBO0FBREZoSSxFQUFBQSxHQUFBQSxXQUFBQSxFQUFnQixNQUFoQkEsV0FIQTtBQUFBLEVBbXpEQSxPQUFBLHNDQUFTLHNCQUFULENBbnpEQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjg4MjEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmFibGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBmYWxzeSwgdHJ1dGh5LCBjb2VyY2VfdG9cblxubW9kdWxlIEVudW1lcmFibGVcbiAgJXh7XG4gICAgZnVuY3Rpb24gY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFsdWUgPSBbbmlsXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZGVmIGFsbD8ocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxuXG4gICAgICAgIHJldHVybiBmYWxzZSB1bmxlc3MgcGF0dGVybi5wdWJsaWNfc2VuZCg6PT09LCAqY29tcGFyYWJsZSlcbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICB1bmxlc3MgeWllbGQoKnZhbHVlKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgdW5sZXNzIE9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBhbnk/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICByZXR1cm4gdHJ1ZSBpZiBwYXR0ZXJuLnB1YmxpY19zZW5kKDo9PT0sICpjb21wYXJhYmxlKVxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaWYgT3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIGNodW5rKCZibG9jaylcbiAgICByZXR1cm4gdG9fZW51bSg6Y2h1bmspIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgOjpFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgcHJldmlvdXMgPSBuaWwsIGFjY3VtdWxhdGUgPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiByZWxlYXNlQWNjdW11bGF0ZSgpIHtcbiAgICAgICAgICBpZiAoYWNjdW11bGF0ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAje3lpZWxkZXIueWllbGQoYHByZXZpb3VzYCwgYGFjY3VtdWxhdGVgKX1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGtleSA9IE9wYWwueWllbGQxKGJsb2NrLCB2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAoa2V5ID09PSBuaWwpIHtcbiAgICAgICAgICAgIHJlbGVhc2VBY2N1bXVsYXRlKCk7XG4gICAgICAgICAgICBhY2N1bXVsYXRlID0gW107XG4gICAgICAgICAgICBwcmV2aW91cyA9IG5pbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzID09PSBuaWwgfHwgcHJldmlvdXMgPT09IGtleSkge1xuICAgICAgICAgICAgICBhY2N1bXVsYXRlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVsZWFzZUFjY3VtdWxhdGUoKTtcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZpb3VzID0ga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgICByZWxlYXNlQWNjdW11bGF0ZSgpO1xuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgY2h1bmtfd2hpbGUoJmJsb2NrKVxuICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgc2xpY2Vfd2hlbiB7IHxiZWZvcmUsIGFmdGVyfCAhKHlpZWxkIGJlZm9yZSwgYWZ0ZXIpIH1cbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29sbGVjdCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3RfY29uY2F0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3RfY29uY2F0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cbiAgICBtYXAgeyB8aXRlbXwgeWllbGQgaXRlbSB9LmZsYXR0ZW4oMSlcbiAgZW5kXG5cbiAgZGVmIGNvdW50KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHJlc3VsdCA9IDBcblxuICAgICV4e1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIGBvYmplY3QgIT0gbnVsbGBcbiAgICAgIGJsb2NrID0gcHJvYyBkbyB8KmFyZ3N8XG4gICAgICAgIE9wYWwuZGVzdHJ1Y3R1cmUoYXJncykgPT0gb2JqZWN0XG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9jay5uaWw/XG4gICAgICBibG9jayA9IHByb2MgeyB0cnVlIH1cbiAgICBlbmRcblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgYHJlc3VsdCsrYCBpZiBgT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3MpYFxuICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiBjeWNsZShuID0gbmlsLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpjeWNsZSwgbikgZG9cbiAgICAgICAgaWYgbi5uaWw/XG4gICAgICAgICAgcmVzcG9uZF90bz8oOnNpemUpID8gRmxvYXQ6OklORklOSVRZIDogbmlsXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBuID0gT3BhbC5jb2VyY2VfdG8hKG4sIEludGVnZXIsIDp0b19pbnQpXG4gICAgICAgICAgbiA+IDAgPyBlbnVtZXJhdG9yX3NpemUgKiBuIDogMFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgdW5sZXNzIG4ubmlsP1xuICAgICAgbiA9IE9wYWwuY29lcmNlX3RvISBuLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICAgIHJldHVybiBpZiBgbiA8PSAwYFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgYWxsID0gW10sIGksIGxlbmd0aCwgdmFsdWU7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGFsbC5wdXNoKHBhcmFtKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICBpZiAoYWxsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICBpZiAobiA9PT0gbmlsKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYWxsLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBhbGxbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHdoaWxlIChuID4gMSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFsbC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgYWxsW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZXRlY3QoaWZub25lID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDpkZXRlY3QsIGlmbm9uZSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBlYWNoIGRvIHwqYXJnc3xcbiAgICAgIHZhbHVlID0gT3BhbC5kZXN0cnVjdHVyZShhcmdzKVxuICAgICAgaWYgeWllbGQodmFsdWUpXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChpZm5vbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mKGlmbm9uZSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaWZub25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGlmbm9uZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgZHJvcChudW1iZXIpXG4gICAgbnVtYmVyID0gYCRjb2VyY2VfdG8obnVtYmVyLCAje0ludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgbnVtYmVyIDwgMGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdhdHRlbXB0IHRvIGRyb3AgbmVnYXRpdmUgc2l6ZSdcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCAgPSBbXSxcbiAgICAgICAgICBjdXJyZW50ID0gMDtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG51bWJlciA8PSBjdXJyZW50KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCsrO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpXG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHJvcF93aGlsZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDpkcm9wX3doaWxlIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCAgID0gW10sXG4gICAgICAgICAgZHJvcHBpbmcgPSB0cnVlO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBpZiAoZHJvcHBpbmcpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICAgaWYgKCRmYWxzeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRyb3BwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfY29ucyhuLCAmYmxvY2spXG4gICAgaWYgYGFyZ3VtZW50cy5sZW5ndGggIT0gMWBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAxKVwiXG4gICAgZW5kXG5cbiAgICBuID0gT3BhbC50cnlfY29udmVydCBuLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBpZiBgbiA8PSAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2ludmFsaWQgc2l6ZSdcbiAgICBlbmRcblxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9jb25zLCBuKSBkb1xuICAgICAgICBlbnVtX3NpemUgPSBlbnVtZXJhdG9yX3NpemVcbiAgICAgICAgaWYgZW51bV9zaXplLm5pbD9cbiAgICAgICAgICBuaWxcbiAgICAgICAgZWxzaWYgZW51bV9zaXplID09IDAgfHwgZW51bV9zaXplIDwgblxuICAgICAgICAgIDBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVudW1fc2l6ZSAtIG4gKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBidWZmZXIgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcbiAgICAgICAgYnVmZmVyLnB1c2goZWxlbWVudCk7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gbikge1xuICAgICAgICAgIGJ1ZmZlci5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IG4pIHtcbiAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgYnVmZmVyLnNsaWNlKDAsIG4pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9lbnRyeSgqZGF0YSwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiB0b19lbnVtKDplYWNoX2VudHJ5LCAqZGF0YSkgeyBlbnVtZXJhdG9yX3NpemUgfVxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXRlbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBpdGVtKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaC5hcHBseShzZWxmLCBkYXRhKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9zbGljZShuLCAmYmxvY2spXG4gICAgbiA9IGAkY29lcmNlX3RvKCN7bn0sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgIGlmIGBuIDw9IDBgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnaW52YWxpZCBzbGljZSBzaXplJ1xuICAgIGVuZFxuXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3NsaWNlLCBuKSB7IHJlc3BvbmRfdG8/KDpzaXplKSA/IChzaXplIC8gbikuY2VpbCA6IG5pbCB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHNsaWNlID0gW11cblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG5cbiAgICAgICAgaWYgKHNsaWNlLmxlbmd0aCA9PT0gbikge1xuICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzbGljZSk7XG4gICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICAvLyBvdXIgXCJsYXN0XCIgZ3JvdXAsIGlmIHNtYWxsZXIgdGhhbiBuIHRoZW4gd29uJ3QgaGF2ZSBiZWVuIHlpZWxkZWRcbiAgICAgIGlmIChzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzbGljZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBlYWNoX3dpdGhfaW5kZXgoKmFyZ3MsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfd2l0aF9pbmRleCwgKmFyZ3MpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBibG9jayhwYXJhbSwgaW5kZXgpO1xuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfd2l0aF9vYmplY3Qob2JqZWN0LCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3dpdGhfb2JqZWN0LCBvYmplY3QpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBibG9jayhwYXJhbSwgb2JqZWN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcbiAgICB9XG5cbiAgICBvYmplY3RcbiAgZW5kXG5cbiAgZGVmIGVudHJpZXMoKmFyZ3MpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2guYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZmlsdGVyX21hcCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpmaWx0ZXJfbWFwKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIG1hcCgmYmxvY2spLnNlbGVjdCgmOml0c2VsZilcbiAgZW5kXG5cbiAgYWxpYXMgZmluZCBkZXRlY3RcblxuICBkZWYgZmluZF9hbGwoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZmluZF9hbGwpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZmlsdGVyIGZpbmRfYWxsXG5cbiAgZGVmIGZpbmRfaW5kZXgob2JqZWN0ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDpmaW5kX2luZGV4IGlmIGBvYmplY3QgPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsYFxuXG4gICAgJXh7XG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAje3dhcm4oJ3dhcm5pbmc6IGdpdmVuIGJsb2NrIG5vdCB1c2VkJyl9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5kZXggPSAwXG5cbiAgICBpZiBgb2JqZWN0ICE9IG51bGxgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIE9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpID09IG9iamVjdFxuICAgICAgICAgIHJldHVybiBpbmRleFxuICAgICAgICBlbmRcblxuICAgICAgICBgaW5kZXggKz0gMWBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaWYgeWllbGQoKnZhbHVlKVxuICAgICAgICAgIHJldHVybiBpbmRleFxuICAgICAgICBlbmRcblxuICAgICAgICBgaW5kZXggKz0gMWBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBmaXJzdChudW1iZXIgPSB1bmRlZmluZWQpXG4gICAgaWYgYG51bWJlciA9PT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8dmFsdWV8XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgcmVzdWx0ID0gW11cbiAgICAgIG51bWJlciA9IGAkY29lcmNlX3RvKG51bWJlciwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICBpZiBgbnVtYmVyIDwgMGBcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2F0dGVtcHQgdG8gdGFrZSBuZWdhdGl2ZSBzaXplJ1xuICAgICAgZW5kXG5cbiAgICAgIGlmIGBudW1iZXIgPT0gMGBcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICBlbmRcblxuICAgICAgY3VycmVudCA9IDBcblxuICAgICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICAgIGByZXN1bHQucHVzaCgje09wYWwuZGVzdHJ1Y3R1cmUoYXJncyl9KWBcblxuICAgICAgICBpZiBgbnVtYmVyIDw9ICsrY3VycmVudGBcbiAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG5cbiAgICAgIHJlc3VsdFxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyBmbGF0X21hcCBjb2xsZWN0X2NvbmNhdFxuXG4gIGRlZiBncmVwKHBhdHRlcm4sICZibG9jaylcbiAgICByZXN1bHQgPSBbXVxuXG4gICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgY21wID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcbiAgICAgIG5leHQgdW5sZXNzIHBhdHRlcm4uX19zZW5kX18oOj09PSwgKmNtcClcbiAgICAgIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICB2YWx1ZSA9IFt2YWx1ZV0gaWYgdmFsdWUubGVuZ3RoID4gMVxuICAgICAgICB2YWx1ZSA9IHlpZWxkKCp2YWx1ZSlcbiAgICAgIGVsc2lmIHZhbHVlLmxlbmd0aCA8PSAxXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF1cbiAgICAgIGVuZFxuXG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSlcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgZ3JlcF92KHBhdHRlcm4sICZibG9jaylcbiAgICByZXN1bHQgPSBbXVxuXG4gICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgY21wID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcbiAgICAgIG5leHQgaWYgcGF0dGVybi5fX3NlbmRfXyg6PT09LCAqY21wKVxuICAgICAgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgIHZhbHVlID0gW3ZhbHVlXSBpZiB2YWx1ZS5sZW5ndGggPiAxXG4gICAgICAgIHZhbHVlID0geWllbGQoKnZhbHVlKVxuICAgICAgZWxzaWYgdmFsdWUubGVuZ3RoIDw9IDFcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXVxuICAgICAgZW5kXG5cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKVxuICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiBncm91cF9ieSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpncm91cF9ieSkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBoYXNoID0ge31cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgI3soaGFzaFtgdmFsdWVgXSB8fD0gW10pIDw8IGBwYXJhbWB9O1xuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhc2hcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGU/KG9iailcbiAgICBlYWNoIGRvIHwqYXJnc3xcbiAgICAgIGlmIE9wYWwuZGVzdHJ1Y3R1cmUoYXJncykgPT0gb2JqXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBpbmplY3Qob2JqZWN0ID0gdW5kZWZpbmVkLCBzeW0gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBvYmplY3Q7XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsICYmIHN5bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZFgoYmxvY2ssIFtyZXN1bHQsIHZhbHVlXSk7XG5cbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoc3ltID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoISN7U3ltYm9sID09PSBvYmplY3R9KSB7XG4gICAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCIje29iamVjdC5pbnNwZWN0fSBpcyBub3QgYSBTeW1ib2xcIn07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3ltICAgID0gb2JqZWN0O1xuICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9ICN7YHJlc3VsdGAuX19zZW5kX18gc3ltLCBgdmFsdWVgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09IHVuZGVmaW5lZCA/IG5pbCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsYXp5XG4gICAgRW51bWVyYXRvcjo6TGF6eS5uZXcoc2VsZiwgZW51bWVyYXRvcl9zaXplKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICBlbnVtLnlpZWxkKCphcmdzKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZW51bWVyYXRvcl9zaXplXG4gICAgcmVzcG9uZF90bz8oOnNpemUpID8gc2l6ZSA6IG5pbFxuICBlbmRcblxuICBhbGlhcyBtYXAgY29sbGVjdFxuXG4gIGRlZiBtYXgobiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKG4gPT09IHVuZGVmaW5lZCB8fCBuID09PSBuaWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG5cbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaXRlbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBbaXRlbSwgcmVzdWx0XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gI3tgaXRlbWAgPD0+IGByZXN1bHRgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnY29tcGFyaXNvbiBmYWlsZWQnfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbiA9ICRjb2VyY2VfdG8obiwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgIH1cblxuICAgIHNvcnQoJmJsb2NrKS5yZXZlcnNlLmZpcnN0KG4pXG4gIGVuZFxuXG4gIGRlZiBtYXhfYnkobiA9IG5pbCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6bWF4X2J5LCBuKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgdW5sZXNzIG4ubmlsP1xuICAgICAgcmV0dXJuIHNvcnRfYnkoJmJsb2NrKS5yZXZlcnNlLnRha2UgblxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIGJ5O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgIDw9PiBgYnlgfSA+IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbVxuICAgICAgICAgIGJ5ICAgICA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG5pbCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIG1lbWJlcj8gaW5jbHVkZT9cblxuICBkZWYgbWluKG4gPSBuaWwsICZibG9jaylcbiAgICB1bmxlc3Mgbi5uaWw/XG4gICAgICBpZiBibG9ja19naXZlbj9cbiAgICAgICAgcmV0dXJuIHNvcnQgeyB8YSwgYnwgeWllbGQgYSwgYiB9LnRha2UgblxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gc29ydC50YWtlIG5cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBibG9jayhwYXJhbSwgcmVzdWx0KTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdjb21wYXJpc29uIGZhaWxlZCd9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoI3tPcGFsLmNvbXBhcmUoYHBhcmFtYCwgYHJlc3VsdGApfSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWluX2J5KG4gPSBuaWwsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOm1pbl9ieSwgbikgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgIHVubGVzcyBuLm5pbD9cbiAgICAgIHJldHVybiBzb3J0X2J5KCZibG9jaykudGFrZSBuXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgYnk7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIGJ5ICAgICA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje2B2YWx1ZWAgPD0+IGBieWB9IDwgMCkge1xuICAgICAgICAgIHJlc3VsdCA9IHBhcmFtXG4gICAgICAgICAgYnkgICAgID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbmlsIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1pbm1heCgmYmxvY2spXG4gICAgYmxvY2sgfHw9IHByb2MgeyB8YSwgYnwgYSA8PT4gYiB9XG5cbiAgICAleHtcbiAgICAgIHZhciBtaW4gPSBuaWwsIG1heCA9IG5pbCwgZmlyc3RfdGltZSA9IHRydWU7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG4gICAgICAgIGlmIChmaXJzdF90aW1lKSB7XG4gICAgICAgICAgbWluID0gbWF4ID0gZWxlbWVudDtcbiAgICAgICAgICBmaXJzdF90aW1lID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1pbl9jbXAgPSAje2Jsb2NrLmNhbGwoYG1pbmAsIGBlbGVtZW50YCl9O1xuXG4gICAgICAgICAgaWYgKG1pbl9jbXAgPT09IG5pbCkge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnY29tcGFyaXNvbiBmYWlsZWQnfVxuICAgICAgICAgIH0gZWxzZSBpZiAobWluX2NtcCA+IDApIHtcbiAgICAgICAgICAgIG1pbiA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG1heF9jbXAgPSAje2Jsb2NrLmNhbGwoYG1heGAsIGBlbGVtZW50YCl9O1xuXG4gICAgICAgICAgaWYgKG1heF9jbXAgPT09IG5pbCkge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnY29tcGFyaXNvbiBmYWlsZWQnfVxuICAgICAgICAgIH0gZWxzZSBpZiAobWF4X2NtcCA8IDApIHtcbiAgICAgICAgICAgIG1heCA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIFttaW4sIG1heF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWlubWF4X2J5KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOm1pbm1heF9ieSkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIG1pbl9yZXN1bHQgPSBuaWwsXG4gICAgICAgICAgbWF4X3Jlc3VsdCA9IG5pbCxcbiAgICAgICAgICBtaW5fYnksXG4gICAgICAgICAgbWF4X2J5O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAoKG1pbl9ieSA9PT0gdW5kZWZpbmVkKSB8fCAje2B2YWx1ZWAgPD0+IGBtaW5fYnlgfSA8IDApIHtcbiAgICAgICAgICBtaW5fcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgbWluX2J5ICAgICA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChtYXhfYnkgPT09IHVuZGVmaW5lZCkgfHwgI3tgdmFsdWVgIDw9PiBgbWF4X2J5YH0gPiAwKSB7XG4gICAgICAgICAgbWF4X3Jlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIG1heF9ieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gW21pbl9yZXN1bHQsIG1heF9yZXN1bHRdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5vbmU/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICByZXR1cm4gZmFsc2UgaWYgcGF0dGVybi5wdWJsaWNfc2VuZCg6PT09LCAqY29tcGFyYWJsZSlcbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiB5aWVsZCgqdmFsdWUpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpdGVtID0gT3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcblxuICAgICAgICByZXR1cm4gZmFsc2UgaWYgaXRlbVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBvbmU/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBjb3VudCA9IDBcblxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxuXG4gICAgICAgIGlmIHBhdHRlcm4ucHVibGljX3NlbmQoOj09PSwgKmNvbXBhcmFibGUpXG4gICAgICAgICAgY291bnQgKz0gMVxuICAgICAgICAgIHJldHVybiBmYWxzZSBpZiBjb3VudCA+IDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgbmV4dCB1bmxlc3MgeWllbGQoKnZhbHVlKVxuICAgICAgICBjb3VudCArPSAxXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGNvdW50ID4gMVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBuZXh0IHVubGVzcyBPcGFsLmRlc3RydWN0dXJlKHZhbHVlKVxuICAgICAgICBjb3VudCArPSAxXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGNvdW50ID4gMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBjb3VudCA9PSAxXG4gIGVuZFxuXG4gIGRlZiBwYXJ0aXRpb24oJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cGFydGl0aW9uKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHRydXRoeSA9IFtdLCBmYWxzeSA9IFtdLCByZXN1bHQ7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgIHRydXRoeS5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmYWxzeS5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gW3RydXRoeSwgZmFsc3ldO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgcmVkdWNlIGluamVjdFxuXG4gIGRlZiByZWplY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVqZWN0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAoJGZhbHN5KHZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJldmVyc2VfZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZXZlcnNlX2VhY2gpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgT3BhbC55aWVsZFgoYmxvY2ssIHJlc3VsdFtpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBzZWxlY3QgZmluZF9hbGxcblxuICBkZWYgc2xpY2VfYmVmb3JlKHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiA9PT0gdW5kZWZpbmVkICYmIGJsb2NrID09PSBuaWxgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnYm90aCBwYXR0ZXJuIGFuZCBibG9jayBhcmUgZ2l2ZW4nXG4gICAgZW5kXG5cbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkICYmIGJsb2NrICE9PSBuaWwgfHwgYXJndW1lbnRzLmxlbmd0aCA+IDFgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBleHBlY3RlZCAxKVwiXG4gICAgZW5kXG5cbiAgICBFbnVtZXJhdG9yLm5ldyBkbyB8ZXxcbiAgICAgICV4e1xuICAgICAgICB2YXIgc2xpY2UgPSBbXTtcblxuICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzbGljZS5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHBhcmFtLCAje3BhdHRlcm4uZHVwfSk7XG5cbiAgICAgICAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpICYmIHNsaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAje2UgPDwgYHNsaWNlYH07XG4gICAgICAgICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNsaWNlLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgICAgIHZhbHVlID0gI3twYXR0ZXJuID09PSBgcGFyYW1gfTtcblxuICAgICAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpICYmIHNsaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzbGljZS5wdXNoKHBhcmFtKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICAgIGlmIChzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzbGljZV9hZnRlcihwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYHBhdHRlcm4gPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2JvdGggcGF0dGVybiBhbmQgYmxvY2sgYXJlIGdpdmVuJ1xuICAgIGVuZFxuXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZCAmJiBibG9jayAhPT0gbmlsIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAxYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZXhwZWN0ZWQgMSlcIlxuICAgIGVuZFxuXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZGBcbiAgICAgIGJsb2NrID0gcHJvYyB7IHxlfCBwYXR0ZXJuID09PSBlIH1cbiAgICBlbmRcblxuICAgIEVudW1lcmF0b3IubmV3IGRvIHx5aWVsZGVyfFxuICAgICAgJXh7XG4gICAgICAgIHZhciBhY2N1bXVsYXRlO1xuXG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgZW5kX2NodW5rID0gT3BhbC55aWVsZDEoYmxvY2ssIGVsZW1lbnQpO1xuXG4gICAgICAgICAgaWYgKGFjY3VtdWxhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgYWNjdW11bGF0ZSA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgkdHJ1dGh5KGVuZF9jaHVuaykpIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICN7eWllbGRlci55aWVsZChgYWNjdW11bGF0ZWApfTtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlLnB1c2goZWxlbWVudClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgICAgaWYgKGFjY3VtdWxhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICN7eWllbGRlci55aWVsZChgYWNjdW11bGF0ZWApfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2xpY2Vfd2hlbigmYmxvY2spXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDEpJyB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgc2xpY2UgPSBuaWwsIGxhc3RfYWZ0ZXIgPSBuaWw7XG5cbiAgICAgICAgc2VsZi4kZWFjaF9jb25zLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwYXJhbXMgPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgYmVmb3JlID0gcGFyYW1zWzBdLFxuICAgICAgICAgICAgICBhZnRlciA9IHBhcmFtc1sxXSxcbiAgICAgICAgICAgICAgbWF0Y2ggPSBPcGFsLnlpZWxkWChibG9jaywgW2JlZm9yZSwgYWZ0ZXJdKTtcblxuICAgICAgICAgIGxhc3RfYWZ0ZXIgPSBhZnRlcjtcblxuICAgICAgICAgIGlmIChzbGljZSA9PT0gbmlsKSB7XG4gICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgkdHJ1dGh5KG1hdGNoKSkge1xuICAgICAgICAgICAgc2xpY2UucHVzaChiZWZvcmUpO1xuICAgICAgICAgICAgI3t5aWVsZGVyLnlpZWxkKGBzbGljZWApfTtcbiAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNsaWNlLnB1c2goYmVmb3JlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoX2NvbnMoMik7XG5cbiAgICAgICAgaWYgKHNsaWNlICE9PSBuaWwpIHtcbiAgICAgICAgICBzbGljZS5wdXNoKGxhc3RfYWZ0ZXIpO1xuICAgICAgICAgICN7eWllbGRlci55aWVsZChgc2xpY2VgKX07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNvcnQoJmJsb2NrKVxuICAgIGFyeSA9IHRvX2FcbiAgICBibG9jayA9IC0+KGEsIGIpIHsgYSA8PT4gYiB9IHVubGVzcyBibG9ja19naXZlbj9cbiAgICBhcnkuc29ydCgmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBzb3J0X2J5KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNvcnRfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgZHVwID0gbWFwIGRvXG4gICAgICBhcmcgPSBPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKVxuICAgICAgW3lpZWxkKGFyZyksIGFyZ11cbiAgICBlbmRcbiAgICBkdXAuc29ydCEgeyB8YSwgYnwgYGFbMF1gIDw9PiBgYlswXWAgfVxuICAgIGR1cC5tYXAhIHsgfGl8IGBpWzFdYCB9XG4gIGVuZFxuXG4gIGRlZiBzdW0oaW5pdGlhbCA9IDApXG4gICAgcmVzdWx0ID0gaW5pdGlhbFxuXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICBpdGVtID0gaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgICAgICAgICB5aWVsZCgqYXJncylcbiAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG4gICAgICAgICAgICAgZW5kXG4gICAgICByZXN1bHQgKz0gaXRlbVxuICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiB0YWtlKG51bSlcbiAgICBmaXJzdChudW0pXG4gIGVuZFxuXG4gIGRlZiB0YWtlX3doaWxlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOnRha2Vfd2hpbGUgdW5sZXNzIGJsb2NrXG5cbiAgICByZXN1bHQgPSBbXVxuXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICB2YWx1ZSA9IE9wYWwuZGVzdHJ1Y3R1cmUoYXJncylcblxuICAgICAgdW5sZXNzIHlpZWxkKHZhbHVlKVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICBlbmRcblxuICAgICAgYHJlc3VsdC5wdXNoKHZhbHVlKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHVuaXEoJmJsb2NrKVxuICAgIGhhc2ggPSB7fVxuXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICB2YWx1ZSA9IE9wYWwuZGVzdHJ1Y3R1cmUoYXJncylcblxuICAgICAgcHJvZHVjZWQgPSBpZiBibG9ja19naXZlbj9cbiAgICAgICAgICAgICAgICAgICB5aWVsZCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgIGVuZFxuXG4gICAgICB1bmxlc3MgaGFzaC5rZXk/KHByb2R1Y2VkKVxuICAgICAgICBoYXNoW3Byb2R1Y2VkXSA9IHZhbHVlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGhhc2gudmFsdWVzXG4gIGVuZFxuXG4gIGRlZiB0YWxseVxuICAgIGdyb3VwX2J5KCY6aXRzZWxmKS50cmFuc2Zvcm1fdmFsdWVzKCY6Y291bnQpXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2EgZW50cmllc1xuXG4gIGRlZiB0b19oKCphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIG1hcCgmYmxvY2spLnRvX2goKmFyZ3MpIGlmIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9ICN7e319O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcbiAgICAgICAgdmFyIGFyeSA9ICN7T3BhbC5jb2VyY2VfdG8/KGBwYXJhbWAsIEFycmF5LCA6dG9fYXJ5KX0sIGtleSwgdmFsO1xuICAgICAgICBpZiAoIWFyeS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgZWxlbWVudCB0eXBlICN7YGFyeWAuY2xhc3N9IChleHBlY3RlZCBhcnJheSlcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJ5Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBhcnJheSBsZW5ndGggKGV4cGVjdGVkIDIsIHdhcyAje2BhcnlgLmxlbmd0aH0pXCJ9XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gYXJ5WzBdO1xuICAgICAgICB2YWwgPSBhcnlbMV07XG5cbiAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB6aXAoKm90aGVycywgJmJsb2NrKVxuICAgIHRvX2EuemlwKCpvdGhlcnMpXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiYWxsPyIsImVhY2giLCJjb21wYXJhYmxlIiwicHVibGljX3NlbmQiLCJwYXR0ZXJuIiwiYmxvY2tfZ2l2ZW4/IiwidmFsdWUiLCJkZXN0cnVjdHVyZSIsImFueT8iLCJjaHVuayIsInRvX2VudW0iLCJlbnVtZXJhdG9yX3NpemUiLCJuZXciLCJ5aWVsZGVyIiwieWllbGQiLCJjaHVua193aGlsZSIsInJhaXNlIiwic2xpY2Vfd2hlbiIsImJlZm9yZSIsImFmdGVyIiwiISIsImNvbGxlY3QiLCJlbnVtX2ZvciIsImNvbGxlY3RfY29uY2F0IiwibWFwIiwiaXRlbSIsImZsYXR0ZW4iLCIxIiwiY291bnQiLCJyZXN1bHQiLCIwIiwid2FybiIsImJsb2NrIiwicHJvYyIsImFyZ3MiLCI9PSIsIm9iamVjdCIsIm5pbD8iLCJjeWNsZSIsIm4iLCJyZXNwb25kX3RvPyIsImNvZXJjZV90byEiLCI+IiwiKiIsImRldGVjdCIsImlmbm9uZSIsImRyb3AiLCJudW1iZXIiLCJkcm9wX3doaWxlIiwiZWFjaF9jb25zIiwidHJ5X2NvbnZlcnQiLCJlbnVtX3NpemUiLCIkcmV0X29yXzEiLCI8IiwiKyIsIi0iLCJlYWNoX2VudHJ5IiwiZGF0YSIsImVhY2hfc2xpY2UiLCIvIiwic2l6ZSIsImNlaWwiLCJlYWNoX3dpdGhfaW5kZXgiLCJzZWxmIiwiZWFjaF93aXRoX29iamVjdCIsImVudHJpZXMiLCJmaWx0ZXJfbWFwIiwic2VsZWN0IiwiZmluZF9hbGwiLCJmaW5kX2luZGV4IiwiaW5kZXgiLCJmaXJzdCIsImN1cnJlbnQiLCJncmVwIiwiY21wIiwiX19zZW5kX18iLCJsZW5ndGgiLCI8PSIsIltdIiwicHVzaCIsImdyZXBfdiIsImdyb3VwX2J5IiwiaGFzaCIsIiRyZXRfb3JfMiIsIiR3cml0ZXIiLCJbXT0iLCI8PCIsImluY2x1ZGU/Iiwib2JqIiwiaW5qZWN0IiwiPT09IiwiaW5zcGVjdCIsInN5bSIsImxhenkiLCJlbnVtJCIsIm1heCIsIjw9PiIsInNvcnQiLCJyZXZlcnNlIiwibWF4X2J5Iiwic29ydF9ieSIsInRha2UiLCJtaW4iLCJhIiwiYiIsImNvbXBhcmUiLCJtaW5fYnkiLCJtaW5tYXgiLCIkcmV0X29yXzMiLCJjYWxsIiwibWlubWF4X2J5Iiwibm9uZT8iLCJvbmU/IiwicGFydGl0aW9uIiwicmVqZWN0IiwicmV2ZXJzZV9lYWNoIiwic2xpY2VfYmVmb3JlIiwiZSIsImR1cCIsInNsaWNlX2FmdGVyIiwiYXJ5IiwidG9fYSIsImFyZyIsInNvcnQhIiwibWFwISIsInN1bSIsImluaXRpYWwiLCJudW0iLCJ0YWtlX3doaWxlIiwidW5pcSIsInByb2R1Y2VkIiwia2V5PyIsInZhbHVlcyIsInRhbGx5IiwidHJhbnNmb3JtX3ZhbHVlcyIsInRvX2giLCJjb2VyY2VfdG8/IiwiY2xhc3MiLCJ6aXAiLCJvdGhlcnMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBRUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQVpFO0FBQUE7QUFjQUMsSUFBQUEsd0JBQUFBLHlCQUFBQSxTQUFTLE9BQVRBLEdBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUFsQkY7QUFrQmdDLE1BQUEsNkNBbEJoQztBQUFBLE1BQUE7QUFBQSxNQW1CSSxJQUFBLFFBQUkscUJBQUosQ0FBQTtBQUFBLFFBQ0VDLFVBQUFBLFFBQUFBLEVBQUFBLEVBQUFBLEVBcEJO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SSxlQUFBQSxDQUFpQixPQUFRLHVCQUFPLFFBQWhDQSxDQUF5QztBQUM3RDtBQUNBLGNBQVl4SCxPQUFBQSxDQUFNLDJCQUFXLEVBQUEsR0FBQSxxQkFBQSxHQUFBLENBQXNCLENBQUMsR0FBRCxDQUFBeUgsT0FBQUEsQ0FBQUEsQ0FBdEIsQ0FBQSxHQUFBLG1CQUFqQnpIO0FBQ1o7QUFDQTtBQUNBLGNBQVlBLE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLHNDQUFBLEdBQUEsQ0FBdUMsQ0FBQyxHQUFELENBQUE0RCxRQUFBQSxDQUFBQSxDQUF2QyxDQUFBLEdBQUEsR0FBckI1RDtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUE5dUNBO0FBc3RDRXVILElBQUFBLENBQUFBLG1DQUFBQSxDQWx0Q0E7QUFBQTtBQTZ1Q0FHLElBQUFBLHVCQUFBQSxzQkFBQUEsZUFqdkNGLEVBaXZDRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBanZDRjtBQWl2Q21CLE1BQUEsMENBanZDbkI7QUFBQTtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQWl2Q1UsTUFBQSxvQkFqdkNWO0FBQUEsTUFrdkNJLE9BQUFBLFVBQUFqQixNQUFBQSxDQUFBQSxDQUFBaUIsT0FBQUEsRUFBUyxVQUFDQyxNQUFELENBQVRELENBbHZDSjtBQWl2Q0VBLElBQUFBLENBQUFBLGtDQUFBQSxDQTd1Q0E7QUFERjNJLEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTA3OTYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmF0b3IucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBicmVha2VyLCBzbGljZSwgZmFsc3ksIHRydXRoeSwgY29lcmNlX3RvXG5cbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcblxuY2xhc3MgRW51bWVyYXRvclxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICBgc2VsZi4kJHByb3RvdHlwZS4kJGlzX2VudW1lcmF0b3IgPSB0cnVlYFxuXG4gIGRlZiBzZWxmLmZvcihvYmplY3QsIG1ldGhvZCA9IDplYWNoLCAqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIG9iaiA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICBvYmoub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgb2JqLnNpemUgICA9IGJsb2NrO1xuICAgICAgb2JqLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIG9iai5hcmdzICAgPSBhcmdzO1xuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoKiwgJmJsb2NrKVxuICAgIGlmIGJsb2NrXG4gICAgICBAb2JqZWN0ID0gR2VuZXJhdG9yLm5ldygmYmxvY2spXG4gICAgICBAbWV0aG9kID0gOmVhY2hcbiAgICAgIEBhcmdzICAgPSBbXVxuICAgICAgQHNpemUgICA9IGBhcmd1bWVudHNbMF0gfHwgbmlsYFxuXG4gICAgICBpZiBAc2l6ZSAmJiAhQHNpemUucmVzcG9uZF90bz8oOmNhbGwpXG4gICAgICAgIEBzaXplID0gYCRjb2VyY2VfdG8oI3tAc2l6ZX0sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIEBvYmplY3QgPSBgYXJndW1lbnRzWzBdYFxuICAgICAgQG1ldGhvZCA9IGBhcmd1bWVudHNbMV0gfHwgXCJlYWNoXCJgXG4gICAgICBAYXJncyAgID0gYCRzbGljZS5jYWxsKGFyZ3VtZW50cywgMilgXG4gICAgICBAc2l6ZSAgID0gbmlsXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIHNlbGYgaWYgYmxvY2submlsPyAmJiBhcmdzLmVtcHR5P1xuXG4gICAgYXJncyA9IEBhcmdzICsgYXJnc1xuXG4gICAgcmV0dXJuIHNlbGYuY2xhc3MubmV3KEBvYmplY3QsIEBtZXRob2QsICphcmdzKSBpZiBibG9jay5uaWw/XG5cbiAgICBAb2JqZWN0Ll9fc2VuZF9fKEBtZXRob2QsICphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBzaXplXG4gICAgQHNpemUucmVzcG9uZF90bz8oOmNhbGwpID8gQHNpemUuY2FsbCgqQGFyZ3MpIDogQHNpemVcbiAgZW5kXG5cbiAgZGVmIHdpdGhfaW5kZXgob2Zmc2V0ID0gMCwgJmJsb2NrKVxuICAgIG9mZnNldCA9IGlmIG9mZnNldFxuICAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob2Zmc2V0LCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgIGVuZFxuXG4gICAgcmV0dXJuIGVudW1fZm9yKDp3aXRoX2luZGV4LCBvZmZzZXQpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LCBpbmRleCA9IG9mZnNldDtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHBhcmFtLCBpbmRleCk7XG5cbiAgICAgICAgaW5kZXgrKztcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiRlYWNoKCk7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyB3aXRoX29iamVjdCBlYWNoX3dpdGhfb2JqZWN0XG5cbiAgZGVmIGVhY2hfd2l0aF9pbmRleCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3dpdGhfaW5kZXgpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHN1cGVyXG4gICAgQG9iamVjdFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIHJlc3VsdCA9IFwiIzwje3NlbGYuY2xhc3N9OiAje0BvYmplY3QuaW5zcGVjdH06I3tAbWV0aG9kfVwiXG5cbiAgICBpZiBAYXJncy5hbnk/XG4gICAgICByZXN1bHQgKz0gXCIoI3tAYXJncy5pbnNwZWN0W1JhbmdlLm5ldygxLCAtMildfSlcIlxuICAgIGVuZFxuXG4gICAgcmVzdWx0ICsgJz4nXG4gIGVuZFxuXG4gIGNsYXNzIEdlbmVyYXRvclxuICAgIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gICAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgICAgcmFpc2UgTG9jYWxKdW1wRXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIEBibG9jayA9IGJsb2NrXG4gICAgZW5kXG5cbiAgICBkZWYgZWFjaCgqYXJncywgJmJsb2NrKVxuICAgICAgeWllbGRlciA9IFlpZWxkZXIubmV3KCZibG9jaylcblxuICAgICAgJXh7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXJncy51bnNoaWZ0KCN7eWllbGRlcn0pO1xuXG4gICAgICAgICAgT3BhbC55aWVsZFgoI3tAYmxvY2t9LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlID09PSAkYnJlYWtlcikge1xuICAgICAgICAgICAgcmV0dXJuICRicmVha2VyLiR2O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgY2xhc3MgWWllbGRlclxuICAgIGRlZiBpbml0aWFsaXplKCZibG9jaylcbiAgICAgIEBibG9jayA9IGJsb2NrXG4gICAgZW5kXG5cbiAgICBkZWYgeWllbGQoKnZhbHVlcylcbiAgICAgICV4e1xuICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWCgje0BibG9ja30sIHZhbHVlcyk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAkYnJlYWtlcikge1xuICAgICAgICAgIHRocm93ICRicmVha2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIDw8KCp2YWx1ZXMpXG4gICAgICBzZWxmLnlpZWxkKCp2YWx1ZXMpXG5cbiAgICAgIHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgY2xhc3MgTGF6eSA8IHNlbGZcbiAgICBjbGFzcyBTdG9wTGF6eUVycm9yIDwgRXhjZXB0aW9uOyBlbmRcblxuICAgIGRlZiBpbml0aWFsaXplKG9iamVjdCwgc2l6ZSA9IG5pbCwgJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IG5ldyB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgQGVudW1lcmF0b3IgPSBvYmplY3RcblxuICAgICAgc3VwZXIgc2l6ZSBkbyB8eWllbGRlciwgKmVhY2hfYXJnc3xcbiAgICAgICAgb2JqZWN0LmVhY2goKmVhY2hfYXJncykgZG8gfCphcmdzfFxuICAgICAgICAgICV4e1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KCN7eWllbGRlcn0pO1xuXG4gICAgICAgICAgICBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICBlbmRcbiAgICAgIHJlc2N1ZSBFeGNlcHRpb25cbiAgICAgICAgbmlsXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFsaWFzIGZvcmNlIHRvX2FcblxuICAgIGRlZiBsYXp5XG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgY29sbGVjdCgmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBtYXAgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIGVudW1lcmF0b3Jfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICAje2VudW0ueWllbGQgYHZhbHVlYH07XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGNvbGxlY3RfY29uY2F0KCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IG1hcCB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgICV4e1xuICAgICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgje2B2YWx1ZWAucmVzcG9uZF90bz8gOmZvcmNlfSAmJiAje2B2YWx1ZWAucmVzcG9uZF90bz8gOmVhY2h9KSB7XG4gICAgICAgICAgICAje2B2YWx1ZWAuZWFjaCB7IHx2fCBlbnVtLnlpZWxkIHYgfX1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSAje09wYWwudHJ5X2NvbnZlcnQgYHZhbHVlYCwgQXJyYXksIDp0b19hcnl9O1xuXG4gICAgICAgICAgICBpZiAoYXJyYXkgPT09IG5pbCkge1xuICAgICAgICAgICAgICAje2VudW0ueWllbGQgYHZhbHVlYH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgI3tgdmFsdWVgLmVhY2ggeyB8dnwgZW51bS55aWVsZCB2IH19O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZHJvcChuKVxuICAgICAgbiA9IGAkY29lcmNlX3RvKCN7bn0sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgaWYgbiA8IDBcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2F0dGVtcHQgdG8gZHJvcCBuZWdhdGl2ZSBzaXplJ1xuICAgICAgZW5kXG5cbiAgICAgIGN1cnJlbnRfc2l6ZSA9IGVudW1lcmF0b3Jfc2l6ZVxuICAgICAgc2V0X3NpemUgICAgID0gaWYgSW50ZWdlciA9PT0gY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICAgIG4gPCBjdXJyZW50X3NpemUgPyBuIDogY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgZW5kXG5cbiAgICAgIGRyb3BwZWQgPSAwXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBzZXRfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICBpZiBkcm9wcGVkIDwgblxuICAgICAgICAgIGRyb3BwZWQgKz0gMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBkcm9wX3doaWxlKCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IGRyb3Bfd2hpbGUgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIHN1Y2NlZWRpbmcgPSB0cnVlXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgaWYgc3VjY2VlZGluZ1xuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3MpO1xuXG4gICAgICAgICAgICBpZiAoJGZhbHN5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBzdWNjZWVkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBlbnVtX2ZvcihtZXRob2QgPSA6ZWFjaCwgKmFyZ3MsICZibG9jaylcbiAgICAgIHNlbGYuY2xhc3MuZm9yKHNlbGYsIG1ldGhvZCwgKmFyZ3MsICZibG9jaylcbiAgICBlbmRcblxuICAgIGFsaWFzIGZpbHRlciBmaW5kX2FsbFxuXG4gICAgZGVmIGZpbmRfYWxsKCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IHNlbGVjdCB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgICV4e1xuICAgICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFsaWFzIGZsYXRfbWFwIGNvbGxlY3RfY29uY2F0XG5cbiAgICBkZWYgZ3JlcChwYXR0ZXJuLCAmYmxvY2spXG4gICAgICBpZiBibG9ja1xuICAgICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShhcmdzKX0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAje3BhdHRlcm4gPT09IGBwYXJhbWB9O1xuXG4gICAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCBgT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKWB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGFyZ3MpfSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICN7cGF0dGVybiA9PT0gYHBhcmFtYH07XG5cbiAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAje2VudW0ueWllbGQgYHBhcmFtYH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYWxpYXMgbWFwIGNvbGxlY3RcblxuICAgIGFsaWFzIHNlbGVjdCBmaW5kX2FsbFxuXG4gICAgZGVmIHJlamVjdCgmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSByZWplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoJGZhbHN5KHZhbHVlKSkge1xuICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB0YWtlKG4pXG4gICAgICBuID0gYCRjb2VyY2VfdG8oI3tufSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICBpZiBuIDwgMFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byB0YWtlIG5lZ2F0aXZlIHNpemUnXG4gICAgICBlbmRcblxuICAgICAgY3VycmVudF9zaXplID0gZW51bWVyYXRvcl9zaXplXG4gICAgICBzZXRfc2l6ZSAgICAgPSBpZiBJbnRlZ2VyID09PSBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgICAgbiA8IGN1cnJlbnRfc2l6ZSA/IG4gOiBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICBlbmRcblxuICAgICAgdGFrZW4gPSAwXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBzZXRfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICBpZiB0YWtlbiA8IG5cbiAgICAgICAgICBlbnVtLnlpZWxkKCphcmdzKVxuICAgICAgICAgIHRha2VuICs9IDFcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJhaXNlIFN0b3BMYXp5RXJyb3JcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB0YWtlX3doaWxlKCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IHRha2Vfd2hpbGUgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICN7ZW51bS55aWVsZCgqYXJncyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICN7cmFpc2UgU3RvcExhenlFcnJvcn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFsaWFzIHRvX2VudW0gZW51bV9mb3JcblxuICAgIGRlZiBpbnNwZWN0XG4gICAgICBcIiM8I3tzZWxmLmNsYXNzfTogI3tAZW51bWVyYXRvci5pbnNwZWN0fT5cIlxuICAgIGVuZFxuICBlbmRcblxuICBjbGFzcyBBcml0aG1ldGljU2VxdWVuY2UgPCBzZWxmXG4gICAgIyBXZSBuZWVkIHRvIHN0dWIgdGhpcyBmb3IgdGhlIHRpbWUgYmVpbmdcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJpbmNsdWRlIiwiZm9yIiwic2VsZiIsImFsbG9jYXRlIiwiaW5pdGlhbGl6ZSIsImJsb2NrIiwiQG9iamVjdCIsIm5ldyIsIkBtZXRob2QiLCJAYXJncyIsIkBzaXplIiwiJHJldF9vcl8xIiwicmVzcG9uZF90bz8iLCIhIiwiZWFjaCIsIiRyZXRfb3JfMiIsIm5pbD8iLCJhcmdzIiwiZW1wdHk/IiwiKyIsIl9fc2VuZF9fIiwic2l6ZSIsImNhbGwiLCJ3aXRoX2luZGV4IiwiMCIsIm9mZnNldCIsImVudW1fZm9yIiwiZGVzdHJ1Y3R1cmUiLCJlYWNoX3dpdGhfaW5kZXgiLCJibG9ja19naXZlbj8iLCJpbnNwZWN0IiwicmVzdWx0IiwiYW55PyIsIltdIiwiMSIsIi0yIiwicmFpc2UiLCJAYmxvY2siLCJ5aWVsZGVyIiwieWllbGQiLCI8PCIsInZhbHVlcyIsIkBlbnVtZXJhdG9yIiwib2JqZWN0IiwiZWFjaF9hcmdzIiwibGF6eSIsImNvbGxlY3QiLCJlbnVtZXJhdG9yX3NpemUiLCJlbnVtJCIsImNvbGxlY3RfY29uY2F0IiwidiIsInRyeV9jb252ZXJ0IiwiZHJvcCIsIm4iLCI8IiwiY3VycmVudF9zaXplIiwic2V0X3NpemUiLCI9PT0iLCJkcm9wcGVkIiwiZHJvcF93aGlsZSIsInN1Y2NlZWRpbmciLCJtZXRob2QiLCJmaW5kX2FsbCIsImdyZXAiLCJwYXR0ZXJuIiwicmVqZWN0IiwidGFrZSIsInRha2VuIiwidGFrZV93aGlsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRUEsTUFBQUEsU0FBQUEsQ0FBUSxvQkFBUkEsQ0FBQTtBQUFBLEVBRUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUNFLFFBQUFDLFNBQUFBLENBQVEsMEJBQVJBLENBQUE7QUFBQSxJQUVDLHVDQUZEO0FBQUEsSUFJQUMsVUFBSUMsSUFBSkQsVUFBQUEsb0JBQUFBLFNBQWEsTUFBRCxFQVZkLEVBVWMsRUFWZCxFQVVFQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUFWRjtBQVU4QyxNQUFBLHdDQVY5QztBQUFBO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBVXVCLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxXQUFTLE1BQVQ7QUFBQSxNQUFBLENBVnZCO0FBQUE7QUFVdUMsTUFBQSxrQkFWdkM7QUFBQTtBQVlBLG9CQUFrQkUsVUFBQUEsQ0FBQUEsQ0FBUzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQXBCQTtBQVVFRixJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FKQTtBQUFBO0FBaUJBRyxJQUFBQSw4QkFBQUEsMkJBQUFBLHNCQXZCRixFQXVCRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBdkJGO0FBdUJvQixNQUFBLCtDQXZCcEI7QUFBQTtBQUFBLE1BQUEsNERBQUE7QUFBQSxNQUFBO0FBQUEsTUF3QkksSUFBQSxRQUFHQyxLQUFILENBQUE7QUFBQTtBQUNFLFFBQUFDLGNBQVVDLE1BQUEseUJBQUFBLE9BQUFBLEVBQUFBLEVBQUFB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QUE7O0FBQUFBO0FBQUFBLElBQUFBLEdBQUFBLFdBQUFBLEVBQTJCRyxJQUEzQkgsV0FwWUE7QUFERkEsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjExNTQyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9udW1lcmljLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcblxuY2xhc3MgTnVtZXJpY1xuICBpbmNsdWRlIENvbXBhcmFibGVcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgIGlmIG90aGVyLmluc3RhbmNlX29mPyBzZWxmLmNsYXNzXG4gICAgICByZXR1cm4gW290aGVyLCBzZWxmXVxuICAgIGVuZFxuXG4gICAgW0Zsb2F0KG90aGVyKSwgRmxvYXQoc2VsZildXG4gIGVuZFxuXG4gIGRlZiBfX2NvZXJjZWRfXyhtZXRob2QsIG90aGVyKVxuICAgIGlmIG90aGVyLnJlc3BvbmRfdG8/KDpjb2VyY2UpXG4gICAgICBhLCBiID0gb3RoZXIuY29lcmNlKHNlbGYpXG4gICAgICBhLl9fc2VuZF9fIG1ldGhvZCwgYlxuICAgIGVsc2VcbiAgICAgIGNhc2UgbWV0aG9kXG4gICAgICB3aGVuIDorLCA6LSwgOiosIDovLCA6JSwgOiYsIDp8LCA6XiwgOioqXG4gICAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCIje290aGVyLmNsYXNzfSBjYW4ndCBiZSBjb2VyY2VkIGludG8gTnVtZXJpY1wiXG4gICAgICB3aGVuIDo+LCA6Pj0sIDo8LCA6PD0sIDo8PT5cbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje290aGVyLmNsYXNzfSBmYWlsZWRcIlxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgaWYgZXF1YWw/IG90aGVyXG4gICAgICByZXR1cm4gMFxuICAgIGVuZFxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiArQFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIC1AXG4gICAgMCAtIHNlbGZcbiAgZW5kXG5cbiAgZGVmICUob3RoZXIpXG4gICAgc2VsZiAtIG90aGVyICogZGl2KG90aGVyKVxuICBlbmRcblxuICBkZWYgYWJzXG4gICAgc2VsZiA8IDAgPyAtc2VsZiA6IHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFiczJcbiAgICBzZWxmICogc2VsZlxuICBlbmRcblxuICBkZWYgYW5nbGVcbiAgICBzZWxmIDwgMCA/IE1hdGg6OlBJIDogMFxuICBlbmRcblxuICBhbGlhcyBhcmcgYW5nbGVcblxuICBkZWYgY2VpbChuZGlnaXRzID0gMClcbiAgICB0b19mLmNlaWwobmRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIGNvbmpcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIGNvbmp1Z2F0ZSBjb25qXG5cbiAgZGVmIGRlbm9taW5hdG9yXG4gICAgdG9fci5kZW5vbWluYXRvclxuICBlbmRcblxuICBkZWYgZGl2KG90aGVyKVxuICAgIHJhaXNlIFplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSBvJyBpZiBvdGhlciA9PSAwXG5cbiAgICAoc2VsZiAvIG90aGVyKS5mbG9vclxuICBlbmRcblxuICBkZWYgZGl2bW9kKG90aGVyKVxuICAgIFtkaXYob3RoZXIpLCBzZWxmICUgb3RoZXJdXG4gIGVuZFxuXG4gIGRlZiBmZGl2KG90aGVyKVxuICAgIHRvX2YgLyBvdGhlclxuICBlbmRcblxuICBkZWYgZmxvb3IobmRpZ2l0cyA9IDApXG4gICAgdG9fZi5mbG9vcihuZGlnaXRzKVxuICBlbmRcblxuICBkZWYgaVxuICAgIENvbXBsZXgoMCwgc2VsZilcbiAgZW5kXG5cbiAgZGVmIGltYWdcbiAgICAwXG4gIGVuZFxuXG4gIGFsaWFzIGltYWdpbmFyeSBpbWFnXG5cbiAgZGVmIGludGVnZXI/XG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgYWxpYXMgbWFnbml0dWRlIGFic1xuXG4gIGFsaWFzIG1vZHVsbyAlXG5cbiAgZGVmIG5vbnplcm8/XG4gICAgemVybz8gPyBuaWwgOiBzZWxmXG4gIGVuZFxuXG4gIGRlZiBudW1lcmF0b3JcbiAgICB0b19yLm51bWVyYXRvclxuICBlbmRcblxuICBhbGlhcyBwaGFzZSBhcmdcblxuICBkZWYgcG9sYXJcbiAgICBbYWJzLCBhcmddXG4gIGVuZFxuXG4gIGRlZiBxdW8ob3RoZXIpXG4gICAgT3BhbC5jb2VyY2VfdG8hKHNlbGYsIFJhdGlvbmFsLCA6dG9fcikgLyBvdGhlclxuICBlbmRcblxuICBkZWYgcmVhbFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJlYWw/XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgcmVjdFxuICAgIFtzZWxmLCAwXVxuICBlbmRcblxuICBhbGlhcyByZWN0YW5ndWxhciByZWN0XG5cbiAgZGVmIHJvdW5kKGRpZ2l0cyA9IHVuZGVmaW5lZClcbiAgICB0b19mLnJvdW5kKGRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIHRvX2NcbiAgICBDb21wbGV4KHNlbGYsIDApXG4gIGVuZFxuXG4gIGRlZiB0b19pbnRcbiAgICB0b19pXG4gIGVuZFxuXG4gIGRlZiB0cnVuY2F0ZShuZGlnaXRzID0gMClcbiAgICB0b19mLnRydW5jYXRlKG5kaWdpdHMpXG4gIGVuZFxuXG4gIGRlZiB6ZXJvP1xuICAgIHNlbGYgPT0gMFxuICBlbmRcblxuICBkZWYgcG9zaXRpdmU/XG4gICAgc2VsZiA+IDBcbiAgZW5kXG5cbiAgZGVmIG5lZ2F0aXZlP1xuICAgIHNlbGYgPCAwXG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjbG9uZShmcmVlemU6IHRydWUpXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZmluaXRlP1xuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmIGluZmluaXRlP1xuICAgIG5pbFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsImluY2x1ZGUiLCJjb2VyY2UiLCJvdGhlciIsImluc3RhbmNlX29mPyIsInNlbGYiLCJGbG9hdCIsIl9fY29lcmNlZF9fIiwicmVzcG9uZF90bz8iLCJhIiwiYiIsIl9fc2VuZF9fIiwibWV0aG9kIiwicmFpc2UiLCI8PT4iLCJlcXVhbD8iLCIwIiwiK0AiLCItQCIsIi0iLCIlIiwiKiIsImRpdiIsImFicyIsIjwiLCJhYnMyIiwiYW5nbGUiLCJjZWlsIiwidG9fZiIsIm5kaWdpdHMiLCJjb25qIiwiZGVub21pbmF0b3IiLCJ0b19yIiwiPT0iLCIvIiwiZmxvb3IiLCJkaXZtb2QiLCJmZGl2IiwiaSIsIkNvbXBsZXgiLCJpbWFnIiwiaW50ZWdlcj8iLCJub256ZXJvPyIsInplcm8/IiwibnVtZXJhdG9yIiwicG9sYXIiLCJhcmciLCJxdW8iLCJjb2VyY2VfdG8hIiwicmVhbCIsInJlYWw/IiwicmVjdCIsInJvdW5kIiwiZGlnaXRzIiwidG9fYyIsInRvX2ludCIsInRvX2kiLCJ0cnVuY2F0ZSIsInBvc2l0aXZlPyIsIj4iLCJuZWdhdGl2ZT8iLCJkdXAiLCJjbG9uZSIsImZpbml0ZT8iLCJpbmZpbml0ZT8iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsb0JBQVJBLENBQUE7QUFBQSxFQUVBLE9BQUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxTQUFBQSxDQUFRLDBCQUFSQSxDQUFBO0FBQUE7QUFFQUMsSUFBQUEsMEJBQUFBLG9CQUFBQSxrQkFBVyxLQUFYQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBLElBQUEsUUFBR0MsS0FBQUMsaUJBQUFBLENBQW1CQyxJQUFBTCxPQUFBQSxDQUFBQSxDQUFuQkksQ0FBSCxDQUFBO0FBQUEsUUFDRSxPQUFPLENBQUNELEtBQUQsRUFBUUUsSUFBUixDQURULENBQUE7QUFBQSxNQUlBLE9BQUEsS0FBQ0MsT0FBQUEsQ0FBTUgsS0FBTkcs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QUEsdUNBQUFBLENBQUFBLHFCQXBMQTtBQURGaEUsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjExODYxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9hcnJheS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgZmFsc3ksIGhhc2hfaWRzLCB5aWVsZDEsIGhhc2hfZ2V0LCBoYXNoX3B1dCwgaGFzaF9kZWxldGUsIGNvZXJjZV90bywgcmVzcG9uZF90b1xuXG5yZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG5yZXF1aXJlICdjb3JlbGliL251bWVyaWMnXG5cbmNsYXNzIEFycmF5IDwgYEFycmF5YFxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICAjIE1hcmsgYWxsIGphdmFzY3JpcHQgYXJyYXlzIGFzIGJlaW5nIHZhbGlkIHJ1YnkgYXJyYXlzXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2FycmF5JywgdHJ1ZSlgXG5cbiAgJXh7XG4gICAgLy8gUmVjZW50IHZlcnNpb25zIG9mIFY4ICg+IDcuMSkgb25seSB1c2UgYW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIHdoZW4gQXJyYXkucHJvdG90eXBlIGlzIHVubW9kaWZpZWQuXG4gICAgLy8gRm9yIGluc3RhbmNlLCBcImFycmF5LXNwbGljZS50cVwiIGhhcyBhIFwiZmFzdCBwYXRoXCIgKEV4dHJhY3RGYXN0SlNBcnJheSwgZGVmaW5lZCBpbiBcInNyYy9jb2RlZ2VuL2NvZGUtc3R1Yi1hc3NlbWJsZXIuY2NcIilcbiAgICAvLyBidXQgaXQncyBvbmx5IGVuYWJsZWQgd2hlbiBcIklzUHJvdG90eXBlSW5pdGlhbEFycmF5UHJvdG90eXBlKClcIiBpcyB0cnVlLlxuICAgIC8vXG4gICAgLy8gT2xkZXIgdmVyc2lvbnMgb2YgVjggd2VyZSB1c2luZyByZWxhdGl2ZWx5IGZhc3QgSlMtd2l0aC1leHRlbnNpb25zIGNvZGUgZXZlbiB3aGVuIEFycmF5LnByb3RvdHlwZSBpcyBtb2RpZmllZDpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdjgvdjgvYmxvYi83LjAuMS9zcmMvanMvYXJyYXkuanMjTDU5OS1MNjQyXG4gICAgLy9cbiAgICAvLyBJbiBzaG9ydCwgQXJyYXkgb3BlcmF0aW9ucyBhcmUgc2xvdyBpbiByZWNlbnQgdmVyc2lvbnMgb2YgVjggd2hlbiB0aGUgQXJyYXkucHJvdG90eXBlIGhhcyBiZWVuIHRhbXBlcmVkLlxuICAgIC8vIFNvLCB3aGVuIHBvc3NpYmxlLCB3ZSBhcmUgdXNpbmcgZmFzdGVyIG9wZW4tY29kZWQgdmVyc2lvbiB0byBib29zdCB0aGUgcGVyZm9ybWFuY2UuXG5cbiAgICAvLyBBcyBvZiBWOCA4LjQsIGRlcGVuZGluZyBvbiB0aGUgc2l6ZSBvZiB0aGUgYXJyYXksIHRoaXMgaXMgdXAgdG8gfjI1eCB0aW1lcyBmYXN0ZXIgdGhhbiBBcnJheSNzaGlmdCgpXG4gICAgLy8gSW1wbGVtZW50YXRpb24gaXMgaGVhdmlseSBpbnNwaXJlZCBieTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvYmE2ODQ4MDViNmMwZWRlZDc2ZTVjZDg5ZWUwMDMyOGFjN2E1OTM2NS9saWIvaW50ZXJuYWwvdXRpbC5qcyNMMzQxLUwzNDdcbiAgICBmdW5jdGlvbiBzaGlmdE5vQXJnKGxpc3QpIHtcbiAgICAgIHZhciByID0gbGlzdFswXTtcbiAgICAgIHZhciBpbmRleCA9IDE7XG4gICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgbGlzdFtpbmRleCAtIDFdID0gbGlzdFtpbmRleF07XG4gICAgICB9XG4gICAgICBsaXN0LnBvcCgpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheVN1YmNsYXNzKG9iaiwga2xhc3MpIHtcbiAgICAgIGlmIChrbGFzcy4kJG5hbWUgPT09IE9wYWwuQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrbGFzcy4kYWxsb2NhdGUoKS4kcmVwbGFjZSgje2BvYmpgLnRvX2F9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBIGhlbHBlciBmb3Iga2VlcF9pZiBhbmQgZGVsZXRlX2lmLCBmaWx0ZXIgaXMgZWl0aGVyIE9wYWwudHJ1dGh5XG4gICAgLy8gb3IgT3BhbC5mYWxzeS5cbiAgICBmdW5jdGlvbiBmaWx0ZXJJZihzZWxmLCBmaWx0ZXIsIGJsb2NrKSB7XG4gICAgICB2YXIgdmFsdWUsIHJhaXNlZCA9IG51bGwsIHVwZGF0ZWQgPSBuZXcgQXJyYXkoc2VsZi5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaTIgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghcmFpc2VkKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSlcbiAgICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICByYWlzZWQgPSBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmFpc2VkIHx8IGZpbHRlcih2YWx1ZSkpIHtcbiAgICAgICAgICB1cGRhdGVkW2kyXSA9IHNlbGZbaV1cbiAgICAgICAgICBpMiArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpMiAhPT0gaSkge1xuICAgICAgICBzZWxmLnNwbGljZS5hcHBseShzZWxmLCBbMCwgdXBkYXRlZC5sZW5ndGhdLmNvbmNhdCh1cGRhdGVkKSk7XG4gICAgICAgIHNlbGYuc3BsaWNlKGkyLCB1cGRhdGVkLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyYWlzZWQpIHRocm93IHJhaXNlZDtcbiAgICB9XG4gIH1cblxuICBkZWYgc2VsZi5bXSgqb2JqZWN0cylcbiAgICBgdG9BcnJheVN1YmNsYXNzKG9iamVjdHMsIHNlbGYpYFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShzaXplID0gbmlsLCBvYmogPSBuaWwsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChvYmogIT09IG5pbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogYmxvY2sgc3VwZXJzZWRlcyBkZWZhdWx0IHZhbHVlIGFyZ3VtZW50Jyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaXplID4gI3tJbnRlZ2VyOjpNQVh9KSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2FycmF5IHNpemUgdG9vIGJpZyd9XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4yKVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoc2l6ZS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgI3tyZXBsYWNlKHNpemUudG9fYSl9XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0gZWxzZSBpZiAoI3tzaXplLnJlc3BvbmRfdG8/IDp0b19hcnl9KSB7XG4gICAgICAgICAgI3tyZXBsYWNlKHNpemUudG9fYXJ5KX1cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzaXplID0gJGNvZXJjZV90byhzaXplLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ31cbiAgICAgIH1cblxuICAgICAgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpO1xuICAgICAgdmFyIGksIHZhbHVlO1xuXG4gICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgc2VsZi5wdXNoKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwLCB2YWx1ZTsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgIHZhbHVlID0gYmxvY2soaSk7XG4gICAgICAgICAgc2VsZltpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQob2JqKVxuICAgIE9wYWwuY29lcmNlX3RvPyBvYmosIEFycmF5LCA6dG9fYXJ5XG4gIGVuZFxuXG4gIGRlZiAmKG90aGVyKVxuICAgIG90aGVyID0gaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob3RoZXIsICN7QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvdGhlci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAkaGFzaF9wdXQoaGFzaCwgb3RoZXJbaV0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICBpZiAoJGhhc2hfZGVsZXRlKGhhc2gsIGl0ZW0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgb3RoZXIgPSBpZiBBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3tBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAkaGFzaF9wdXQoaGFzaCwgc2VsZltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBvdGhlcltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoLiRrZXlzKCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICByZXR1cm4gam9pbihvdGhlci50b19zdHIpIGlmIG90aGVyLnJlc3BvbmRfdG8/IDp0b19zdHJcblxuICAgIG90aGVyID0gYCRjb2VyY2VfdG8ob3RoZXIsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgIGlmIGBvdGhlciA8IDBgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJndW1lbnQnXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBjb252ZXJ0ZWQgPSAje3RvX2F9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChjb252ZXJ0ZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9BcnJheVN1YmNsYXNzKHJlc3VsdCwgI3tzZWxmLmNsYXNzfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgKyhvdGhlcilcbiAgICBvdGhlciA9IGlmIEFycmF5ID09PSBvdGhlclxuICAgICAgICAgICAgICBvdGhlci50b19hXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGAkY29lcmNlX3RvKG90aGVyLCAje0FycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgIGBzZWxmLmNvbmNhdChvdGhlcilgXG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgIG90aGVyID0gaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob3RoZXIsICN7QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgcmV0dXJuIFtdIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgICByZXR1cm4gYHNlbGYuc2xpY2UoKWAgaWYgYG90aGVyLmxlbmd0aCA9PT0gMGBcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb3RoZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIG90aGVyW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgaWYgKCRoYXNoX2dldChoYXNoLCBpdGVtKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PChvYmplY3QpXG4gICAgYHNlbGYucHVzaChvYmplY3QpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGlmIEFycmF5ID09PSBvdGhlclxuICAgICAgb3RoZXIgPSBvdGhlci50b19hXG4gICAgZWxzaWYgb3RoZXIucmVzcG9uZF90bz8gOnRvX2FyeVxuICAgICAgb3RoZXIgPSBvdGhlci50b19hcnkudG9fYVxuICAgIGVsc2VcbiAgICAgIHJldHVyblxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoI3toYXNofSA9PT0gI3tvdGhlci5oYXNofSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvdW50ID0gTWF0aC5taW4oc2VsZi5sZW5ndGgsIG90aGVyLmxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgdG1wID0gI3tgc2VsZltpXWAgPD0+IGBvdGhlcltpXWB9O1xuXG4gICAgICAgIGlmICh0bXAgIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje2BzZWxmLmxlbmd0aGAgPD0+IGBvdGhlci5sZW5ndGhgfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciByZWN1cnNlZCA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBfZXFlcShhcnJheSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIGksIGxlbmd0aCwgYSwgYjtcblxuICAgICAgICBpZiAoYXJyYXkgPT09IG90aGVyKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGlmICghb3RoZXIuJCRpc19hcnJheSkge1xuICAgICAgICAgIGlmICgkcmVzcG9uZF90byhvdGhlciwgJyR0b19hcnknKSkge1xuICAgICAgICAgICAgcmV0dXJuICN7YG90aGVyYCA9PSBgYXJyYXlgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcnJheS4kJGNvbnN0cnVjdG9yICE9PSBBcnJheSlcbiAgICAgICAgICBhcnJheSA9ICN7YGFycmF5YC50b19hfTtcbiAgICAgICAgaWYgKG90aGVyLiQkY29uc3RydWN0b3IgIT09IEFycmF5KVxuICAgICAgICAgIG90aGVyID0gI3tgb3RoZXJgLnRvX2F9O1xuXG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2VkWyN7YGFycmF5YC5vYmplY3RfaWR9XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhID0gYXJyYXlbaV07XG4gICAgICAgICAgYiA9IG90aGVyW2ldO1xuICAgICAgICAgIGlmIChhLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChiLiQkaXNfYXJyYXkgJiYgYi5sZW5ndGggIT09IGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQuaGFzT3duUHJvcGVydHkoI3tgYWAub2JqZWN0X2lkfSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFfZXFlcShhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgID09IGBiYH0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxZXEoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gJGFycmF5X3NsaWNlX3JhbmdlKHNlbGYsIGluZGV4KSB7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIGV4Y2x1ZGUsIGZyb20sIHRvLCByZXN1bHQ7XG5cbiAgICAgIGV4Y2x1ZGUgPSBpbmRleC5leGNsO1xuICAgICAgZnJvbSAgICA9ICRjb2VyY2VfdG8oaW5kZXguYmVnaW4sIE9wYWwuSW50ZWdlciwgJ3RvX2ludCcpO1xuICAgICAgdG8gICAgICA9ICRjb2VyY2VfdG8oaW5kZXguZW5kLCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcblxuICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgIGZyb20gKz0gc2l6ZTtcblxuICAgICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmcm9tID4gc2l6ZSkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICBpZiAodG8gPCAwKSB7XG4gICAgICAgIHRvICs9IHNpemU7XG5cbiAgICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWV4Y2x1ZGUpIHtcbiAgICAgICAgdG8gKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZShmcm9tLCB0byk7XG4gICAgICByZXR1cm4gdG9BcnJheVN1YmNsYXNzKHJlc3VsdCwgc2VsZi4kY2xhc3MoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJGFycmF5X3NsaWNlX2luZGV4X2xlbmd0aChzZWxmLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIGV4Y2x1ZGUsIGZyb20sIHRvLCByZXN1bHQ7XG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2l6ZTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDAgfHwgaW5kZXggPiBzaXplIHx8IGluZGV4IDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9BcnJheVN1YmNsYXNzKHJlc3VsdCwgc2VsZi4kY2xhc3MoKSk7XG4gICAgfVxuICB9XG5cbiAgZGVmIFtdKGluZGV4LCBsZW5ndGggPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoaW5kZXguJCRpc19yYW5nZSkge1xuICAgICAgICByZXR1cm4gJGFycmF5X3NsaWNlX3JhbmdlKHNlbGYsIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJGFycmF5X3NsaWNlX2luZGV4X2xlbmd0aChzZWxmLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXT0oaW5kZXgsIHZhbHVlLCBleHRyYSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBpLCBzaXplID0gc2VsZi5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgUmFuZ2UgPT09IGluZGV4XG4gICAgICBkYXRhID0gaWYgQXJyYXkgPT09IHZhbHVlXG4gICAgICAgICAgICAgICB2YWx1ZS50b19hXG4gICAgICAgICAgICAgZWxzaWYgdmFsdWUucmVzcG9uZF90bz8gOnRvX2FyeVxuICAgICAgICAgICAgICAgdmFsdWUudG9fYXJ5LnRvX2FcbiAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICBbdmFsdWVdXG4gICAgICAgICAgICAgZW5kXG5cbiAgICAgICV4e1xuICAgICAgICB2YXIgZXhjbHVkZSA9IGluZGV4LmV4Y2wsXG4gICAgICAgICAgICBmcm9tICAgID0gJGNvZXJjZV90byhpbmRleC5iZWdpbiwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpLFxuICAgICAgICAgICAgdG8gICAgICA9ICRjb2VyY2VfdG8oaW5kZXguZW5kLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgICAgZnJvbSArPSBzaXplO1xuXG4gICAgICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgICAgICAje3JhaXNlIFJhbmdlRXJyb3IsIFwiI3tpbmRleC5pbnNwZWN0fSBvdXQgb2YgcmFuZ2VcIn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICAgIHRvICs9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV4Y2x1ZGUpIHtcbiAgICAgICAgICB0byArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyb20gPiBzaXplKSB7XG4gICAgICAgICAgZm9yIChpID0gc2l6ZTsgaSA8IGZyb207IGkrKykge1xuICAgICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG8gPCAwKSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2Zyb20sIDBdLmNvbmNhdChkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2Zyb20sIHRvIC0gZnJvbV0uY29uY2F0KGRhdGEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBpZiBgZXh0cmEgPT09IHVuZGVmaW5lZGBcbiAgICAgICAgbGVuZ3RoID0gMVxuICAgICAgZWxzZVxuICAgICAgICBsZW5ndGggPSB2YWx1ZVxuICAgICAgICB2YWx1ZSAgPSBleHRyYVxuXG4gICAgICAgIGRhdGEgPSBpZiBBcnJheSA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgICAgdmFsdWUudG9fYVxuICAgICAgICAgICAgICAgZWxzaWYgdmFsdWUucmVzcG9uZF90bz8gOnRvX2FyeVxuICAgICAgICAgICAgICAgICB2YWx1ZS50b19hcnkudG9fYVxuICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICBbdmFsdWVdXG4gICAgICAgICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICAleHtcbiAgICAgICAgdmFyIG9sZDtcblxuICAgICAgICBpbmRleCAgPSAkY29lcmNlX3RvKGluZGV4LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGxlbmd0aCA9ICRjb2VyY2VfdG8obGVuZ3RoLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIG9sZCAgICA9IGluZGV4O1xuICAgICAgICAgIGluZGV4ICs9IHNpemU7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAje3JhaXNlIEluZGV4RXJyb3IsIFwiaW5kZXggI3tgb2xkYH0gdG9vIHNtYWxsIGZvciBhcnJheTsgbWluaW11bSAje2Atc2VsZi5sZW5ndGhgfVwifTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICN7cmFpc2UgSW5kZXhFcnJvciwgXCJuZWdhdGl2ZSBsZW5ndGggKCN7bGVuZ3RofSlcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA+IHNpemUpIHtcbiAgICAgICAgICBmb3IgKGkgPSBzaXplOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0cmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNlbGZbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2luZGV4LCBsZW5ndGhdLmNvbmNhdChkYXRhKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBhbnk/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBgaWYgKHNlbGYubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2VgXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIGFzc29jKG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpdGVtID0gc2VsZltpXSwgaXRlbS5sZW5ndGggJiYgI3tgaXRlbVswXWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXQoaW5kZXgpXG4gICAgJXh7XG4gICAgICBpbmRleCA9ICRjb2VyY2VfdG8oaW5kZXgsICN7SW50ZWdlcn0sICd0b19pbnQnKVxuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBic2VhcmNoX2luZGV4KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmJzZWFyY2hfaW5kZXggdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gMCxcbiAgICAgICAgICBtYXggPSBzZWxmLmxlbmd0aCxcbiAgICAgICAgICBtaWQsXG4gICAgICAgICAgdmFsLFxuICAgICAgICAgIHJldCxcbiAgICAgICAgICBzbWFsbGVyID0gZmFsc2UsXG4gICAgICAgICAgc2F0aXNmaWVkID0gbmlsO1xuXG4gICAgICB3aGlsZSAobWluIDwgbWF4KSB7XG4gICAgICAgIG1pZCA9IG1pbiArIE1hdGguZmxvb3IoKG1heCAtIG1pbikgLyAyKTtcbiAgICAgICAgdmFsID0gc2VsZlttaWRdO1xuICAgICAgICByZXQgPSAkeWllbGQxKGJsb2NrLCB2YWwpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IHRydWUpIHtcbiAgICAgICAgICBzYXRpc2ZpZWQgPSBtaWQ7XG4gICAgICAgICAgc21hbGxlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmV0ID09PSBmYWxzZSB8fCByZXQgPT09IG5pbCkge1xuICAgICAgICAgIHNtYWxsZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXQuJCRpc19udW1iZXIpIHtcbiAgICAgICAgICBpZiAocmV0ID09PSAwKSB7IHJldHVybiBtaWQ7IH1cbiAgICAgICAgICBzbWFsbGVyID0gKHJldCA8IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgcmV0YC5jbGFzc30gKG11c3QgYmUgbnVtZXJpYywgdHJ1ZSwgZmFsc2Ugb3IgbmlsKVwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNtYWxsZXIpIHsgbWF4ID0gbWlkOyB9IGVsc2UgeyBtaW4gPSBtaWQgKyAxOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzYXRpc2ZpZWQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnNlYXJjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDpic2VhcmNoIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGluZGV4ID0gYnNlYXJjaF9pbmRleCgmYmxvY2spXG5cbiAgICAleHtcbiAgICAgIGlmIChpbmRleCAhPSBudWxsICYmIGluZGV4LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjeWNsZShuID0gbmlsLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpjeWNsZSwgbikgZG9cbiAgICAgICAgaWYgbi5uaWw/XG4gICAgICAgICAgRmxvYXQ6OklORklOSVRZXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBuID0gT3BhbC5jb2VyY2VfdG8hKG4sIEludGVnZXIsIDp0b19pbnQpXG4gICAgICAgICAgbiA+IDAgPyBlbnVtZXJhdG9yX3NpemUgKiBuIDogMFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgcmV0dXJuIGlmIGVtcHR5PyB8fCBuID09IDBcblxuICAgICV4e1xuICAgICAgdmFyIGksIGxlbmd0aCwgdmFsdWU7XG5cbiAgICAgIGlmIChuID09PSBuaWwpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG4gPSAje09wYWwuY29lcmNlX3RvIShuLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xlYXJcbiAgICBgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY291bnQob2JqZWN0ID0gbmlsLCAmYmxvY2spXG4gICAgaWYgb2JqZWN0IHx8IGJsb2NrXG4gICAgICBzdXBlclxuICAgIGVsc2VcbiAgICAgIHNpemVcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgICByZXBsYWNlIG90aGVyXG4gIGVuZFxuXG4gIGRlZiBjb2xsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICBzZWxmW2ldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICAleHtcbiAgICBmdW5jdGlvbiBiaW5vbWlhbF9jb2VmZmljaWVudChuLCBrKSB7XG4gICAgICBpZiAobiA9PT0gayB8fCBrID09PSAwKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoayA+IDAgJiYgbiA+IGspIHtcbiAgICAgICAgcmV0dXJuIGJpbm9taWFsX2NvZWZmaWNpZW50KG4gLSAxLCBrIC0gMSkgKyBiaW5vbWlhbF9jb2VmZmljaWVudChuIC0gMSwgayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBjb21iaW5hdGlvbihuKVxuICAgIG51bSA9IE9wYWwuY29lcmNlX3RvISBuLCBJbnRlZ2VyLCA6dG9faW50XG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb21iaW5hdGlvbiwgbnVtKSB7IGBiaW5vbWlhbF9jb2VmZmljaWVudCgje3NlbGZ9Lmxlbmd0aCwgbnVtKWAgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW5ndGgsIHN0YWNrLCBjaG9zZW4sIGxldiwgZG9uZSwgbmV4dDtcblxuICAgICAgaWYgKG51bSA9PT0gMCkge1xuICAgICAgICAje3lpZWxkIFtdfVxuICAgICAgfSBlbHNlIGlmIChudW0gPT09IDEpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICN7eWllbGQgYFtzZWxmW2ldXWB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA9PT0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgI3t5aWVsZCBgc2VsZi5zbGljZSgpYH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA+PSAwICYmIG51bSA8IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHN0YWNrID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPD0gbnVtICsgMTsgaSsrKSB7XG4gICAgICAgICAgc3RhY2sucHVzaCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNob3NlbiA9IFtdO1xuICAgICAgICBsZXYgPSAwO1xuICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIHN0YWNrWzBdID0gLTE7XG5cbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgY2hvc2VuW2xldl0gPSBzZWxmW3N0YWNrW2xldisxXV07XG4gICAgICAgICAgd2hpbGUgKGxldiA8IG51bSAtIDEpIHtcbiAgICAgICAgICAgIGxldisrO1xuICAgICAgICAgICAgbmV4dCA9IHN0YWNrW2xldisxXSA9IHN0YWNrW2xldl0gKyAxO1xuICAgICAgICAgICAgY2hvc2VuW2xldl0gPSBzZWxmW25leHRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAjeyB5aWVsZCBgY2hvc2VuLnNsaWNlKClgIH1cbiAgICAgICAgICBsZXYrKztcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBkb25lID0gKGxldiA9PT0gMCk7XG4gICAgICAgICAgICBzdGFja1tsZXZdKys7XG4gICAgICAgICAgICBsZXYtLTtcbiAgICAgICAgICB9IHdoaWxlICggc3RhY2tbbGV2KzFdICsgbnVtID09PSBzZWxmLmxlbmd0aCArIGxldiArIDEgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXBlYXRlZF9jb21iaW5hdGlvbihuKVxuICAgIG51bSA9IE9wYWwuY29lcmNlX3RvISBuLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnJlcGVhdGVkX2NvbWJpbmF0aW9uLCBudW0pIHsgYGJpbm9taWFsX2NvZWZmaWNpZW50KHNlbGYubGVuZ3RoICsgbnVtIC0gMSwgbnVtKWAgfVxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBpdGVyYXRlKG1heCwgZnJvbSwgYnVmZmVyLCBzZWxmKSB7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IG1heCkge1xuICAgICAgICAgIHZhciBjb3B5ID0gYnVmZmVyLnNsaWNlKCk7XG4gICAgICAgICAgI3t5aWVsZCBgY29weWB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKHNlbGZbaV0pO1xuICAgICAgICAgIGl0ZXJhdGUobWF4LCBpLCBidWZmZXIsIHNlbGYpO1xuICAgICAgICAgIGJ1ZmZlci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobnVtID49IDApIHtcbiAgICAgICAgaXRlcmF0ZShudW0sIDAsIFtdLCBzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY29tcGFjdFxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKGl0ZW0gPSBzZWxmW2ldKSAhPT0gbmlsKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0IVxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsID0gc2VsZi5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmW2ldID09PSBuaWwpIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsID8gbmlsIDogc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb25jYXQoKm90aGVycylcbiAgICBvdGhlcnMgPSBvdGhlcnMubWFwIGRvIHxvdGhlcnxcbiAgICAgIG90aGVyID0gaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob3RoZXIsICN7QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgICAgZW5kXG5cbiAgICAgIGlmIG90aGVyLmVxdWFsPyhzZWxmKVxuICAgICAgICBvdGhlciA9IG90aGVyLmR1cFxuICAgICAgZW5kXG5cbiAgICAgIG90aGVyXG4gICAgZW5kXG5cbiAgICBvdGhlcnMuZWFjaCBkbyB8b3RoZXJ8XG4gICAgICAleHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc2VsZi5wdXNoKG90aGVyW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZGVsZXRlKG9iamVjdClcbiAgICAleHtcbiAgICAgIHZhciBvcmlnaW5hbCA9IHNlbGYubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb3JpZ2luYWw7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoI3tgc2VsZltpXWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgIHNlbGYuc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gb3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKCN7YmxvY2tfZ2l2ZW4/fSkge1xuICAgICAgICAgIHJldHVybiAje3lpZWxkfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfYXQoaW5kZXgpXG4gICAgJXh7XG4gICAgICBpbmRleCA9ICRjb2VyY2VfdG8oaW5kZXgsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gc2VsZltpbmRleF07XG5cbiAgICAgIHNlbGYuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfaWYoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZGVsZXRlX2lmKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgJXh7ZmlsdGVySWYoc2VsZiwgJGZhbHN5LCBibG9jayl9XG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBkaWZmZXJlbmNlIC1cblxuICBkZWYgZGlnKGlkeCwgKmlkeHMpXG4gICAgaXRlbSA9IHNlbGZbaWR4XVxuXG4gICAgJXh7XG4gICAgICBpZiAoaXRlbSA9PT0gbmlsIHx8IGlkeHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVubGVzcyBpdGVtLnJlc3BvbmRfdG8/KDpkaWcpXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwiI3tpdGVtLmNsYXNzfSBkb2VzIG5vdCBoYXZlICNkaWcgbWV0aG9kXCJcbiAgICBlbmRcblxuICAgIGl0ZW0uZGlnKCppZHhzKVxuICBlbmRcblxuICBkZWYgZHJvcChudW1iZXIpXG4gICAgJXh7XG4gICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3J9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLnNsaWNlKG51bWJlcik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGNsYXNzID09PSBPcGFsLkFycmF5ICYmXG4gICAgICAgICAgc2VsZi4kJGNsYXNzLiRhbGxvY2F0ZS4kJHByaXN0aW5lICYmXG4gICAgICAgICAgc2VsZi4kY29weV9pbnN0YW5jZV92YXJpYWJsZXMuJCRwcmlzdGluZSAmJlxuICAgICAgICAgIHNlbGYuJGluaXRpYWxpemVfZHVwLiQkcHJpc3RpbmUpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2luZGV4KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfaW5kZXgpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkMShibG9jaywgaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgYHNlbGYubGVuZ3RoID09PSAwYFxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciByZWN1cnNlZCA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBfZXFsKGFycmF5LCBvdGhlcikge1xuICAgICAgICB2YXIgaSwgbGVuZ3RoLCBhLCBiO1xuXG4gICAgICAgIGlmICghb3RoZXIuJCRpc19hcnJheSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyID0gI3tvdGhlci50b19hfTtcblxuICAgICAgICBpZiAoYXJyYXkubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZWN1cnNlZFsje2BhcnJheWAub2JqZWN0X2lkfV0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYSA9IGFycmF5W2ldO1xuICAgICAgICAgIGIgPSBvdGhlcltpXTtcbiAgICAgICAgICBpZiAoYS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgICBpZiAoYi4kJGlzX2FycmF5ICYmIGIubGVuZ3RoICE9PSBhLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlY3Vyc2VkLmhhc093blByb3BlcnR5KCN7YGFgLm9iamVjdF9pZH0pKSB7XG4gICAgICAgICAgICAgIGlmICghX2VxbChhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgLmVxbD8oYGJgKX0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxbChzZWxmLCBvdGhlcik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZmV0Y2goaW5kZXgsIGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWwgPSBpbmRleDtcblxuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGZbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCAmJiBkZWZhdWx0cyAhPSBudWxsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogYmxvY2sgc3VwZXJzZWRlcyBkZWZhdWx0IHZhbHVlIGFyZ3VtZW50Jyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBibG9jayhvcmlnaW5hbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0cyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICN7cmFpc2UgSW5kZXhFcnJvciwgXCJpbmRleCAje2BvcmlnaW5hbGB9IG91dHNpZGUgb2YgYXJyYXkgYm91bmRzOiAwLi4uMFwifVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7cmFpc2UgSW5kZXhFcnJvciwgXCJpbmRleCAje2BvcmlnaW5hbGB9IG91dHNpZGUgb2YgYXJyYXkgYm91bmRzOiAtI3tgc2VsZi5sZW5ndGhgfS4uLiN7YHNlbGYubGVuZ3RoYH1cIn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZmlsbCgqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGksIGxlbmd0aCwgdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgYmxvY2tcbiAgICAgIGlmIGBhcmdzLmxlbmd0aCA+IDJgXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLmxlbmd0aH0gZm9yIDAuLjIpXCJcbiAgICAgIGVuZFxuXG4gICAgICBvbmUsIHR3byA9IGFyZ3NcbiAgICBlbHNlXG4gICAgICBpZiBgYXJncy5sZW5ndGggPT0gMGBcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDEuLjMpJ1xuICAgICAgZWxzaWYgYGFyZ3MubGVuZ3RoID4gM2BcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2FyZ3MubGVuZ3RofSBmb3IgMS4uMylcIlxuICAgICAgZW5kXG5cbiAgICAgIG9iaiwgb25lLCB0d28gPSBhcmdzXG4gICAgZW5kXG5cbiAgICBpZiBSYW5nZSA9PT0gb25lXG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdsZW5ndGggaW52YWxpZCB3aXRoIHJhbmdlJyBpZiB0d29cblxuICAgICAgbGVmdCAgID0gYCRjb2VyY2VfdG8ob25lLmJlZ2luLCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBgbGVmdCArPSB0aGlzLmxlbmd0aGAgaWYgYGxlZnQgPCAwYFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgXCIje29uZS5pbnNwZWN0fSBvdXQgb2YgcmFuZ2VcIiBpZiBgbGVmdCA8IDBgXG5cbiAgICAgIHJpZ2h0ID0gYCRjb2VyY2VfdG8ob25lLmVuZCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgYHJpZ2h0ICs9IHRoaXMubGVuZ3RoYCBpZiBgcmlnaHQgPCAwYFxuICAgICAgYHJpZ2h0ICs9IDFgIHVubGVzcyBvbmUuZXhjbHVkZV9lbmQ/XG5cbiAgICAgIHJldHVybiBzZWxmIGlmIGByaWdodCA8PSBsZWZ0YFxuICAgIGVsc2lmIG9uZVxuICAgICAgbGVmdCAgID0gYCRjb2VyY2VfdG8ob25lLCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBgbGVmdCArPSB0aGlzLmxlbmd0aGAgaWYgYGxlZnQgPCAwYFxuICAgICAgbGVmdCAgID0gMCBpZiBgbGVmdCA8IDBgXG5cbiAgICAgIGlmIHR3b1xuICAgICAgICByaWdodCA9IGAkY29lcmNlX3RvKHR3bywgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICAgIHJldHVybiBzZWxmIGlmIGByaWdodCA9PSAwYFxuXG4gICAgICAgIGByaWdodCArPSBsZWZ0YFxuICAgICAgZWxzZVxuICAgICAgICByaWdodCA9IGB0aGlzLmxlbmd0aGBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGxlZnQgID0gMFxuICAgICAgcmlnaHQgPSBgdGhpcy5sZW5ndGhgXG4gICAgZW5kXG5cbiAgICBpZiBgbGVmdCA+IHRoaXMubGVuZ3RoYFxuICAgICAgJXh7XG4gICAgICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoOyBpIDwgcmlnaHQ7IGkrKykge1xuICAgICAgICAgIHNlbGZbaV0gPSBuaWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGlmIGByaWdodCA+IHRoaXMubGVuZ3RoYFxuICAgICAgYHRoaXMubGVuZ3RoID0gcmlnaHRgXG4gICAgZW5kXG5cbiAgICBpZiBibG9ja1xuICAgICAgJXh7XG4gICAgICAgIGZvciAobGVuZ3RoID0gdGhpcy5sZW5ndGg7IGxlZnQgPCByaWdodDsgbGVmdCsrKSB7XG4gICAgICAgICAgdmFsdWUgPSBibG9jayhsZWZ0KTtcbiAgICAgICAgICBzZWxmW2xlZnRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICAleHtcbiAgICAgICAgZm9yIChsZW5ndGggPSB0aGlzLmxlbmd0aDsgbGVmdCA8IHJpZ2h0OyBsZWZ0KyspIHtcbiAgICAgICAgICBzZWxmW2xlZnRdID0gI3tvYmp9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmaXJzdChjb3VudCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChjb3VudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gMCA/IG5pbCA6IHNlbGZbMF07XG4gICAgICB9XG5cbiAgICAgIGNvdW50ID0gJGNvZXJjZV90byhjb3VudCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoMCwgY291bnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZsYXR0ZW4obGV2ZWwgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBfZmxhdHRlbihhcnJheSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuZ3RoLFxuICAgICAgICAgICAgaXRlbSwgYXJ5O1xuXG4gICAgICAgIGFycmF5ID0gI3tgYXJyYXlgLnRvX2F9O1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IGFycmF5W2ldO1xuXG4gICAgICAgICAgaWYgKCEkcmVzcG9uZF90byhpdGVtLCAnJHRvX2FyeScsIHRydWUpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFyeSA9ICN7YGl0ZW1gLnRvX2FyeX07XG5cbiAgICAgICAgICBpZiAoYXJ5ID09PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFhcnkuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3J9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhcnkgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvcn07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChfZmxhdHRlbihhcnkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFyeSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBfZmxhdHRlbihhcnksIGxldmVsIC0gMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXZlbCA9ICRjb2VyY2VfdG8obGV2ZWwsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvQXJyYXlTdWJjbGFzcyhfZmxhdHRlbihzZWxmLCBsZXZlbCksICN7c2VsZi5jbGFzc30pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZsYXR0ZW4hKGxldmVsID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIGZsYXR0ZW5lZCA9ICN7ZmxhdHRlbiBsZXZlbH07XG5cbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PSBmbGF0dGVuZWQubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHNlbGZbaV0gIT09IGZsYXR0ZW5lZFtpXSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAje3JlcGxhY2UgYGZsYXR0ZW5lZGB9O1xuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICAleHtcbiAgICAgIHZhciB0b3AgPSAoJGhhc2hfaWRzID09PSB1bmRlZmluZWQpLFxuICAgICAgICAgIHJlc3VsdCA9IFsnQSddLFxuICAgICAgICAgIGhhc2hfaWQgPSBzZWxmLiRvYmplY3RfaWQoKSxcbiAgICAgICAgICBpdGVtLCBpLCBrZXk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAkaGFzaF9pZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIGVhcmx5IGZvciByZWN1cnNpdmUgc3RydWN0dXJlc1xuICAgICAgICBpZiAoJGhhc2hfaWRzW2hhc2hfaWRdKSB7XG4gICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluICRoYXNoX2lkcykge1xuICAgICAgICAgIGl0ZW0gPSAkaGFzaF9pZHNba2V5XTtcbiAgICAgICAgICBpZiAoI3tlcWw/KGBpdGVtYCl9KSB7XG4gICAgICAgICAgICByZXR1cm4gJ3NlbGYnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICRoYXNoX2lkc1toYXNoX2lkXSA9IHNlbGY7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtLiRoYXNoKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcsJyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgJGhhc2hfaWRzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5jbHVkZT8obWVtYmVyKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IG1lbWJlcn0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5kZXgob2JqZWN0ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZTtcblxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICgje2BzZWxmW2ldYCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhbHVlID0gYmxvY2soc2VsZltpXSk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT09IGZhbHNlICYmIHZhbHVlICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje2VudW1fZm9yIDppbmRleH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zZXJ0KGluZGV4LCAqb2JqZWN0cylcbiAgICAleHtcbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAob2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBpbmRleCArPSBzZWxmLmxlbmd0aCArIDE7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAjeyByYWlzZSBJbmRleEVycm9yLCBcIiN7aW5kZXh9IGlzIG91dCBvZiBib3VuZHNcIiB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPiBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSBzZWxmLmxlbmd0aDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIHNlbGYucHVzaChuaWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtpbmRleCwgMF0uY29uY2F0KG9iamVjdHMpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgaWQgICAgID0gI3tfX2lkX199O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaXRlbSA9ICN7c2VsZltgaWBdfTtcblxuICAgICAgICBpZiAoI3tgaXRlbWAuX19pZF9ffSA9PT0gaWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgnWy4uLl0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgje2BpdGVtYC5pbnNwZWN0fSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdbJyArIHJlc3VsdC5qb2luKCcsICcpICsgJ10nO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgaW50ZXJzZWN0aW9uICZcblxuICBkZWYgam9pbihzZXAgPSBuaWwpXG4gICAgcmV0dXJuICcnIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcblxuICAgIGlmIGBzZXAgPT09IG5pbGBcbiAgICAgIHNlcCA9ICQsXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBpLCBsZW5ndGgsIGl0ZW0sIHRtcDtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICBpZiAoJHJlc3BvbmRfdG8oaXRlbSwgJyR0b19zdHInKSkge1xuICAgICAgICAgIHRtcCA9ICN7YGl0ZW1gLnRvX3N0cn07XG5cbiAgICAgICAgICBpZiAodG1wICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCN7YHRtcGAudG9fc30pO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJHJlc3BvbmRfdG8oaXRlbSwgJyR0b19hcnknKSkge1xuICAgICAgICAgIHRtcCA9ICN7YGl0ZW1gLnRvX2FyeX07XG5cbiAgICAgICAgICBpZiAodG1wID09PSBzZWxmKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3J9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0bXAgIT09IG5pbCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goI3tgdG1wYC5qb2luKHNlcCl9KTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRyZXNwb25kX3RvKGl0ZW0sICckdG9fcycpKSB7XG4gICAgICAgICAgdG1wID0gI3tgaXRlbWAudG9fc307XG5cbiAgICAgICAgICBpZiAodG1wICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRtcCk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICN7cmFpc2UgTm9NZXRob2RFcnJvci5uZXcoXCIje2BPcGFsLmluc3BlY3QoaXRlbSlgfSBkb2Vzbid0IHJlc3BvbmQgdG8gI3RvX3N0ciwgI3RvX2FyeSBvciAjdG9fc1wiLCAndG9fc3RyJyl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VwID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oI3tPcGFsLmNvZXJjZV90byEoc2VwLCBTdHJpbmcsIDp0b19zdHIpLnRvX3N9KTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBrZWVwX2lmKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmtlZXBfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cbiAgICAleHtmaWx0ZXJJZihzZWxmLCAkdHJ1dGh5LCBibG9jayl9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGFzdChjb3VudCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChjb3VudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gMCA/IG5pbCA6IHNlbGZbc2VsZi5sZW5ndGggLSAxXTtcbiAgICAgIH1cblxuICAgICAgY291bnQgPSAkY29lcmNlX3RvKGNvdW50LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSd9O1xuICAgICAgfVxuXG4gICAgICBpZiAoY291bnQgPiBzZWxmLmxlbmd0aCkge1xuICAgICAgICBjb3VudCA9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZShzZWxmLmxlbmd0aCAtIGNvdW50LCBzZWxmLmxlbmd0aCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYHNlbGYubGVuZ3RoYFxuICBlbmRcblxuICBhbGlhcyBtYXAgY29sbGVjdFxuXG4gIGFsaWFzIG1hcCEgY29sbGVjdCFcblxuICBkZWYgbWF4KG4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBlYWNoLm1heChuLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBtaW4oJmJsb2NrKVxuICAgIGVhY2gubWluKCZibG9jaylcbiAgZW5kXG5cbiAgJXh7XG4gICAgLy8gUmV0dXJucyB0aGUgcHJvZHVjdCBvZiBmcm9tLCBmcm9tLTEsIC4uLiwgZnJvbSAtIGhvd19tYW55ICsgMS5cbiAgICBmdW5jdGlvbiBkZXNjZW5kaW5nX2ZhY3RvcmlhbChmcm9tLCBob3dfbWFueSkge1xuICAgICAgdmFyIGNvdW50ID0gaG93X21hbnkgPj0gMCA/IDEgOiAwO1xuICAgICAgd2hpbGUgKGhvd19tYW55KSB7XG4gICAgICAgIGNvdW50ICo9IGZyb207XG4gICAgICAgIGZyb20tLTtcbiAgICAgICAgaG93X21hbnktLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gIH1cblxuICBkZWYgcGVybXV0YXRpb24obnVtID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpwZXJtdXRhdGlvbiwgbnVtKSBkb1xuICAgICAgICBgZGVzY2VuZGluZ19mYWN0b3JpYWwoc2VsZi5sZW5ndGgsIG51bSA9PT0gdW5kZWZpbmVkID8gc2VsZi5sZW5ndGggOiBudW0pYFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBwZXJtdXRlLCBvZmZlbnNpdmUsIG91dHB1dDtcblxuICAgICAgaWYgKG51bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG51bSA9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG51bSA9ICRjb2VyY2VfdG8obnVtLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChudW0gPCAwIHx8IHNlbGYubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgIC8vIG5vIHBlcm11dGF0aW9ucywgeWllbGQgbm90aGluZ1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID09PSAwKSB7XG4gICAgICAgIC8vIGV4YWN0bHkgb25lIHBlcm11dGF0aW9uOiB0aGUgemVyby1sZW5ndGggYXJyYXlcbiAgICAgICAgI3sgeWllbGQgW10gfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID09PSAxKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBzcGVjaWFsLCBlYXN5IGNhc2VcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgI3sgeWllbGQgYFtzZWxmW2ldXWAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZ2VuZXJhbCBjYXNlXG4gICAgICAgICN7IHBlcm0gPSBBcnJheS5uZXcobnVtKSB9O1xuICAgICAgICAjeyB1c2VkID0gQXJyYXkubmV3KGBzZWxmLmxlbmd0aGAsIGZhbHNlKSB9O1xuXG4gICAgICAgIHBlcm11dGUgPSBmdW5jdGlvbihudW0sIHBlcm0sIGluZGV4LCB1c2VkLCBibGspIHtcbiAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBpZigjeyAhdXNlZFtgaWBdIH0pIHtcbiAgICAgICAgICAgICAgcGVybVtpbmRleF0gPSBpO1xuICAgICAgICAgICAgICBpZihpbmRleCA8IG51bSAtIDEpIHtcbiAgICAgICAgICAgICAgICB1c2VkW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwZXJtdXRlLmNhbGwoc2VsZiwgbnVtLCBwZXJtLCBpbmRleCArIDEsIHVzZWQsIGJsayk7XG4gICAgICAgICAgICAgICAgdXNlZFtpXSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGVybS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc2VsZltwZXJtW2pdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICR5aWVsZDEoYmxrLCBvdXRwdXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YmxvY2tfZ2l2ZW4/fSkge1xuICAgICAgICAgIC8vIG9mZmVuc2l2ZSAoYm90aCBkZWZpbml0aW9ucykgY29weS5cbiAgICAgICAgICBvZmZlbnNpdmUgPSBzZWxmLnNsaWNlKCk7XG4gICAgICAgICAgcGVybXV0ZS5jYWxsKG9mZmVuc2l2ZSwgbnVtLCBwZXJtLCAwLCB1c2VkLCBibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcGVybXV0ZS5jYWxsKHNlbGYsIG51bSwgcGVybSwgMCwgdXNlZCwgYmxvY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVwZWF0ZWRfcGVybXV0YXRpb24obilcbiAgICBudW0gPSBPcGFsLmNvZXJjZV90byEgbiwgSW50ZWdlciwgOnRvX2ludFxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVwZWF0ZWRfcGVybXV0YXRpb24sIG51bSkgeyBudW0gPj0gMCA/IHNpemUqKm51bSA6IDAgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZ1bmN0aW9uIGl0ZXJhdGUobWF4LCBidWZmZXIsIHNlbGYpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT0gbWF4KSB7XG4gICAgICAgICAgdmFyIGNvcHkgPSBidWZmZXIuc2xpY2UoKTtcbiAgICAgICAgICAje3lpZWxkIGBjb3B5YH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYnVmZmVyLnB1c2goc2VsZltpXSk7XG4gICAgICAgICAgaXRlcmF0ZShtYXgsIGJ1ZmZlciwgc2VsZik7XG4gICAgICAgICAgYnVmZmVyLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGUobnVtLCBbXSwgc2VsZi5zbGljZSgpKTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwb3AoY291bnQgPSB1bmRlZmluZWQpXG4gICAgaWYgYGNvdW50ID09PSB1bmRlZmluZWRgXG4gICAgICByZXR1cm4gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuICAgICAgcmV0dXJuIGBzZWxmLnBvcCgpYFxuICAgIGVuZFxuXG4gICAgY291bnQgPSBgJGNvZXJjZV90byhjb3VudCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgaWYgYGNvdW50IDwgMGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ1xuICAgIGVuZFxuXG4gICAgcmV0dXJuIFtdIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcblxuICAgIGlmIGBjb3VudCA9PT0gMWBcbiAgICAgIGBbc2VsZi5wb3AoKV1gXG4gICAgZWxzaWYgYGNvdW50ID4gc2VsZi5sZW5ndGhgXG4gICAgICBgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpYFxuICAgIGVsc2VcbiAgICAgIGBzZWxmLnNwbGljZShzZWxmLmxlbmd0aCAtIGNvdW50LCBzZWxmLmxlbmd0aClgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBwcm9kdWN0KCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gI3tibG9ja19naXZlbj99ID8gbnVsbCA6IFtdLFxuICAgICAgICAgIG4gPSBhcmdzLmxlbmd0aCArIDEsXG4gICAgICAgICAgY291bnRlcnMgPSBuZXcgQXJyYXkobiksXG4gICAgICAgICAgbGVuZ3RocyAgPSBuZXcgQXJyYXkobiksXG4gICAgICAgICAgYXJyYXlzICAgPSBuZXcgQXJyYXkobiksXG4gICAgICAgICAgaSwgbSwgc3ViYXJyYXksIGxlbiwgcmVzdWx0bGVuID0gMTtcblxuICAgICAgYXJyYXlzWzBdID0gc2VsZjtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgYXJyYXlzW2ldID0gJGNvZXJjZV90byhhcmdzW2kgLSAxXSwgI3tBcnJheX0sICd0b19hcnknKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBsZW4gPSBhcnJheXNbaV0ubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdGxlbiAqPSBsZW47XG4gICAgICAgIGlmIChyZXN1bHRsZW4gPiAyMTQ3NDgzNjQ3KSB7XG4gICAgICAgICAgI3tyYWlzZSBSYW5nZUVycm9yLCAndG9vIGJpZyB0byBwcm9kdWN0J31cbiAgICAgICAgfVxuICAgICAgICBsZW5ndGhzW2ldID0gbGVuO1xuICAgICAgICBjb3VudGVyc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIG91dGVyX2xvb3A6IGZvciAoOzspIHtcbiAgICAgICAgc3ViYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHN1YmFycmF5LnB1c2goYXJyYXlzW2ldW2NvdW50ZXJzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHN1YmFycmF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAje3lpZWxkIGBzdWJhcnJheWB9XG4gICAgICAgIH1cbiAgICAgICAgbSA9IG4gLSAxO1xuICAgICAgICBjb3VudGVyc1ttXSsrO1xuICAgICAgICB3aGlsZSAoY291bnRlcnNbbV0gPT09IGxlbmd0aHNbbV0pIHtcbiAgICAgICAgICBjb3VudGVyc1ttXSA9IDA7XG4gICAgICAgICAgaWYgKC0tbSA8IDApIGJyZWFrIG91dGVyX2xvb3A7XG4gICAgICAgICAgY291bnRlcnNbbV0rKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0IHx8IHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHVzaCgqb2JqZWN0cylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYucHVzaChvYmplY3RzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIGFwcGVuZCBwdXNoXG5cbiAgZGVmIHJhc3NvYyhvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICBpZiAoaXRlbS5sZW5ndGggJiYgaXRlbVsxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCN7YGl0ZW1bMV1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlamVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBibG9jayhzZWxmW2ldKTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChzZWxmW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIG9yaWdpbmFsID0gbGVuZ3RoXG4gICAgZGVsZXRlX2lmKCZibG9jaylcblxuICAgIHVubGVzcyBsZW5ndGggPT0gb3JpZ2luYWxcbiAgICAgIHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHJlcGxhY2Uob3RoZXIpXG4gICAgb3RoZXIgPSBpZiBBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3tBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKTtcbiAgICAgIHNlbGYucHVzaC5hcHBseShzZWxmLCBvdGhlcik7XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmV2ZXJzZVxuICAgIGBzZWxmLnNsaWNlKDApLnJldmVyc2UoKWBcbiAgZW5kXG5cbiAgZGVmIHJldmVyc2UhXG4gICAgYHNlbGYucmV2ZXJzZSgpYFxuICBlbmRcblxuICBkZWYgcmV2ZXJzZV9lYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJldmVyc2VfZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgcmV2ZXJzZS5lYWNoKCZibG9jaylcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByaW5kZXgob2JqZWN0ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgaSwgdmFsdWU7XG5cbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogZ2l2ZW4gYmxvY2sgbm90IHVzZWQnKX1cbiAgICAgIH1cblxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAoaSA9IHNlbGYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAoaSA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgje2BzZWxmW2ldYCA9PSBgb2JqZWN0YH0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSBzZWxmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGkgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbHVlID0gYmxvY2soc2VsZltpXSk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT09IGZhbHNlICYmIHZhbHVlICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICN7ZW51bV9mb3IgOnJpbmRleH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcm90YXRlKG4gPSAxKVxuICAgICV4e1xuICAgICAgdmFyIGFyeSwgaWR4LCBmaXJzdFBhcnQsIGxhc3RQYXJ0O1xuXG4gICAgICBuID0gJGNvZXJjZV90byhuLCAje0ludGVnZXJ9LCAndG9faW50JylcblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNsaWNlKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBhcnkgPSBzZWxmLnNsaWNlKCk7XG4gICAgICBpZHggPSBuICUgYXJ5Lmxlbmd0aDtcblxuICAgICAgZmlyc3RQYXJ0ID0gYXJ5LnNsaWNlKGlkeCk7XG4gICAgICBsYXN0UGFydCA9IGFyeS5zbGljZSgwLCBpZHgpO1xuICAgICAgcmV0dXJuIGZpcnN0UGFydC5jb25jYXQobGFzdFBhcnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJvdGF0ZSEoY250ID0gMSlcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCB8fCBzZWxmLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIGNudCA9ICRjb2VyY2VfdG8oY250LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgfVxuICAgIGFyeSA9IHJvdGF0ZShjbnQpXG4gICAgcmVwbGFjZSBhcnlcbiAgZW5kXG5cbiAgY2xhc3MgU2FtcGxlUmFuZG9tXG4gICAgZGVmIGluaXRpYWxpemUocm5nKVxuICAgICAgQHJuZyA9IHJuZ1xuICAgIGVuZFxuXG4gICAgZGVmIHJhbmQoc2l6ZSlcbiAgICAgIHJhbmRvbSA9IGAkY29lcmNlX3RvKCN7QHJuZy5yYW5kKHNpemUpfSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgJ3JhbmRvbSB2YWx1ZSBtdXN0IGJlID49IDAnIGlmIGByYW5kb20gPCAwYFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgJ3JhbmRvbSB2YWx1ZSBtdXN0IGJlIGxlc3MgdGhhbiBBcnJheSBzaXplJyB1bmxlc3MgYHJhbmRvbSA8IHNpemVgXG5cbiAgICAgIHJhbmRvbVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2FtcGxlKGNvdW50ID0gdW5kZWZpbmVkLCBvcHRpb25zID0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBhdCBLZXJuZWwucmFuZChgc2VsZi5sZW5ndGhgKSBpZiBgY291bnQgPT09IHVuZGVmaW5lZGBcblxuICAgIGlmIGBvcHRpb25zID09PSB1bmRlZmluZWRgXG4gICAgICBpZiAobyA9IE9wYWwuY29lcmNlX3RvPyBjb3VudCwgSGFzaCwgOnRvX2hhc2gpXG4gICAgICAgIG9wdGlvbnMgPSBvXG4gICAgICAgIGNvdW50ID0gbmlsXG4gICAgICBlbHNlXG4gICAgICAgIG9wdGlvbnMgPSBuaWxcbiAgICAgICAgY291bnQgPSBgJGNvZXJjZV90byhjb3VudCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgY291bnQgPSBgJGNvZXJjZV90byhjb3VudCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgb3B0aW9ucyA9IGAkY29lcmNlX3RvKG9wdGlvbnMsICN7SGFzaH0sICd0b19oYXNoJylgXG4gICAgZW5kXG5cbiAgICBpZiBjb3VudCAmJiBgY291bnQgPCAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2NvdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnXG4gICAgZW5kXG5cbiAgICBybmcgPSBvcHRpb25zWzpyYW5kb21dIGlmIG9wdGlvbnNcbiAgICBybmcgPSBpZiBybmcgJiYgcm5nLnJlc3BvbmRfdG8/KDpyYW5kKVxuICAgICAgICAgICAgU2FtcGxlUmFuZG9tLm5ldyBybmdcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBLZXJuZWxcbiAgICAgICAgICBlbmRcblxuICAgIHJldHVybiBgc2VsZlsje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfV1gIHVubGVzcyBjb3VudFxuXG4gICAgJXh7XG5cbiAgICAgIHZhciBhYmFuZG9uLCBzcGluLCByZXN1bHQsIGksIGosIGssIHRhcmdldEluZGV4LCBvbGRWYWx1ZTtcblxuICAgICAgaWYgKGNvdW50ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgY291bnQgPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIFtzZWxmWyN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9XV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgaiA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICBqID0gaSA9PT0gMCA/IGkgKyAxIDogaSAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbc2VsZltpXSwgc2VsZltqXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHNlbGYubGVuZ3RoIC8gY291bnQgPiAzKSB7XG4gICAgICAgICAgICBhYmFuZG9uID0gZmFsc2U7XG4gICAgICAgICAgICBzcGluID0gMDtcblxuICAgICAgICAgICAgcmVzdWx0ID0gI3sgQXJyYXkubmV3KGNvdW50KSB9O1xuICAgICAgICAgICAgaSA9IDE7XG5cbiAgICAgICAgICAgIHJlc3VsdFswXSA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBjb3VudCkge1xuICAgICAgICAgICAgICBrID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgICAgIGogPSAwO1xuXG4gICAgICAgICAgICAgIHdoaWxlIChqIDwgaSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChrID09PSByZXN1bHRbal0pIHtcbiAgICAgICAgICAgICAgICAgIHNwaW4rKztcbiAgICAgICAgICAgICAgICAgIGlmIChzcGluID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFiYW5kb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGsgPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFiYW5kb24pIHsgYnJlYWs7IH1cblxuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhYmFuZG9uKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgICAgICAgcmVzdWx0W2ldID0gaztcblxuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghYWJhbmRvbikge1xuICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgd2hpbGUgKGkgPCBjb3VudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHNlbGZbcmVzdWx0W2ldXTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoKTtcblxuICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY291bnQ7IGMrKykge1xuICAgICAgICAgICAgdGFyZ2V0SW5kZXggPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICAgIG9sZFZhbHVlID0gcmVzdWx0W2NdO1xuICAgICAgICAgICAgcmVzdWx0W2NdID0gcmVzdWx0W3RhcmdldEluZGV4XTtcbiAgICAgICAgICAgIHJlc3VsdFt0YXJnZXRJbmRleF0gPSBvbGRWYWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY291bnQgPT09IHNlbGYubGVuZ3RoID8gcmVzdWx0IDogI3tgcmVzdWx0YFswLCBjb3VudF19O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzZWxlY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW0sIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG5cbiAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBpdGVtKTtcblxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWwgPSBzZWxmLmxlbmd0aDtcbiAgICAgICN7IGtlZXBfaWYoJmJsb2NrKSB9O1xuICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSBvcmlnaW5hbCA/IG5pbCA6IHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBmaWx0ZXIgc2VsZWN0XG4gIGFsaWFzIGZpbHRlciEgc2VsZWN0IVxuXG4gIGRlZiBzaGlmdChjb3VudCA9IHVuZGVmaW5lZClcbiAgICBpZiBgY291bnQgPT09IHVuZGVmaW5lZGBcbiAgICAgIHJldHVybiBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG4gICAgICByZXR1cm4gYHNoaWZ0Tm9Bcmcoc2VsZilgXG4gICAgZW5kXG5cbiAgICBjb3VudCA9IGAkY29lcmNlX3RvKGNvdW50LCAje0ludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgY291bnQgPCAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gW10gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuXG4gICAgYHNlbGYuc3BsaWNlKDAsIGNvdW50KWBcbiAgZW5kXG5cbiAgYWxpYXMgc2l6ZSBsZW5ndGhcblxuICBkZWYgc2h1ZmZsZShybmcgPSB1bmRlZmluZWQpXG4gICAgZHVwLnRvX2Euc2h1ZmZsZSEocm5nKVxuICBlbmRcblxuICBkZWYgc2h1ZmZsZSEocm5nID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIHJhbmRnZW4sIGkgPSBzZWxmLmxlbmd0aCwgaiwgdG1wO1xuXG4gICAgICBpZiAocm5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcm5nID0gI3tPcGFsLmNvZXJjZV90bz8ocm5nLCBIYXNoLCA6dG9faGFzaCl9O1xuXG4gICAgICAgIGlmIChybmcgIT09IG5pbCkge1xuICAgICAgICAgIHJuZyA9ICN7cm5nWzpyYW5kb21dfTtcblxuICAgICAgICAgIGlmIChybmcgIT09IG5pbCAmJiAje3JuZy5yZXNwb25kX3RvPyg6cmFuZCl9KSB7XG4gICAgICAgICAgICByYW5kZ2VuID0gcm5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaSkge1xuICAgICAgICBpZiAocmFuZGdlbikge1xuICAgICAgICAgIGogPSByYW5kZ2VuLiRyYW5kKGkpLiR0b19pbnQoKTtcblxuICAgICAgICAgIGlmIChqIDwgMCkge1xuICAgICAgICAgICAgI3tyYWlzZSBSYW5nZUVycm9yLCBcInJhbmRvbSBudW1iZXIgdG9vIHNtYWxsICN7YGpgfVwifVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChqID49IGkpIHtcbiAgICAgICAgICAgICN7cmFpc2UgUmFuZ2VFcnJvciwgXCJyYW5kb20gbnVtYmVyIHRvbyBiaWcgI3tgamB9XCJ9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGogPSAje3JhbmQoYGlgKX07XG4gICAgICAgIH1cblxuICAgICAgICB0bXAgPSBzZWxmWy0taV07XG4gICAgICAgIHNlbGZbaV0gPSBzZWxmW2pdO1xuICAgICAgICBzZWxmW2pdID0gdG1wO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHNsaWNlIFtdXG5cbiAgZGVmIHNsaWNlIShpbmRleCwgbGVuZ3RoID0gdW5kZWZpbmVkKVxuICAgIHJlc3VsdCA9IG5pbFxuXG4gICAgaWYgYGxlbmd0aCA9PT0gdW5kZWZpbmVkYFxuICAgICAgaWYgUmFuZ2UgPT09IGluZGV4XG4gICAgICAgIHJhbmdlID0gaW5kZXhcbiAgICAgICAgcmVzdWx0ID0gc2VsZltyYW5nZV1cblxuICAgICAgICByYW5nZV9zdGFydCA9IGAkY29lcmNlX3RvKHJhbmdlLmJlZ2luLCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgIHJhbmdlX2VuZCA9IGAkY29lcmNlX3RvKHJhbmdlLmVuZCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChyYW5nZV9zdGFydCA8IDApIHtcbiAgICAgICAgICAgIHJhbmdlX3N0YXJ0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZV9lbmQgPCAwKSB7XG4gICAgICAgICAgICByYW5nZV9lbmQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChyYW5nZV9lbmQgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJhbmdlX2VuZCA9IHNlbGYubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5leGNsKSB7XG4gICAgICAgICAgICAgIHJhbmdlX2VuZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByYW5nZV9sZW5ndGggPSByYW5nZV9lbmQgLSByYW5nZV9zdGFydDtcbiAgICAgICAgICBpZiAocmFuZ2UuZXhjbCkge1xuICAgICAgICAgICAgcmFuZ2VfZW5kIC09IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlX2xlbmd0aCArPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZV9zdGFydCA8IHNlbGYubGVuZ3RoICYmIHJhbmdlX3N0YXJ0ID49IDAgJiYgcmFuZ2VfZW5kIDwgc2VsZi5sZW5ndGggJiYgcmFuZ2VfZW5kID49IDAgJiYgcmFuZ2VfbGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2VsZi5zcGxpY2UocmFuZ2Vfc3RhcnQsIHJhbmdlX2xlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXJ0ID0gYCRjb2VyY2VfdG8oaW5kZXgsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgICAgJXh7XG4gICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgPSBzZWxmW3N0YXJ0XTtcblxuICAgICAgICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgICAgICAgc2VsZi5zaGlmdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnNwbGljZShzdGFydCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBzdGFydCA9IGAkY29lcmNlX3RvKGluZGV4LCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBsZW5ndGggPSBgJGNvZXJjZV90byhsZW5ndGgsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgJXh7XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbmQgPSBzdGFydCArIGxlbmd0aDtcblxuICAgICAgICByZXN1bHQgPSAje3NlbGZbc3RhcnQsIGxlbmd0aF19O1xuXG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICBzdGFydCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCArIGxlbmd0aCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggLSBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCA8IHNlbGYubGVuZ3RoICYmIHN0YXJ0ID49IDApIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShzdGFydCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgc29ydCgmYmxvY2spXG4gICAgcmV0dXJuIHNlbGYgdW5sZXNzIGBzZWxmLmxlbmd0aCA+IDFgXG5cbiAgICAleHtcbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgIGJsb2NrID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHJldHVybiAje2BhYCA8PT4gYGJgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHJldCA9IGJsb2NrKHgsIHkpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IG5pbCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7YHhgLmluc3BlY3R9IHdpdGggI3tgeWAuaW5zcGVjdH0gZmFpbGVkXCJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICN7YHJldGAgPiAwfSA/IDEgOiAoI3tgcmV0YCA8IDB9ID8gLTEgOiAwKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNvcnQhKCZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmICgje2Jsb2NrX2dpdmVuP30pIHtcbiAgICAgICAgcmVzdWx0ID0gI3tgc2VsZi5zbGljZSgpYC5zb3J0KCZibG9jayl9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9ICN7YHNlbGYuc2xpY2UoKWAuc29ydH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYubGVuZ3RoID0gMDtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLnB1c2gocmVzdWx0W2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc29ydF9ieSEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c29ydF9ieSEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHJlcGxhY2Ugc29ydF9ieSgmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB0YWtlKGNvdW50KVxuICAgICV4e1xuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3J9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZSgwLCBjb3VudCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICB2YWx1ZSA9IGJsb2NrKGl0ZW0pO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyB0b19hcnkgdG9fYVxuXG4gIGRlZiB0b19oKCZibG9jaylcbiAgICBhcnJheSA9IHNlbGZcbiAgICBhcnJheSA9IGFycmF5Lm1hcCgmYmxvY2spIGlmIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuID0gYXJyYXkubGVuZ3RoLCBhcnksIGtleSwgdmFsLCBoYXNoID0gI3t7fX07XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBhcnkgPSAje09wYWwuY29lcmNlX3RvPyhgYXJyYXlbaV1gLCBBcnJheSwgOnRvX2FyeSl9O1xuICAgICAgICBpZiAoIWFyeS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgZWxlbWVudCB0eXBlICN7YGFyeWAuY2xhc3N9IGF0ICN7YGlgfSAoZXhwZWN0ZWQgYXJyYXkpXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyeS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgYXJyYXkgbGVuZ3RoIGF0ICN7YGlgfSAoZXhwZWN0ZWQgMiwgd2FzICN7YGFyeWAubGVuZ3RofSlcIn1cbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBhcnlbMF07XG4gICAgICAgIHZhbCA9IGFyeVsxXTtcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGtleSwgdmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyB0b19zIGluc3BlY3RcblxuICBkZWYgdHJhbnNwb3NlXG4gICAgcmV0dXJuIFtdIGlmIGVtcHR5P1xuXG4gICAgcmVzdWx0ID0gW11cbiAgICBtYXggICAgPSBuaWxcblxuICAgIGVhY2ggZG8gfHJvd3xcbiAgICAgIHJvdyA9IGlmIEFycmF5ID09PSByb3dcbiAgICAgICAgICAgICAgcm93LnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ocm93LCAje0FycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgICAgbWF4IHx8PSBgcm93Lmxlbmd0aGBcblxuICAgICAgaWYgYHJvdy5sZW5ndGhgICE9IG1heFxuICAgICAgICByYWlzZSBJbmRleEVycm9yLCBcImVsZW1lbnQgc2l6ZSBkaWZmZXJzICgje2Byb3cubGVuZ3RoYH0gc2hvdWxkIGJlICN7bWF4fSlcIlxuICAgICAgZW5kXG5cbiAgICAgIGByb3cubGVuZ3RoYC50aW1lcyBkbyB8aXxcbiAgICAgICAgZW50cnkgPSAocmVzdWx0W2ldIHx8PSBbXSlcbiAgICAgICAgZW50cnkgPDwgcm93LmF0KGkpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBhbGlhcyB1bmlvbiB8XG5cbiAgZGVmIHVuaXEoJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtLCBrZXk7XG5cbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgICBpZiAoJGhhc2hfZ2V0KGhhc2gsIGl0ZW0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICRoYXNoX3B1dChoYXNoLCBpdGVtLCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgICAga2V5ID0gJHlpZWxkMShibG9jaywgaXRlbSk7XG4gICAgICAgICAgaWYgKCRoYXNoX2dldChoYXNoLCBrZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICRoYXNoX3B1dChoYXNoLCBrZXksIGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9BcnJheVN1YmNsYXNzKCN7YGhhc2hgLnZhbHVlc30sICN7c2VsZi5jbGFzc30pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHVuaXEhKCZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBvcmlnaW5hbF9sZW5ndGggPSBzZWxmLmxlbmd0aCwgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW0sIGtleTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb3JpZ2luYWxfbGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgIGtleSA9IChibG9jayA9PT0gbmlsID8gaXRlbSA6ICR5aWVsZDEoYmxvY2ssIGl0ZW0pKTtcblxuICAgICAgICBpZiAoJGhhc2hfZ2V0KGhhc2gsIGtleSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICRoYXNoX3B1dChoYXNoLCBrZXksIGl0ZW0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGxlbmd0aC0tO1xuICAgICAgICBpLS07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gb3JpZ2luYWxfbGVuZ3RoID8gbmlsIDogc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB1bnNoaWZ0KCpvYmplY3RzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IG9iamVjdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgc2VsZi51bnNoaWZ0KG9iamVjdHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgcHJlcGVuZCB1bnNoaWZ0XG5cbiAgZGVmIHZhbHVlc19hdCgqYXJncylcbiAgICBvdXQgPSBbXVxuXG4gICAgYXJncy5lYWNoIGRvIHxlbGVtfFxuICAgICAgaWYgZWxlbS5pc19hPyBSYW5nZVxuICAgICAgICBmaW5pc2ggPSBgJGNvZXJjZV90bygje2VsZW0ubGFzdH0sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgICAgc3RhcnQgPSBgJGNvZXJjZV90bygje2VsZW0uZmlyc3R9LCAje0ludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICAgICAgJXh7XG4gICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgPSBzdGFydCArIHNlbGYubGVuZ3RoO1xuICAgICAgICAgICAgI3tuZXh0fTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAleHtcbiAgICAgICAgICBpZiAoZmluaXNoIDwgMCkge1xuICAgICAgICAgICAgZmluaXNoID0gZmluaXNoICsgc2VsZi5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgje2VsZW0uZXhjbHVkZV9lbmQ/fSkge1xuICAgICAgICAgICAgZmluaXNoLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmaW5pc2ggPCBzdGFydCkge1xuICAgICAgICAgICAgI3tuZXh0fTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydC51cHRvKGZpbmlzaCkgeyB8aXwgb3V0IDw8IGF0KGkpIH1cbiAgICAgIGVsc2VcbiAgICAgICAgaSA9IGAkY29lcmNlX3RvKGVsZW0sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgICAgb3V0IDw8IGF0KGkpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIG91dFxuICBlbmRcblxuICBkZWYgemlwKCpvdGhlcnMsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgc2l6ZSA9IHNlbGYubGVuZ3RoLCBwYXJ0LCBvLCBpLCBqLCBqajtcblxuICAgICAgZm9yIChqID0gMCwgamogPSBvdGhlcnMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICBvID0gb3RoZXJzW2pdO1xuICAgICAgICBpZiAoby4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8uJCRpc19lbnVtZXJhdG9yKSB7XG4gICAgICAgICAgaWYgKG8uJHNpemUoKSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIG90aGVyc1tqXSA9IG8uJHRha2Uoc2l6ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG90aGVyc1tqXSA9IG8uJHRvX2EoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJzW2pdID0gI3soXG4gICAgICAgICAgT3BhbC5jb2VyY2VfdG8/KGBvYCwgQXJyYXksIDp0b19hcnkpIHx8XG4gICAgICAgICAgT3BhbC5jb2VyY2VfdG8hKGBvYCwgRW51bWVyYXRvciwgOnRvX2VudW0sIDplYWNoKVxuICAgICAgICApLnRvX2F9O1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHBhcnQgPSBbc2VsZltpXV07XG5cbiAgICAgICAgZm9yIChqID0gMCwgamogPSBvdGhlcnMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgIG8gPSBvdGhlcnNbal1baV07XG5cbiAgICAgICAgICBpZiAobyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvID0gbmlsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRbaiArIDFdID0gbztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdFtpXSA9IHBhcnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICBibG9jayhyZXN1bHRbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmluaGVyaXRlZChrbGFzcylcbiAgICAleHtcbiAgICAgIGtsYXNzLiQkcHJvdG90eXBlLiR0b19hID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICBzdXBlci5yZWplY3QgeyB8aXZhcnwgYC9eQFxcZCskLy50ZXN0KCN7aXZhcn0pYCB8fCBpdmFyID09ICdAbGVuZ3RoJyB9XG4gIGVuZFxuXG4gIE9wYWwucHJpc3RpbmUgc2luZ2xldG9uX2NsYXNzLCA6YWxsb2NhdGVcbiAgT3BhbC5wcmlzdGluZSBzZWxmLCA6Y29weV9pbnN0YW5jZV92YXJpYWJsZXMsIDppbml0aWFsaXplX2R1cFxuXG4gIGRlZiBwYWNrKCphcmdzKVxuICAgIHJhaXNlIFwiVG8gdXNlIEFycmF5I3BhY2ssIHlvdSBtdXN0IGZpcnN0IHJlcXVpcmUgJ2NvcmVsaWIvYXJyYXkvcGFjaycuXCJcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJpbmNsdWRlIiwidG9fYSIsIltdIiwic2VsZiIsImluaXRpYWxpemUiLCJ3YXJuIiwicmFpc2UiLCJyZXBsYWNlIiwic2l6ZSIsInJlc3BvbmRfdG8/IiwidG9fYXJ5IiwidHJ5X2NvbnZlcnQiLCJjb2VyY2VfdG8/Iiwib2JqIiwiJiIsIm90aGVyIiwiPT09IiwifCIsIioiLCJqb2luIiwidG9fc3RyIiwiKyIsIi0iLCI8PCIsIjw9PiIsImhhc2giLCI9PSIsIm9iamVjdF9pZCIsIltdPSIsImluZGV4IiwiZGF0YSIsInZhbHVlIiwiaW5zcGVjdCIsImxlbmd0aCIsIjEiLCJleHRyYSIsImFueT8iLCJhc3NvYyIsIm9iamVjdCIsImF0IiwiYnNlYXJjaF9pbmRleCIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiYnNlYXJjaCIsImJsb2NrIiwiY3ljbGUiLCJuIiwibmlsPyIsImNvZXJjZV90byEiLCI+IiwiMCIsImVudW1lcmF0b3Jfc2l6ZSIsIiRyZXRfb3JfMSIsImVtcHR5PyIsImNsZWFyIiwiY291bnQiLCIkcmV0X29yXzIiLCJpbml0aWFsaXplX2NvcHkiLCJjb2xsZWN0IiwiY29sbGVjdCEiLCJjb21iaW5hdGlvbiIsIm51bSIsInJlcGVhdGVkX2NvbWJpbmF0aW9uIiwiY29tcGFjdCIsImNvbXBhY3QhIiwiY29uY2F0Iiwib3RoZXJzIiwibWFwIiwiZXF1YWw/IiwiZHVwIiwiZWFjaCIsImRlbGV0ZSIsImRlbGV0ZV9hdCIsImRlbGV0ZV9pZiIsImRpZyIsIml0ZW0iLCJpZHgiLCJpZHhzIiwiZHJvcCIsImVhY2hfaW5kZXgiLCJlcWw/IiwiZmV0Y2giLCJmaWxsIiwiYXJncyIsIm9uZSIsInR3byIsImxlZnQiLCJyaWdodCIsImV4Y2x1ZGVfZW5kPyIsImZpcnN0IiwiZmxhdHRlbiIsImZsYXR0ZW4hIiwibGV2ZWwiLCJpbmNsdWRlPyIsIm1lbWJlciIsImluc2VydCIsIl9faWRfXyIsInNlcCIsIiQsIiwidG9fcyIsIm5ldyIsImtlZXBfaWYiLCJsYXN0IiwibWF4IiwibWluIiwicGVybXV0YXRpb24iLCJwZXJtIiwidXNlZCIsIiEiLCJyZXBlYXRlZF9wZXJtdXRhdGlvbiIsIj49IiwiKioiLCJwb3AiLCJwcm9kdWN0IiwicHVzaCIsInJhc3NvYyIsInJlamVjdCIsInJlamVjdCEiLCJvcmlnaW5hbCIsInJldmVyc2UiLCJyZXZlcnNlISIsInJldmVyc2VfZWFjaCIsInJpbmRleCIsInJvdGF0ZSIsInJvdGF0ZSEiLCJhcnkiLCJjbnQiLCJAcm5nIiwicm5nIiwicmFuZCIsInJhbmRvbSIsInNhbXBsZSIsIm8iLCJvcHRpb25zIiwiJHJldF9vcl8zIiwiJHJldF9vcl80Iiwic2VsZWN0Iiwic2VsZWN0ISIsInNoaWZ0Iiwic2h1ZmZsZSIsInNodWZmbGUhIiwic2xpY2UhIiwicmVzdWx0IiwicmFuZ2UiLCJyYW5nZV9zdGFydCIsInJhbmdlX2VuZCIsInN0YXJ0Iiwic29ydCIsIjwiLCJzb3J0ISIsInNvcnRfYnkhIiwic29ydF9ieSIsInRha2UiLCJ0YWtlX3doaWxlIiwidG9faCIsImFycmF5IiwidHJhbnNwb3NlIiwicm93IiwiJHJldF9vcl81IiwiIT0iLCJ0aW1lcyIsImVudHJ5IiwiJHJldF9vcl82IiwiaSIsIiR3cml0ZXIiLCJ1bmlxIiwidmFsdWVzIiwidW5pcSEiLCJ1bnNoaWZ0IiwidmFsdWVzX2F0Iiwib3V0IiwiZWxlbSIsImlzX2E/IiwiZmluaXNoIiwidXB0byIsInppcCIsIiRyZXRfb3JfNyIsImluaGVyaXRlZCIsImluc3RhbmNlX3ZhcmlhYmxlcyIsIiRyZXRfb3JfOCIsIml2YXIiLCJwcmlzdGluZSIsInNpbmdsZXRvbl9jbGFzcyIsInBhY2siXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLE1BQUFBLFNBQUFBLENBQVEsb0JBQVJBLENBQUE7QUFBQSxNQUNBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQURBO0FBQUEsRUFHQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUMsU0FBQUEsQ0FBUSwwQkFBUkEsQ0FBQTtBQUFBLElBR0MseURBSEQ7QUFBQTtBQU1GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBNEMsQ0FBQyxHQUFELENBQUFDLE1BQUFBLENBQUFBLENBQVc7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUFBO0FBeDFFRjtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQXcxRVcsTUFBQSxrQkF4MUVYO0FBQUEsTUF5MUVJLFdBQUFqTCxPQUFBQSxDQUFNLGlFQUFOQSxDQXoxRUo7QUF3MUVFaUwsSUFBQUEsQ0FBQUEsOEJBQUFBLENBQUFBLGdCQWoxRUE7QUFERnhMLEVBQUFBLEdBQUFBLFdBQUFBLEVBQWUsS0FBZkEsV0FIQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE0ODM0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9oYXNoLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcblxuIyAtLS1cbiMgSW50ZXJuYWwgcHJvcGVydGllczpcbiNcbiMgLSAkJG1hcCAgICAgICAgIFtKUzo6T2JqZWN0PFN0cmluZyA9PiBoYXNoLWJ1Y2tldD5dIHRoZSBoYXNoIHRhYmxlIGZvciBvcmRpbmFyeSBrZXlzXG4jIC0gJCRzbWFwICAgICAgICBbSlM6Ok9iamVjdDxTdHJpbmcgPT4gaGFzaC1idWNrZXQ+XSB0aGUgaGFzaCB0YWJsZSBmb3Igc3RyaW5nIGtleXNcbiMgLSAkJGtleXMgICAgICAgIFtBcnJheTxoYXNoLWJ1Y2tldD5dIHRoZSBsaXN0IG9mIGFsbCBrZXlzXG4jIC0gJCRwcm9jICAgICAgICBbUHJvYyxudWxsLG5pbF0gdGhlIGRlZmF1bHQgcHJvYyB1c2VkIGZvciBtaXNzaW5nIGtleXNcbiMgLSBoYXNoLWJ1Y2tldCAgIFtKUzo6T2JqZWN0XSBhbiBlbGVtZW50IG9mIGEgbGlua2VkIGxpc3QgdGhhdCBob2xkcyBoYXNoIHZhbHVlcywga2V5cyBhcmUgYHtrZXk6LGtleV9oYXNoOix2YWx1ZTosbmV4dDp9YFxuY2xhc3MgSGFzaFxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICAjIE1hcmsgYWxsIGhhc2ggaW5zdGFuY2VzIGFzIHZhbGlkIGhhc2hlcyAodXNlZCB0byBjaGVjayBrZXl3b3JkIGFyZ3MsIGV0YylcbiAgYHNlbGYuJCRwcm90b3R5cGUuJCRpc19oYXNoID0gdHJ1ZWBcblxuICBkZWYgc2VsZi5bXSgqYXJndilcbiAgICAleHtcbiAgICAgIHZhciBoYXNoLCBhcmdjID0gYXJndi5sZW5ndGgsIGk7XG5cbiAgICAgIGlmIChhcmdjID09PSAxKSB7XG4gICAgICAgIGhhc2ggPSAje09wYWwuY29lcmNlX3RvPyhhcmd2WzBdLCBIYXNoLCA6dG9faGFzaCl9O1xuICAgICAgICBpZiAoaGFzaCAhPT0gbmlsKSB7XG4gICAgICAgICAgcmV0dXJuICN7YWxsb2NhdGUubWVyZ2UhKGBoYXNoYCl9O1xuICAgICAgICB9XG5cbiAgICAgICAgYXJndiA9ICN7T3BhbC5jb2VyY2VfdG8/KGFyZ3ZbMF0sIEFycmF5LCA6dG9fYXJ5KX07XG4gICAgICAgIGlmIChhcmd2ID09PSBuaWwpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgSGFzaCd9XG4gICAgICAgIH1cblxuICAgICAgICBhcmdjID0gYXJndi5sZW5ndGg7XG4gICAgICAgIGhhc2ggPSAje2FsbG9jYXRlfTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnYzsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFhcmd2W2ldLiQkaXNfYXJyYXkpIGNvbnRpbnVlO1xuICAgICAgICAgIHN3aXRjaChhcmd2W2ldLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGhhc2guJHN0b3JlKGFyZ3ZbaV1bMF0sIG5pbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBoYXNoLiRzdG9yZShhcmd2W2ldWzBdLCBhcmd2W2ldWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCBudW1iZXIgb2YgZWxlbWVudHMgKCN7YGFyZ3ZbaV0ubGVuZ3RoYH0gZm9yIDEuLjIpXCJ9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmdjICUgMiAhPT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgSGFzaCd9XG4gICAgICB9XG5cbiAgICAgIGhhc2ggPSAje2FsbG9jYXRlfTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ2M7IGkgKz0gMikge1xuICAgICAgICBoYXNoLiRzdG9yZShhcmd2W2ldLCBhcmd2W2kgKyAxXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuYWxsb2NhdGVcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcigpO1xuXG4gICAgICBPcGFsLmhhc2hfaW5pdChoYXNoKTtcblxuICAgICAgaGFzaC4kJG5vbmUgPSBuaWw7XG4gICAgICBoYXNoLiQkcHJvYyA9IG5pbDtcblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi50cnlfY29udmVydChvYmopXG4gICAgT3BhbC5jb2VyY2VfdG8/KG9iaiwgSGFzaCwgOnRvX2hhc2gpXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoZGVmYXVsdHMgIT09IHVuZGVmaW5lZCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDEgZm9yIDApJ31cbiAgICAgIH1cbiAgICAgIHNlbGYuJCRub25lID0gKGRlZmF1bHRzID09PSB1bmRlZmluZWQgPyBuaWwgOiBkZWZhdWx0cyk7XG4gICAgICBzZWxmLiQkcHJvYyA9IGJsb2NrO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvdGhlci4kJGlzX2hhc2gpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi4kJGtleXMubGVuZ3RoICE9PSBvdGhlci4kJGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG90aGVyX3ZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KG90aGVyLCBrZXkua2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdGhlcl92YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICF2YWx1ZVsnJGVxbD8nXShvdGhlcl92YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgb3RoZXIgPSBPcGFsLmNvZXJjZV90byEob3RoZXIsIEhhc2gsIDp0b19oYXNoKVxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGtleXMubGVuZ3RoIDwgb3RoZXIuJCRrZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHQgPSB0cnVlXG5cbiAgICBvdGhlci5lYWNoIGRvIHxvdGhlcl9rZXksIG90aGVyX3ZhbHxcbiAgICAgIHZhbCA9IGZldGNoKG90aGVyX2tleSwgYG51bGxgKVxuXG4gICAgICAleHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsIHx8IHZhbCAhPT0gb3RoZXJfdmFsKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmID4ob3RoZXIpXG4gICAgb3RoZXIgPSBPcGFsLmNvZXJjZV90byEob3RoZXIsIEhhc2gsIDp0b19oYXNoKVxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGtleXMubGVuZ3RoIDw9IG90aGVyLiQka2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZiA+PSBvdGhlclxuICBlbmRcblxuICBkZWYgPChvdGhlcilcbiAgICBvdGhlciA9IE9wYWwuY29lcmNlX3RvIShvdGhlciwgSGFzaCwgOnRvX2hhc2gpXG4gICAgb3RoZXIgPiBzZWxmXG4gIGVuZFxuXG4gIGRlZiA8PShvdGhlcilcbiAgICBvdGhlciA9IE9wYWwuY29lcmNlX3RvIShvdGhlciwgSGFzaCwgOnRvX2hhc2gpXG4gICAgb3RoZXIgPj0gc2VsZlxuICBlbmRcblxuICBkZWYgW10oa2V5KVxuICAgICV4e1xuICAgICAgdmFyIHZhbHVlID0gT3BhbC5oYXNoX2dldChzZWxmLCBrZXkpO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiRkZWZhdWx0KGtleSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgW109KGtleSwgdmFsdWUpXG4gICAgJXh7XG4gICAgICBPcGFsLmhhc2hfcHV0KHNlbGYsIGtleSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFzc29jKG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICBpZiAoI3tga2V5YCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgICByZXR1cm4gW2tleSwgc2VsZi4kJHNtYXBba2V5XV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgje2BrZXkua2V5YCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgICByZXR1cm4gW2tleS5rZXksIGtleS52YWx1ZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xlYXJcbiAgICAleHtcbiAgICAgIE9wYWwuaGFzaF9pbml0KHNlbGYpO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xvbmVcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gbmV3IHNlbGYuJCRjbGFzcygpO1xuXG4gICAgICBPcGFsLmhhc2hfaW5pdChoYXNoKTtcbiAgICAgIE9wYWwuaGFzaF9jbG9uZShzZWxmLCBoYXNoKTtcblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFjdFxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBPcGFsLmhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSBuaWwpIHtcbiAgICAgICAgICBPcGFsLmhhc2hfcHV0KGhhc2gsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbXBhY3QhXG4gICAgJXh7XG4gICAgICB2YXIgY2hhbmdlc193ZXJlX21hZGUgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICBpZiAoT3BhbC5oYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXNfd2VyZV9tYWRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhbmdlc193ZXJlX21hZGUgPyBzZWxmIDogbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbXBhcmVfYnlfaWRlbnRpdHlcbiAgICAleHtcbiAgICAgIHZhciBpLCBpaSwga2V5LCBrZXlzID0gc2VsZi4kJGtleXMsIGlkZW50aXR5X2hhc2g7XG5cbiAgICAgIGlmIChzZWxmLiQkYnlfaWRlbnRpdHkpIHJldHVybiBzZWxmO1xuICAgICAgaWYgKHNlbGYuJCRrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWxmLiQkYnlfaWRlbnRpdHkgPSB0cnVlXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBpZGVudGl0eV9oYXNoID0gI3sge30uY29tcGFyZV9ieV9pZGVudGl0eSB9O1xuICAgICAgZm9yKGkgPSAwLCBpaSA9IGtleXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoIWtleS4kJGlzX3N0cmluZykga2V5ID0ga2V5LmtleTtcbiAgICAgICAgT3BhbC5oYXNoX3B1dChpZGVudGl0eV9oYXNoLCBrZXksIE9wYWwuaGFzaF9nZXQoc2VsZiwga2V5KSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJCRieV9pZGVudGl0eSA9IHRydWU7XG4gICAgICBzZWxmLiQkbWFwID0gaWRlbnRpdHlfaGFzaC4kJG1hcDtcbiAgICAgIHNlbGYuJCRzbWFwID0gaWRlbnRpdHlfaGFzaC4kJHNtYXA7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYXJlX2J5X2lkZW50aXR5P1xuICAgIGBzZWxmLiQkYnlfaWRlbnRpdHkgPT09IHRydWVgXG4gIGVuZFxuXG4gIGRlZiBkZWZhdWx0KGtleSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCAmJiBzZWxmLiQkcHJvYyAhPT0gbmlsICYmIHNlbGYuJCRwcm9jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRwcm9jLiRjYWxsKHNlbGYsIGtleSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi4kJG5vbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuJCRub25lO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlZmF1bHQ9KG9iamVjdClcbiAgICAleHtcbiAgICAgIHNlbGYuJCRwcm9jID0gbmlsO1xuICAgICAgc2VsZi4kJG5vbmUgPSBvYmplY3Q7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVmYXVsdF9wcm9jXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJHByb2MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJHByb2M7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlZmF1bHRfcHJvYz0oZGVmYXVsdF9wcm9jKVxuICAgICV4e1xuICAgICAgdmFyIHByb2MgPSBkZWZhdWx0X3Byb2M7XG5cbiAgICAgIGlmIChwcm9jICE9PSBuaWwpIHtcbiAgICAgICAgcHJvYyA9ICN7T3BhbC5jb2VyY2VfdG8hKGBwcm9jYCwgUHJvYywgOnRvX3Byb2MpfTtcblxuICAgICAgICBpZiAoI3tgcHJvY2AubGFtYmRhP30gJiYgI3tgcHJvY2AuYXJpdHkuYWJzfSAhPT0gMikge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAnZGVmYXVsdF9wcm9jIHRha2VzIHR3byBhcmd1bWVudHMnfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLiQkbm9uZSA9IG5pbDtcbiAgICAgIHNlbGYuJCRwcm9jID0gcHJvYztcblxuICAgICAgcmV0dXJuIGRlZmF1bHRfcHJvYztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGUoa2V5LCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgdmFsdWUgPSBPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuICN7eWllbGQga2V5fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfaWYoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZGVsZXRlX2lmKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiAhPT0gZmFsc2UgJiYgb2JqICE9PSBuaWwpIHtcbiAgICAgICAgICBpZiAoT3BhbC5oYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGR1cCBjbG9uZVxuXG4gIGRlZiBkaWcoa2V5LCAqa2V5cylcbiAgICBpdGVtID0gc2VsZltrZXldXG5cbiAgICAleHtcbiAgICAgIGlmIChpdGVtID09PSBuaWwgfHwga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGl0ZW0ucmVzcG9uZF90bz8oOmRpZylcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCIje2l0ZW0uY2xhc3N9IGRvZXMgbm90IGhhdmUgI2RpZyBtZXRob2RcIlxuICAgIGVuZFxuXG4gICAgaXRlbS5kaWcoKmtleXMpXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfa2V5KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfa2V5KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgYmxvY2soa2V5LiQkaXNfc3RyaW5nID8ga2V5IDoga2V5LmtleSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZWFjaF9wYWlyIGVhY2hcblxuICBkZWYgZWFjaF92YWx1ZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3ZhbHVlKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgYmxvY2soa2V5LiQkaXNfc3RyaW5nID8gc2VsZi4kJHNtYXBba2V5XSA6IGtleS52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVtcHR5P1xuICAgIGBzZWxmLiQka2V5cy5sZW5ndGggPT09IDBgXG4gIGVuZFxuXG4gIGFsaWFzIGVxbD8gPT1cblxuICBkZWYgZmV0Y2goa2V5LCBkZWZhdWx0cyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIHZhbHVlID0gT3BhbC5oYXNoX2dldChzZWxmLCBrZXkpO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBibG9jayhrZXkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmYXVsdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmFpc2UgS2V5RXJyb3IubmV3KFwia2V5IG5vdCBmb3VuZDogI3trZXkuaW5zcGVjdH1cIiwga2V5OiBrZXksIHJlY2VpdmVyOiBzZWxmKVxuICBlbmRcblxuICBkZWYgZmV0Y2hfdmFsdWVzKCprZXlzLCAmYmxvY2spXG4gICAga2V5cy5tYXAgeyB8a2V5fCBmZXRjaChrZXksICZibG9jaykgfVxuICBlbmRcblxuICBkZWYgZmxhdHRlbihsZXZlbCA9IDEpXG4gICAgbGV2ZWwgPSBPcGFsLmNvZXJjZV90byEobGV2ZWwsIEludGVnZXIsIDp0b19pbnQpXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG5cbiAgICAgICAgaWYgKHZhbHVlLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPT09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoI3tgdmFsdWVgLmZsYXR0ZW4oYGxldmVsIC0gMmApfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaGFzX2tleT8oa2V5KVxuICAgIGBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZGBcbiAgZW5kXG5cbiAgZGVmIGhhc192YWx1ZT8odmFsdWUpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoI3tgKGtleS4kJGlzX3N0cmluZyA/IHNlbGYuJCRzbWFwW2tleV0gOiBrZXkudmFsdWUpYCA9PSB2YWx1ZX0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgICV4e1xuICAgICAgdmFyIHRvcCA9IChPcGFsLmhhc2hfaWRzID09PSB1bmRlZmluZWQpLFxuICAgICAgICAgIGhhc2hfaWQgPSBzZWxmLiRvYmplY3RfaWQoKSxcbiAgICAgICAgICByZXN1bHQgPSBbJ0hhc2gnXSxcbiAgICAgICAgICBrZXksIGl0ZW07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICBPcGFsLmhhc2hfaWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPcGFsW2hhc2hfaWRdKSB7XG4gICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluIE9wYWwuaGFzaF9pZHMpIHtcbiAgICAgICAgICBpdGVtID0gT3BhbC5oYXNoX2lkc1trZXldO1xuICAgICAgICAgIGlmICgje2VxbD8oYGl0ZW1gKX0pIHtcbiAgICAgICAgICAgIHJldHVybiAnc2VsZic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgT3BhbC5oYXNoX2lkc1toYXNoX2lkXSA9IHNlbGY7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChba2V5LCBzZWxmLiQkc21hcFtrZXldLiRoYXNoKCldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW2tleS5rZXlfaGFzaCwga2V5LnZhbHVlLiRoYXNoKCldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0LnNvcnQoKS5qb2luKCk7XG5cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICBPcGFsLmhhc2hfaWRzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBpbmNsdWRlPyBoYXNfa2V5P1xuXG4gIGRlZiBpbmRleChvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YHZhbHVlYCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluZGV4ZXMoKmFyZ3MpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcmdzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGFyZ3NbaV07XG4gICAgICAgIHZhbHVlID0gT3BhbC5oYXNoX2dldChzZWxmLCBrZXkpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goI3tkZWZhdWx0fSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBpbmRpY2VzIGluZGV4ZXNcblxuICBgdmFyIGluc3BlY3RfaWRzYFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICB2YXIgdG9wID0gKGluc3BlY3RfaWRzID09PSB1bmRlZmluZWQpLFxuICAgICAgICAgIGhhc2hfaWQgPSBzZWxmLiRvYmplY3RfaWQoKSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIGluc3BlY3RfaWRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5zcGVjdF9pZHMuaGFzT3duUHJvcGVydHkoaGFzaF9pZCkpIHtcbiAgICAgICAgICByZXR1cm4gJ3suLi59JztcbiAgICAgICAgfVxuXG4gICAgICAgIGluc3BlY3RfaWRzW2hhc2hfaWRdID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleS4kaW5zcGVjdCgpICsgJz0+JyArIHZhbHVlLiRpbnNwZWN0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICd7JyArIHJlc3VsdC5qb2luKCcsICcpICsgJ30nO1xuXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgaW5zcGVjdF9pZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnZlcnRcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBPcGFsLmhhc2hfcHV0KGhhc2gsIHZhbHVlLCBrZXkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBrZWVwX2lmKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmtlZXBfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqID09PSBmYWxzZSB8fCBvYmogPT09IG5pbCkge1xuICAgICAgICAgIGlmIChPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMga2V5IGluZGV4XG5cbiAgYWxpYXMga2V5PyBoYXNfa2V5P1xuXG4gIGRlZiBrZXlzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleS5rZXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYHNlbGYuJCRrZXlzLmxlbmd0aGBcbiAgZW5kXG5cbiAgYWxpYXMgbWVtYmVyPyBoYXNfa2V5P1xuXG4gIGRlZiBtZXJnZShvdGhlciwgJmJsb2NrKVxuICAgIGR1cC5tZXJnZSEob3RoZXIsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIG1lcmdlIShvdGhlciwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKCFvdGhlci4kJGlzX2hhc2gpIHtcbiAgICAgICAgb3RoZXIgPSAje09wYWwuY29lcmNlX3RvIShvdGhlciwgSGFzaCwgOnRvX2hhc2gpfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGksIG90aGVyX2tleXMgPSBvdGhlci4kJGtleXMsIGxlbmd0aCA9IG90aGVyX2tleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvdGhlcl92YWx1ZTtcblxuICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAga2V5ID0gb3RoZXJfa2V5c1tpXTtcblxuICAgICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG90aGVyX3ZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBPcGFsLmhhc2hfcHV0KHNlbGYsIGtleSwgb3RoZXJfdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBvdGhlcl9rZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICBvdGhlcl92YWx1ZSA9IG90aGVyLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG90aGVyX3ZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IE9wYWwuaGFzaF9nZXQoc2VsZiwga2V5KTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCBvdGhlcl92YWx1ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBPcGFsLmhhc2hfcHV0KHNlbGYsIGtleSwgYmxvY2soa2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWUpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmFzc29jKG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVoYXNoXG4gICAgJXh7XG4gICAgICBPcGFsLmhhc2hfcmVoYXNoKHNlbGYpO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbmlsKSB7XG4gICAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgY2hhbmdlc193ZXJlX21hZGUgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiAhPT0gZmFsc2UgJiYgb2JqICE9PSBuaWwpIHtcbiAgICAgICAgICBpZiAoT3BhbC5oYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXNfd2VyZV9tYWRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhbmdlc193ZXJlX21hZGUgPyBzZWxmIDogbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlcGxhY2Uob3RoZXIpXG4gICAgb3RoZXIgPSBPcGFsLmNvZXJjZV90byEob3RoZXIsIEhhc2gsIDp0b19oYXNoKVxuXG4gICAgJXh7XG4gICAgICBPcGFsLmhhc2hfaW5pdChzZWxmKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG90aGVyX2tleXMgPSBvdGhlci4kJGtleXMsIGxlbmd0aCA9IG90aGVyX2tleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvdGhlcl92YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IG90aGVyX2tleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCBvdGhlcl92YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgb3RoZXIuZGVmYXVsdF9wcm9jXG4gICAgICBzZWxmLmRlZmF1bHRfcHJvYyA9IG90aGVyLmRlZmF1bHRfcHJvY1xuICAgIGVsc2VcbiAgICAgIHNlbGYuZGVmYXVsdCA9IG90aGVyLmRlZmF1bHRcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzZWxlY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9IE9wYWwuaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqICE9PSBmYWxzZSAmJiBvYmogIT09IG5pbCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzZWxlY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IG5pbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSBuaWwpIHtcbiAgICAgICAgICBpZiAoT3BhbC5oYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBzZWxmO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBmaWx0ZXIgc2VsZWN0XG4gIGFsaWFzIGZpbHRlciEgc2VsZWN0IVxuXG4gIGRlZiBzaGlmdFxuICAgICV4e1xuICAgICAgdmFyIGtleXMgPSBzZWxmLiQka2V5cyxcbiAgICAgICAgICBrZXk7XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAga2V5ID0ga2V5c1swXTtcblxuICAgICAgICBrZXkgPSBrZXkuJCRpc19zdHJpbmcgPyBrZXkgOiBrZXkua2V5O1xuXG4gICAgICAgIHJldHVybiBba2V5LCBPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kZGVmYXVsdChuaWwpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc2l6ZSBsZW5ndGhcblxuICBkZWYgc2xpY2UoKmtleXMpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldLCB2YWx1ZSA9IE9wYWwuaGFzaF9nZXQoc2VsZiwga2V5KTtcblxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc3RvcmUgW109XG5cbiAgZGVmIHRvX2FcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9faCgmYmxvY2spXG4gICAgcmV0dXJuIG1hcCgmYmxvY2spLnRvX2ggaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkY2xhc3MgPT09IE9wYWwuSGFzaCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc2ggPSBuZXcgT3BhbC5IYXNoKCk7XG5cbiAgICAgIE9wYWwuaGFzaF9pbml0KGhhc2gpO1xuICAgICAgT3BhbC5oYXNoX2Nsb25lKHNlbGYsIGhhc2gpO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19oYXNoXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgIHByb2MgZG8gfGtleSA9IHVuZGVmaW5lZHxcbiAgICAgICV4e1xuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBrZXkgZ2l2ZW4nfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGZba2V5XVxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyB0b19zIGluc3BlY3RcblxuICBkZWYgdHJhbnNmb3JtX2tleXMoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX2tleXMpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBrZXkgPSBPcGFsLnlpZWxkMShibG9jaywga2V5KTtcblxuICAgICAgICBPcGFsLmhhc2hfcHV0KHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdHJhbnNmb3JtX2tleXMhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRyYW5zZm9ybV9rZXlzISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBrZXlzID0gT3BhbC5zbGljZS5jYWxsKHNlbGYuJCRrZXlzKSxcbiAgICAgICAgICBpLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgbmV3X2tleTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3X2tleSA9IE9wYWwueWllbGQxKGJsb2NrLCBrZXkpO1xuXG4gICAgICAgIE9wYWwuaGFzaF9kZWxldGUoc2VsZiwga2V5KTtcbiAgICAgICAgT3BhbC5oYXNoX3B1dChzZWxmLCBuZXdfa2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybV92YWx1ZXMoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX3ZhbHVlcykgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBPcGFsLmhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHZhbHVlKTtcblxuICAgICAgICBPcGFsLmhhc2hfcHV0KHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdHJhbnNmb3JtX3ZhbHVlcyEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX3ZhbHVlcyEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgdmFsdWUpO1xuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgdXBkYXRlIG1lcmdlIVxuXG4gIGFsaWFzIHZhbHVlPyBoYXNfdmFsdWU/XG5cbiAgYWxpYXMgdmFsdWVzX2F0IGluZGV4ZXNcblxuICBkZWYgdmFsdWVzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChzZWxmLiQkc21hcFtrZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsImluY2x1ZGUiLCJbXSIsInNlbGYiLCJjb2VyY2VfdG8/IiwiYXJndiIsIjAiLCJhbGxvY2F0ZSIsIm1lcmdlISIsInJhaXNlIiwidHJ5X2NvbnZlcnQiLCJvYmoiLCJpbml0aWFsaXplIiwiPT0iLCI+PSIsIm90aGVyIiwiY29lcmNlX3RvISIsInJlc3VsdCIsImVhY2giLCJ2YWwiLCJmZXRjaCIsIm90aGVyX2tleSIsIj4iLCI8IiwiPD0iLCJbXT0iLCJhc3NvYyIsIm9iamVjdCIsImNsZWFyIiwiY2xvbmUiLCJjb21wYWN0IiwiY29tcGFjdCEiLCJjb21wYXJlX2J5X2lkZW50aXR5IiwiY29tcGFyZV9ieV9pZGVudGl0eT8iLCJkZWZhdWx0IiwiZGVmYXVsdD0iLCJkZWZhdWx0X3Byb2MiLCJkZWZhdWx0X3Byb2M9IiwibGFtYmRhPyIsImFyaXR5IiwiYWJzIiwiZGVsZXRlIiwia2V5IiwiZGVsZXRlX2lmIiwiYmxvY2siLCJlbnVtX2ZvciIsInNpemUiLCJkaWciLCJpdGVtIiwicmVzcG9uZF90bz8iLCJrZXlzIiwiZWFjaF9rZXkiLCJlYWNoX3ZhbHVlIiwiZW1wdHk/IiwibmV3IiwiaW5zcGVjdCIsImZldGNoX3ZhbHVlcyIsIm1hcCIsImZsYXR0ZW4iLCIxIiwibGV2ZWwiLCJoYXNfa2V5PyIsImhhc192YWx1ZT8iLCJ2YWx1ZSIsImhhc2giLCJlcWw/IiwiaW5kZXgiLCJpbmRleGVzIiwiaW52ZXJ0Iiwia2VlcF9pZiIsImxlbmd0aCIsIm1lcmdlIiwiZHVwIiwicmFzc29jIiwicmVoYXNoIiwicmVqZWN0IiwicmVqZWN0ISIsInJlcGxhY2UiLCIkd3JpdGVyIiwiLSIsInNlbGVjdCIsInNlbGVjdCEiLCJzaGlmdCIsInNsaWNlIiwidG9fYSIsInRvX2giLCJibG9ja19naXZlbj8iLCJ0b19oYXNoIiwidG9fcHJvYyIsInByb2MiLCJ0cmFuc2Zvcm1fa2V5cyIsInRyYW5zZm9ybV9rZXlzISIsInRyYW5zZm9ybV92YWx1ZXMiLCJ0cmFuc2Zvcm1fdmFsdWVzISIsInZhbHVlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxvQkFBUkEsQ0FBQTtBQUFBLEVBVUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLFFBQUFDLFNBQUFBLENBQVEsMEJBQVJBLENBQUE7QUFBQSxJQUdDLGlDQUhEO0FBQUEsSUFLQUMsVUFBSUMsSUFBSkQsU0FBQUEsYUFBQUEsU0FqQkYsRUFpQkVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQWpCRjtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQWlCYyxNQUFBLGtCQWpCZDtBQUFBO0FBbUJBOztBQUVBO0FBQ0EsZUFBaUIsb0JBQUFFLGVBQUFBLENBQWdCQyxJQUFBSCxPQUFBQSxDQUFLSSxDQUFMSixHQUFTLHNCQUFNLFNBQS9CRSxDQUF5QztBQUMxRDtBQUNBLHFCQUFtQkcsVUFBQUEsQ0FBQUEsQ0FBQUMsV0FBQUEsQ0FBaUIsSUFBakJBLENBQXdCO0FBQzNDOztBQUVBLGVBQWlCLG9CQUFBSixlQUFBQSxDQUFnQkMsSUFBQUgsT0FBQUEsQ0FBS0ksQ0FBTEosR0FBUyx1QkFBTyxRQUFoQ0UsQ0FBeUM7QUFDMUQ7QUFDQSxjQUFZSyxPQUFBQSxDQUFNLCtCQUFlLGtDQUFyQkE7QUFDWjs7QUFFQTtBQUNBLG1CQUFpQkYsVUFBQUEsQ0FBQUEsQ0FBUzs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBY0UsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsOEJBQUEsR0FBQSxDQUFnQyxjQUFoQyxDQUFBLEdBQUEsWUFBckJBO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBVUEsT0FBQUEsQ0FBTSwrQkFBZSxrQ0FBckJBO0FBQ1Y7O0FBRUEsaUJBQWVGLFVBQUFBLENBQUFBLENBQVM7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBL0RBO0FBaUJFTCxJQUFBQSxDQUFBQSx5QkFBQUEsQ0FMQTtBQUFBLElBc0RBSyxVQUFJSixJQUFKSSxlQUFBQSxtQkFBQUEsb0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQVZFQSxJQUFBQSxDQUFBQSw4QkFBQUEsQ0F0REE7QUFBQSxJQW1FQUcsVUFBSVAsSUFBSk8sa0JBQUFBLHNCQUFBQSx1QkFBcUIsR0FBckJBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsb0JBQUFOLGVBQUFBLENBQWdCTyxLQUFLLHNCQUFNLFNBQTNCUDtBQURGTSxJQUFBQSxDQUFBQSxpQ0FBQUEsQ0FuRUE7QUFBQTtBQXVFQUUsSUFBQUEsOEJBQUFBLHFCQUFBQSxzQkFBZSxRQUFmQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUFuRkY7QUFtRnVDLE1BQUEseUNBbkZ2QztBQUFBLE1BQUE7QUFBQTtBQXFGQTtBQUNBLFlBQVVILE9BQUFBLENBQU0sK0JBQWUscUNBQXJCQTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBNUZBO0FBbUZFRyxJQUFBQSxDQUFBQSxpQ0FBQUEsQ0F2RUE7QUFBQTtBQW1GQUMsSUFBQUEsc0JBQUFBLGlCQUFBQSxTQUFPLEtBQVBBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQS9CRUEsSUFBQUEsQ0FBQUEsNEJBQUFBLENBbkZBO0FBQUE7QUFxSEFDLElBQUFBLHNCQUFBQSxpQkFBQUEsU0FBTyxLQUFQQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBQyxRQUFRLG9CQUFBQyxlQUFBQSxDQUFnQkQsT0FBTyxzQkFBTSxTQUE3QkMsQ0FBUjtBQUFBO0FBR0o7QUFDQTtBQUNBO0FBQ0EsSUFOSTtBQUFBLE1BUUFDLFNBQVMsSUFSVDtBQUFBLE1BVUFDLE1BQUFILEtBQUFHLFFBQUFBLEVBQUFBLEVBQUFBLEVBNUlKLGdCQTRJbUIsU0FBRCxFQUFZLFNBNUk5QixFQUFBOztBQUFBO0FBQUE7QUE0SW1CLFFBQUE7QUFBQSxRQUFBO0FBQUEsUUFBQSxDQTVJbkI7QUFBQTtBQTRJOEIsUUFBQTtBQUFBLFFBQUE7QUFBQSxRQUFBLENBNUk5QjtBQUFBLFFBNklNQyxVQUFNQyxPQUFBQSxDQUFNQyxXQUFZLElBQWxCRCxDQTdJWjtBQUFBO0FBZ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFwSkEsQ0FBQSxrQkFBQSxpQkFBQSxLQTRJSUYsQ0FWQTtBQUFBLE1BcUJBLE9BQUFELE1BckJBO0FBREZILElBQUFBLENBQUFBLDRCQUFBQSxDQXJIQTtBQUFBO0FBOElBUSxJQUFBQSxxQkFBQUEsY0FBQUEsU0FBTSxLQUFOQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBUCxRQUFRLG9CQUFBQyxlQUFBQSxDQUFnQkQsT0FBTyxzQkFBTSxTQUE3QkMsQ0FBUjtBQUFBO0FBR0o7QUFDQTtBQUNBO0FBQ0EsSUFOSTtBQUFBLE1BUUEsT0FBQUYsT0FBQVgsSUFBQVcsRUFBUUMsS0FBUkQsQ0FSQTtBQURGUSxJQUFBQSxDQUFBQSx5QkFBQUEsQ0E5SUE7QUFBQTtBQTBKQUMsSUFBQUEscUJBQUFBLGNBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQVIsUUFBUSxvQkFBQUMsZUFBQUEsQ0FBZ0JELE9BQU8sc0JBQU0sU0FBN0JDLENBQVI7QUFBQSxNQUNBLE9BQUFNLE9BQUFQLEtBQUFPLEVBQVFuQixJQUFSbUIsQ0FEQTtBQURGQyxJQUFBQSxDQUFBQSx5QkFBQUEsQ0ExSkE7QUFBQTtBQStKQUMsSUFBQUEsc0JBQUFBLGtCQUFBQSxTQUFPLEtBQVBBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFULFFBQVEsb0JBQUFDLGVBQUFBLENBQWdCRCxPQUFPLHNCQUFNLFNBQTdCQyxDQUFSO0FBQUEsTUFDQSxPQUFBRixPQUFBQyxLQUFBRCxFQUFTWCxJQUFUVyxDQURBO0FBREZVLElBQUFBLENBQUFBLDZCQUFBQSxDQS9KQTtBQUFBO0FBb0tBdEIsSUFBQUEsc0JBQUFBLGNBQUFBLFNBQU8sR0FBUEE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFURUEsSUFBQUEsQ0FBQUEseUJBQUFBLENBcEtBO0FBQUE7QUFnTEF1QixJQUFBQSx1QkFBQUEsaUJBQUFBLFNBQVEsR0FBRCxFQUFNLEtBQWJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0E7QUFDQTtBQUpFQSxJQUFBQSxDQUFBQSw0QkFBQUEsQ0FoTEE7QUFBQTtBQXVMQUMsSUFBQUEseUJBQUFBLGlCQUFBQSxpQkFBVSxNQUFWQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBOztBQUVBO0FBQ0EsY0FBZ0IsQ0FBQyxHQUFELENBQUFiLE9BQUFBLENBQVNjLE1BQVRkLENBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGNBQWdCLENBQUMsT0FBRCxDQUFBQSxPQUFBQSxDQUFhYyxNQUFiZCxDQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBakJFYSxJQUFBQSxDQUFBQSw0QkFBQUEsQ0F2TEE7QUFBQTtBQTJNQUUsSUFBQUEseUJBQUFBLGlCQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7QUFDQTtBQUNBO0FBSkVBLElBQUFBLENBQUFBLDRCQUFBQSxDQTNNQTtBQUFBO0FBa05BQyxJQUFBQSx5QkFBQUEsaUJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFSRUEsSUFBQUEsQ0FBQUEsNEJBQUFBLENBbE5BO0FBQUE7QUE2TkFDLElBQUFBLDJCQUFBQSxtQkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFwQkVBLElBQUFBLENBQUFBLDhCQUFBQSxDQTdOQTtBQUFBO0FBb1BBQyxJQUFBQSw0QkFBQUEsd0JBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQXhCRUEsSUFBQUEsQ0FBQUEsbUNBQUFBLENBcFBBO0FBQUE7QUErUUFDLElBQUFBLHVDQUFBQSwrQkFBQUEsK0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXlCLFlBQUEsRUFBQUEscUJBQUFBLENBQUFBLENBQXdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCRUEsSUFBQUEsQ0FBQUEsMENBQUFBLENBL1FBO0FBQUE7QUF1U0FDLElBQUFBLHdDQUFBQSxvQ0FBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQywyQkFBRDtBQURGQSxJQUFBQSxDQUFBQSwrQ0FBQUEsQ0F2U0E7QUFBQTtBQTJTQUMsSUFBQUEsMkJBQUFBLG1CQUFBQSxTQUFZLEdBQVpBO0FBQUFBLE1BQUFBOztBQUFBQTtBQXZURixNQUFBO0FBQUE7QUF5VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQWhVQTtBQXVURUEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBM1NBO0FBQUE7QUF1VEFDLElBQUFBLDRCQUFBQSxzQkFBQUEsU0FBYSxNQUFiQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFORUEsSUFBQUEsQ0FBQUEsaUNBQUFBLENBdlRBO0FBQUE7QUFnVUFDLElBQUFBLGdDQUFBQSx3QkFBQUEsd0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFORUEsSUFBQUEsQ0FBQUEsbUNBQUFBLENBaFVBO0FBQUE7QUF5VUFDLElBQUFBLGlDQUFBQSwyQkFBQUEsU0FBa0IsWUFBbEJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGOztBQUVBO0FBQ0EsZUFBaUIsb0JBQUFyQixlQUFBQSxDQUFpQixNQUFPLHNCQUFNLFNBQTlCQSxDQUF3Qzs7QUFFekQsWUFBYyxDQUFDLElBQUQsQ0FBQXNCLFlBQUFBLENBQUFBLENBQWUsSUFBTSxDQUFDLElBQUQsQ0FBQUMsT0FBQUEsQ0FBQUEsQ0FBQUMsS0FBQUEsQ0FBQUEsQ0FBaUI7QUFDcEQsY0FBWS9CLE9BQUFBLENBQU0sMkJBQVcsa0NBQWpCQSxDQUFvRDtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQWhCRTRCLElBQUFBLENBQUFBLHNDQUFBQSxDQXpVQTtBQUFBO0FBNFZBSSxJQUFBQSwwQkFBQUEsa0JBQUFBLFNBQVcsR0FBWEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBeFdGO0FBd1drQixNQUFBLHNDQXhXbEI7QUFBQTtBQTBXQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFpQixtQkFBTUMsR0FBTixDQUFVO0FBQzNCOztBQUVBO0FBQ0EsSUFyWEE7QUF3V0VELElBQUFBLENBQUFBLDZCQUFBQSxDQTVWQTtBQUFBO0FBNFdBRSxJQUFBQSw2QkFBQUEscUJBQUFBLHFCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUF4WEY7QUF3WGdCLE1BQUEseUNBeFhoQjtBQUFBLE1BeVhJLElBQUEsUUFBNENDLEtBQTVDLENBQUE7QUFBQSxNQUFBO0FBQUEsUUFBQSxPQUFPQyxVQUFBQSxZQUFBQSxFQUFBQSxDQUFTLFdBQVRBLENBQUFBLEVBelhYLGlCQUFBLEVBQUE7O0FBQUEsUUF5WGtDLFdBQUFDLE1BQUFBLENBQUFBLENBelhsQyxtQkFBQSxrQkFBQSxNQXlYV0Q7QUFBUCxNQUFBLENBelhKO0FBQUE7QUE0WEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQWpaQTtBQXdYRUYsSUFBQUEsQ0FBQUEsZ0NBQUFBLENBNVdBO0FBQUEsSUF3WUEsaUJBQU0sS0FBTixFQUFVLE9BQVYsQ0F4WUE7QUFBQTtBQTBZQUksSUFBQUEsdUJBQUFBLGVBQUFBLGVBQVEsR0FBRCxFQXRaVCxFQXNaRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBdFpGO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBc1plLE1BQUEsa0JBdFpmO0FBQUEsTUF1WklDLE9BQU83QyxJQUFBRCxPQUFBQSxDQUFLd0MsR0FBTHhDLENBdlpYO0FBQUE7QUEwWkE7QUFDQTtBQUNBO0FBQ0EsSUE3WkE7QUFBQSxNQStaSSxJQUFBLFFBQU84QyxJQUFBQyxnQkFBQUEsQ0FBaUIsS0FBakJBLENBQVAsQ0FBQTtBQUFBLE1BQUE7QUFBQSxZQUNFeEMsT0FBQUEsQ0FBTSwyQkFBVyxFQUFBLEdBQUEsQ0FBR3VDLElBQUFoRCxPQUFBQSxDQUFBQSxDQUFILENBQUEsR0FBQSw0QkFBakJTO0FBREYsTUFBQSxDQS9aSjtBQUFBLE1BbWFJLE9BQUFzQyxNQUFBQyxJQUFBRCxPQUFBQSxFQUFTLFVBQUNHLElBQUQsQ0FBVEgsQ0FuYUo7QUFzWkVBLElBQUFBLENBQUFBLDJCQUFBQSxDQTFZQTtBQUFBO0FBMFpBN0IsSUFBQUEsd0JBQUFBLGdCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBdGFGO0FBc2FXLE1BQUEsb0NBdGFYO0FBQUEsTUF1YUksSUFBQSxRQUF1QzBCLEtBQXZDLENBQUE7QUFBQSxNQUFBO0FBQUEsUUFBQSxPQUFPQyxVQUFBQSxZQUFBQSxFQUFBQSxDQUFTLE1BQVRBLENBQUFBLEVBdmFYLGlCQUFBLEVBQUE7O0FBQUEsUUF1YTZCLFdBQUFDLE1BQUFBLENBQUFBLENBdmE3QixtQkFBQSxrQkFBQSxNQXVhV0Q7QUFBUCxNQUFBLENBdmFKO0FBQUE7QUEwYUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBeGJBO0FBc2FFM0IsSUFBQUEsQ0FBQUEsMkJBQUFBLENBMVpBO0FBQUE7QUErYUFpQyxJQUFBQSw0QkFBQUEsb0JBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUEzYkY7QUEyYmUsTUFBQSx3Q0EzYmY7QUFBQSxNQTRiSSxJQUFBLFFBQTJDUCxLQUEzQyxDQUFBO0FBQUEsTUFBQTtBQUFBLFFBQUEsT0FBT0MsVUFBQUEsWUFBQUEsRUFBQUEsQ0FBUyxVQUFUQSxDQUFBQSxFQTViWCxpQkFBQSxFQUFBOztBQUFBLFFBNGJpQyxXQUFBQyxNQUFBQSxDQUFBQSxDQTViakMsbUJBQUEsa0JBQUEsTUE0YldEO0FBQVAsTUFBQSxDQTViSjtBQUFBO0FBK2JBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBdGNBO0FBMmJFTSxJQUFBQSxDQUFBQSwrQkFBQUEsQ0EvYUE7QUFBQSxJQTZiQSxpQkFBTSxXQUFOLEVBQWdCLE1BQWhCLENBN2JBO0FBQUE7QUErYkFDLElBQUFBLDhCQUFBQSxzQkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQTNjRjtBQTJjaUIsTUFBQSwwQ0EzY2pCO0FBQUEsTUE0Y0ksSUFBQSxRQUE2Q1IsS0FBN0MsQ0FBQTtBQUFBLE1BQUE7QUFBQSxRQUFBLE9BQU9DLFVBQUFBLFlBQUFBLEVBQUFBLENBQVMsWUFBVEEsQ0FBQUEsRUE1Y1gsaUJBQUEsRUFBQTs7QUFBQSxRQTRjbUMsV0FBQUMsTUFBQUEsQ0FBQUEsQ0E1Y25DLG1CQUFBLGtCQUFBLE1BNGNXRDtBQUFQLE1BQUEsQ0E1Y0o7QUFBQTtBQStjQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQXRkQTtBQTJjRU8sSUFBQUEsQ0FBQUEsaUNBQUFBLENBL2JBO0FBQUE7QUE2Y0FDLElBQUFBLDBCQUFBQSxzQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyx3QkFBRDtBQURGQSxJQUFBQSxDQUFBQSxpQ0FBQUEsQ0E3Y0E7QUFBQSxJQWlkQSxpQkFBTSxNQUFOLEVBQVcsSUFBWCxDQWpkQTtBQUFBO0FBbWRBakMsSUFBQUEseUJBQUFBLGlCQUFBQSxpQkFBVSxHQUFELEVBQU0sUUFBZkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBL2RGO0FBK2R1QyxNQUFBLHFDQS9kdkM7QUFBQSxNQUFBO0FBQUE7QUFpZUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQTllQTtBQUFBLE1BZ2ZJLFdBQUFYLE9BQUFBLENBQU0sd0JBQUE2QyxLQUFBQSxDQUFhLEVBQUEsR0FBQSxpQkFBQSxHQUFBLENBQWtCWixHQUFBYSxTQUFBQSxDQUFBQSxDQUFsQixHQUFpQyw2QkFBQSxPQUFLYixHQUFMLEVBQUEsWUFBb0J2QyxJQUFwQixFQUE5Q21ELENBQU43QyxDQWhmSjtBQStkRVcsSUFBQUEsQ0FBQUEsNkJBQUFBLENBbmRBO0FBQUE7QUF1ZUFvQyxJQUFBQSxnQ0FBQUEsd0JBQUFBLHdCQW5mRixFQW1mRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBbmZGO0FBbWYwQixNQUFBLDRDQW5mMUI7QUFBQTtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQW1mbUIsTUFBQSxrQkFuZm5CO0FBQUEsTUFvZkksT0FBQUMsTUFBQVAsSUFBQU8sT0FBQUEsRUFBQUEsRUFBQUEsRUFwZkosaUJBb2ZnQixHQXBmaEIsRUFBQTs7QUFBQTtBQUFBO0FBb2ZnQixRQUFBO0FBQUEsUUFBQTtBQUFBLFFBQUEsQ0FwZmhCO0FBQUEsUUFvZnFCLE9BQUFyQyxVQUFBQSxTQUFBQSxFQUFBQSxDQUFNc0IsR0FBTnRCLENBQUFBLEVBQVl3QixnQkFBWnhCLENBcGZyQixDQUFBLG1CQUFBLGtCQUFBLE1Bb2ZJcUMsQ0FwZko7QUFtZkVELElBQUFBLENBQUFBLG9DQUFBQSxDQXZlQTtBQUFBO0FBMmVBRSxJQUFBQSwyQkFBQUEsbUJBQUFBLG1CQUFZLEtBQVpBO0FBQUFBLE1BQUFBOztBQUFBQTtBQXZmRjtBQXVmYyxNQUFBO0FBQUEsTUFBQSxVQUFRQyxDQUFSO0FBQUEsTUFBQSxDQXZmZDtBQUFBLE1Bd2ZJQyxRQUFRLG9CQUFBNUMsZUFBQUEsQ0FBZ0I0QyxPQUFPLHlCQUFTLFFBQWhDNUMsQ0F4Zlo7QUFBQTtBQTJmQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFtQyxDQUFDLEtBQUQsQ0FBQTBDLFNBQUFBLENBQWlCLFNBQWpCQSxDQUE2QjtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQXZoQkE7QUF1ZkVBLElBQUFBLENBQUFBLCtCQUFBQSxDQTNlQTtBQUFBO0FBOGdCQUcsSUFBQUEsNEJBQUFBLHdCQUFBQSxTQUFhLEdBQWJBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsc0NBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsbUNBQUFBLENBOWdCQTtBQUFBO0FBa2hCQUMsSUFBQUEsOEJBQUFBLDBCQUFBQSxTQUFlLEtBQWZBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0E7O0FBRUEsWUFBYyxDQUFDLGdEQUFELENBQUFqRCxPQUFBQSxDQUFzRGtELEtBQXREbEQsQ0FBNEQ7QUFDMUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFYRWlELElBQUFBLENBQUFBLHFDQUFBQSxDQWxoQkE7QUFBQTtBQWdpQkFFLElBQUFBLHdCQUFBQSxnQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWdCQyxTQUFBQSxDQUFNLElBQU5BLENBQWE7QUFDN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTFDRUQsSUFBQUEsQ0FBQUEsMkJBQUFBLENBaGlCQTtBQUFBLElBNmtCQSxpQkFBTSxVQUFOLEVBQWUsVUFBZixDQTdrQkE7QUFBQTtBQStrQkFFLElBQUFBLHlCQUFBQSxpQkFBQUEsaUJBQVUsTUFBVkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBYyxDQUFDLEtBQUQsQ0FBQXJELE9BQUFBLENBQVdjLE1BQVhkLENBQWtCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBbEJFcUQsSUFBQUEsQ0FBQUEsNEJBQUFBLENBL2tCQTtBQUFBO0FBb21CQUMsSUFBQUEsMkJBQUFBLG1CQUFBQSxtQkFobkJGLEVBZ25CRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBaG5CRjtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQWduQmMsTUFBQSxrQkFobkJkO0FBQUE7QUFrbkJBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUF3QmpDLFNBQUFBLENBQUFBLENBQVE7QUFDaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFqb0JBO0FBZ25CRWlDLElBQUFBLENBQUFBLCtCQUFBQSxDQXBtQkE7QUFBQSxJQXduQkEsaUJBQU0sU0FBTixFQUFjLFNBQWQsQ0F4bkJBO0FBQUEsSUEwbkJDLGVBMW5CRDtBQUFBO0FBNG5CQVosSUFBQUEsMkJBQUFBLG1CQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJDRUEsSUFBQUEsQ0FBQUEsOEJBQUFBLENBNW5CQTtBQUFBO0FBb3FCQWEsSUFBQUEsMEJBQUFBLGtCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBbEJFQSxJQUFBQSxDQUFBQSw2QkFBQUEsQ0FwcUJBO0FBQUE7QUF5ckJBQyxJQUFBQSwyQkFBQUEsbUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUFyc0JGO0FBcXNCYyxNQUFBLHVDQXJzQmQ7QUFBQSxNQXNzQkksSUFBQSxRQUEwQ3pCLEtBQTFDLENBQUE7QUFBQSxNQUFBO0FBQUEsUUFBQSxPQUFPQyxVQUFBQSxZQUFBQSxFQUFBQSxDQUFTLFNBQVRBLENBQUFBLEVBdHNCWCxpQkFBQSxFQUFBOztBQUFBLFFBc3NCZ0MsV0FBQUMsTUFBQUEsQ0FBQUEsQ0F0c0JoQyxtQkFBQSxrQkFBQSxNQXNzQldEO0FBQVAsTUFBQSxDQXRzQko7QUFBQTtBQXlzQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQTl0QkE7QUFxc0JFd0IsSUFBQUEsQ0FBQUEsOEJBQUFBLENBenJCQTtBQUFBLElBcXRCQSxpQkFBTSxLQUFOLEVBQVUsT0FBVixDQXJ0QkE7QUFBQSxJQXV0QkEsaUJBQU0sTUFBTixFQUFXLFVBQVgsQ0F2dEJBO0FBQUE7QUF5dEJBbkIsSUFBQUEsd0JBQUFBLGdCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQWZFQSxJQUFBQSxDQUFBQSwyQkFBQUEsQ0F6dEJBO0FBQUE7QUEydUJBb0IsSUFBQUEsMEJBQUFBLGtCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyxrQkFBRDtBQURGQSxJQUFBQSxDQUFBQSw2QkFBQUEsQ0EzdUJBO0FBQUEsSUErdUJBLGlCQUFNLFNBQU4sRUFBYyxVQUFkLENBL3VCQTtBQUFBO0FBaXZCQUMsSUFBQUEseUJBQUFBLGlCQUFBQSxpQkFBVSxLQUFWQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUE3dkJGO0FBNnZCbUIsTUFBQSxxQ0E3dkJuQjtBQUFBLE1BOHZCSSxPQUFBL0QsVUFBQWdFLEtBQUFBLENBQUFBLENBQUFoRSxVQUFBQSxFQUFBQSxDQUFXTyxLQUFYUCxDQUFBQSxFQUFtQm9DLGdCQUFuQnBDLENBOXZCSjtBQTZ2QkUrRCxJQUFBQSxDQUFBQSw0QkFBQUEsQ0FqdkJBO0FBQUE7QUFxdkJBL0QsSUFBQUEsMEJBQUFBLHNCQUFBQSxTQUFXLEtBQVhBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQWp3QkY7QUFpd0JvQixNQUFBLDBDQWp3QnBCO0FBQUE7QUFtd0JBO0FBQ0EsZ0JBQWtCLG9CQUFBUSxlQUFBQSxDQUFnQkQsT0FBTyxzQkFBTSxTQUE3QkMsQ0FBdUM7QUFDekQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBL3lCQTtBQWl3QkVSLElBQUFBLENBQUFBLGlDQUFBQSxDQXJ2QkE7QUFBQTtBQXN5QkFpRSxJQUFBQSwwQkFBQUEsa0JBQUFBLGtCQUFXLE1BQVhBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQWMsQ0FBQyxLQUFELENBQUE1RCxPQUFBQSxDQUFXYyxNQUFYZCxDQUFrQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQWxCRTRELElBQUFBLENBQUFBLDZCQUFBQSxDQXR5QkE7QUFBQTtBQTJ6QkFDLElBQUFBLDBCQUFBQSxrQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0E7QUFDQTtBQUpFQSxJQUFBQSxDQUFBQSw2QkFBQUEsQ0EzekJBO0FBQUE7QUFrMEJBQyxJQUFBQSwwQkFBQUEsa0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUE5MEJGO0FBODBCYSxNQUFBLHNDQTkwQmI7QUFBQSxNQSswQkksSUFBQSxRQUF5Qy9CLEtBQXpDLENBQUE7QUFBQSxNQUFBO0FBQUEsUUFBQSxPQUFPQyxVQUFBQSxZQUFBQSxFQUFBQSxDQUFTLFFBQVRBLENBQUFBLEVBLzBCWCxpQkFBQSxFQUFBOztBQUFBLFFBKzBCK0IsV0FBQUMsTUFBQUEsQ0FBQUEsQ0EvMEIvQixtQkFBQSxrQkFBQSxNQSswQldEO0FBQVAsTUFBQSxDQS8wQko7QUFBQTtBQWsxQkE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQXQyQkE7QUE4MEJFOEIsSUFBQUEsQ0FBQUEsNkJBQUFBLENBbDBCQTtBQUFBO0FBNjFCQUMsSUFBQUEsMkJBQUFBLHVCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUF6MkJGO0FBeTJCYyxNQUFBLDJDQXoyQmQ7QUFBQSxNQTAyQkksSUFBQSxRQUEwQ2hDLEtBQTFDLENBQUE7QUFBQSxNQUFBO0FBQUEsUUFBQSxPQUFPQyxVQUFBQSxZQUFBQSxFQUFBQSxDQUFTLFNBQVRBLENBQUFBLEVBMTJCWCxpQkFBQSxFQUFBOztBQUFBLFFBMDJCZ0MsV0FBQUMsTUFBQUEsQ0FBQUEsQ0ExMkJoQyxtQkFBQSxrQkFBQSxNQTAyQldEO0FBQVAsTUFBQSxDQTEyQko7QUFBQTtBQTYyQkE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBcjRCQTtBQXkyQkUrQixJQUFBQSxDQUFBQSxrQ0FBQUEsQ0E3MUJBO0FBQUE7QUE0M0JBQyxJQUFBQSwyQkFBQUEsbUJBQUFBLG1CQUFZLEtBQVpBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUE5RCxRQUFRLG9CQUFBQyxlQUFBQSxDQUFnQkQsT0FBTyxzQkFBTSxTQUE3QkMsQ0FBUjtBQUFBO0FBR0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBakJJO0FBQUEsTUFtQkEsSUFBQSxRQUFHRCxLQUFBcUIsY0FBQUEsQ0FBQUEsQ0FBSCxDQUFBO0FBQUE7QUE1NUJKLFFBQUEwQyxVQUFBLENBNjVCMEIvRCxLQUFBcUIsY0FBQUEsQ0FBQUEsQ0E3NUIxQixDQUFBO0FBQUEsUUE2NUJNQyxNQUFBbEMsSUFBQWtDLGlCQUFBQSxFQTc1Qk4sVUFBQXlDLE9BQUEsQ0E2NUJNekMsQ0E3NUJOO0FBQUEsUUFBQXlDLE9BQUEsQ0FBQUMsVUFBQUQsT0FBQSxDQUFBLFFBQUEsQ0FBQUMsRUFBQXBCLENBQUFvQixDQUFBLENBQUE7QUE0NUJJLE1BQUE7QUFBQTtBQTU1QkosUUFBQUQsVUFBQSxDQSs1QnFCL0QsS0FBQW1CLFNBQUFBLENBQUFBLENBLzVCckIsQ0FBQTtBQUFBLFFBKzVCTUMsTUFBQWhDLElBQUFnQyxZQUFBQSxFQS81Qk4sVUFBQTJDLE9BQUEsQ0ErNUJNM0MsQ0EvNUJOO0FBQUEsUUFBQTJDLE9BQUEsQ0FBQUMsVUFBQUQsT0FBQSxDQUFBLFFBQUEsQ0FBQUMsRUFBQXBCLENBQUFvQixDQUFBLENBQUE7QUE0NUJJLE1BQUEsQ0FuQkE7QUFBQSxNQXlCQSxPQUFBNUUsSUF6QkE7QUFERjBFLElBQUFBLENBQUFBLDhCQUFBQSxDQTUzQkE7QUFBQTtBQXk1QkFHLElBQUFBLDBCQUFBQSxrQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQXI2QkY7QUFxNkJhLE1BQUEsc0NBcjZCYjtBQUFBLE1BczZCSSxJQUFBLFFBQXlDcEMsS0FBekMsQ0FBQTtBQUFBLE1BQUE7QUFBQSxRQUFBLE9BQU9DLFVBQUFBLFlBQUFBLEVBQUFBLENBQVMsUUFBVEEsQ0FBQUEsRUF0NkJYLGlCQUFBLEVBQUE7O0FBQUEsUUFzNkIrQixXQUFBQyxNQUFBQSxDQUFBQSxDQXQ2Qi9CLG1CQUFBLGtCQUFBLE1BczZCV0Q7QUFBUCxNQUFBLENBdDZCSjtBQUFBO0FBeTZCQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBNzdCQTtBQXE2QkVtQyxJQUFBQSxDQUFBQSw2QkFBQUEsQ0F6NUJBO0FBQUE7QUFvN0JBQyxJQUFBQSwyQkFBQUEsdUJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQWg4QkY7QUFnOEJjLE1BQUEsMkNBaDhCZDtBQUFBLE1BaThCSSxJQUFBLFFBQTBDckMsS0FBMUMsQ0FBQTtBQUFBLE1BQUE7QUFBQSxRQUFBLE9BQU9DLFVBQUFBLFlBQUFBLEVBQUFBLENBQVMsU0FBVEEsQ0FBQUEsRUFqOEJYLGlCQUFBLEVBQUE7O0FBQUEsUUFpOEJnQyxXQUFBQyxNQUFBQSxDQUFBQSxDQWo4QmhDLG1CQUFBLGtCQUFBLE1BaThCV0Q7QUFBUCxNQUFBLENBajhCSjtBQUFBO0FBbzhCQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUE1OUJBO0FBZzhCRW9DLElBQUFBLENBQUFBLGtDQUFBQSxDQXA3QkE7QUFBQSxJQW05QkEsaUJBQU0sUUFBTixFQUFhLFFBQWIsQ0FuOUJBO0FBQUEsSUFvOUJBLGlCQUFNLFNBQU4sRUFBYyxTQUFkLENBcDlCQTtBQUFBO0FBczlCQUMsSUFBQUEseUJBQUFBLGlCQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQWRFQSxJQUFBQSxDQUFBQSw0QkFBQUEsQ0F0OUJBO0FBQUEsSUF1K0JBLGlCQUFNLE1BQU4sRUFBVyxRQUFYLENBditCQTtBQUFBO0FBeStCQUMsSUFBQUEseUJBQUFBLGlCQUFBQSxpQkFyL0JGLEVBcS9CRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBci9CRjtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQXEvQlksTUFBQSxrQkFyL0JaO0FBQUE7QUF1L0JBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQWxnQ0E7QUFxL0JFQSxJQUFBQSxDQUFBQSw2QkFBQUEsQ0F6K0JBO0FBQUEsSUF5L0JBLGlCQUFNLE9BQU4sRUFBWSxLQUFaLENBei9CQTtBQUFBO0FBMi9CQUMsSUFBQUEsd0JBQUFBLGdCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBbEJFQSxJQUFBQSxDQUFBQSwyQkFBQUEsQ0EzL0JBO0FBQUE7QUFnaENBQyxJQUFBQSx3QkFBQUEsZ0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUE1aENGO0FBNGhDVyxNQUFBLG9DQTVoQ1g7QUFBQSxNQTZoQ0ksSUFBMkJDLGVBQTNCO0FBQUEsUUFBQSxPQUFPN0IsVUFBQUEsT0FBQUEsRUFBQUEsRUFBQUEsRUFBS2IsZ0JBQUxhLENBQUE0QixNQUFBQSxDQUFBQSxDQUFQLENBN2hDSjtBQUFBO0FBZ2lDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBMWlDQTtBQTRoQ0VBLElBQUFBLENBQUFBLDJCQUFBQSxDQWhoQ0E7QUFBQTtBQWlpQ0FFLElBQUFBLDJCQUFBQSxtQkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFwRjtBQURGb0YsSUFBQUEsQ0FBQUEsOEJBQUFBLENBamlDQTtBQUFBO0FBcWlDQUMsSUFBQUEsMkJBQUFBLG1CQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQUMsVUFBQUEsUUFBQUEsRUFBQUEsRUFBQUEsRUFsakNKLGlCQWtqQ2EsR0FsakNiLEVBQUE7O0FBQUE7QUFBQSxRQUFBO0FBQUE7QUFvakNBO0FBQ0EsY0FBWWhGLE9BQUFBLENBQU0sK0JBQWUsY0FBckJBO0FBQ1o7QUFDQSxNQXZqQ0E7QUFBQSxRQXlqQ00sT0FBQU4sSUFBQUQsT0FBQUEsQ0FBS3dDLEdBQUx4QyxDQXpqQ04sQ0FBQSxtQkFBQSxtQkFBQSxNQWtqQ0l1RjtBQURGRCxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FyaUNBO0FBQUEsSUFpakNBLGlCQUFNLE1BQU4sRUFBVyxTQUFYLENBampDQTtBQUFBO0FBbWpDQUUsSUFBQUEsa0NBQUFBLDBCQUFBQSwwQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBL2pDRjtBQStqQ3FCLE1BQUEsOENBL2pDckI7QUFBQSxNQWdrQ0ksSUFBQSxRQUFpRDlDLEtBQWpELENBQUE7QUFBQSxNQUFBO0FBQUEsUUFBQSxPQUFPQyxVQUFBQSxZQUFBQSxFQUFBQSxDQUFTLGdCQUFUQSxDQUFBQSxFQWhrQ1gsaUJBQUEsRUFBQTs7QUFBQSxRQWdrQ3VDLFdBQUFDLE1BQUFBLENBQUFBLENBaGtDdkMsbUJBQUEsa0JBQUEsTUFna0NXRDtBQUFQLE1BQUEsQ0Foa0NKO0FBQUE7QUFta0NBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQXJsQ0E7QUErakNFNkMsSUFBQUEsQ0FBQUEscUNBQUFBLENBbmpDQTtBQUFBO0FBNGtDQUMsSUFBQUEsbUNBQUFBLCtCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUF4bENGO0FBd2xDc0IsTUFBQSxtREF4bEN0QjtBQUFBLE1BeWxDSSxJQUFBLFFBQWtEL0MsS0FBbEQsQ0FBQTtBQUFBLE1BQUE7QUFBQSxRQUFBLE9BQU9DLFVBQUFBLFlBQUFBLEVBQUFBLENBQVMsaUJBQVRBLENBQUFBLEVBemxDWCxpQkFBQSxFQUFBOztBQUFBLFFBeWxDd0MsV0FBQUMsTUFBQUEsQ0FBQUEsQ0F6bEN4QyxtQkFBQSxrQkFBQSxNQXlsQ1dEO0FBQVAsTUFBQSxDQXpsQ0o7QUFBQTtBQTRsQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQWhuQ0E7QUF3bENFOEMsSUFBQUEsQ0FBQUEsMENBQUFBLENBNWtDQTtBQUFBO0FBdW1DQUMsSUFBQUEsb0NBQUFBLDRCQUFBQSw0QkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBbm5DRjtBQW1uQ3VCLE1BQUEsZ0RBbm5DdkI7QUFBQSxNQW9uQ0ksSUFBQSxRQUFtRGhELEtBQW5ELENBQUE7QUFBQSxNQUFBO0FBQUEsUUFBQSxPQUFPQyxVQUFBQSxZQUFBQSxFQUFBQSxDQUFTLGtCQUFUQSxDQUFBQSxFQXBuQ1gsaUJBQUEsRUFBQTs7QUFBQSxRQW9uQ3lDLFdBQUFDLE1BQUFBLENBQUFBLENBcG5DekMsbUJBQUEsa0JBQUEsTUFvbkNXRDtBQUFQLE1BQUEsQ0FwbkNKO0FBQUE7QUF1bkNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQXpvQ0E7QUFtbkNFK0MsSUFBQUEsQ0FBQUEsdUNBQUFBLENBdm1DQTtBQUFBO0FBZ29DQUMsSUFBQUEscUNBQUFBLGlDQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUE1b0NGO0FBNG9Dd0IsTUFBQSxxREE1b0N4QjtBQUFBLE1BNm9DSSxJQUFBLFFBQW9EakQsS0FBcEQsQ0FBQTtBQUFBLE1BQUE7QUFBQSxRQUFBLE9BQU9DLFVBQUFBLFlBQUFBLEVBQUFBLENBQVMsbUJBQVRBLENBQUFBLEVBN29DWCxpQkFBQSxFQUFBOztBQUFBLFFBNm9DMEMsV0FBQUMsTUFBQUEsQ0FBQUEsQ0E3b0MxQyxtQkFBQSxrQkFBQSxNQTZvQ1dEO0FBQVAsTUFBQSxDQTdvQ0o7QUFBQTtBQWdwQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBaHFDQTtBQTRvQ0VnRCxJQUFBQSxDQUFBQSw0Q0FBQUEsQ0Fob0NBO0FBQUEsSUF1cENBLGlCQUFNLFFBQU4sRUFBYSxRQUFiLENBdnBDQTtBQUFBLElBeXBDQSxpQkFBTSxRQUFOLEVBQWEsWUFBYixDQXpwQ0E7QUFBQSxJQTJwQ0EsaUJBQU0sV0FBTixFQUFnQixTQUFoQixDQTNwQ0E7QUFBQSxJQTZwQ0EsT0FBQUMsQ0FBQUEsMEJBQUFBLGtCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQWZFQSxJQUFBQSxDQUFBQSw2QkFBQUEsQ0FBQUEsa0JBN3BDQTtBQURGOUYsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FWQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE2MzM4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9udW1iZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xuXG5jbGFzcyBOdW1iZXIgPCBOdW1lcmljXG4gIE9wYWwuYnJpZGdlKGBOdW1iZXJgLCBzZWxmKVxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19udW1iZXInLCB0cnVlKWBcbiAgYHNlbGYuJCRpc19udW1iZXJfY2xhc3MgPSB0cnVlYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJhbGxvY2F0b3IgdW5kZWZpbmVkIGZvciAje25hbWV9XCJcbiAgICBlbmRcblxuICAgIHVuZGVmIDpuZXdcbiAgZW5kXG5cbiAgZGVmIGNvZXJjZShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlciA9PT0gbmlsKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tvdGhlci5jbGFzc30gaW50byBGbG9hdFwifTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBbI3tGbG9hdChvdGhlcil9LCBzZWxmXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCN7b3RoZXIucmVzcG9uZF90bz8oOnRvX2YpfSkge1xuICAgICAgICByZXR1cm4gWyN7T3BhbC5jb2VyY2VfdG8hKG90aGVyLCBGbG9hdCwgOnRvX2YpfSwgc2VsZl07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gW290aGVyLCBzZWxmXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7b3RoZXIuY2xhc3N9IGludG8gRmxvYXRcIn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgX19pZF9fXG4gICAgYChzZWxmICogMikgKyAxYFxuICBlbmRcblxuICBhbGlhcyBvYmplY3RfaWQgX19pZF9fXG5cbiAgZGVmICsob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgKyBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Kywgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgLSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6LSwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmICoob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgKiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Kiwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIC8ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgLyBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Lywgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZmRpdiAvXG5cbiAgZGVmICUob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlciA9PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCd9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG90aGVyIDwgMCB8fCBzZWxmIDwgMCkge1xuICAgICAgICAgIHJldHVybiAoc2VsZiAlIG90aGVyICsgb3RoZXIpICUgb3RoZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYgJSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDolLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgJihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiAmIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDomLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgfChvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiB8IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDp8LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgXihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiBeIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDpeLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPChvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiA8IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo8LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPD0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgPD0gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOjw9LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiA+IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo+LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgPj0gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOj49LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICAjIENvbXB1dGUgdGhlIHJlc3VsdCBvZiB0aGUgc3BhY2VzaGlwIG9wZXJhdG9yIGluc2lkZSBpdHMgb3duIGZ1bmN0aW9uIHNvIGl0XG4gICMgY2FuIGJlIG9wdGltaXplZCBkZXNwaXRlIGEgdHJ5L2ZpbmFsbHkgY29uc3RydWN0LlxuICAleHtcbiAgICB2YXIgc3BhY2VzaGlwX29wZXJhdG9yID0gZnVuY3Rpb24oc2VsZiwgb3RoZXIpIHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoaXNOYU4oc2VsZikgfHwgaXNOYU4ob3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmID4gb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmIDwgb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6PD0+LCBgb3RoZXJgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGBzcGFjZXNoaXBfb3BlcmF0b3Ioc2VsZiwgb3RoZXIpYFxuICByZXNjdWUgQXJndW1lbnRFcnJvclxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgPDwoY291bnQpXG4gICAgY291bnQgPSBPcGFsLmNvZXJjZV90byEgY291bnQsIEludGVnZXIsIDp0b19pbnRcblxuICAgIGAje2NvdW50fSA+IDAgPyBzZWxmIDw8ICN7Y291bnR9IDogc2VsZiA+PiAtI3tjb3VudH1gXG4gIGVuZFxuXG4gIGRlZiA+Pihjb3VudClcbiAgICBjb3VudCA9IE9wYWwuY29lcmNlX3RvISBjb3VudCwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgYCN7Y291bnR9ID4gMCA/IHNlbGYgPj4gI3tjb3VudH0gOiBzZWxmIDw8IC0je2NvdW50fWBcbiAgZW5kXG5cbiAgZGVmIFtdKGJpdClcbiAgICBiaXQgPSBPcGFsLmNvZXJjZV90byEgYml0LCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICAleHtcbiAgICAgIGlmICgje2JpdH0gPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKCN7Yml0fSA+PSAzMikge1xuICAgICAgICByZXR1cm4gI3sgc2VsZiB9IDwgMCA/IDEgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChzZWxmID4+ICN7Yml0fSkgJiAxO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICtAXG4gICAgYCtzZWxmYFxuICBlbmRcblxuICBkZWYgLUBcbiAgICBgLXNlbGZgXG4gIGVuZFxuXG4gIGRlZiB+XG4gICAgYH5zZWxmYFxuICBlbmRcblxuICBkZWYgKioob3RoZXIpXG4gICAgaWYgSW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIGlmICEoSW50ZWdlciA9PT0gc2VsZikgfHwgb3RoZXIgPiAwXG4gICAgICAgIGBNYXRoLnBvdyhzZWxmLCBvdGhlcilgXG4gICAgICBlbHNlXG4gICAgICAgIFJhdGlvbmFsLm5ldyhzZWxmLCAxKSoqb3RoZXJcbiAgICAgIGVuZFxuICAgIGVsc2lmIHNlbGYgPCAwICYmIChGbG9hdCA9PT0gb3RoZXIgfHwgUmF0aW9uYWwgPT09IG90aGVyKVxuICAgICAgQ29tcGxleC5uZXcoc2VsZiwgMCkqKm90aGVyLnRvX2ZcbiAgICBlbHNpZiBgb3RoZXIuJCRpc19udW1iZXIgIT0gbnVsbGBcbiAgICAgIGBNYXRoLnBvdyhzZWxmLCBvdGhlcilgXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOioqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnZhbHVlT2YoKSA9PT0gb3RoZXIudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3tvdGhlci5yZXNwb25kX3RvPyA6PT19KSB7XG4gICAgICAgIHJldHVybiAje290aGVyID09IHNlbGZ9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZi52YWx1ZU9mKCkgPT09IG90aGVyLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCN7b3RoZXIucmVzcG9uZF90bz8gOj09fSkge1xuICAgICAgICByZXR1cm4gI3tvdGhlciA9PSBzZWxmfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYWJzXG4gICAgYE1hdGguYWJzKHNlbGYpYFxuICBlbmRcblxuICBkZWYgYWJzMlxuICAgIGBNYXRoLmFicyhzZWxmICogc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBhbGxiaXRzPyhtYXNrKVxuICAgIG1hc2sgPSBPcGFsLmNvZXJjZV90byEgbWFzaywgSW50ZWdlciwgOnRvX2ludFxuICAgIGAoc2VsZiAmIG1hc2spID09IG1hc2tgXG4gIGVuZFxuXG4gIGRlZiBhbnliaXRzPyhtYXNrKVxuICAgIG1hc2sgPSBPcGFsLmNvZXJjZV90byEgbWFzaywgSW50ZWdlciwgOnRvX2ludFxuICAgIGAoc2VsZiAmIG1hc2spICE9PSAwYFxuICBlbmRcblxuICBkZWYgYW5nbGVcbiAgICByZXR1cm4gc2VsZiBpZiBuYW4/XG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IDApIHtcbiAgICAgICAgaWYgKDEgLyBzZWxmID4gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWxmIDwgMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5QSTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGFyZyBhbmdsZVxuICBhbGlhcyBwaGFzZSBhbmdsZVxuXG4gIGRlZiBiaXRfbGVuZ3RoXG4gICAgdW5sZXNzIEludGVnZXIgPT09IHNlbGZcbiAgICAgIHJhaXNlIE5vTWV0aG9kRXJyb3IubmV3KFwidW5kZWZpbmVkIG1ldGhvZCBgYml0X2xlbmd0aGAgZm9yICN7c2VsZn06RmxvYXRcIiwgJ2JpdF9sZW5ndGgnKVxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PT0gMCB8fCBzZWxmID09PSAtMSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IDAsXG4gICAgICAgICAgdmFsdWUgID0gc2VsZiA8IDAgPyB+c2VsZiA6IHNlbGY7XG5cbiAgICAgIHdoaWxlICh2YWx1ZSAhPSAwKSB7XG4gICAgICAgIHJlc3VsdCAgICs9IDE7XG4gICAgICAgIHZhbHVlICA+Pj49IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2VpbChuZGlnaXRzID0gMClcbiAgICAleHtcbiAgICAgIHZhciBmID0gI3t0b19mfTtcblxuICAgICAgaWYgKGYgJSAxID09PSAwICYmIG5kaWdpdHMgPj0gMCkge1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGZhY3RvciA9IE1hdGgucG93KDEwLCBuZGlnaXRzKSxcbiAgICAgICAgICByZXN1bHQgPSBNYXRoLmNlaWwoZiAqIGZhY3RvcikgLyBmYWN0b3I7XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCkge1xuICAgICAgICByZXN1bHQgPSBNYXRoLnJvdW5kKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2hyKGVuY29kaW5nID0gdW5kZWZpbmVkKVxuICAgIGBTdHJpbmcuZnJvbUNoYXJDb2RlKHNlbGYpYFxuICBlbmRcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICBpZiBuYW4/IHx8IGluZmluaXRlP1xuICAgICAgMVxuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBkb3dudG8oc3RvcCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6ZG93bnRvLCBzdG9wKSBkb1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCIgdW5sZXNzIE51bWVyaWMgPT09IHN0b3BcbiAgICAgICAgc3RvcCA+IHNlbGYgPyAwIDogc2VsZiAtIHN0b3AgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCFzdG9wLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje3N0b3AuY2xhc3N9IGZhaWxlZFwifVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IHNlbGY7IGkgPj0gc3RvcDsgaS0tKSB7XG4gICAgICAgIGJsb2NrKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuXG4gIGRlZiBlcXVhbD8ob3RoZXIpXG4gICAgc2VsZiA9PSBvdGhlciB8fCBgaXNOYU4oc2VsZikgJiYgaXNOYU4ob3RoZXIpYFxuICBlbmRcblxuICBkZWYgZXZlbj9cbiAgICBgc2VsZiAlIDIgPT09IDBgXG4gIGVuZFxuXG4gIGRlZiBmbG9vcihuZGlnaXRzID0gMClcbiAgICAleHtcbiAgICAgIHZhciBmID0gI3t0b19mfTtcblxuICAgICAgaWYgKGYgJSAxID09PSAwICYmIG5kaWdpdHMgPj0gMCkge1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGZhY3RvciA9IE1hdGgucG93KDEwLCBuZGlnaXRzKSxcbiAgICAgICAgICByZXN1bHQgPSBNYXRoLmZsb29yKGYgKiBmYWN0b3IpIC8gZmFjdG9yO1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdjZChvdGhlcilcbiAgICB1bmxlc3MgSW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ25vdCBhbiBpbnRlZ2VyJ1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gTWF0aC5hYnMoc2VsZiksXG4gICAgICAgICAgbWF4ID0gTWF0aC5hYnMob3RoZXIpO1xuXG4gICAgICB3aGlsZSAobWluID4gMCkge1xuICAgICAgICB2YXIgdG1wID0gbWluO1xuXG4gICAgICAgIG1pbiA9IG1heCAlIG1pbjtcbiAgICAgICAgbWF4ID0gdG1wO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdjZGxjbShvdGhlcilcbiAgICBbZ2NkKG90aGVyKSwgbGNtKG90aGVyKV1cbiAgZW5kXG5cbiAgZGVmIGludGVnZXI/XG4gICAgYHNlbGYgJSAxID09PSAwYFxuICBlbmRcblxuICBkZWYgaXNfYT8oa2xhc3MpXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gSW50ZWdlciAmJiBJbnRlZ2VyID09PSBzZWxmXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gSW50ZWdlciAmJiBJbnRlZ2VyID09PSBzZWxmXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gRmxvYXQgJiYgRmxvYXQgPT09IHNlbGZcblxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGFsaWFzIGtpbmRfb2Y/IGlzX2E/XG5cbiAgZGVmIGluc3RhbmNlX29mPyhrbGFzcylcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSBJbnRlZ2VyICYmIEludGVnZXIgPT09IHNlbGZcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSBJbnRlZ2VyICYmIEludGVnZXIgPT09IHNlbGZcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSBGbG9hdCAmJiBGbG9hdCA9PT0gc2VsZlxuXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIGxjbShvdGhlcilcbiAgICB1bmxlc3MgSW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ25vdCBhbiBpbnRlZ2VyJ1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSAwIHx8IG90aGVyID09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHNlbGYgKiBvdGhlciAvICN7Z2NkKG90aGVyKX0pO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgbWFnbml0dWRlIGFic1xuXG4gIGFsaWFzIG1vZHVsbyAlXG5cbiAgZGVmIG5leHRcbiAgICBgc2VsZiArIDFgXG4gIGVuZFxuXG4gIGRlZiBub2JpdHM/KG1hc2spXG4gICAgbWFzayA9IE9wYWwuY29lcmNlX3RvISBtYXNrLCBJbnRlZ2VyLCA6dG9faW50XG4gICAgYChzZWxmICYgbWFzaykgPT0gMGBcbiAgZW5kXG5cbiAgZGVmIG5vbnplcm8/XG4gICAgYHNlbGYgPT0gMCA/IG5pbCA6IHNlbGZgXG4gIGVuZFxuXG4gIGRlZiBudW1lcmF0b3JcbiAgICBpZiBuYW4/IHx8IGluZmluaXRlP1xuICAgICAgc2VsZlxuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBvZGQ/XG4gICAgYHNlbGYgJSAyICE9PSAwYFxuICBlbmRcblxuICBkZWYgb3JkXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcG93KGIsIG0gPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSAwKSB7XG4gICAgICAgICN7cmFpc2UgWmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnfVxuICAgICAgfVxuXG4gICAgICBpZiAobSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAje3NlbGYqKmJ9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEoI3tJbnRlZ2VyID09PSBifSkpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ0ludGVnZXIjcG93KCkgMm5kIGFyZ3VtZW50IG5vdCBhbGxvd2VkIHVubGVzcyBhIDFzdCBhcmd1bWVudCBpcyBpbnRlZ2VyJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiIDwgMCkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAnSW50ZWdlciNwb3coKSAxc3QgYXJndW1lbnQgY2Fubm90IGJlIG5lZ2F0aXZlIHdoZW4gMm5kIGFyZ3VtZW50IHNwZWNpZmllZCd9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISgje0ludGVnZXIgPT09IG19KSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAnSW50ZWdlciNwb3coKSAybmQgYXJndW1lbnQgbm90IGFsbG93ZWQgdW5sZXNzIGFsbCBhcmd1bWVudHMgYXJlIGludGVnZXJzJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtID09PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCd9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gI3soc2VsZioqYikgJSBtfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHByZWRcbiAgICBgc2VsZiAtIDFgXG4gIGVuZFxuXG4gIGRlZiBxdW8ob3RoZXIpXG4gICAgaWYgSW50ZWdlciA9PT0gc2VsZlxuICAgICAgc3VwZXJcbiAgICBlbHNlXG4gICAgICBzZWxmIC8gb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHJhdGlvbmFsaXplKGVwcyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4xKVwifTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBJbnRlZ2VyID09PSBzZWxmXG4gICAgICBSYXRpb25hbC5uZXcoc2VsZiwgMSlcbiAgICBlbHNpZiBpbmZpbml0ZT9cbiAgICAgIHJhaXNlIEZsb2F0RG9tYWluRXJyb3IsICdJbmZpbml0eSdcbiAgICBlbHNpZiBuYW4/XG4gICAgICByYWlzZSBGbG9hdERvbWFpbkVycm9yLCAnTmFOJ1xuICAgIGVsc2lmIGBlcHMgPT0gbnVsbGBcbiAgICAgIGYsIG4gID0gTWF0aC5mcmV4cCBzZWxmXG4gICAgICBmICAgICA9IE1hdGgubGRleHAoZiwgRmxvYXQ6Ok1BTlRfRElHKS50b19pXG4gICAgICBuICAgIC09IEZsb2F0OjpNQU5UX0RJR1xuXG4gICAgICBSYXRpb25hbC5uZXcoMiAqIGYsIDEgPDwgKDEgLSBuKSkucmF0aW9uYWxpemUoUmF0aW9uYWwubmV3KDEsIDEgPDwgKDEgLSBuKSkpXG4gICAgZWxzZVxuICAgICAgdG9fci5yYXRpb25hbGl6ZShlcHMpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiByZW1haW5kZXIoeSlcbiAgICBzZWxmIC0geSAqIChzZWxmIC8geSkudHJ1bmNhdGVcbiAgZW5kXG5cbiAgZGVmIHJvdW5kKG5kaWdpdHMgPSB1bmRlZmluZWQpXG4gICAgaWYgSW50ZWdlciA9PT0gc2VsZlxuICAgICAgaWYgYG5kaWdpdHMgPT0gbnVsbGBcbiAgICAgICAgcmV0dXJuIHNlbGZcbiAgICAgIGVuZFxuXG4gICAgICBpZiBGbG9hdCA9PT0gbmRpZ2l0cyAmJiBuZGlnaXRzLmluZmluaXRlP1xuICAgICAgICByYWlzZSBSYW5nZUVycm9yLCAnSW5maW5pdHknXG4gICAgICBlbmRcblxuICAgICAgbmRpZ2l0cyA9IE9wYWwuY29lcmNlX3RvIShuZGlnaXRzLCBJbnRlZ2VyLCA6dG9faW50KVxuXG4gICAgICBpZiBuZGlnaXRzIDwgSW50ZWdlcjo6TUlOXG4gICAgICAgIHJhaXNlIFJhbmdlRXJyb3IsICdvdXQgb2YgYm91bmRzJ1xuICAgICAgZW5kXG5cbiAgICAgIGlmIGBuZGlnaXRzID49IDBgXG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgbmRpZ2l0cyA9IC1uZGlnaXRzXG5cbiAgICAgICV4e1xuICAgICAgICBpZiAoMC40MTUyNDEgKiBuZGlnaXRzIC0gMC4xMjUgPiAje3NpemV9KSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZiA9IE1hdGgucG93KDEwLCBuZGlnaXRzKSxcbiAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKChNYXRoLmFicyhzZWxmKSArIGYgLyAyKSAvIGYpICogZjtcblxuICAgICAgICByZXR1cm4gc2VsZiA8IDAgPyAteCA6IHg7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgaWYgbmFuPyAmJiBgbmRpZ2l0cyA9PSBudWxsYFxuICAgICAgICByYWlzZSBGbG9hdERvbWFpbkVycm9yLCAnTmFOJ1xuICAgICAgZW5kXG5cbiAgICAgIG5kaWdpdHMgPSBPcGFsLmNvZXJjZV90byEoYG5kaWdpdHMgfHwgMGAsIEludGVnZXIsIDp0b19pbnQpXG5cbiAgICAgIGlmIG5kaWdpdHMgPD0gMFxuICAgICAgICBpZiBuYW4/XG4gICAgICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgJ05hTidcbiAgICAgICAgZWxzaWYgaW5maW5pdGU/XG4gICAgICAgICAgcmFpc2UgRmxvYXREb21haW5FcnJvciwgJ0luZmluaXR5J1xuICAgICAgICBlbmRcbiAgICAgIGVsc2lmIG5kaWdpdHMgPT0gMFxuICAgICAgICByZXR1cm4gYE1hdGgucm91bmQoc2VsZilgXG4gICAgICBlbHNpZiBuYW4/IHx8IGluZmluaXRlP1xuICAgICAgICByZXR1cm4gc2VsZlxuICAgICAgZW5kXG5cbiAgICAgIF8sIGV4cCA9IE1hdGguZnJleHAoc2VsZilcblxuICAgICAgaWYgbmRpZ2l0cyA+PSAoRmxvYXQ6OkRJRyArIDIpIC0gKGV4cCA+IDAgPyBleHAgLyA0IDogZXhwIC8gMyAtIDEpXG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgaWYgbmRpZ2l0cyA8IC0oZXhwID4gMCA/IGV4cCAvIDMgKyAxIDogZXhwIC8gNClcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIGVuZFxuXG4gICAgICBgTWF0aC5yb3VuZChzZWxmICogTWF0aC5wb3coMTAsIG5kaWdpdHMpKSAvIE1hdGgucG93KDEwLCBuZGlnaXRzKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHN0ZXAobGltaXQgPSB1bmRlZmluZWQsIHN0ZXAgPSB1bmRlZmluZWQsIHRvOiB1bmRlZmluZWQsIGJ5OiB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkICYmIHRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAndG8gaXMgZ2l2ZW4gdHdpY2UnfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RlcCAhPT0gdW5kZWZpbmVkICYmIGJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnc3RlcCBpcyBnaXZlbiB0d2ljZSd9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUGFyYW1ldGVycygpIHtcbiAgICAgICAgaWYgKHRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsaW1pdCA9IHRvO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsaW1pdCA9IG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGVwID09PSBuaWwpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ3N0ZXAgbXVzdCBiZSBudW1lcmljJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGVwID09PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInN0ZXAgY2FuJ3QgYmUgMFwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdGVwID0gYnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RlcCA9PT0gbmlsIHx8IHN0ZXAgPT0gbnVsbCkge1xuICAgICAgICAgIHN0ZXAgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpZ24gPSAje3N0ZXAgPD0+IDB9O1xuXG4gICAgICAgIGlmIChzaWduID09PSBuaWwpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiMCBjYW4ndCBiZSBjb2VyY2VkIGludG8gI3tzdGVwLmNsYXNzfVwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbWl0ID09PSBuaWwgfHwgbGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgIGxpbWl0ID0gc2lnbiA+IDAgPyAje0Zsb2F0OjpJTkZJTklUWX0gOiAjey1GbG9hdDo6SU5GSU5JVFl9O1xuICAgICAgICB9XG5cbiAgICAgICAgI3tPcGFsLmNvbXBhcmUoc2VsZiwgbGltaXQpfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdGVwRmxvYXRTaXplKCkge1xuICAgICAgICBpZiAoKHN0ZXAgPiAwICYmIHNlbGYgPiBsaW1pdCkgfHwgKHN0ZXAgPCAwICYmIHNlbGYgPCBsaW1pdCkpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIGlmIChzdGVwID09PSBJbmZpbml0eSB8fCBzdGVwID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYWJzID0gTWF0aC5hYnMsIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgICAgICAgZXJyID0gKGFicyhzZWxmKSArIGFicyhsaW1pdCkgKyBhYnMobGltaXQgLSBzZWxmKSkgLyBhYnMoc3RlcCkgKiAje0Zsb2F0OjpFUFNJTE9OfTtcblxuICAgICAgICAgIGlmIChlcnIgPT09IEluZmluaXR5IHx8IGVyciA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVyciA+IDAuNSkge1xuICAgICAgICAgICAgICBlcnIgPSAwLjU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmbG9vcigobGltaXQgLSBzZWxmKSAvIHN0ZXAgKyBlcnIpICsgMVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdGVwU2l6ZSgpIHtcbiAgICAgICAgdmFsaWRhdGVQYXJhbWV0ZXJzKCk7XG5cbiAgICAgICAgaWYgKHN0ZXAgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RlcCAlIDEgIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gc3RlcEZsb2F0U2l6ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKChzdGVwID4gMCAmJiBzZWxmID4gbGltaXQpIHx8IChzdGVwIDwgMCAmJiBzZWxmIDwgbGltaXQpKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNlaWwgPSBNYXRoLmNlaWwsIGFicyA9IE1hdGguYWJzLFxuICAgICAgICAgICAgICBsaHMgPSBhYnMoc2VsZiAtIGxpbWl0KSArIDEsXG4gICAgICAgICAgICAgIHJocyA9IGFicyhzdGVwKTtcblxuICAgICAgICAgIHJldHVybiBjZWlsKGxocyAvIHJocyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICBwb3NpdGlvbmFsX2FyZ3MgPSBbXVxuICAgICAga2V5d29yZF9hcmdzID0ge31cblxuICAgICAgJXh7XG4gICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcG9zaXRpb25hbF9hcmdzLnB1c2gobGltaXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBvc2l0aW9uYWxfYXJncy5wdXNoKHN0ZXApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBPcGFsLmhhc2hfcHV0KGtleXdvcmRfYXJncywgXCJ0b1wiLCB0byk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoa2V5d29yZF9hcmdzLCBcImJ5XCIsIGJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje2tleXdvcmRfYXJncy5hbnk/fSkge1xuICAgICAgICAgIHBvc2l0aW9uYWxfYXJncy5wdXNoKGtleXdvcmRfYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVudW1fZm9yKDpzdGVwLCAqcG9zaXRpb25hbF9hcmdzKSB7IGBzdGVwU2l6ZSgpYCB9XG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhbGlkYXRlUGFyYW1ldGVycygpO1xuXG4gICAgICBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGJsb2NrKHNlbGYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmICUgMSAhPT0gMCB8fCBsaW1pdCAlIDEgIT09IDAgfHwgc3RlcCAlIDEgIT09IDApIHtcbiAgICAgICAgdmFyIG4gPSBzdGVwRmxvYXRTaXplKCk7XG5cbiAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgaWYgKHN0ZXAgPT09IEluZmluaXR5IHx8IHN0ZXAgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgYmxvY2soc2VsZik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpID0gMCwgZDtcblxuICAgICAgICAgICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICAgICAgICAgIGQgPSBpICogc3RlcCArIHNlbGY7XG4gICAgICAgICAgICAgICAgaWYgKGxpbWl0IDwgZCkge1xuICAgICAgICAgICAgICAgICAgZCA9IGxpbWl0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBibG9jayhkKTtcbiAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICAgICAgICAgIGQgPSBpICogc3RlcCArIHNlbGY7XG4gICAgICAgICAgICAgICAgaWYgKGxpbWl0ID4gZCkge1xuICAgICAgICAgICAgICAgICAgZCA9IGxpbWl0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBibG9jayhkKTtcbiAgICAgICAgICAgICAgICBpICs9IDFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc2VsZjtcblxuICAgICAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgICAgICB3aGlsZSAodmFsdWUgPD0gbGltaXQpIHtcbiAgICAgICAgICAgIGJsb2NrKHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlICs9IHN0ZXA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoaWxlICh2YWx1ZSA+PSBsaW1pdCkge1xuICAgICAgICAgICAgYmxvY2sodmFsdWUpO1xuICAgICAgICAgICAgdmFsdWUgKz0gc3RlcFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHN1Y2MgbmV4dFxuXG4gIGRlZiB0aW1lcygmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDp0aW1lcykgeyBzZWxmIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZjsgaSsrKSB7XG4gICAgICAgIGJsb2NrKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX2ZcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19pXG4gICAgYHBhcnNlSW50KHNlbGYsIDEwKWBcbiAgZW5kXG5cbiAgYWxpYXMgdG9faW50IHRvX2lcblxuICBkZWYgdG9fclxuICAgIGlmIEludGVnZXIgPT09IHNlbGZcbiAgICAgIFJhdGlvbmFsLm5ldyhzZWxmLCAxKVxuICAgIGVsc2VcbiAgICAgIGYsIGUgID0gTWF0aC5mcmV4cChzZWxmKVxuICAgICAgZiAgICAgPSBNYXRoLmxkZXhwKGYsIEZsb2F0OjpNQU5UX0RJRykudG9faVxuICAgICAgZSAgICAtPSBGbG9hdDo6TUFOVF9ESUdcblxuICAgICAgKGYgKiAoRmxvYXQ6OlJBRElYKiplKSkudG9fclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdG9fcyhiYXNlID0gMTApXG4gICAgYmFzZSA9IE9wYWwuY29lcmNlX3RvISBiYXNlLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBpZiBiYXNlIDwgMiB8fCBiYXNlID4gMzZcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYWRpeCAje2Jhc2V9XCJcbiAgICBlbmRcblxuICAgIGBzZWxmLnRvU3RyaW5nKGJhc2UpYFxuICBlbmRcblxuICBkZWYgdHJ1bmNhdGUobmRpZ2l0cyA9IDApXG4gICAgJXh7XG4gICAgICB2YXIgZiA9ICN7dG9fZn07XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCAmJiBuZGlnaXRzID49IDApIHtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWN0b3IgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgcmVzdWx0ID0gcGFyc2VJbnQoZiAqIGZhY3RvciwgMTApIC8gZmFjdG9yO1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgaW5zcGVjdCB0b19zXG5cbiAgZGVmIGRpZ2l0cyhiYXNlID0gMTApXG4gICAgaWYgc2VsZiA8IDBcbiAgICAgIHJhaXNlIE1hdGg6OkRvbWFpbkVycm9yLCAnb3V0IG9mIGRvbWFpbidcbiAgICBlbmRcblxuICAgIGJhc2UgPSBPcGFsLmNvZXJjZV90byEgYmFzZSwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYmFzZSA8IDJcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYWRpeCAje2Jhc2V9XCJcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHZhbHVlID0gc2VsZiwgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICh2YWx1ZSAhPT0gMCkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSAlIGJhc2UpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlIC8gYmFzZSwgMTApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRpdm1vZChvdGhlcilcbiAgICBpZiBuYW4/IHx8IG90aGVyLm5hbj9cbiAgICAgIHJhaXNlIEZsb2F0RG9tYWluRXJyb3IsICdOYU4nXG4gICAgZWxzaWYgaW5maW5pdGU/XG4gICAgICByYWlzZSBGbG9hdERvbWFpbkVycm9yLCAnSW5maW5pdHknXG4gICAgZWxzZVxuICAgICAgc3VwZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHVwdG8oc3RvcCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6dXB0bywgc3RvcCkgZG9cbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje3N0b3AuY2xhc3N9IGZhaWxlZFwiIHVubGVzcyBOdW1lcmljID09PSBzdG9wXG4gICAgICAgIHN0b3AgPCBzZWxmID8gMCA6IHN0b3AgLSBzZWxmICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICghc3RvcC4kJGlzX251bWJlcikge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje3NlbGYuY2xhc3N9IHdpdGggI3tzdG9wLmNsYXNzfSBmYWlsZWRcIn1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSBzZWxmOyBpIDw9IHN0b3A7IGkrKykge1xuICAgICAgICBibG9jayhpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB6ZXJvP1xuICAgIGBzZWxmID09IDBgXG4gIGVuZFxuXG4gICMgU2luY2UgYml0d2lzZSBvcGVyYXRpb25zIGFyZSAzMiBiaXQsIGRlY2xhcmUgaXQgdG8gYmUgc28uXG4gIGRlZiBzaXplXG4gICAgNFxuICBlbmRcblxuICBkZWYgbmFuP1xuICAgIGBpc05hTihzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGZpbml0ZT9cbiAgICBgc2VsZiAhPSBJbmZpbml0eSAmJiBzZWxmICE9IC1JbmZpbml0eSAmJiAhaXNOYU4oc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBpbmZpbml0ZT9cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiArMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlbGYgPT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHBvc2l0aXZlP1xuICAgIGBzZWxmICE9IDAgJiYgKHNlbGYgPT0gSW5maW5pdHkgfHwgMSAvIHNlbGYgPiAwKWBcbiAgZW5kXG5cbiAgZGVmIG5lZ2F0aXZlP1xuICAgIGBzZWxmID09IC1JbmZpbml0eSB8fCAxIC8gc2VsZiA8IDBgXG4gIGVuZFxuZW5kXG5cbkZpeG51bSA9IE51bWJlclxuXG5jbGFzcyBJbnRlZ2VyIDwgTnVtZXJpY1xuICBgc2VsZi4kJGlzX251bWJlcl9jbGFzcyA9IHRydWVgXG4gIGBzZWxmLiQkaXNfaW50ZWdlcl9jbGFzcyA9IHRydWVgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuXG4gICAgZGVmIHNxcnQobilcbiAgICAgIG4gPSBPcGFsLmNvZXJjZV90byEobiwgSW50ZWdlciwgOnRvX2ludClcbiAgICAgICV4e1xuICAgICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgICAje3JhaXNlIE1hdGg6OkRvbWFpbkVycm9yLCAnTnVtZXJpY2FsIGFyZ3VtZW50IGlzIG91dCBvZiBkb21haW4gLSBcImlzcXJ0XCInfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KE1hdGguc3FydChuKSwgMTApO1xuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBNQVggPSBgTWF0aC5wb3coMiwgMzApIC0gMWBcbiAgTUlOID0gYC1NYXRoLnBvdygyLCAzMClgXG5lbmRcblxuY2xhc3MgRmxvYXQgPCBOdW1lcmljXG4gIGBzZWxmLiQkaXNfbnVtYmVyX2NsYXNzID0gdHJ1ZWBcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGFsbG9jYXRlXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwiYWxsb2NhdG9yIHVuZGVmaW5lZCBmb3IgI3tuYW1lfVwiXG4gICAgZW5kXG5cbiAgICB1bmRlZiA6bmV3XG5cbiAgICBkZWYgPT09KG90aGVyKVxuICAgICAgYCEhb3RoZXIuJCRpc19udW1iZXJgXG4gICAgZW5kXG4gIGVuZFxuXG4gIElORklOSVRZID0gYEluZmluaXR5YFxuICBNQVggICAgICA9IGBOdW1iZXIuTUFYX1ZBTFVFYFxuICBNSU4gICAgICA9IGBOdW1iZXIuTUlOX1ZBTFVFYFxuICBOQU4gICAgICA9IGBOYU5gXG5cbiAgRElHICAgICAgPSAxNVxuICBNQU5UX0RJRyA9IDUzXG4gIFJBRElYICAgID0gMlxuXG4gIEVQU0lMT04gPSBgTnVtYmVyLkVQU0lMT04gfHwgMi4yMjA0NDYwNDkyNTAzMTMwODA4NDcyNjMzMzYxODE2RS0xNmBcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsImJyaWRnZSIsInNlbGYiLCJhbGxvY2F0ZSIsInJhaXNlIiwibmFtZSIsImNvZXJjZSIsIm90aGVyIiwiRmxvYXQiLCJyZXNwb25kX3RvPyIsImNvZXJjZV90byEiLCJfX2lkX18iLCIrIiwiX19jb2VyY2VkX18iLCItIiwiKiIsIi8iLCIlIiwiJiIsInwiLCJeIiwiPCIsIjw9IiwiPiIsIj49IiwiPD0+IiwiPDwiLCJjb3VudCIsIj4+IiwiW10iLCJiaXQiLCIrQCIsIi1AIiwifiIsIioqIiwiPT09IiwiJHJldF9vcl8xIiwiISIsIjAiLCJuZXciLCIxIiwiJHJldF9vcl8yIiwiJHJldF9vcl8zIiwidG9fZiIsIj09IiwiYWJzIiwiYWJzMiIsImFsbGJpdHM/IiwibWFzayIsImFueWJpdHM/IiwiYW5nbGUiLCJuYW4/IiwiYml0X2xlbmd0aCIsImNlaWwiLCJjaHIiLCJkZW5vbWluYXRvciIsIiRyZXRfb3JfNCIsImluZmluaXRlPyIsImRvd250byIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwic3RvcCIsImVxdWFsPyIsIiRyZXRfb3JfNSIsImV2ZW4/IiwiZmxvb3IiLCJnY2QiLCJnY2RsY20iLCJsY20iLCJpbnRlZ2VyPyIsImlzX2E/IiwiJHJldF9vcl82Iiwia2xhc3MiLCIkcmV0X29yXzciLCIkcmV0X29yXzgiLCJpbnN0YW5jZV9vZj8iLCIkcmV0X29yXzkiLCIkcmV0X29yXzEwIiwiJHJldF9vcl8xMSIsIm5leHQiLCJub2JpdHM/Iiwibm9uemVybz8iLCJudW1lcmF0b3IiLCIkcmV0X29yXzEyIiwib2RkPyIsIm9yZCIsInBvdyIsImIiLCJtIiwicHJlZCIsInF1byIsInJhdGlvbmFsaXplIiwiZnJleHAiLCJmIiwibiIsImxkZXhwIiwidG9faSIsIjIiLCJ0b19yIiwiZXBzIiwicmVtYWluZGVyIiwieSIsInRydW5jYXRlIiwicm91bmQiLCIkcmV0X29yXzEzIiwibmRpZ2l0cyIsInNpemUiLCIkcmV0X29yXzE0IiwiJHJldF9vcl8xNSIsIl8iLCJleHAiLCI0IiwiMyIsInN0ZXAiLCJjb21wYXJlIiwibGltaXQiLCJwb3NpdGlvbmFsX2FyZ3MiLCJrZXl3b3JkX2FyZ3MiLCJhbnk/IiwidGltZXMiLCJibG9jayIsImUiLCJ0b19zIiwiMTAiLCJiYXNlIiwiJHJldF9vcl8xNiIsIjM2IiwiZGlnaXRzIiwiZGl2bW9kIiwiJHJldF9vcl8xNyIsInVwdG8iLCJ6ZXJvPyIsImZpbml0ZT8iLCJwb3NpdGl2ZT8iLCJuZWdhdGl2ZT8iLCJzcXJ0IiwiMTUiLCI1MyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxpQkFBUkEsQ0FBQTtBQUFBLEVBRUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFBLG9CQUFBQyxRQUFBQSxDQUFhLFFBQVNDLElBQXRCRCxDQUFBO0FBQUEsSUFDQywwREFERDtBQUFBLElBRUMsNkJBRkQ7QUFBQSxJQUlBO0FBQUEsTUFBQTs7QUFBQTtBQUNFO0FBQUFFLE1BQUFBLDRCQUFBQSxjQUFBQSxvQkFBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQ0UsV0FBQUMsT0FBQUEsQ0FBTSwyQkFBVyxFQUFBLEdBQUEsMEJBQUEsR0FBQSxLQUEyQkMsTUFBQUEsQ0FBQUEsQ0FBM0IsQ0FBakJEO0FBREZELE1BQUFBLENBQUFBLHlCQUFBQSxDQUFBO0FBQUE7O0FBSUEsTUFBQSxzQkFBTSxLQUFOO2lCQUpBO0FBREYsSUFBQSw0QkFBU0QsSUFBVCxZQUpBO0FBQUE7QUFZQUksSUFBQUEsMEJBQUFBLG1CQUFBQSxrQkFBVyxLQUFYQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBLFlBQVVGLE9BQUFBLENBQU0sMkJBQVcsRUFBQSxHQUFBLGdCQUFBLEdBQUEsQ0FBaUJHLEtBQUFQLE9BQUFBLENBQUFBLENBQWpCLENBQUEsR0FBQSxhQUFqQkksQ0FBMkQ7QUFDckU7QUFDQTtBQUNBLG9CQUFrQkksT0FBQUEsQ0FBTUQsS0FBTkMsQ0FBYTtBQUMvQjtBQUNBLGVBQWlCRCxLQUFBRSxnQkFBQUEsQ0FBa0IsTUFBbEJBLENBQXlCO0FBQzFD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QUFBQSxlQU5BO0FBREYsSUFBQSw0QkFBU2pDLElBQVQsWUFGQTtBQUFBLElBY0Esd0NBQVksUUFBWixDQWRBO0FBQUEsSUFlQSxtQ0FBWSxnQkFBWixDQWZBO0FBQUEsSUFnQkEsbUNBQVksZ0JBQVosQ0FoQkE7QUFBQSxJQWlCQSxtQ0FBWSxHQUFaLENBakJBO0FBQUEsSUFtQkEsbUNBQVdzSSxFQUFYLENBbkJBO0FBQUEsSUFvQkEsd0NBQVdDLEVBQVgsQ0FwQkE7QUFBQSxJQXFCQSxxQ0FBV3hDLENBQVgsQ0FyQkE7QUFBQSxJQXVCQSxPQUFBLHVDQUFXLHVEQUFYLENBdkJBO0FBREZqRyxFQUFBQSxHQUFBQSxXQUFBQSxFQUFjLHVCQUFkQSxXQTdnQ0E7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxNzc3NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZ2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG5jbGFzcyBSYW5nZVxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICBgc2VsZi4kJHByb3RvdHlwZS4kJGlzX3JhbmdlID0gdHJ1ZWBcblxuICBhdHRyX3JlYWRlciA6YmVnaW4sIDplbmRcblxuICBkZWYgaW5pdGlhbGl6ZShmaXJzdCwgbGFzdCwgZXhjbHVkZSA9IGZhbHNlKVxuICAgIHJhaXNlIE5hbWVFcnJvciwgXCInaW5pdGlhbGl6ZScgY2FsbGVkIHR3aWNlXCIgaWYgQGJlZ2luXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2JhZCB2YWx1ZSBmb3IgcmFuZ2UnIHVubGVzcyBmaXJzdCA8PT4gbGFzdFxuXG4gICAgQGJlZ2luID0gZmlyc3RcbiAgICBAZW5kICAgPSBsYXN0XG4gICAgQGV4Y2wgID0gZXhjbHVkZVxuICBlbmRcblxuICBkZWYgPT09KHZhbHVlKVxuICAgIGluY2x1ZGU/IHZhbHVlXG4gIGVuZFxuXG4gIGRlZiBjb3Zlcj8odmFsdWUpXG4gICAgYmVnX2NtcCA9IChAYmVnaW4gPD0+IHZhbHVlKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgYmVnX2NtcCAmJiBiZWdfY21wIDw9IDBcbiAgICBlbmRfY21wID0gKHZhbHVlIDw9PiBAZW5kKVxuICAgIGlmIEBleGNsXG4gICAgICBlbmRfY21wICYmIGVuZF9jbXAgPCAwXG4gICAgZWxzZVxuICAgICAgZW5kX2NtcCAmJiBlbmRfY21wIDw9IDBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGltaXQ7XG5cbiAgICAgIGlmICgje0BiZWdpbn0uJCRpc19udW1iZXIgJiYgI3tAZW5kfS4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoI3tAYmVnaW59ICUgMSAhPT0gMCB8fCAje0BlbmR9ICUgMSAhPT0gMCkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGl0ZXJhdGUgZnJvbSBGbG9hdFwifVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gI3tAYmVnaW59LCBsaW1pdCA9ICN7QGVuZH0gKyAje0BleGNsID8gMCA6IDF9OyBpIDwgbGltaXQ7IGkrKykge1xuICAgICAgICAgIGJsb2NrKGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIGlmICgje0BiZWdpbn0uJCRpc19zdHJpbmcgJiYgI3tAZW5kfS4kJGlzX3N0cmluZykge1xuICAgICAgICAje0BiZWdpbi51cHRvKEBlbmQsIEBleGNsLCAmYmxvY2spfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50ID0gQGJlZ2luXG4gICAgbGFzdCAgICA9IEBlbmRcblxuICAgIHVubGVzcyBjdXJyZW50LnJlc3BvbmRfdG8/KDpzdWNjKVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGl0ZXJhdGUgZnJvbSAje2N1cnJlbnQuY2xhc3N9XCJcbiAgICBlbmRcblxuICAgIHdoaWxlIChjdXJyZW50IDw9PiBsYXN0KSA8IDBcbiAgICAgIHlpZWxkIGN1cnJlbnRcblxuICAgICAgY3VycmVudCA9IGN1cnJlbnQuc3VjY1xuICAgIGVuZFxuXG4gICAgeWllbGQgY3VycmVudCBpZiAhQGV4Y2wgJiYgY3VycmVudCA9PSBsYXN0XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgUmFuZ2UgPT09IG90aGVyXG5cbiAgICBAZXhjbCA9PT0gb3RoZXIuZXhjbHVkZV9lbmQ/ICYmXG4gICAgICBAYmVnaW4uZXFsPyhvdGhlci5iZWdpbikgJiZcbiAgICAgIEBlbmQuZXFsPyhvdGhlci5lbmQpXG4gIGVuZFxuXG4gIGFsaWFzID09IGVxbD9cblxuICBkZWYgZXhjbHVkZV9lbmQ/XG4gICAgQGV4Y2xcbiAgZW5kXG5cbiAgZGVmIGZpcnN0KG4gPSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEBiZWdpbiBpZiBgbiA9PSBudWxsYFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGFsaWFzIGluY2x1ZGU/IGNvdmVyP1xuXG4gIGRlZiBsYXN0KG4gPSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEBlbmQgaWYgYG4gPT0gbnVsbGBcbiAgICB0b19hLmxhc3QobilcbiAgZW5kXG5cbiAgIyBGSVhNRTogY3VycmVudGx5IGhhcmRjb2RlZCB0byBhc3N1bWUgcmFuZ2UgaG9sZHMgbnVtZXJpY3NcbiAgZGVmIG1heFxuICAgIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgc3VwZXJcbiAgICBlbHNpZiBAYmVnaW4gPiBAZW5kXG4gICAgICBuaWxcbiAgICBlbHNpZiBAZXhjbCAmJiBAYmVnaW4gPT0gQGVuZFxuICAgICAgbmlsXG4gICAgZWxzZVxuICAgICAgYCN7QGV4Y2x9ID8gI3tAZW5kfSAtIDEgOiAje0BlbmR9YFxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyBtZW1iZXI/IGNvdmVyP1xuXG4gIGRlZiBtaW5cbiAgICBpZiBibG9ja19naXZlbj9cbiAgICAgIHN1cGVyXG4gICAgZWxzaWYgQGJlZ2luID4gQGVuZFxuICAgICAgbmlsXG4gICAgZWxzaWYgQGV4Y2wgJiYgQGJlZ2luID09IEBlbmRcbiAgICAgIG5pbFxuICAgIGVsc2VcbiAgICAgIEBiZWdpblxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2l6ZVxuICAgIHJhbmdlX2JlZ2luID0gQGJlZ2luXG4gICAgcmFuZ2VfZW5kICAgPSBAZW5kXG4gICAgcmFuZ2VfZW5kICAtPSAxIGlmIEBleGNsXG5cbiAgICByZXR1cm4gbmlsIHVubGVzcyBOdW1lcmljID09PSByYW5nZV9iZWdpbiAmJiBOdW1lcmljID09PSByYW5nZV9lbmRcbiAgICByZXR1cm4gMCBpZiByYW5nZV9lbmQgPCByYW5nZV9iZWdpblxuICAgIGluZmluaXR5ID0gRmxvYXQ6OklORklOSVRZXG4gICAgcmV0dXJuIGluZmluaXR5IGlmIFtyYW5nZV9iZWdpbi5hYnMsIHJhbmdlX2VuZC5hYnNdLmluY2x1ZGU/KGluZmluaXR5KVxuXG4gICAgYE1hdGguYWJzKHJhbmdlX2VuZCAtIHJhbmdlX2JlZ2luKSArIDFgLnRvX2lcbiAgZW5kXG5cbiAgZGVmIHN0ZXAobiA9IDEpXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBjb2VyY2VTdGVwU2l6ZSgpIHtcbiAgICAgICAgaWYgKCFuLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgbiA9ICN7T3BhbC5jb2VyY2VfdG8hKG4sIEludGVnZXIsIDp0b19pbnQpfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInN0ZXAgY2FuJ3QgYmUgbmVnYXRpdmVcIn1cbiAgICAgICAgfSBlbHNlIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInN0ZXAgY2FuJ3QgYmUgMFwifVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVudW1lcmF0b3JTaXplKCkge1xuICAgICAgICBpZiAoISN7QGJlZ2luLnJlc3BvbmRfdG8/KDpzdWNjKX0pIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7QGJlZ2lufS4kJGlzX3N0cmluZyAmJiAje0BlbmR9LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuICUgMSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAjeyhzaXplIC8gbikuY2VpbH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbiBpcyBhIGZsb2F0XG4gICAgICAgICAgdmFyIGJlZ2luID0gc2VsZi5iZWdpbiwgZW5kID0gc2VsZi5lbmQsXG4gICAgICAgICAgICAgIGFicyA9IE1hdGguYWJzLCBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgICAgICAgIGVyciA9IChhYnMoYmVnaW4pICsgYWJzKGVuZCkgKyBhYnMoZW5kIC0gYmVnaW4pKSAvIGFicyhuKSAqICN7RmxvYXQ6OkVQU0lMT059LFxuICAgICAgICAgICAgICBzaXplO1xuXG4gICAgICAgICAgaWYgKGVyciA+IDAuNSkge1xuICAgICAgICAgICAgZXJyID0gMC41O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxmLmV4Y2wpIHtcbiAgICAgICAgICAgIHNpemUgPSBmbG9vcigoZW5kIC0gYmVnaW4pIC8gbiAtIGVycik7XG4gICAgICAgICAgICBpZiAoc2l6ZSAqIG4gKyBiZWdpbiA8IGVuZCkge1xuICAgICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpemUgPSBmbG9vcigoZW5kIC0gYmVnaW4pIC8gbiArIGVycikgKyAxXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnN0ZXAsIG4pIGRvXG4gICAgICAgICV4e1xuICAgICAgICAgIGNvZXJjZVN0ZXBTaXplKCk7XG4gICAgICAgICAgcmV0dXJuIGVudW1lcmF0b3JTaXplKCk7XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYGNvZXJjZVN0ZXBTaXplKClgXG5cbiAgICBpZiBgc2VsZi5iZWdpbi4kJGlzX251bWJlciAmJiBzZWxmLmVuZC4kJGlzX251bWJlcmBcbiAgICAgIGkgPSAwXG4gICAgICBsb29wIGRvXG4gICAgICAgIGN1cnJlbnQgPSBAYmVnaW4gKyBpICogblxuICAgICAgICBpZiBAZXhjbFxuICAgICAgICAgIGJyZWFrIGlmIGN1cnJlbnQgPj0gQGVuZFxuICAgICAgICBlbHNpZiBjdXJyZW50ID4gQGVuZFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGVuZFxuICAgICAgICB5aWVsZChjdXJyZW50KVxuICAgICAgICBpICs9IDFcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgICV4e1xuICAgICAgICBpZiAoI3tAYmVnaW59LiQkaXNfc3RyaW5nICYmICN7QGVuZH0uJCRpc19zdHJpbmcgJiYgbiAlIDEgIT09IDApIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ25vIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gZmxvYXQgZnJvbSBzdHJpbmcnfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlYWNoX3dpdGhfaW5kZXggZG8gfHZhbHVlLCBpZHh8XG4gICAgICAgIHlpZWxkKHZhbHVlKSBpZiBpZHggJSBuID09IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGJzZWFyY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6YnNlYXJjaCkgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgdW5sZXNzIGBzZWxmLmJlZ2luLiQkaXNfbnVtYmVyICYmIHNlbGYuZW5kLiQkaXNfbnVtYmVyYFxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGRvIGJpbmFyeSBzZWFyY2ggZm9yICN7QGJlZ2luLmNsYXNzfVwiXG4gICAgZW5kXG5cbiAgICB0b19hLmJzZWFyY2goJmJsb2NrKVxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIFwiI3tAYmVnaW59I3tAZXhjbCA/ICcuLi4nIDogJy4uJ30je0BlbmR9XCJcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiN7QGJlZ2luLmluc3BlY3R9I3tAZXhjbCA/ICcuLi4nIDogJy4uJ30je0BlbmQuaW5zcGVjdH1cIlxuICBlbmRcblxuICBkZWYgbWFyc2hhbF9sb2FkKGFyZ3MpXG4gICAgQGJlZ2luID0gYXJnc1s6YmVnaW5dXG4gICAgQGVuZCA9IGFyZ3NbOmVuZF1cbiAgICBAZXhjbCA9IGFyZ3NbOmV4Y2xdXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgW0BiZWdpbiwgQGVuZCwgQGV4Y2xdLmhhc2hcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJpbmNsdWRlIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQGJlZ2luIiwicmFpc2UiLCJmaXJzdCIsIjw9PiIsImxhc3QiLCJAZW5kIiwiQGV4Y2wiLCJleGNsdWRlIiwiPT09IiwiaW5jbHVkZT8iLCJ2YWx1ZSIsImNvdmVyPyIsImJlZ19jbXAiLCIkcmV0X29yXzEiLCI8PSIsIjAiLCJlbmRfY21wIiwiJHJldF9vcl8yIiwiPCIsIiRyZXRfb3JfMyIsImVhY2giLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsInNpemUiLCIxIiwidXB0byIsImJsb2NrIiwiY3VycmVudCIsInJlc3BvbmRfdG8/Iiwic3VjYyIsIiRyZXRfb3JfNCIsIiEiLCI9PSIsInNlbGYiLCJlcWw/Iiwib3RoZXIiLCIkcmV0X29yXzUiLCIkcmV0X29yXzYiLCJleGNsdWRlX2VuZD8iLCJiZWdpbiIsImVuZCIsInRvX2EiLCJuIiwibWF4IiwiPiIsIiRyZXRfb3JfNyIsIm1pbiIsIiRyZXRfb3JfOCIsInJhbmdlX2JlZ2luIiwicmFuZ2VfZW5kIiwiLSIsIiRyZXRfb3JfOSIsImluZmluaXR5IiwiYWJzIiwidG9faSIsInN0ZXAiLCJjb2VyY2VfdG8hIiwiLyIsImNlaWwiLCJpIiwibG9vcCIsIisiLCIqIiwiPj0iLCJlYWNoX3dpdGhfaW5kZXgiLCJpZHgiLCIlIiwiYnNlYXJjaCIsInRvX3MiLCJpbnNwZWN0IiwibWFyc2hhbF9sb2FkIiwiYXJncyIsIltdIiwiaGFzaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxvQkFBUkEsQ0FBQTtBQUFBLEVBRUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUNFLFFBQUFDLFNBQUFBLENBQVEsMEJBQVJBLENBQUE7QUFBQSxJQUVDLGtDQUZEO0FBQUEsUUFJQUMsYUFBQUEsQ0FBWSxTQUFRLEtBQXBCQSxDQUpBO0FBQUE7QUFNQUMsSUFBQUEsOEJBQUFBLHNCQUFBQSxzQkFBZSxLQUFELEVBQVEsSUFBUixFQUFjLE9BQTVCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFWRjtBQVU4QixNQUFBO0FBQUEsTUFBQSxZQUFVLEtBQVY7QUFBQSxNQUFBLENBVjlCO0FBQUEsTUFXSSxJQUFBLFFBQWdEQyxVQUFoRCxDQUFBO0FBQUEsWUFBQUMsT0FBQUEsQ0FBTSwyQkFBVywyQkFBakJBLENBQUEsQ0FYSjtBQUFBLE1BWUksSUFBQSxRQUFrREMsS0FBQUMsUUFBQUEsQ0FBVUMsSUFBVkQsQ0FBbEQsQ0FBQTtBQUFBLE1BQUE7QUFBQSxZQUFBRixPQUFBQSxDQUFNLCtCQUFlLHFCQUFyQkE7QUFBQSxNQUFBLENBWko7QUFBQSxNQWNJRCxhQUFTRSxLQWRiO0FBQUEsTUFlSUcs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Q0FBQTtBQUFBLFFBQVEsT0FBQTtBQUFSLE1BQUE7QUFBQSxRQUFnQixPQUFBO0FBQWhCLE1BQUEsQ0FBQSxrQkFBcEIsQ0FBQSxHQUFBLENBQTJDRCxRQUFBZ0UsU0FBQUEsQ0FBQUEsQ0FBM0M7QUFERkEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBOU9BO0FBQUE7QUFrUEFDLElBQUFBLGdDQUFBQSx5QkFBQUEsd0JBQWlCLElBQWpCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBdEUsYUFBU3VFLElBQUFDLE9BQUFBLENBQUssT0FBTEEsQ0FBVDtBQUFBLE1BQ0FuRSxXQUFPa0UsSUFBQUMsT0FBQUEsQ0FBSyxLQUFMQSxDQURQO0FBQUEsTUFFQSxPQUFBbEUsQ0FBQUEsWUFBUWlFLElBQUFDLE9BQUFBLENBQUssTUFBTEEsQ0FBUmxFLENBRkE7QUFERmdFLElBQUFBLENBQUFBLG9DQUFBQSxDQWxQQTtBQUFBLElBd1BBLE9BQUFHLENBQUFBLHdCQUFBQSxpQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsQ0FBQ3pFLFVBQUQsRUFBU0ssUUFBVCxFQUFlQyxTQUFmLENBQUFtRSxNQUFBQSxDQUFBQTtBQURGQSxJQUFBQSxDQUFBQSw0QkFBQUEsQ0FBQUEsZ0JBeFBBO0FBREY3RSxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQUZBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTgyMTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3Byb2MucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBzbGljZVxuXG5jbGFzcyBQcm9jIDwgYEZ1bmN0aW9uYFxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19wcm9jJywgdHJ1ZSlgXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2xhbWJkYScsIGZhbHNlKWBcblxuICBkZWYgc2VsZi5uZXcoJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja1xuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNyZWF0ZSBhIFByb2Mgb2JqZWN0IHdpdGhvdXQgYSBibG9jaydcbiAgICBlbmRcblxuICAgIGJsb2NrXG4gIGVuZFxuXG4gIGRlZiBjYWxsKCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBzZWxmLiQkcCA9IGJsb2NrO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0LCAkYnJrID0gc2VsZi4kJGJyaztcblxuICAgICAgaWYgKCRicmspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc2VsZi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBPcGFsLnlpZWxkWChzZWxmLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChlcnIgPT09ICRicmspIHtcbiAgICAgICAgICAgIHJldHVybiAkYnJrLiR2XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHNlbGYuJCRpc19sYW1iZGEpIHtcbiAgICAgICAgICByZXN1bHQgPSBzZWxmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IE9wYWwueWllbGRYKHNlbGYsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBbXSBjYWxsXG4gIGFsaWFzID09PSBjYWxsXG4gIGFsaWFzIHlpZWxkIGNhbGxcblxuICBkZWYgPj4ob3RoZXIpXG4gICAgcHJvYyBkbyB8KmFyZ3MsICZibG9ja3xcbiAgICAgIG91dCA9IGNhbGwoKmFyZ3MsICZibG9jaylcbiAgICAgIG90aGVyLmNhbGwob3V0KVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPDwob3RoZXIpXG4gICAgcHJvYyBkbyB8KmFyZ3MsICZibG9ja3xcbiAgICAgIG91dCA9IG90aGVyLmNhbGwoKmFyZ3MsICZibG9jaylcbiAgICAgIGNhbGwob3V0KVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGxhbWJkYT9cbiAgICAjIFRoaXMgbWV0aG9kIHNob3VsZCB0ZWxsIHRoZSB1c2VyIGlmIHRoZSBwcm9jIHRyaWNrcyBhcmUgdW5hdmFpbGFibGUsXG4gICAgIyAoc2VlIFByb2MjbGFtYmRhPyBvbiBydWJ5IGRvY3MgdG8gZmluZCBvdXQgbW9yZSkuXG4gICAgYCEhc2VsZi4kJGlzX2xhbWJkYWBcbiAgZW5kXG5cbiAgZGVmIGFyaXR5XG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGlzX2N1cnJpZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRhcml0eTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VfbG9jYXRpb25cbiAgICBgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7IHJldHVybiBuaWw7IH1gXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBiaW5kaW5nXG4gICAgYGlmIChzZWxmLiQkaXNfY3VycmllZCkgeyAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiQ2FuJ3QgY3JlYXRlIEJpbmRpbmdcIn0gfWBcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIHBhcmFtZXRlcnNcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkaXNfY3VycmllZCkge1xuICAgICAgICByZXR1cm4gI3tbWzpyZXN0XV19O1xuICAgICAgfSBlbHNlIGlmIChzZWxmLiQkcGFyYW1ldGVycykge1xuICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiQkcGFyYW1ldGVycztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gW10sIGksIGxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYuJCRwYXJhbWV0ZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVyID0gc2VsZi4kJHBhcmFtZXRlcnNbaV07XG5cbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJbMF0gPT09ICdyZXEnKSB7XG4gICAgICAgICAgICAgIC8vIHJlcXVpcmVkIGFyZ3VtZW50cyBhbHdheXMgaGF2ZSBuYW1lXG4gICAgICAgICAgICAgIHBhcmFtZXRlciA9IFsnb3B0JywgcGFyYW1ldGVyWzFdXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyYW1ldGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY3VycnkoYXJpdHkgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoYXJpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhcml0eSA9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGFyaXR5ID0gI3tPcGFsLmNvZXJjZV90byEoYXJpdHksIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgaWYgKHNlbGYuJCRpc19sYW1iZGEgJiYgYXJpdHkgIT09IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyaXR5YH0gZm9yICN7YHNlbGYubGVuZ3RoYH0pXCJ9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3VycmllZCAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gJHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAgIGlmIChsZW5ndGggPiBhcml0eSAmJiBzZWxmLiQkaXNfbGFtYmRhICYmICFzZWxmLiQkaXNfY3VycmllZCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2BsZW5ndGhgfSBmb3IgI3tgYXJpdHlgfSlcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGggPj0gYXJpdHkpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi4kY2FsbC5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmllZC5hcHBseShudWxsLFxuICAgICAgICAgICAgYXJncy5jb25jYXQoJHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC4kJGlzX2xhbWJkYSA9IHNlbGYuJCRpc19sYW1iZGE7XG4gICAgICAgIHJlc3VsdC4kJGlzX2N1cnJpZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuXG4gICAgICBjdXJyaWVkLiQkaXNfbGFtYmRhID0gc2VsZi4kJGlzX2xhbWJkYTtcbiAgICAgIGN1cnJpZWQuJCRpc19jdXJyaWVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBjdXJyaWVkO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsX3Byb2MgPSBzZWxmLiQkb3JpZ2luYWxfcHJvYyB8fCBzZWxmLFxuICAgICAgICAgIHByb2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxfcHJvYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gc2VsZikge1xuICAgICAgICBpZiAoc2VsZi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgIHByb2NbcHJvcF0gPSBzZWxmW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9jO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgY2xvbmUgZHVwXG5lbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsIm5ldyIsInNlbGYiLCJibG9jayIsInJhaXNlIiwiY2FsbCIsIj4+IiwicHJvYyIsIm91dCIsImFyZ3MiLCJvdGhlciIsIjw8IiwidG9fcHJvYyIsImxhbWJkYT8iLCJhcml0eSIsInNvdXJjZV9sb2NhdGlvbiIsImJpbmRpbmciLCJwYXJhbWV0ZXJzIiwiY3VycnkiLCJjb2VyY2VfdG8hIiwiZHVwIl0sIm1hcHBpbmdzIjoiOzs7OztFQUVBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFDLHdEQUFEO0FBQUEsSUFDQywyREFERDtBQUFBLElBR0FDLFVBQUlDLElBQUpELFVBQUFBLGNBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQVBGO0FBT2UsTUFBQSxrQ0FQZjtBQUFBLE1BUUksSUFBQSxRQUFPRSxLQUFQLENBQUE7QUFBQSxNQUFBO0FBQUEsWUFDRUMsT0FBQUEsQ0FBTSwrQkFBZSwrQ0FBckJBO0FBREYsTUFBQSxDQVJKO0FBQUEsTUFZSSxPQUFBRCxLQVpKO0FBT0VGLElBQUFBLENBQUFBLHlCQUFBQSxDQUhB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QUFFQTtBQUNBO0FBZEVBLElBQUFBLENBQUFBLDBCQUFBQSxDQXZLQTtBQUFBLElBd0xBLE9BQUEsaUJBQU0sT0FBTixFQUFZLEtBQVosQ0F4TEE7QUFERnBCLEVBQUFBLEdBQUFBLFdBQUFBLEVBQWMsUUFBZEE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxODQ2OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbWV0aG9kLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIE1ldGhvZFxuICBhdHRyX3JlYWRlciA6b3duZXIsIDpyZWNlaXZlciwgOm5hbWVcblxuICBkZWYgaW5pdGlhbGl6ZShyZWNlaXZlciwgb3duZXIsIG1ldGhvZCwgbmFtZSlcbiAgICBAcmVjZWl2ZXIgPSByZWNlaXZlclxuICAgIEBvd25lciAgICA9IG93bmVyXG4gICAgQG5hbWUgICAgID0gbmFtZVxuICAgIEBtZXRob2QgICA9IG1ldGhvZFxuICBlbmRcblxuICBkZWYgYXJpdHlcbiAgICBAbWV0aG9kLmFyaXR5XG4gIGVuZFxuXG4gIGRlZiBwYXJhbWV0ZXJzXG4gICAgYCN7QG1ldGhvZH0uJCRwYXJhbWV0ZXJzYFxuICBlbmRcblxuICBkZWYgc291cmNlX2xvY2F0aW9uXG4gICAgYCN7QG1ldGhvZH0uJCRzb3VyY2VfbG9jYXRpb25gIHx8IFsnKGV2YWwpJywgMF1cbiAgZW5kXG5cbiAgZGVmIGNvbW1lbnRzXG4gICAgYCN7QG1ldGhvZH0uJCRjb21tZW50c2AgfHwgW11cbiAgZW5kXG5cbiAgZGVmIGNhbGwoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgICN7QG1ldGhvZH0uJCRwID0gYmxvY2s7XG5cbiAgICAgIHJldHVybiAje0BtZXRob2R9LmFwcGx5KCN7QHJlY2VpdmVyfSwgYXJncyk7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBbXSBjYWxsXG5cbiAgZGVmID4+KG90aGVyKVxuICAgIEBtZXRob2QgPj4gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIDw8KG90aGVyKVxuICAgIEBtZXRob2QgPDwgb3RoZXJcbiAgZW5kXG5cbiAgZGVmIHVuYmluZFxuICAgIFVuYm91bmRNZXRob2QubmV3KEByZWNlaXZlci5jbGFzcywgQG93bmVyLCBAbWV0aG9kLCBAbmFtZSlcbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICAleHtcbiAgICAgIHZhciBwcm9jID0gc2VsZi4kY2FsbC5iaW5kKHNlbGYpO1xuICAgICAgcHJvYy4kJHVuYm91bmQgPSAje0BtZXRob2R9O1xuICAgICAgcHJvYy4kJGlzX2xhbWJkYSA9IHRydWU7XG4gICAgICBwcm9jLiQkYXJpdHkgPSAje0BtZXRob2R9LiQkYXJpdHk7XG4gICAgICBwcm9jLiQkcGFyYW1ldGVycyA9ICN7QG1ldGhvZH0uJCRwYXJhbWV0ZXJzO1xuICAgICAgcmV0dXJuIHByb2M7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzwje3NlbGYuY2xhc3N9OiAje0ByZWNlaXZlci5jbGFzc30jI3tAbmFtZX0gKGRlZmluZWQgaW4gI3tAb3duZXJ9IGluICN7c291cmNlX2xvY2F0aW9uLmpvaW4oJzonKX0pPlwiXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFVuYm91bmRNZXRob2RcbiAgYXR0cl9yZWFkZXIgOnNvdXJjZSwgOm93bmVyLCA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKHNvdXJjZSwgb3duZXIsIG1ldGhvZCwgbmFtZSlcbiAgICBAc291cmNlID0gc291cmNlXG4gICAgQG93bmVyICA9IG93bmVyXG4gICAgQG1ldGhvZCA9IG1ldGhvZFxuICAgIEBuYW1lICAgPSBuYW1lXG4gIGVuZFxuXG4gIGRlZiBhcml0eVxuICAgIEBtZXRob2QuYXJpdHlcbiAgZW5kXG5cbiAgZGVmIHBhcmFtZXRlcnNcbiAgICBgI3tAbWV0aG9kfS4kJHBhcmFtZXRlcnNgXG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VfbG9jYXRpb25cbiAgICBgI3tAbWV0aG9kfS4kJHNvdXJjZV9sb2NhdGlvbmAgfHwgWycoZXZhbCknLCAwXVxuICBlbmRcblxuICBkZWYgY29tbWVudHNcbiAgICBgI3tAbWV0aG9kfS4kJGNvbW1lbnRzYCB8fCBbXVxuICBlbmRcblxuICBkZWYgYmluZChvYmplY3QpXG4gICAgJXh7XG4gICAgICBpZiAoI3tAb3duZXJ9LiQkaXNfbW9kdWxlIHx8IE9wYWwuaXNfYSgje29iamVjdH0sICN7QG93bmVyfSkpIHtcbiAgICAgICAgcmV0dXJuICN7TWV0aG9kLm5ldyhvYmplY3QsIEBvd25lciwgQG1ldGhvZCwgQG5hbWUpfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBiaW5kIHNpbmdsZXRvbiBtZXRob2QgdG8gYSBkaWZmZXJlbnQgY2xhc3MgKGV4cGVjdGVkICN7b2JqZWN0fS5raW5kX29mPygje0Bvd25lcn0gdG8gYmUgdHJ1ZSlcIn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzwje3NlbGYuY2xhc3N9OiAje0Bzb3VyY2V9IyN7QG5hbWV9IChkZWZpbmVkIGluICN7QG93bmVyfSBpbiAje3NvdXJjZV9sb2NhdGlvbi5qb2luKCc6Jyl9KT5cIlxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQHJlY2VpdmVyIiwicmVjZWl2ZXIiLCJAb3duZXIiLCJvd25lciIsIkBuYW1lIiwibmFtZSIsIkBtZXRob2QiLCJtZXRob2QiLCJhcml0eSIsInBhcmFtZXRlcnMiLCJzb3VyY2VfbG9jYXRpb24iLCIkcmV0X29yXzEiLCIwIiwiY29tbWVudHMiLCIkcmV0X29yXzIiLCJjYWxsIiwiPj4iLCJvdGhlciIsIjw8IiwidW5iaW5kIiwibmV3IiwidG9fcHJvYyIsImluc3BlY3QiLCJzZWxmIiwiam9pbiIsIkBzb3VyY2UiLCJzb3VyY2UiLCIkcmV0X29yXzMiLCIkcmV0X29yXzQiLCJiaW5kIiwib2JqZWN0IiwicmFpc2Ui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QUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLEVBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBS0MsSUFBQTFCLE9BQUFBLENBQUFBLENBQUwsQ0FBQSxHQUFBLElBQUEsR0FBQSxDQUFvQjRCLFdBQXBCLENBQUEsR0FBQSxHQUFBLEdBQUEsQ0FBK0JyQixTQUEvQixDQUFBLEdBQUEsZUFBQSxHQUFBLENBQW9ERixVQUFwRCxDQUFBLEdBQUEsTUFBQSxHQUFBLEtBQWlFUSxpQkFBQUEsQ0FBQUEsQ0FBQWMsTUFBQUEsQ0FBcUIsR0FBckJBLENBQWpFLENBQUEsR0FBQTtBQURGRixJQUFBQSxDQUFBQSx1Q0FBQUEsQ0FBQUEsbUJBcENBO0FBREZ6QixFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQWhFQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE4NjUyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi92YXJpYWJsZXMucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyByZWdleHAgbWF0Y2hlc1xuJXh7JGd2YXJzWycmJ10gPSAkZ3ZhcnNbJ34nXSA9ICRndmFyc1snYCddID0gJGd2YXJzW1wiJ1wiXSA9IG5pbH1cblxuIyByZXF1aXJlc1xuJExPQURFRF9GRUFUVVJFUyA9ICRcIiA9IGBPcGFsLmxvYWRlZF9mZWF0dXJlc2BcbiRMT0FEX1BBVEggICAgICAgPSAkOiA9IFtdXG5cbiMgc3BsaXQgbGluZXNcbiQvID0gXCJcXG5cIlxuJCwgPSBuaWxcblxuQVJHViA9IFtdXG5BUkdGID0gT2JqZWN0Lm5ld1xuRU5WICA9IHt9XG5cbiRWRVJCT1NFID0gZmFsc2VcbiRERUJVRyAgID0gZmFsc2VcbiRTQUZFICAgID0gMFxuIl0sIm5hbWVzIjpbIiRMT0FERURfRkVBVFVSRVMiLCIkXCIiLCIkTE9BRF9QQVRIIiwiJDoiLCIkLyIsIiQsIiwibmV3IiwiJFZFUkJPU0UiLCIkREVCVUciLCIkU0FGRSIsIjAiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLEVBQUcsMkRBQUg7QUFBQSxFQUdBQSx5QkFBbUJDLENBQUFBLGVBQU0sb0JBQU5BLENBSG5CO0FBQUEsRUFJQUMsbUJBQW1CQyxDQUFBQSxjQUFLLEVBQUxBLENBSm5CO0FBQUEsRUFPQUMsY0FBSyxJQVBMO0FBQUEsRUFRQUMsY0FBSyxHQVJMO0FBQUEsRUFVQSxvQ0FBTyxFQUFQLENBVkE7QUFBQSxFQVdBLG9DQUFPLHNCQUFBQyxLQUFBQSxDQUFBQSxDQUFQLENBWEE7QUFBQSxFQVlBLG1DQUFPLFlBQUEsRUFBUCxDQVpBO0FBQUEsRUFjQUMsaUJBQVcsS0FkWDtBQUFBLEVBZUFDLGVBQVcsS0FmWDtBQUFBLEVBZ0JBLE9BQUFDLENBQUFBLGNBQVdDLENBQVhELENBaEJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTg2NzEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2lvLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIElPXG4gIFNFRUtfU0VUID0gMFxuICBTRUVLX0NVUiA9IDFcbiAgU0VFS19FTkQgPSAyXG5cbiAgZGVmIHR0eT9cbiAgICBAdHR5XG4gIGVuZFxuXG4gIGRlZiBjbG9zZWQ/XG4gICAgQGNsb3NlZFxuICBlbmRcblxuICBhdHRyX2FjY2Vzc29yIDp3cml0ZV9wcm9jXG5cbiAgZGVmIHdyaXRlKHN0cmluZylcbiAgICBgc2VsZi53cml0ZV9wcm9jKHN0cmluZylgXG4gICAgc3RyaW5nLnNpemVcbiAgZW5kXG5cbiAgYXR0cl9hY2Nlc3NvciA6c3luYywgOnR0eVxuXG4gIGRlZiBmbHVzaFxuICAgICMgbm9vcFxuICBlbmRcblxuICBtb2R1bGUgV3JpdGFibGVcbiAgICBkZWYgPDwoc3RyaW5nKVxuICAgICAgd3JpdGUoc3RyaW5nKVxuICAgICAgc2VsZlxuICAgIGVuZFxuXG4gICAgZGVmIHByaW50KCphcmdzKVxuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFyZ3MubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSAje1N0cmluZyhgYXJnc1tpXWApfVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuJHdyaXRlKGFyZ3Muam9pbigjeyQsfSkpO1xuICAgICAgfVxuICAgICAgbmlsXG4gICAgZW5kXG5cbiAgICBkZWYgcHV0cygqYXJncylcbiAgICAgICV4e1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcmdzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gI3tTdHJpbmcoYGFyZ3NbaV1gKS5jaG9tcH1cbiAgICAgICAgfVxuICAgICAgICBzZWxmLiR3cml0ZShhcmdzLmNvbmNhdChbbmlsXSkuam9pbigjeyQvfSkpO1xuICAgICAgfVxuICAgICAgbmlsXG4gICAgZW5kXG4gIGVuZFxuXG4gIG1vZHVsZSBSZWFkYWJsZVxuICAgIGRlZiByZWFkYnl0ZVxuICAgICAgZ2V0Ynl0ZVxuICAgIGVuZFxuXG4gICAgZGVmIHJlYWRjaGFyXG4gICAgICBnZXRjXG4gICAgZW5kXG5cbiAgICBkZWYgcmVhZGxpbmUoc2VwID0gJC8pXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gICAgZW5kXG5cbiAgICBkZWYgcmVhZHBhcnRpYWwoaW50ZWdlciwgb3V0YnVmID0gbmlsKVxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5TVERFUlIgPSAkc3RkZXJyID0gSU8ubmV3XG5TVERJTiAgPSAkc3RkaW4gID0gSU8ubmV3XG5TVERPVVQgPSAkc3Rkb3V0ID0gSU8ubmV3XG5cbmB2YXIgY29uc29sZSA9IE9wYWwuZ2xvYmFsLmNvbnNvbGVgXG5TVERPVVQud3JpdGVfcHJvYyA9IGB0eXBlb2YocHJvY2VzcykgPT09ICdvYmplY3QnICYmIHR5cGVvZihwcm9jZXNzLnN0ZG91dCkgPT09ICdvYmplY3QnID8gZnVuY3Rpb24ocyl7cHJvY2Vzcy5zdGRvdXQud3JpdGUocyl9IDogZnVuY3Rpb24ocyl7Y29uc29sZS5sb2cocyl9YFxuU1RERVJSLndyaXRlX3Byb2MgPSBgdHlwZW9mKHByb2Nlc3MpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YocHJvY2Vzcy5zdGRlcnIpID09PSAnb2JqZWN0JyA/IGZ1bmN0aW9uKHMpe3Byb2Nlc3Muc3RkZXJyLndyaXRlKHMpfSA6IGZ1bmN0aW9uKHMpe2NvbnNvbGUud2FybihzKX1gXG5cblNURE9VVC5leHRlbmQoSU86OldyaXRhYmxlKVxuU1RERVJSLmV4dGVuZChJTzo6V3JpdGFibGUpXG4iXSwibmFtZXMiOlsiY2xhc3MiLCIwIiwiMSIsIjIiLCJ0dHk/IiwiQHR0eSIsImNsb3NlZD8iLCJAY2xvc2VkIiwiYXR0cl9hY2Nlc3NvciIsIndyaXRlIiwic3RyaW5nIiwic2l6ZSIsImZsdXNoIiwibW9kdWxlIiwiPDwiLCJzZWxmIiwicHJpbnQiLCJTdHJpbmciLCIkLCIsInB1dHMiLCJjaG9tcCIsIiQvIiwicmVhZGJ5dGUiLCJnZXRieXRlIiwicmVhZGNoYXIiLCJnZXRjIiwicmVhZGxpbmUiLCJyYWlzZSIsInJlYWRwYXJ0aWFsIiwiJHN0ZGVyciIsIm5ldyIsIiRzdGRpbiIsIiRzdGRvdXQiLCIkd3JpdGVyIiwid3JpdGVfcHJvYz0iLCItIiwiZXh0ZW5kIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxFQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0UsSUFBQSx3Q0FBV0MsQ0FBWCxDQUFBO0FBQUEsSUFDQSx3Q0FBV0MsQ0FBWCxDQURBO0FBQUEsSUFFQSx3Q0FBV0MsQ0FBWCxDQUZBO0FBQUE7QUFJQUMsSUFBQUEsd0JBQUFBLGlCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBQztBQURGRCxJQUFBQSxDQUFBQSw0QkFBQUEsQ0FKQTtBQUFBO0FBUUFFLElBQUFBLDJCQUFBQSxvQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7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QUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBQUE7QUFBQSxFQXdFQSxzQ0FBUzZCLENBQUFBLGdCQUFVLGtCQUFBQyxLQUFBQSxDQUFBQSxDQUFWRCxDQUFULENBeEVBO0FBQUEsRUF5RUEscUNBQVNFLENBQUFBLGVBQVUsa0JBQUFELEtBQUFBLENBQUFBLENBQVZDLENBQVQsQ0F6RUE7QUFBQSxFQTBFQSxzQ0FBU0MsQ0FBQUEsZ0JBQVUsa0JBQUFGLEtBQUFBLENBQUFBLENBQVZFLENBQVQsQ0ExRUE7QUFBQSxFQTRFQyxpQ0E1RUQ7QUFBQTtBQURBLEVBQUFDLFVBQUEsQ0E4RXFCLHdJQTlFckIsQ0FBQTtBQUFBLEVBOEVBQyxNQUFBLHNCQUFBQSxlQUFBQSxFQTlFQSxVQUFBRCxPQUFBLENBOEVBQyxDQTlFQTtBQUFBLEVBQUFELE9BQUEsQ0FBQUUsVUFBQUYsT0FBQSxDQUFBLFFBQUEsQ0FBQUUsRUFBQWpDLENBQUFpQyxDQUFBLENBQUEsQ0FDQTtBQUFBO0FBREEsRUFBQUYsVUFBQSxDQStFcUIseUlBL0VyQixDQUFBO0FBQUEsRUErRUFDLE1BQUEsc0JBQUFBLGVBQUFBLEVBL0VBLFVBQUFELE9BQUEsQ0ErRUFDLENBL0VBO0FBQUEsRUFBQUQsT0FBQSxDQUFBRSxVQUFBRixPQUFBLENBQUEsUUFBQSxDQUFBRSxFQUFBakMsQ0FBQWlDLENBQUEsQ0FBQSxDQUNBO0FBQUEsRUFnRkEsc0JBQUFDLFFBQUFBLENBQWMsSUFBQSxrQkFBQSxhQUFkQSxDQWhGQTtBQUFBLEVBaUZBLE9BQUEsc0JBQUFBLFFBQUFBLENBQWMsSUFBQSxrQkFBQSxhQUFkQSxDQWpGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE4ODI4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsib3BhbC9yZWdleHBfYW5jaG9ycy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogdHJ1ZVxuXG5tb2R1bGUgT3BhbFxuICBSRUdFWFBfU1RBUlQgPSBSVUJZX0VOR0lORSA9PSAnb3BhbCcgPyAnXicgOiAnXFxBJ1xuICBSRUdFWFBfRU5EID0gUlVCWV9FTkdJTkUgPT0gJ29wYWwnID8gJyQnIDogJ1xceidcblxuICAjIFVuaWNvZGUgY2hhcmFjdGVycyBpbiByYW5nZXNcbiAgIyBcXHUwMDAxIC0gXFx1MDAyRiAoYmxhbmsgdW5pY29kZSBjaGFyYWN0ZXJzICsgc3BhY2UgKyAhXCIjJCUmJygpKissLS4vIGNoYXJzKVxuICAjIFxcdTAwM0EgLSBcXHUwMDQwICg6Ozw9Pj9AIGNoYXJzKVxuICAjIFxcdTAwNUIgLSBcXHUwMDVFIChbXFxdXiBjaGFycylcbiAgIyBcXHUwMDYwICAgICAgICAgIChgIGNoYXIpXG4gICMgXFx1MDA3QiAtIFxcdTAwN0YgKHt8fX4gY2hhcnN9KVxuICAjIGFyZSBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIGlkZW50aWZpZXIgaW4gdGhlIGJlZ2dpbmluZyBvciBtaWRkbGUgb2YgaXRzIG5hbWVcbiAgRk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlMgPSAnXFx1MDAwMS1cXHUwMDJGXFx1MDAzQS1cXHUwMDQwXFx1MDA1Qi1cXHUwMDVFXFx1MDA2MFxcdTAwN0ItXFx1MDA3RidcblxuICAjIFVuaWNvZGUgY2hhcmFjdGVycyBpbiByYW5nZXNcbiAgIyBcXHUwMDAxIC0gXFx1MDAyMCAoYmxhbmsgdW5pY29kZSBjaGFyYWN0ZXJzICsgc3BhY2UpXG4gICMgXFx1MDAyMiAtIFxcdTAwMkYgKFwiIyQlJicoKSorLC0uLyBjaGFycylcbiAgIyBcXHUwMDNBIC0gXFx1MDAzRSAoOjs8PT4gY2hhcnMpXG4gICMgXFx1MDA0MCAgICAgICAgICAoQCBjaGFyKVxuICAjIFxcdTAwNUIgLSBcXHUwMDVFIChbXFxdXiBjaGFycylcbiAgIyBcXHUwMDYwICAgICAgICAgIChgIGNoYXIpXG4gICMgXFx1MDA3QiAtIFxcdTAwN0YgKHt8fX4gY2hhcnN9KVxuICAjIGFyZSBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIGlkZW50aWZpZXIgaW4gdGhlIGVuZCBvZiBpdHMgbmFtZVxuICAjIEluIGZhY3QsIEZPUkJJRERFTl9TVEFSVElOR19JREVOVElGSUVSX0NIQVJTID0gRk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTICsgXFx1MDAyMSAoJz8nKSArIFxcdTAwM0YgKCchJylcbiAgRk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTICAgPSAnXFx1MDAwMS1cXHUwMDIwXFx1MDAyMi1cXHUwMDJGXFx1MDAzQS1cXHUwMDNFXFx1MDA0MFxcdTAwNUItXFx1MDA1RVxcdTAwNjBcXHUwMDdCLVxcdTAwN0YnXG4gIElOTElORV9JREVOVElGSUVSX1JFR0VYUCA9IFJlZ2V4cC5uZXcoXCJbXiN7Rk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlN9XSpbXiN7Rk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTfV1cIilcblxuICAjIEZvciBjb25zdGFudHMgcnVsZXMgYXJlIHByZXR0eSBtdWNoIHRoZSBzYW1lLCBidXQgJzonIGlzIGFsbG93ZWQgYW5kICc/IScgYXJlIG5vdC5cbiAgIyBQbHVzIGl0IG1heSBzdGFydCB3aXRoIGEgJzo6JyB3aGljaCBpbmRpY2F0ZXMgdGhhdCB0aGUgY29uc3RhbnQgY29tZXMgZnJvbSB0b3BsZXZlbC5cbiAgRk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlMgPSAnXFx1MDAwMS1cXHUwMDIwXFx1MDAyMS1cXHUwMDJGXFx1MDAzQi1cXHUwMDNGXFx1MDA0MFxcdTAwNUItXFx1MDA1RVxcdTAwNjBcXHUwMDdCLVxcdTAwN0YnXG4gIENPTlNUX05BTUVfUkVHRVhQID0gUmVnZXhwLm5ldyhcIiN7UkVHRVhQX1NUQVJUfSg6Oik/W0EtWl1bXiN7Rk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlN9XSoje1JFR0VYUF9FTkR9XCIpXG5lbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCI9PSIsIm5ldyJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFFQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQSw0Q0FBZSxhQUFBLElBQUEsMkJBQUFDLE9BQUFBLENBQWUsTUFBZkEsQ0FBQTtBQUFBLE1BQXdCLE9BQUE7QUFBeEIsSUFBQTtBQUFBLE1BQUEsT0FBQTtBQUFBLElBQUEsQ0FBQSxrQkFBZixDQUFBO0FBQUEsSUFDQSwwQ0FBYSxhQUFBLElBQUEsMkJBQUFBLE9BQUFBLENBQWUsTUFBZkEsQ0FBQTtBQUFBLE1BQXdCLE9BQUE7QUFBeEIsSUFBQTtBQUFBLE1BQUEsT0FBQTtBQUFBLElBQUEsQ0FBQSxrQkFBYixDQURBO0FBQUEsSUFVQSxtRUFBc0MscUVBQXRDLENBVkE7QUFBQSxJQXNCQSxpRUFBc0MsMkZBQXRDLENBdEJBO0FBQUEsSUF1QkEsd0RBQTJCLHNCQUFBQyxLQUFBQSxDQUFXLEVBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBSyxtREFBTCxDQUFBLEdBQUEsTUFBQSxHQUFBLENBQStDLGlEQUEvQyxDQUFBLEdBQUEsR0FBWEEsQ0FBM0IsQ0F2QkE7QUFBQSxJQTJCQSwwREFBNkIsMkZBQTdCLENBM0JBO0FBQUEsSUE0QkEsaURBQW9CLHNCQUFBQSxLQUFBQSxDQUFXLEVBQUEsR0FBQSxDQUFHLDRCQUFILENBQUEsR0FBQSxjQUFBLEdBQUEsQ0FBOEIsMENBQTlCLENBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBNkQsMEJBQTdELENBQVhBLENBQXBCLENBNUJBO0FBREZGLEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTg4NTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGFsL21pbmkucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnb3BhbC9iYXNlJ1xuXG5yZXF1aXJlICdjb3JlbGliL25pbCdcbnJlcXVpcmUgJ2NvcmVsaWIvYm9vbGVhbidcbnJlcXVpcmUgJ2NvcmVsaWIvc3RyaW5nJ1xucmVxdWlyZSAnY29yZWxpYi9jb21wYXJhYmxlJ1xucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhdG9yJ1xucmVxdWlyZSAnY29yZWxpYi9hcnJheSdcbnJlcXVpcmUgJ2NvcmVsaWIvaGFzaCdcbnJlcXVpcmUgJ2NvcmVsaWIvbnVtYmVyJ1xucmVxdWlyZSAnY29yZWxpYi9yYW5nZSdcbnJlcXVpcmUgJ2NvcmVsaWIvcHJvYydcbnJlcXVpcmUgJ2NvcmVsaWIvbWV0aG9kJ1xucmVxdWlyZSAnY29yZWxpYi9yZWdleHAnXG5yZXF1aXJlICdjb3JlbGliL3ZhcmlhYmxlcydcbnJlcXVpcmUgJ2NvcmVsaWIvaW8nXG5yZXF1aXJlICdvcGFsL3JlZ2V4cF9hbmNob3JzJ1xuIl0sIm5hbWVzIjpbInJlcXVpcmUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsV0FBUkEsQ0FBQTtBQUFBLE1BRUFBLFNBQUFBLENBQVEsYUFBUkEsQ0FGQTtBQUFBLE1BR0FBLFNBQUFBLENBQVEsaUJBQVJBLENBSEE7QUFBQSxNQUlBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQUpBO0FBQUEsTUFLQUEsU0FBQUEsQ0FBUSxvQkFBUkEsQ0FMQTtBQUFBLE1BTUFBLFNBQUFBLENBQVEsb0JBQVJBLENBTkE7QUFBQSxNQU9BQSxTQUFBQSxDQUFRLG9CQUFSQSxDQVBBO0FBQUEsTUFRQUEsU0FBQUEsQ0FBUSxlQUFSQSxDQVJBO0FBQUEsTUFTQUEsU0FBQUEsQ0FBUSxjQUFSQSxDQVRBO0FBQUEsTUFVQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FWQTtBQUFBLE1BV0FBLFNBQUFBLENBQVEsZUFBUkEsQ0FYQTtBQUFBLE1BWUFBLFNBQUFBLENBQVEsY0FBUkEsQ0FaQTtBQUFBLE1BYUFBLFNBQUFBLENBQVEsZ0JBQVJBLENBYkE7QUFBQSxNQWNBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQWRBO0FBQUEsTUFlQUEsU0FBQUEsQ0FBUSxtQkFBUkEsQ0FmQTtBQUFBLE1BZ0JBQSxTQUFBQSxDQUFRLFlBQVJBLENBaEJBO0FBQUEsRUFpQkEsV0FBQUEsU0FBQUEsQ0FBUSxxQkFBUkEsQ0FqQkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxODg4MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIva2VybmVsL2Zvcm1hdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGNvZXJjZV90b1xuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBmb3JtYXQoZm9ybWF0X3N0cmluZywgKmFyZ3MpXG4gICAgaWYgYXJncy5sZW5ndGggPT0gMSAmJiBhcmdzWzBdLnJlc3BvbmRfdG8/KDp0b19hcnkpXG4gICAgICBhcnkgPSBPcGFsLmNvZXJjZV90bz8oYXJnc1swXSwgQXJyYXksIDp0b19hcnkpXG4gICAgICBhcmdzID0gYXJ5LnRvX2EgdW5sZXNzIGFyeS5uaWw/XG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICAvL3VzZWQgZm9yIHNsaWNpbmc6XG4gICAgICAgICAgYmVnaW5fc2xpY2UgPSAwLFxuICAgICAgICAgIGVuZF9zbGljZSxcbiAgICAgICAgICAvL3VzZWQgZm9yIGl0ZXJhdGluZyBvdmVyIHRoZSBmb3JtYXQgc3RyaW5nOlxuICAgICAgICAgIGksXG4gICAgICAgICAgbGVuID0gZm9ybWF0X3N0cmluZy5sZW5ndGgsXG4gICAgICAgICAgLy91c2VkIGZvciBwcm9jZXNzaW5nIGZpZWxkIHZhbHVlczpcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgc3RyLFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyAlZyBhbmQgJUcgZmllbGRzOlxuICAgICAgICAgIGV4cG9uZW50LFxuICAgICAgICAgIC8vdXNlZCBmb3Iga2VlcGluZyB0cmFjayBvZiB3aWR0aCBhbmQgcHJlY2lzaW9uOlxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIHByZWNpc2lvbixcbiAgICAgICAgICAvL3VzZWQgZm9yIGhvbGRpbmcgdGVtcG9yYXJ5IHZhbHVlczpcbiAgICAgICAgICB0bXBfbnVtLFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyAle30gYW5kICU8PiBmaWxlZHM6XG4gICAgICAgICAgaGFzaF9wYXJhbWV0ZXJfa2V5LFxuICAgICAgICAgIGNsb3NpbmdfYnJhY2VfY2hhcixcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgJWIsICVCLCAlbywgJXgsIGFuZCAlWCBmaWVsZHM6XG4gICAgICAgICAgYmFzZV9udW1iZXIsXG4gICAgICAgICAgYmFzZV9wcmVmaXgsXG4gICAgICAgICAgYmFzZV9uZWdfemVyb19yZWdleCxcbiAgICAgICAgICBiYXNlX25lZ196ZXJvX2RpZ2l0LFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgbmV4dF9hcmcsXG4gICAgICAgICAgc2VxX2FyZ19udW0gPSAxLFxuICAgICAgICAgIHBvc19hcmdfbnVtID0gMCxcbiAgICAgICAgICAvL3VzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgZmxhZ3M6XG4gICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgRk5PTkUgID0gMCxcbiAgICAgICAgICBGU0hBUlAgPSAxLFxuICAgICAgICAgIEZNSU5VUyA9IDIsXG4gICAgICAgICAgRlBMVVMgID0gNCxcbiAgICAgICAgICBGWkVSTyAgPSA4LFxuICAgICAgICAgIEZTUEFDRSA9IDE2LFxuICAgICAgICAgIEZXSURUSCA9IDMyLFxuICAgICAgICAgIEZQUkVDICA9IDY0LFxuICAgICAgICAgIEZQUkVDMCA9IDEyODtcblxuICAgICAgZnVuY3Rpb24gQ0hFQ0tfRk9SX0ZMQUdTKCkge1xuICAgICAgICBpZiAoZmxhZ3MmRldJRFRIKSB7ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2ZsYWcgYWZ0ZXIgd2lkdGgnfSB9XG4gICAgICAgIGlmIChmbGFncyZGUFJFQzApIHsgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnZmxhZyBhZnRlciBwcmVjaXNpb24nfSB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIENIRUNLX0ZPUl9XSURUSCgpIHtcbiAgICAgICAgaWYgKGZsYWdzJkZXSURUSCkgeyAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd3aWR0aCBnaXZlbiB0d2ljZSd9IH1cbiAgICAgICAgaWYgKGZsYWdzJkZQUkVDMCkgeyAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd3aWR0aCBhZnRlciBwcmVjaXNpb24nfSB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEdFVF9OVEhfQVJHKG51bSkge1xuICAgICAgICBpZiAobnVtID49IGFyZ3MubGVuZ3RoKSB7ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3RvbyBmZXcgYXJndW1lbnRzJ30gfVxuICAgICAgICByZXR1cm4gYXJnc1tudW1dO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBHRVRfTkVYVF9BUkcoKSB7XG4gICAgICAgIHN3aXRjaCAocG9zX2FyZ19udW0pIHtcbiAgICAgICAgY2FzZSAtMTogI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInVubnVtYmVyZWQoI3tgc2VxX2FyZ19udW1gfSkgbWl4ZWQgd2l0aCBudW1iZXJlZFwifVxuICAgICAgICBjYXNlIC0yOiAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwidW5udW1iZXJlZCgje2BzZXFfYXJnX251bWB9KSBtaXhlZCB3aXRoIG5hbWVkXCJ9XG4gICAgICAgIH1cbiAgICAgICAgcG9zX2FyZ19udW0gPSBzZXFfYXJnX251bSsrO1xuICAgICAgICByZXR1cm4gR0VUX05USF9BUkcocG9zX2FyZ19udW0gLSAxKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gR0VUX1BPU19BUkcobnVtKSB7XG4gICAgICAgIGlmIChwb3NfYXJnX251bSA+IDApIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibnVtYmVyZWQoI3tgbnVtYH0pIGFmdGVyIHVubnVtYmVyZWQoI3tgcG9zX2FyZ19udW1gfSlcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zX2FyZ19udW0gPT09IC0yKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm51bWJlcmVkKCN7YG51bWB9KSBhZnRlciBuYW1lZFwifVxuICAgICAgICB9XG4gICAgICAgIGlmIChudW0gPCAxKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgaW5kZXggLSAje2BudW1gfSRcIn1cbiAgICAgICAgfVxuICAgICAgICBwb3NfYXJnX251bSA9IC0xO1xuICAgICAgICByZXR1cm4gR0VUX05USF9BUkcobnVtIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEdFVF9BUkcoKSB7XG4gICAgICAgIHJldHVybiAobmV4dF9hcmcgPT09IHVuZGVmaW5lZCA/IEdFVF9ORVhUX0FSRygpIDogbmV4dF9hcmcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBSRUFEX05VTShsYWJlbCkge1xuICAgICAgICB2YXIgbnVtLCBzdHIgPSAnJztcbiAgICAgICAgZm9yICg7OyBpKyspIHtcbiAgICAgICAgICBpZiAoaSA9PT0gbGVuKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdtYWxmb3JtZWQgZm9ybWF0IHN0cmluZyAtICUqWzAtOV0nfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQ29kZUF0KGkpIDwgNDggfHwgZm9ybWF0X3N0cmluZy5jaGFyQ29kZUF0KGkpID4gNTcpIHtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIG51bSA9IHBhcnNlSW50KHN0ciwgMTApIHx8IDA7XG4gICAgICAgICAgICBpZiAobnVtID4gMjE0NzQ4MzY0Nykge1xuICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiI3tgbGFiZWxgfSB0b28gYmlnXCJ9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIgKz0gZm9ybWF0X3N0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gUkVBRF9OVU1fQUZURVJfQVNURVIobGFiZWwpIHtcbiAgICAgICAgdmFyIGFyZywgbnVtID0gUkVBRF9OVU0obGFiZWwpO1xuICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSArIDEpID09PSAnJCcpIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgYXJnID0gR0VUX1BPU19BUkcobnVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcmcgPSBHRVRfTkVYVF9BUkcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gI3tgYXJnYC50b19pbnR9O1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSBmb3JtYXRfc3RyaW5nLmluZGV4T2YoJyUnKTsgaSAhPT0gLTE7IGkgPSBmb3JtYXRfc3RyaW5nLmluZGV4T2YoJyUnLCBpKSkge1xuICAgICAgICBzdHIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgZmxhZ3MgPSBGTk9ORTtcbiAgICAgICAgd2lkdGggPSAtMTtcbiAgICAgICAgcHJlY2lzaW9uID0gLTE7XG4gICAgICAgIG5leHRfYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGVuZF9zbGljZSA9IGk7XG5cbiAgICAgICAgaSsrO1xuXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkpIHtcbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgYmVnaW5fc2xpY2UgPSBpO1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICBjYXNlICdcXDAnOlxuICAgICAgICAgIGkrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdF9zZXF1ZW5jZTogZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHN3aXRjaCAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkpIHtcblxuICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGU1BBQ0U7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRlNIQVJQO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZQTFVTO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZNSU5VUztcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGWkVSTztcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJzEnOlxuICAgICAgICAgIGNhc2UgJzInOlxuICAgICAgICAgIGNhc2UgJzMnOlxuICAgICAgICAgIGNhc2UgJzQnOlxuICAgICAgICAgIGNhc2UgJzUnOlxuICAgICAgICAgIGNhc2UgJzYnOlxuICAgICAgICAgIGNhc2UgJzcnOlxuICAgICAgICAgIGNhc2UgJzgnOlxuICAgICAgICAgIGNhc2UgJzknOlxuICAgICAgICAgICAgdG1wX251bSA9IFJFQURfTlVNKCd3aWR0aCcpO1xuICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkgKyAxKSA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgIGlmIChpICsgMiA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJyUnO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG5leHRfYXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwidmFsdWUgZ2l2ZW4gdHdpY2UgLSAlI3tgdG1wX251bWB9JFwifVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5leHRfYXJnID0gR0VUX1BPU19BUkcodG1wX251bSk7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIENIRUNLX0ZPUl9XSURUSCgpO1xuICAgICAgICAgICAgICBmbGFncyB8PSBGV0lEVEg7XG4gICAgICAgICAgICAgIHdpZHRoID0gdG1wX251bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgIGNhc2UgJ1xceyc6XG4gICAgICAgICAgICBjbG9zaW5nX2JyYWNlX2NoYXIgPSAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkgPT09ICc8JyA/ICc+JyA6ICdcXH0nKTtcbiAgICAgICAgICAgIGhhc2hfcGFyYW1ldGVyX2tleSA9ICcnO1xuXG4gICAgICAgICAgICBpKys7XG5cbiAgICAgICAgICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChpID09PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdtYWxmb3JtZWQgbmFtZSAtIHVubWF0Y2hlZCBwYXJlbnRoZXNpcyd9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSBjbG9zaW5nX2JyYWNlX2NoYXIpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwb3NfYXJnX251bSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJuYW1lZCAje2BoYXNoX3BhcmFtZXRlcl9rZXlgfSBhZnRlciB1bm51bWJlcmVkKCN7YHBvc19hcmdfbnVtYH0pXCJ9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3NfYXJnX251bSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJuYW1lZCAje2BoYXNoX3BhcmFtZXRlcl9rZXlgfSBhZnRlciBudW1iZXJlZFwifVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3NfYXJnX251bSA9IC0yO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbMF0gPT09IHVuZGVmaW5lZCB8fCAhYXJnc1swXS4kJGlzX2hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ29uZSBoYXNoIHJlcXVpcmVkJ31cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXh0X2FyZyA9ICN7YGFyZ3NbMF1gLmZldGNoKGBoYXNoX3BhcmFtZXRlcl9rZXlgKX07XG5cbiAgICAgICAgICAgICAgICBpZiAoY2xvc2luZ19icmFjZV9jaGFyID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RyID0gbmV4dF9hcmcudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwcmVjaXNpb24gIT09IC0xKSB7IHN0ciA9IHN0ci5zbGljZSgwLCBwcmVjaXNpb24pOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBoYXNoX3BhcmFtZXRlcl9rZXkgKz0gZm9ybWF0X3N0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIENIRUNLX0ZPUl9XSURUSCgpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRldJRFRIO1xuICAgICAgICAgICAgd2lkdGggPSBSRUFEX05VTV9BRlRFUl9BU1RFUignd2lkdGgnKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgICAgZmxhZ3MgfD0gRk1JTlVTO1xuICAgICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgaWYgKGZsYWdzJkZQUkVDMCkge1xuICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdwcmVjaXNpb24gZ2l2ZW4gdHdpY2UnfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmxhZ3MgfD0gRlBSRUN8RlBSRUMwO1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gMDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgcHJlY2lzaW9uID0gUkVBRF9OVU1fQUZURVJfQVNURVIoJ3ByZWNpc2lvbicpO1xuICAgICAgICAgICAgICBpZiAocHJlY2lzaW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIGZsYWdzICY9IH5GUFJFQztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVjaXNpb24gPSBSRUFEX05VTSgncHJlY2lzaW9uJyk7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgIGFyZyA9ICN7SW50ZWdlcihgR0VUX0FSRygpYCl9O1xuICAgICAgICAgICAgaWYgKGFyZyA+PSAwKSB7XG4gICAgICAgICAgICAgIHN0ciA9IGFyZy50b1N0cmluZygpO1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAoKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgPyAxIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgcHJlY2lzaW9uKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAxKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgY2FzZSAnQic6XG4gICAgICAgICAgY2FzZSAnbyc6XG4gICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG4gICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgICAgICBiYXNlX251bWJlciA9IDI7XG4gICAgICAgICAgICAgIGJhc2VfcHJlZml4ID0gJzBiJztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19yZWdleCA9IC9eMSsvO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX2RpZ2l0ID0gJzEnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgICAgICBiYXNlX251bWJlciA9IDg7XG4gICAgICAgICAgICAgIGJhc2VfcHJlZml4ID0gJzAnO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX3JlZ2V4ID0gL14zPzcrLztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCA9ICc3JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgICBiYXNlX251bWJlciA9IDE2O1xuICAgICAgICAgICAgICBiYXNlX3ByZWZpeCA9ICcweCc7XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXggPSAvXmYrLztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCA9ICdmJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmcgPSAje0ludGVnZXIoYEdFVF9BUkcoKWApfTtcbiAgICAgICAgICAgIGlmIChhcmcgPj0gMCkge1xuICAgICAgICAgICAgICBzdHIgPSBhcmcudG9TdHJpbmcoYmFzZV9udW1iZXIpO1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgcHJlY2lzaW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtICgoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSA/IDEgOiAwKSAtICgoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgPyBiYXNlX3ByZWZpeC5sZW5ndGggOiAwKSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCAmJiBhcmcgIT09IDApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9TdHJpbmcoYmFzZV9udW1iZXIpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgcHJlY2lzaW9uKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAxIC0gKGZsYWdzJkZTSEFSUCA/IDIgOiAwKSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyID0gKGFyZyA+Pj4gMCkudG9TdHJpbmcoYmFzZV9udW1iZXIpLnJlcGxhY2UoYmFzZV9uZWdfemVyb19yZWdleCwgYmFzZV9uZWdfemVyb19kaWdpdCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24gLSAyKSB7IHN0ciA9IGJhc2VfbmVnX3plcm9fZGlnaXQgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLi4nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtIDIgLSAoZmxhZ3MmRlNIQVJQID8gYmFzZV9wcmVmaXgubGVuZ3RoIDogMCkpIHsgc3RyID0gYmFzZV9uZWdfemVyb19kaWdpdCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLi4nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLi4nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkgPT09IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgIGFyZyA9ICN7RmxvYXQoYEdFVF9BUkcoKWApfTtcbiAgICAgICAgICAgIGlmIChhcmcgPj0gMCB8fCBpc05hTihhcmcpKSB7XG4gICAgICAgICAgICAgIGlmIChhcmcgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJ0luZic7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gYXJnLnRvRml4ZWQocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9FeHBvbmVudGlhbChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZy50b0V4cG9uZW50aWFsKCk7XG4gICAgICAgICAgICAgICAgICBleHBvbmVudCA9IHBhcnNlSW50KHN0ci5zcGxpdCgnZScpWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShleHBvbmVudCA8IC00IHx8IGV4cG9uZW50ID49IChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZy50b1ByZWNpc2lvbihwcmVjaXNpb24gPT09IC0xID8gKGZsYWdzJkZTSEFSUCA/IDYgOiB1bmRlZmluZWQpIDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgYXJnICE9PSBJbmZpbml0eSAmJiAhaXNOYU4oYXJnKSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtICgoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSA/IDEgOiAwKSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYXJnID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAnSW5mJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9GaXhlZChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b0V4cG9uZW50aWFsKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvRXhwb25lbnRpYWwoKTtcbiAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gcGFyc2VJbnQoc3RyLnNwbGl0KCdlJylbMV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgIGlmICghKGV4cG9uZW50IDwgLTQgfHwgZXhwb25lbnQgPj0gKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvUHJlY2lzaW9uKHByZWNpc2lvbiA9PT0gLTEgPyAoZmxhZ3MmRlNIQVJQID8gNiA6IHVuZGVmaW5lZCkgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgYXJnICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAxKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSBmb3JtYXRfc3RyaW5nLmNoYXJBdChpKS50b1VwcGVyQ2FzZSgpICYmIGFyZyAhPT0gSW5maW5pdHkgJiYgYXJnICE9PSAtSW5maW5pdHkgJiYgIWlzTmFOKGFyZykpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFtlRV1bLStdPykoWzAtOV0pJC8sICckMTAkMicpO1xuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAvLyBOb3QgaW1wbGVtZW50ZWQgYmVjYXVzZSB0aGVyZSBhcmUgbm8gc3BlY3MgZm9yIHRoaXMgZmllbGQgdHlwZS5cbiAgICAgICAgICAgICN7cmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ2BBYCBhbmQgYGFgIGZvcm1hdCBmaWVsZCB0eXBlcyBhcmUgbm90IGltcGxlbWVudGVkIGluIE9wYWwgeWV0J31cblxuICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgYXJnID0gR0VUX0FSRygpO1xuICAgICAgICAgICAgaWYgKCN7YGFyZ2AucmVzcG9uZF90bz8oOnRvX2FyeSl9KSB7IGFyZyA9ICN7YGFyZ2AudG9fYXJ5fVswXTsgfVxuICAgICAgICAgICAgaWYgKCN7YGFyZ2AucmVzcG9uZF90bz8oOnRvX3N0cil9KSB7XG4gICAgICAgICAgICAgIHN0ciA9ICN7YGFyZ2AudG9fc3RyfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoJGNvZXJjZV90byhhcmcsICN7SW50ZWdlcn0sICd0b19pbnQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICclYyByZXF1aXJlcyBhIGNoYXJhY3Rlcid9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICBzdHIgPSAje2BHRVRfQVJHKClgLmluc3BlY3R9O1xuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiAhPT0gLTEpIHsgc3RyID0gc3RyLnNsaWNlKDAsIHByZWNpc2lvbik7IH1cbiAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHN0ciA9ICN7YEdFVF9BUkcoKWAudG9fc307XG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uICE9PSAtMSkgeyBzdHIgPSBzdHIuc2xpY2UoMCwgcHJlY2lzaW9uKTsgfVxuICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibWFsZm9ybWVkIGZvcm1hdCBzdHJpbmcgLSAlI3tgZm9ybWF0X3N0cmluZy5jaGFyQXQoaSlgfVwifVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ21hbGZvcm1lZCBmb3JtYXQgc3RyaW5nIC0gJSd9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgKz0gZm9ybWF0X3N0cmluZy5zbGljZShiZWdpbl9zbGljZSwgZW5kX3NsaWNlKSArIHN0cjtcbiAgICAgICAgYmVnaW5fc2xpY2UgPSBpICsgMTtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7JERFQlVHfSAmJiBwb3NfYXJnX251bSA+PSAwICYmIHNlcV9hcmdfbnVtIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAndG9vIG1hbnkgYXJndW1lbnRzIGZvciBmb3JtYXQgc3RyaW5nJ31cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdCArIGZvcm1hdF9zdHJpbmcuc2xpY2UoYmVnaW5fc2xpY2UpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc3ByaW50ZiBmb3JtYXRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImZvcm1hdCIsIiRyZXRfb3JfMSIsImFyZ3MiLCJsZW5ndGgiLCI9PSIsIjEiLCJbXSIsIjAiLCJyZXNwb25kX3RvPyIsImFyeSIsImNvZXJjZV90bz8iLCJuaWw/IiwidG9fYSIsInJhaXNlIiwidG9faW50IiwiZmV0Y2giLCJJbnRlZ2VyIiwiRmxvYXQiLCJ0b19hcnkiLCJ0b19zdHIiLCJpbnNwZWN0IiwidG9fcyIsIiRERUJVRyJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFFQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0U7QUFBQUMsSUFBQUEsMEJBQUFBLG1CQUFBQSxrQkFBVyxhQUFELEVBSlosRUFJRUE7QUFBQUEsTUFBQUE7QUFBQUE7O0FBQUFBO0FBSkY7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUFJNEIsTUFBQSxrQkFKNUI7QUFBQSxNQUtJLElBQUEsUUFBRyxhQUFBLElBQUEsUUFMUEMsQ0FBQUEsWUFLT0MsSUFBQUMsUUFBQUEsQ0FBQUEsQ0FBQUMsT0FBQUEsQ0FBZUMsQ0FBZkQsQ0FMUEgsQ0FLTyxDQUFBO0FBQUEsUUFBb0IsT0FBQUMsSUFBQUksT0FBQUEsQ0FBS0MsQ0FBTEQsQ0FBQUUsZ0JBQUFBLENBQW9CLFFBQXBCQTtBQUFwQixNQUFBO0FBQUEsUUFMUCxPQUFBO0FBS08sTUFBQSxDQUFBLGtCQUFILENBQUE7QUFBQTtBQUNFLFFBQUFDLE1BQU0sb0JBQUFDLGVBQUFBLENBQWdCUixJQUFBSSxPQUFBQSxDQUFLQyxDQUFMRCxHQUFTLHVC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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFvQkEsU0FBQUEsQ0FBUyxTQUFUQSxDQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQW9CQyxPQUFBQSxDQUFPLFNBQVBBLENBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWNKLE9BQUFBLENBQU0scUNBQXFCLGdFQUEzQkE7O0FBRWQ7QUFDQTtBQUNBLGdCQUFrQixDQUFDLEdBQUQsQ0FBQUwsZ0JBQUFBLENBQWtCLFFBQWxCQSxDQUEyQixVQUFZLENBQUMsR0FBRCxDQUFBVSxRQUFBQSxDQUFBQSxDQUFhO0FBQ3RFLGdCQUFrQixDQUFDLEdBQUQsQ0FBQVYsZ0JBQUFBLENBQWtCLFFBQWxCQSxDQUEyQjtBQUM3QyxvQkFBc0IsQ0FBQyxHQUFELENBQUFXLFFBQUFBLENBQUFBLENBQWE7QUFDbkM7QUFDQSx3REFBMEQsdUJBQVE7QUFDbEU7QUFDQTtBQUNBLGtCQUFnQk4sT0FBQUEsQ0FBTSwrQkFBZSx5QkFBckJBO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQW9CLENBQUMsU0FBRCxDQUFBTyxTQUFBQSxDQUFBQSxDQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFvQixDQUFDLFNBQUQsQ0FBQUMsTUFBQUEsQ0FBQUEsQ0FBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBY1IsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsNkJBQUEsR0FBQSxDQUErQix1QkFBL0IsQ0FBckJBO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQVlBLE9BQUFBLENBQU0sK0JBQWUsNkJBQXJCQTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFZUyxZQUFPO0FBQ25CLFlBQVVULE9BQUFBLENBQU0sK0JBQWUsc0NBQXJCQTtBQUNWOztBQUVBO0FBQ0EsSUE5aEJBO0FBSUViLElBQUFBLENBQUFBLCtCQUFBQSxDQUFBO0FBQUEsSUE2aEJBLGlCQUFNLFNBQU4sRUFBYyxRQUFkLENBN2hCQTtBQURGRCxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5NDUyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9zdHJpbmcvZW5jb2RpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9zdHJpbmcnXG5cbmNsYXNzIEVuY29kaW5nXG4gIGRlZiBzZWxmLnJlZ2lzdGVyKG5hbWUsIG9wdGlvbnMgPSB7fSwgJmJsb2NrKVxuICAgIG5hbWVzID0gW25hbWVdICsgKG9wdGlvbnNbOmFsaWFzZXNdIHx8IFtdKVxuICAgIGFzY2lpID0gb3B0aW9uc1s6YXNjaWldIHx8IGZhbHNlXG4gICAgZHVtbXkgPSBvcHRpb25zWzpkdW1teV0gfHwgZmFsc2VcblxuICAgIGVuY29kaW5nID0gbmV3KG5hbWUsIG5hbWVzLCBhc2NpaSwgZHVtbXkpXG4gICAgZW5jb2RpbmcuaW5zdGFuY2VfZXZhbCgmYmxvY2spXG5cbiAgICByZWdpc3RlciA9IGBPcGFsLmVuY29kaW5nc2BcbiAgICBuYW1lcy5lYWNoIGRvIHxlbmNvZGluZ19uYW1lfFxuICAgICAgY29uc3Rfc2V0IGVuY29kaW5nX25hbWUuc3ViKCctJywgJ18nKSwgZW5jb2RpbmdcbiAgICAgIHJlZ2lzdGVyLkpTW2VuY29kaW5nX25hbWVdID0gZW5jb2RpbmdcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZmluZChuYW1lKVxuICAgIHJldHVybiBkZWZhdWx0X2V4dGVybmFsIGlmIG5hbWUgPT0gOmRlZmF1bHRfZXh0ZXJuYWxcbiAgICByZWdpc3RlciA9IGBPcGFsLmVuY29kaW5nc2BcbiAgICBlbmNvZGluZyA9IHJlZ2lzdGVyLkpTW25hbWVdIHx8IHJlZ2lzdGVyLkpTW25hbWUudXBjYXNlXVxuICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwidW5rbm93biBlbmNvZGluZyBuYW1lIC0gI3tuYW1lfVwiIHVubGVzcyBlbmNvZGluZ1xuICAgIGVuY29kaW5nXG4gIGVuZFxuXG4gIHNpbmdsZXRvbl9jbGFzcy5hdHRyX2FjY2Vzc29yIDpkZWZhdWx0X2V4dGVybmFsXG5cbiAgYXR0cl9yZWFkZXIgOm5hbWUsIDpuYW1lc1xuXG4gIGRlZiBpbml0aWFsaXplKG5hbWUsIG5hbWVzLCBhc2NpaSwgZHVtbXkpXG4gICAgQG5hbWUgID0gbmFtZVxuICAgIEBuYW1lcyA9IG5hbWVzXG4gICAgQGFzY2lpID0gYXNjaWlcbiAgICBAZHVtbXkgPSBkdW1teVxuICBlbmRcblxuICBkZWYgYXNjaWlfY29tcGF0aWJsZT9cbiAgICBAYXNjaWlcbiAgZW5kXG5cbiAgZGVmIGR1bW15P1xuICAgIEBkdW1teVxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIEBuYW1lXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIjPEVuY29kaW5nOiN7QG5hbWV9I3snIChkdW1teSknIGlmIEBkdW1teX0+XCJcbiAgZW5kXG5cbiAgIyBtZXRob2RzIHRvIGltcGxlbWVudCBwZXIgZW5jb2RpbmdcbiAgZGVmIGVhY2hfYnl0ZSgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3JcbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICBlbmRcblxuICBjbGFzcyBFbmNvZGluZ0Vycm9yIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG4gIGNsYXNzIENvbXBhdGliaWxpdHlFcnJvciA8IEVuY29kaW5nRXJyb3I7IGVuZFxuZW5kXG5cbkVuY29kaW5nLnJlZ2lzdGVyICdVVEYtOCcsIGFsaWFzZXM6IFsnQ1A2NTAwMSddLCBhc2NpaTogdHJ1ZSBkb1xuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgLy8gVGFrZW4gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi9mNTJkZmZkOWRmMDQ0NWI5M2MwYzkwNjVjMmY4ZjBmNDZiMmM3MjlhL2luZGV4LmpzI0wxOTU0LUwyMDMyXG4gICAgICB2YXIgdW5pdHMgPSBJbmZpbml0eVxuICAgICAgdmFyIGNvZGVQb2ludFxuICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgICAgIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAgICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkge1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4RUZgfTtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEJGYH07XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRGB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEVGYH07XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4QkRgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkge1xuICAgICAgICAgICAgICAje3lpZWxkIGAweEVGYH07XG4gICAgICAgICAgICAgICN7eWllbGQgYDB4QkZgfTtcbiAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRGB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICAgICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkge1xuICAgICAgICAgICAgI3t5aWVsZCBgMHhFRmB9O1xuICAgICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xuICAgICAgICAgICAgI3t5aWVsZCBgMHhCRGB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAgICAgLy8gZW5jb2RlIHV0ZjhcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnRgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweDYgfCAweEMwYH07XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ID4+IDB4QyB8IDB4RTBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwYH07XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwYH07XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwYH07XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJbnZhbGlkIGNvZGUgcG9pbnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKHN0cmluZylcbiAgICBzdHJpbmcuYnl0ZXMubGVuZ3RoXG4gIGVuZFxuZW5kXG5cbkVuY29kaW5nLnJlZ2lzdGVyICdVVEYtMTZMRScgZG9cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAje3lpZWxkIGBjb2RlICYgMHhmZmB9O1xuICAgICAgICAje3lpZWxkIGBjb2RlID4+IDhgfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBieXRlc2l6ZShzdHJpbmcpXG4gICAgc3RyaW5nLmJ5dGVzLmxlbmd0aFxuICBlbmRcbmVuZFxuXG5FbmNvZGluZy5yZWdpc3RlciAnVVRGLTE2QkUnIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgI3t5aWVsZCBgY29kZSA+PiA4YH07XG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIHN0cmluZy5ieXRlcy5sZW5ndGhcbiAgZW5kXG5lbmRcblxuRW5jb2RpbmcucmVnaXN0ZXIgJ1VURi0zMkxFJyBkb1xuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICAgICN7eWllbGQgYGNvZGUgPj4gOGB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKHN0cmluZylcbiAgICBzdHJpbmcuYnl0ZXMubGVuZ3RoXG4gIGVuZFxuZW5kXG5cbkVuY29kaW5nLnJlZ2lzdGVyICdBU0NJSS04QklUJywgYWxpYXNlczogWydCSU5BUlknLCAnVVMtQVNDSUknLCAnQVNDSUknXSwgYXNjaWk6IHRydWUsIGR1bW15OiB0cnVlIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICAgICN7eWllbGQgYGNvZGUgPj4gOGB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKHN0cmluZylcbiAgICBzdHJpbmcuYnl0ZXMubGVuZ3RoXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFN0cmluZ1xuICBhdHRyX3JlYWRlciA6ZW5jb2RpbmdcbiAgYXR0cl9yZWFkZXIgOmludGVybmFsX2VuY29kaW5nXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsICdieXRlcycsIG5pbClgXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsICdlbmNvZGluZycsICN7RW5jb2Rpbmc6OlVURl84fSlgXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsICdpbnRlcm5hbF9lbmNvZGluZycsICN7RW5jb2Rpbmc6OlVURl84fSlgXG5cbiAgZGVmIGJ5dGVzXG4gICAgQGJ5dGVzIHx8PSBlYWNoX2J5dGUudG9fYVxuICAgIEBieXRlcy5kdXBcbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplXG4gICAgQGludGVybmFsX2VuY29kaW5nLmJ5dGVzaXplKHNlbGYpXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2J5dGUoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9ieXRlIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIEBpbnRlcm5hbF9lbmNvZGluZy5lYWNoX2J5dGUoc2VsZiwgJmJsb2NrKVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaF9jb2RlcG9pbnQoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9jb2RlcG9pbnQgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgI3t5aWVsZCBgc2VsZi5jb2RlUG9pbnRBdChpKWB9O1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjb2RlcG9pbnRzKCZibG9jaylcbiAgICAjIElmIGEgYmxvY2sgaXMgZ2l2ZW4sIHdoaWNoIGlzIGEgZGVwcmVjYXRlZCBmb3JtLCB3b3JrcyB0aGUgc2FtZSBhcyBlYWNoX2NvZGVwb2ludC5cbiAgICByZXR1cm4gZWFjaF9jb2RlcG9pbnQoJmJsb2NrKSBpZiBibG9ja19naXZlbj9cbiAgICBlYWNoX2NvZGVwb2ludC50b19hXG4gIGVuZFxuXG4gIGRlZiBlbmNvZGUoZW5jb2RpbmcpXG4gICAgYE9wYWwuZW5jKHNlbGYsIGVuY29kaW5nKWBcbiAgZW5kXG5cbiAgZGVmIGZvcmNlX2VuY29kaW5nKGVuY29kaW5nKVxuICAgICV4e1xuICAgICAgaWYgKGVuY29kaW5nID09PSBzZWxmLmVuY29kaW5nKSB7IHJldHVybiBzZWxmOyB9XG5cbiAgICAgIGVuY29kaW5nID0gI3tPcGFsLmNvZXJjZV90byEoZW5jb2RpbmcsIFN0cmluZywgOnRvX3MpfTtcbiAgICAgIGVuY29kaW5nID0gI3tFbmNvZGluZy5maW5kKGVuY29kaW5nKX07XG5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gc2VsZi5lbmNvZGluZykgeyByZXR1cm4gc2VsZjsgfVxuXG4gICAgICBPcGFsLnNldF9lbmNvZGluZyhzZWxmLCBlbmNvZGluZyk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdldGJ5dGUoaWR4KVxuICAgIHN0cmluZ19ieXRlcyA9IGJ5dGVzXG4gICAgaWR4ID0gT3BhbC5jb2VyY2VfdG8hKGlkeCwgSW50ZWdlciwgOnRvX2ludClcbiAgICByZXR1cm4gaWYgc3RyaW5nX2J5dGVzLmxlbmd0aCA8IGlkeFxuXG4gICAgc3RyaW5nX2J5dGVzW2lkeF1cbiAgZW5kXG5cbiAgIyBzdHViXG4gIGRlZiB2YWxpZF9lbmNvZGluZz9cbiAgICB0cnVlXG4gIGVuZFxuZW5kXG5cbkVuY29kaW5nLmRlZmF1bHRfZXh0ZXJuYWwgPSBfX0VOQ09ESU5HX19cbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJyZWdpc3RlciIsInNlbGYiLCJuYW1lcyIsIisiLCJuYW1lIiwiJHJldF9vcl8xIiwib3B0aW9ucyIsIltdIiwiYXNjaWkiLCIkcmV0X29yXzIiLCJkdW1teSIsIiRyZXRfb3JfMyIsImVuY29kaW5nIiwibmV3IiwiaW5zdGFuY2VfZXZhbCIsImJsb2NrIiwiZWFjaCIsImNvbnN0X3NldCIsImVuY29kaW5nX25hbWUiLCJzdWIiLCJmaW5kIiwiPT0iLCJkZWZhdWx0X2V4dGVybmFsIiwiJHJldF9vcl80IiwidXBjYXNlIiwicmFpc2UiLCJzaW5nbGV0b25fY2xhc3MiLCJhdHRyX2FjY2Vzc29yIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQG5hbWUiLCJAbmFtZXMiLCJAYXNjaWkiLCJAZHVtbXkiLCJhc2NpaV9jb21wYXRpYmxlPyIsImR1bW15PyIsInRvX3MiLCJpbnNwZWN0IiwiZWFjaF9ieXRlIiwiYnl0ZXNpemUiLCJzdHJpbmciLCJieXRlcyIsImxlbmd0aCIsIkBieXRlcyIsIiRyZXRfb3JfNSIsInRvX2EiLCJkdXAiLCJAaW50ZXJuYWxfZW5jb2RpbmciLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImVhY2hfY29kZXBvaW50IiwiY29kZXBvaW50cyIsImVuY29kZSIsImZvcmNlX2VuY29kaW5nIiwiY29lcmNlX3RvISIsImdldGJ5dGUiLCJzdHJpbmdfYnl0ZXMiLCJpZHgiLCI8IiwidmFsaWRfZW5jb2Rpbmc/IiwiJHdyaXRlciIsImRlZmF1bHRfZXh0ZXJuYWw9IiwiLSIsIjEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsZ0JBQVJBLENBQUE7QUFBQSxFQUVBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0UsSUFBQUMsVUFBSUMsSUFBSkQsZUFBQUEsdUJBQUFBLG9CQUFrQixJQUFELEVBQU8sT0FBeEJBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQUpGO0FBSXdDLE1BQUEsMkNBSnhDO0FBQUE7QUFJMEIsTUFBQTtBQUFBLE1BQUEsWUFBVSxZQUFBLEVBQVY7QUFBQSxNQUFBLENBSjFCO0FBQUEsTUFLSUUsUUFBUUMsU0FBQSxDQUFDQyxJQUFELENBQUFELEVBQVUsYUFBQSxJQUFBLFFBTHRCRSxDQUFBQSxZQUtzQkMsT0FBQUMsT0FBQUEsQ0FBUSxTQUFSQSxDQUx0QkYsQ0FLc0IsQ0FBQTtBQUFBLFFBTHRCLE9BQUE7QUFLc0IsTUFBQTtBQUFBLFFBQXFCLE9BQUE7QUFBckIsTUFBQSxDQUFBLGtCQUFWRixDQUxaO0FBQUEsTUFNSUssUUFBUSxhQUFBLElBQUEsUUFOWkMsQ0FBQUEsWUFNWUgsT0FBQUMsT0FBQUEsQ0FBUSxPQUFSQSxDQU5aRSxDQU1ZLENBQUE7QUFBQSxRQU5aLE9BQUE7QUFNWSxNQUFBO0FBQUEsUUFBbUIsT0FBQTtBQUFuQixNQUFBLENBQUEsa0JBTlo7QUFBQSxNQU9JQyxRQUFRLGFBQUEsSUFBQSxRQVBaQyxDQUFBQSxZQU9ZTCxPQUFBQyxPQUFBQSxDQUFRLE9BQVJBLENBUFpJLENBT1ksQ0FBQTtBQUFBLFFBUFosT0FBQTtBQU9ZLE1BQUE7QUFBQSxRQUFtQixPQUFBO0FBQW5C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QUEsMkJBbkVBO0FBREY1RCxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQXJPQTtBQUFBO0FBREEsRUFBQTZELFVBQUEsQ0ErUzRCLDRCQUFBLFVBL1M1QixDQUFBO0FBQUEsRUErU0FDLE1BQUEsd0JBQUFBLHFCQUFBQSxFQS9TQSxVQUFBRCxPQUFBLENBK1NBQyxDQS9TQTtBQUFBLEVBQUEsT0FBQUQsT0FBQSxDQUFBRSxVQUFBRixPQUFBLENBQUEsUUFBQSxDQUFBRSxFQUFBQyxDQUFBRCxDQUFBLENBQUEsQ0FDQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5OTMyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tYXRoLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHlwZV9lcnJvclxuXG5tb2R1bGUgTWF0aFxuICBFICA9IGBNYXRoLkVgXG4gIFBJID0gYE1hdGguUElgXG5cbiAgRG9tYWluRXJyb3IgPSBDbGFzcy5uZXcoU3RhbmRhcmRFcnJvcilcblxuICBkZWYgc2VsZi5jaGVja2VkKG1ldGhvZCwgKmFyZ3MpXG4gICAgJXh7XG4gICAgICBpZiAoaXNOYU4oYXJnc1swXSkgfHwgKGFyZ3MubGVuZ3RoID09IDIgJiYgaXNOYU4oYXJnc1sxXSkpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBNYXRoW21ldGhvZF0uYXBwbHkobnVsbCwgYXJncyk7XG5cbiAgICAgIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICN7cmFpc2UgRG9tYWluRXJyb3IsIFwiTnVtZXJpY2FsIGFyZ3VtZW50IGlzIG91dCBvZiBkb21haW4gLSBcXFwiI3ttZXRob2R9XFxcIlwifTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmZsb2F0ISh2YWx1ZSlcbiAgICBGbG9hdCh2YWx1ZSlcbiAgcmVzY3VlIEFyZ3VtZW50RXJyb3JcbiAgICByYWlzZSBgJHR5cGVfZXJyb3IodmFsdWUsICN7RmxvYXR9KWBcbiAgZW5kXG5cbiAgZGVmIHNlbGYuaW50ZWdlciEodmFsdWUpXG4gICAgSW50ZWdlcih2YWx1ZSlcbiAgcmVzY3VlIEFyZ3VtZW50RXJyb3JcbiAgICByYWlzZSBgJHR5cGVfZXJyb3IodmFsdWUsICN7SW50ZWdlcn0pYFxuICBlbmRcblxuICBtb2R1bGVfZnVuY3Rpb25cblxuICBkZWYgYWNvcyh4KVxuICAgIE1hdGguY2hlY2tlZCA6YWNvcywgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmFjb3NoYClcbiAgICAleHtcbiAgICAgIE1hdGguYWNvc2ggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4IC0gMSkpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFjb3NoKHgpXG4gICAgTWF0aC5jaGVja2VkIDphY29zaCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGFzaW4oeClcbiAgICBNYXRoLmNoZWNrZWQgOmFzaW4sIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5hc2luaGApXG4gICAgJXh7XG4gICAgICBNYXRoLmFzaW5oID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCArIDEpKVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFzaW5oKHgpXG4gICAgTWF0aC5jaGVja2VkIDphc2luaCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGF0YW4oeClcbiAgICBNYXRoLmNoZWNrZWQgOmF0YW4sIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBhdGFuMih5LCB4KVxuICAgIE1hdGguY2hlY2tlZCA6YXRhbjIsIE1hdGguZmxvYXQhKHkpLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguYXRhbmhgKVxuICAgICV4e1xuICAgICAgTWF0aC5hdGFuaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgubG9nKCgxICsgeCkgLyAoMSAtIHgpKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhdGFuaCh4KVxuICAgIE1hdGguY2hlY2tlZCA6YXRhbmgsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5jYnJ0YClcbiAgICAleHtcbiAgICAgIE1hdGguY2JydCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHggPT0gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIC1NYXRoLmNicnQoLXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHIgID0geCxcbiAgICAgICAgICAgIGV4ID0gMDtcblxuICAgICAgICB3aGlsZSAociA8IDAuMTI1KSB7XG4gICAgICAgICAgciAqPSA4O1xuICAgICAgICAgIGV4LS07XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAociA+IDEuMCkge1xuICAgICAgICAgIHIgKj0gMC4xMjU7XG4gICAgICAgICAgZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHIgPSAoLTAuNDY5NDYxMTYgKiByICsgMS4wNzIzMDIpICogciArIDAuMzgxMjUxMztcblxuICAgICAgICB3aGlsZSAoZXggPCAwKSB7XG4gICAgICAgICAgciAqPSAwLjU7XG4gICAgICAgICAgZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChleCA+IDApIHtcbiAgICAgICAgICByICo9IDI7XG4gICAgICAgICAgZXgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIgPSAoMi4wIC8gMy4wKSAqIHIgKyAoMS4wIC8gMy4wKSAqIHggLyAociAqIHIpO1xuICAgICAgICByID0gKDIuMCAvIDMuMCkgKiByICsgKDEuMCAvIDMuMCkgKiB4IC8gKHIgKiByKTtcbiAgICAgICAgciA9ICgyLjAgLyAzLjApICogciArICgxLjAgLyAzLjApICogeCAvIChyICogcik7XG4gICAgICAgIHIgPSAoMi4wIC8gMy4wKSAqIHIgKyAoMS4wIC8gMy4wKSAqIHggLyAociAqIHIpO1xuXG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNicnQoeClcbiAgICBNYXRoLmNoZWNrZWQgOmNicnQsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBjb3MoeClcbiAgICBNYXRoLmNoZWNrZWQgOmNvcywgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmNvc2hgKVxuICAgICV4e1xuICAgICAgTWF0aC5jb3NoID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gKE1hdGguZXhwKHgpICsgTWF0aC5leHAoLXgpKSAvIDI7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29zaCh4KVxuICAgIE1hdGguY2hlY2tlZCA6Y29zaCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmVyZmApXG4gICAgJXh7XG4gICAgICBPcGFsLmRlZmluZVByb3BlcnR5KE1hdGgsICdlcmYnLCBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBBMSA9ICAwLjI1NDgyOTU5MixcbiAgICAgICAgICAgIEEyID0gLTAuMjg0NDk2NzM2LFxuICAgICAgICAgICAgQTMgPSAgMS40MjE0MTM3NDEsXG4gICAgICAgICAgICBBNCA9IC0xLjQ1MzE1MjAyNyxcbiAgICAgICAgICAgIEE1ID0gIDEuMDYxNDA1NDI5LFxuICAgICAgICAgICAgUCAgPSAgMC4zMjc1OTExO1xuXG4gICAgICAgIHZhciBzaWduID0gMTtcblxuICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHggPSBNYXRoLmFicyh4KTtcblxuICAgICAgICB2YXIgdCA9IDEuMCAvICgxLjAgKyBQICogeCk7XG4gICAgICAgIHZhciB5ID0gMS4wIC0gKCgoKChBNSAqIHQgKyBBNCkgKiB0KSArIEEzKSAqIHQgKyBBMikgKiB0ICsgQTEpICogdCAqIE1hdGguZXhwKC14ICogeCk7XG5cbiAgICAgICAgcmV0dXJuIHNpZ24gKiB5O1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZXJmKHgpXG4gICAgTWF0aC5jaGVja2VkIDplcmYsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5lcmZjYClcbiAgICAleHtcbiAgICAgIE9wYWwuZGVmaW5lUHJvcGVydHkoTWF0aCwgJ2VyZmMnLCBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciB6ID0gTWF0aC5hYnMoeCksXG4gICAgICAgICAgICB0ID0gMS4wIC8gKDAuNSAqIHogKyAxLjApO1xuXG4gICAgICAgIHZhciBBMSA9IHQgKiAwLjE3MDg3Mjc3ICsgLTAuODIyMTUyMjMsXG4gICAgICAgICAgICBBMiA9IHQgKiBBMSArIDEuNDg4NTE1ODcsXG4gICAgICAgICAgICBBMyA9IHQgKiBBMiArIC0xLjEzNTIwMzk4LFxuICAgICAgICAgICAgQTQgPSB0ICogQTMgKyAwLjI3ODg2ODA3LFxuICAgICAgICAgICAgQTUgPSB0ICogQTQgKyAtMC4xODYyODgwNixcbiAgICAgICAgICAgIEE2ID0gdCAqIEE1ICsgMC4wOTY3ODQxOCxcbiAgICAgICAgICAgIEE3ID0gdCAqIEE2ICsgMC4zNzQwOTE5NixcbiAgICAgICAgICAgIEE4ID0gdCAqIEE3ICsgMS4wMDAwMjM2OCxcbiAgICAgICAgICAgIEE5ID0gdCAqIEE4LFxuICAgICAgICAgICAgQTEwID0gLXogKiB6IC0gMS4yNjU1MTIyMyArIEE5O1xuXG4gICAgICAgIHZhciBhID0gdCAqIE1hdGguZXhwKEExMCk7XG5cbiAgICAgICAgaWYgKHggPCAwLjApIHtcbiAgICAgICAgICByZXR1cm4gMi4wIC0gYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZXJmYyh4KVxuICAgIE1hdGguY2hlY2tlZCA6ZXJmYywgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGV4cCh4KVxuICAgIE1hdGguY2hlY2tlZCA6ZXhwLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgZnJleHAoeClcbiAgICB4ID0gTWF0aC5mbG9hdCEoeClcblxuICAgICV4e1xuICAgICAgaWYgKGlzTmFOKHgpKSB7XG4gICAgICAgIHJldHVybiBbTmFOLCAwXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4ICAgPSBNYXRoLmZsb29yKE1hdGgubG9nKE1hdGguYWJzKHgpKSAvIE1hdGgubG9nKDIpKSArIDEsXG4gICAgICAgICAgZnJhYyA9IHggLyBNYXRoLnBvdygyLCBleCk7XG5cbiAgICAgIHJldHVybiBbZnJhYywgZXhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdhbW1hKG4pXG4gICAgbiA9IE1hdGguZmxvYXQhKG4pXG5cbiAgICAleHtcbiAgICAgIHZhciBpLCB0LCB4LCB2YWx1ZSwgcmVzdWx0LCB0d29OLCB0aHJlZU4sIGZvdXJOLCBmaXZlTjtcblxuICAgICAgdmFyIEcgPSA0Ljc0MjE4NzU7XG5cbiAgICAgIHZhciBQID0gW1xuICAgICAgICAgMC45OTk5OTk5OTk5OTk5OTcwOTE4MixcbiAgICAgICAgIDU3LjE1NjIzNTY2NTg2MjkyMzUxNyxcbiAgICAgICAgLTU5LjU5Nzk2MDM1NTQ3NTQ5MTI0OCxcbiAgICAgICAgIDE0LjEzNjA5Nzk3NDc0MTc0NzE3NCxcbiAgICAgICAgLTAuNDkxOTEzODE2MDk3NjIwMTk5NzgsXG4gICAgICAgICAwLjMzOTk0NjQ5OTg0ODExODg4Njk5ZS00LFxuICAgICAgICAgMC40NjUyMzYyODkyNzA0ODU3NTY2NWUtNCxcbiAgICAgICAgLTAuOTgzNzQ0NzUzMDQ4Nzk1NjQ2NzdlLTQsXG4gICAgICAgICAwLjE1ODA4ODcwMzIyNDkxMjQ4ODg0ZS0zLFxuICAgICAgICAtMC4yMTAyNjQ0NDE3MjQxMDQ4ODMxOWUtMyxcbiAgICAgICAgIDAuMjE3NDM5NjE4MTE1MjEyNjQzMjBlLTMsXG4gICAgICAgIC0wLjE2NDMxODEwNjUzNjc2Mzg5MDIyZS0zLFxuICAgICAgICAgMC44NDQxODIyMzk4Mzg1Mjc0MzI5M2UtNCxcbiAgICAgICAgLTAuMjYxOTA4Mzg0MDE1ODE0MDg2NzBlLTQsXG4gICAgICAgICAwLjM2ODk5MTgyNjU5NTMxNjIyNzA0ZS01XG4gICAgICBdO1xuXG5cbiAgICAgIGlmIChpc05hTihuKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuXG4gICAgICBpZiAobiA9PT0gMCAmJiAxIC8gbiA8IDApIHtcbiAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPT09IC0xIHx8IG4gPT09IC1JbmZpbml0eSkge1xuICAgICAgICAje3JhaXNlIERvbWFpbkVycm9yLCAnTnVtZXJpY2FsIGFyZ3VtZW50IGlzIG91dCBvZiBkb21haW4gLSBcImdhbW1hXCInfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7SW50ZWdlciA9PT0gbn0pIHtcbiAgICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICAgIHJldHVybiBpc0Zpbml0ZShuKSA/IEluZmluaXR5IDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4gPiAxNzEpIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSAgPSBuIC0gMjtcbiAgICAgICAgcmVzdWx0ID0gbiAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHZhbHVlID4gMSkge1xuICAgICAgICAgIHJlc3VsdCAqPSB2YWx1ZTtcbiAgICAgICAgICB2YWx1ZS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PSAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChuIDwgMC41KSB7XG4gICAgICAgIHJldHVybiBNYXRoLlBJIC8gKE1hdGguc2luKE1hdGguUEkgKiBuKSAqICN7TWF0aC5nYW1tYSgxIC0gbil9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPj0gMTcxLjM1KSB7XG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPiA4NS4wKSB7XG4gICAgICAgIHR3b04gICA9IG4gKiBuO1xuICAgICAgICB0aHJlZU4gPSB0d29OICogbjtcbiAgICAgICAgZm91ck4gID0gdGhyZWVOICogbjtcbiAgICAgICAgZml2ZU4gID0gZm91ck4gKiBuO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoMiAqIE1hdGguUEkgLyBuKSAqIE1hdGgucG93KChuIC8gTWF0aC5FKSwgbikgKlxuICAgICAgICAgICgxICsgMSAvICgxMiAqIG4pICsgMSAvICgyODggKiB0d29OKSAtIDEzOSAvICg1MTg0MCAqIHRocmVlTikgLVxuICAgICAgICAgIDU3MSAvICgyNDg4MzIwICogZm91ck4pICsgMTYzODc5IC8gKDIwOTAxODg4MCAqIGZpdmVOKSArXG4gICAgICAgICAgNTI0NjgxOSAvICg3NTI0Njc5NjgwMCAqIGZpdmVOICogbikpO1xuICAgICAgfVxuXG4gICAgICBuIC09IDE7XG4gICAgICB4ICA9IFBbMF07XG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPCBQLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHggKz0gUFtpXSAvIChuICsgaSk7XG4gICAgICB9XG5cbiAgICAgIHQgPSBuICsgRyArIDAuNTtcblxuICAgICAgcmV0dXJuIE1hdGguc3FydCgyICogTWF0aC5QSSkgKiBNYXRoLnBvdyh0LCBuICsgMC41KSAqIE1hdGguZXhwKC10KSAqIHg7XG4gICAgfVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguaHlwb3RgKVxuICAgICV4e1xuICAgICAgTWF0aC5oeXBvdCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGh5cG90KHgsIHkpXG4gICAgTWF0aC5jaGVja2VkIDpoeXBvdCwgTWF0aC5mbG9hdCEoeCksIE1hdGguZmxvYXQhKHkpXG4gIGVuZFxuXG4gIGRlZiBsZGV4cChtYW50aXNzYSwgZXhwb25lbnQpXG4gICAgbWFudGlzc2EgPSBNYXRoLmZsb2F0IShtYW50aXNzYSlcbiAgICBleHBvbmVudCA9IE1hdGguaW50ZWdlciEoZXhwb25lbnQpXG5cbiAgICAleHtcbiAgICAgIGlmIChpc05hTihleHBvbmVudCkpIHtcbiAgICAgICAgI3tyYWlzZSBSYW5nZUVycm9yLCAnZmxvYXQgTmFOIG91dCBvZiByYW5nZSBvZiBpbnRlZ2VyJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsZ2FtbWEobilcbiAgICAleHtcbiAgICAgIGlmIChuID09IC0xKSB7XG4gICAgICAgIHJldHVybiBbSW5maW5pdHksIDFdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbTWF0aC5sb2coTWF0aC5hYnMoI3tNYXRoLmdhbW1hKG4pfSkpLCAje01hdGguZ2FtbWEobil9IDwgMCA/IC0xIDogMV07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbG9nKHgsIGJhc2UgPSB1bmRlZmluZWQpXG4gICAgaWYgU3RyaW5nID09PSB4XG4gICAgICByYWlzZSBgJHR5cGVfZXJyb3IoeCwgI3tGbG9hdH0pYFxuICAgIGVuZFxuXG4gICAgaWYgYGJhc2UgPT0gbnVsbGBcbiAgICAgIE1hdGguY2hlY2tlZCA6bG9nLCBNYXRoLmZsb2F0ISh4KVxuICAgIGVsc2VcbiAgICAgIGlmIFN0cmluZyA9PT0gYmFzZVxuICAgICAgICByYWlzZSBgJHR5cGVfZXJyb3IoYmFzZSwgI3tGbG9hdH0pYFxuICAgICAgZW5kXG5cbiAgICAgIE1hdGguY2hlY2tlZCg6bG9nLCBNYXRoLmZsb2F0ISh4KSkgLyBNYXRoLmNoZWNrZWQoOmxvZywgTWF0aC5mbG9hdCEoYmFzZSkpXG4gICAgZW5kXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5sb2cxMGApXG4gICAgJXh7XG4gICAgICBNYXRoLmxvZzEwID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMTA7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbG9nMTAoeClcbiAgICBpZiBTdHJpbmcgPT09IHhcbiAgICAgIHJhaXNlIGAkdHlwZV9lcnJvcih4LCAje0Zsb2F0fSlgXG4gICAgZW5kXG5cbiAgICBNYXRoLmNoZWNrZWQgOmxvZzEwLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGgubG9nMmApXG4gICAgJXh7XG4gICAgICBNYXRoLmxvZzIgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4yO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxvZzIoeClcbiAgICBpZiBTdHJpbmcgPT09IHhcbiAgICAgIHJhaXNlIGAkdHlwZV9lcnJvcih4LCAje0Zsb2F0fSlgXG4gICAgZW5kXG5cbiAgICBNYXRoLmNoZWNrZWQgOmxvZzIsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBzaW4oeClcbiAgICBNYXRoLmNoZWNrZWQgOnNpbiwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLnNpbmhgKVxuICAgICV4e1xuICAgICAgTWF0aC5zaW5oID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gKE1hdGguZXhwKHgpIC0gTWF0aC5leHAoLXgpKSAvIDI7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2luaCh4KVxuICAgIE1hdGguY2hlY2tlZCA6c2luaCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIHNxcnQoeClcbiAgICBNYXRoLmNoZWNrZWQgOnNxcnQsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiB0YW4oeClcbiAgICB4ID0gTWF0aC5mbG9hdCEoeClcblxuICAgIGlmIHguaW5maW5pdGU/XG4gICAgICByZXR1cm4gRmxvYXQ6Ok5BTlxuICAgIGVuZFxuXG4gICAgTWF0aC5jaGVja2VkIDp0YW4sIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC50YW5oYClcbiAgICAleHtcbiAgICAgIE1hdGgudGFuaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHggPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4ID09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gKE1hdGguZXhwKHgpIC0gTWF0aC5leHAoLXgpKSAvIChNYXRoLmV4cCh4KSArIE1hdGguZXhwKC14KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0YW5oKHgpXG4gICAgTWF0aC5jaGVja2VkIDp0YW5oLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsIm5ldyIsImNoZWNrZWQiLCJzZWxmIiwicmFpc2UiLCJtZXRob2QiLCJmbG9hdCEiLCJGbG9hdCIsInZhbHVlIiwiaW50ZWdlciEiLCJJbnRlZ2VyIiwibW9kdWxlX2Z1bmN0aW9uIiwiYWNvcyIsIngiLCJhY29zaCIsImFzaW4iLCJhc2luaCIsImF0YW4iLCJhdGFuMiIsInkiLCJhdGFuaCIsImNicnQiLCJjb3MiLCJjb3NoIiwiZXJmIiwiZXJmYyIsImV4cCIsImZyZXhwIiwiZ2FtbWEiLCJuIiwiPT09IiwiLSIsIjEiLCJoeXBvdCIsImxkZXhwIiwibWFudGlzc2EiLCJleHBvbmVudCIsImxnYW1tYSIsImxvZyIsImJhc2UiLCIvIiwibG9nMTAiLCJsb2cyIiwic2luIiwic2luaCIsInNxcnQiLCJ0YW4iLCJpbmZpbml0ZT8iLCJ0YW5oIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztFQUVBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFBLGlDQUFNLE1BQU4sQ0FBQTtBQUFBLElBQ0Esa0NBQU0sT0FBTixDQURBO0FBQUEsSUFHQSwyQ0FBYyxxQkFBQUMsS0FBQUEsQ0FBVSw2QkFBVkEsQ0FBZCxDQUhBO0FBQUEsSUFLQUMsVUFBSUMsSUFBSkQsY0FBQUEsa0JBQUFBLG1CQUFpQixNQUFELEVBVGxCLEVBU0VBO0FBQUFBLE1BQUFBOztBQUFBQTtBQVRGO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBUzJCLE1BQUEsa0JBVDNCO0FBQUE7QUFXQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFVRSxPQUFBQSxDQUFNLDZCQUFhLEVBQUEsR0FBQSwwQ0FBQSxHQUFBLENBQTJDQyxNQUEzQyxDQUFBLEdBQUEsSUFBbkJELENBQXlFO0FBQ25GOztBQUVBO0FBQ0EsSUF0QkE7QUFTRUYsSUFBQUEsQ0FBQUEsOEJBQUFBLENBTEE7QUFBQSxJQXFCQUksVUFBSUgsSUFBSkcsYUFBQUEscUJBQUFBLFNBQWdCLEtBQWhCQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRTtBQUFBLFFBQUEsV0FBQUMsT0FBQUEsQ0FBTUMsS0FBTkQ7QUFBQSxNQUFBO0FBQUEsUUFDRixzQkFBTyxD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WlAsQ0FBSjtBQUFBLE1BRUEsSUFBQSxRQUFHTyxDQUFBa0MsY0FBQUEsQ0FBQUEsQ0FBSCxDQUFBO0FBQUEsUUFDRSxPQUFPLElBQUEscUJBQUEsUUFEVCxDQUZBO0FBQUEsTUFNQSxPQUFBLG9CQUFBN0MsU0FBQUEsQ0FBYSxPQUFNLG9CQUFBSSxXQUFBQSxDQUFZTyxDQUFaUCxDQUFuQkosQ0FOQTtBQURGNEMsSUFBQUEsQ0FBQUEsMEJBQUFBLENBbmJBO0FBQUEsSUE2YkEsSUFBQSxRQUFPLFFBQVUsU0FBVixrQkFBUCxDQUFBO0FBQUEsSUFBQTtBQUFBO0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkUsSUFBQSxDQTdiQTtBQUFBO0FBNmNBRSxJQUFBQSx3QkFBQUEsZ0JBQUFBLGdCQUFTLENBQVRBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsb0JBQUE5QyxTQUFBQSxDQUFhLFFBQU8sb0JBQUFJLFdBQUFBLENBQVlPLENBQVpQLENBQXBCSjtBQURGOEMsSUFBQUEsQ0FBQUEsMkJBQUFBLENBN2NBO0FBREZoRCxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIwNDgxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jb21wbGV4LnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvbnVtZXJpYydcblxuY2xhc3MgQ29tcGxleCA8IE51bWVyaWNcbiAgZGVmIHNlbGYucmVjdChyZWFsLCBpbWFnID0gMClcbiAgICB1bmxlc3MgTnVtZXJpYyA9PT0gcmVhbCAmJiByZWFsLnJlYWw/ICYmIE51bWVyaWMgPT09IGltYWcgJiYgaW1hZy5yZWFsP1xuICAgICAgcmFpc2UgVHlwZUVycm9yLCAnbm90IGEgcmVhbCdcbiAgICBlbmRcblxuICAgIG5ldyhyZWFsLCBpbWFnKVxuICBlbmRcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgYWxpYXMgcmVjdGFuZ3VsYXIgcmVjdFxuICBlbmRcblxuICBkZWYgc2VsZi5wb2xhcihyLCB0aGV0YSA9IDApXG4gICAgdW5sZXNzIE51bWVyaWMgPT09IHIgJiYgci5yZWFsPyAmJiBOdW1lcmljID09PSB0aGV0YSAmJiB0aGV0YS5yZWFsP1xuICAgICAgcmFpc2UgVHlwZUVycm9yLCAnbm90IGEgcmVhbCdcbiAgICBlbmRcblxuICAgIG5ldyhyICogTWF0aC5jb3ModGhldGEpLCByICogTWF0aC5zaW4odGhldGEpKVxuICBlbmRcblxuICBhdHRyX3JlYWRlciA6cmVhbCwgOmltYWdcblxuICBkZWYgaW5pdGlhbGl6ZShyZWFsLCBpbWFnID0gMClcbiAgICBAcmVhbCA9IHJlYWxcbiAgICBAaW1hZyA9IGltYWdcbiAgZW5kXG5cbiAgZGVmIGNvZXJjZShvdGhlcilcbiAgICBpZiBDb21wbGV4ID09PSBvdGhlclxuICAgICAgW290aGVyLCBzZWxmXVxuICAgIGVsc2lmIE51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICBbQ29tcGxleC5uZXcob3RoZXIsIDApLCBzZWxmXVxuICAgIGVsc2VcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCIje290aGVyLmNsYXNzfSBjYW4ndCBiZSBjb2VyY2VkIGludG8gQ29tcGxleFwiXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBpZiBDb21wbGV4ID09PSBvdGhlclxuICAgICAgQHJlYWwgPT0gb3RoZXIucmVhbCAmJiBAaW1hZyA9PSBvdGhlci5pbWFnXG4gICAgZWxzaWYgTnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIEByZWFsID09IG90aGVyICYmIEBpbWFnID09IDBcbiAgICBlbHNlXG4gICAgICBvdGhlciA9PSBzZWxmXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAtQFxuICAgIENvbXBsZXgoLUByZWFsLCAtQGltYWcpXG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICBDb21wbGV4KEByZWFsICsgb3RoZXIucmVhbCwgQGltYWcgKyBvdGhlci5pbWFnKVxuICAgIGVsc2lmIE51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICBDb21wbGV4KEByZWFsICsgb3RoZXIsIEBpbWFnKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDorLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLShvdGhlcilcbiAgICBpZiBDb21wbGV4ID09PSBvdGhlclxuICAgICAgQ29tcGxleChAcmVhbCAtIG90aGVyLnJlYWwsIEBpbWFnIC0gb3RoZXIuaW1hZylcbiAgICBlbHNpZiBOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgQ29tcGxleChAcmVhbCAtIG90aGVyLCBAaW1hZylcbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6LSwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmICoob3RoZXIpXG4gICAgaWYgQ29tcGxleCA9PT0gb3RoZXJcbiAgICAgIENvbXBsZXgoQHJlYWwgKiBvdGhlci5yZWFsIC0gQGltYWcgKiBvdGhlci5pbWFnLFxuICAgICAgICBAcmVhbCAqIG90aGVyLmltYWcgKyBAaW1hZyAqIG90aGVyLnJlYWwsXG4gICAgICApXG4gICAgZWxzaWYgTnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIENvbXBsZXgoQHJlYWwgKiBvdGhlciwgQGltYWcgKiBvdGhlcilcbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Kiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC8ob3RoZXIpXG4gICAgaWYgQ29tcGxleCA9PT0gb3RoZXJcbiAgICAgIGlmIChOdW1iZXIgPT09IEByZWFsICYmIEByZWFsLm5hbj8pIHx8IChOdW1iZXIgPT09IEBpbWFnICYmIEBpbWFnLm5hbj8pIHx8XG4gICAgICAgICAoTnVtYmVyID09PSBvdGhlci5yZWFsICYmIG90aGVyLnJlYWwubmFuPykgfHwgKE51bWJlciA9PT0gb3RoZXIuaW1hZyAmJiBvdGhlci5pbWFnLm5hbj8pXG4gICAgICAgIENvbXBsZXgubmV3KEZsb2F0OjpOQU4sIEZsb2F0OjpOQU4pXG4gICAgICBlbHNlXG4gICAgICAgIHNlbGYgKiBvdGhlci5jb25qIC8gb3RoZXIuYWJzMlxuICAgICAgZW5kXG4gICAgZWxzaWYgTnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIENvbXBsZXgoQHJlYWwucXVvKG90aGVyKSwgQGltYWcucXVvKG90aGVyKSlcbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Lywgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmICoqKG90aGVyKVxuICAgIGlmIG90aGVyID09IDBcbiAgICAgIHJldHVybiBDb21wbGV4Lm5ldygxLCAwKVxuICAgIGVuZFxuXG4gICAgaWYgQ29tcGxleCA9PT0gb3RoZXJcbiAgICAgIHIsIHRoZXRhID0gcG9sYXJcbiAgICAgIG9yZSAgICAgID0gb3RoZXIucmVhbFxuICAgICAgb2ltICAgICAgPSBvdGhlci5pbWFnXG4gICAgICBuciAgICAgICA9IE1hdGguZXhwKG9yZSAqIE1hdGgubG9nKHIpIC0gb2ltICogdGhldGEpXG4gICAgICBudGhldGEgICA9IHRoZXRhICogb3JlICsgb2ltICogTWF0aC5sb2cocilcblxuICAgICAgQ29tcGxleC5wb2xhcihuciwgbnRoZXRhKVxuICAgIGVsc2lmIEludGVnZXIgPT09IG90aGVyXG4gICAgICBpZiBvdGhlciA+IDBcbiAgICAgICAgeCA9IHNlbGZcbiAgICAgICAgeiA9IHhcbiAgICAgICAgbiA9IG90aGVyIC0gMVxuXG4gICAgICAgIHdoaWxlIG4gIT0gMFxuICAgICAgICAgIGRpdiwgbW9kID0gbi5kaXZtb2QoMilcbiAgICAgICAgICB3aGlsZSBtb2QgPT0gMFxuICAgICAgICAgICAgeCA9IENvbXBsZXgoeC5yZWFsICogeC5yZWFsIC0geC5pbWFnICogeC5pbWFnLCAyICogeC5yZWFsICogeC5pbWFnKVxuICAgICAgICAgICAgbiA9IGRpdlxuICAgICAgICAgICAgZGl2LCBtb2QgPSBuLmRpdm1vZCgyKVxuICAgICAgICAgIGVuZFxuXG4gICAgICAgICAgeiAqPSB4XG4gICAgICAgICAgbiAtPSAxXG4gICAgICAgIGVuZFxuXG4gICAgICAgIHpcbiAgICAgIGVsc2VcbiAgICAgICAgKFJhdGlvbmFsLm5ldygxLCAxKSAvIHNlbGYpKiotb3RoZXJcbiAgICAgIGVuZFxuICAgIGVsc2lmIEZsb2F0ID09PSBvdGhlciB8fCBSYXRpb25hbCA9PT0gb3RoZXJcbiAgICAgIHIsIHRoZXRhID0gcG9sYXJcblxuICAgICAgQ29tcGxleC5wb2xhcihyKipvdGhlciwgdGhldGEgKiBvdGhlcilcbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6KiosIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBhYnNcbiAgICBNYXRoLmh5cG90KEByZWFsLCBAaW1hZylcbiAgZW5kXG5cbiAgZGVmIGFiczJcbiAgICBAcmVhbCAqIEByZWFsICsgQGltYWcgKiBAaW1hZ1xuICBlbmRcblxuICBkZWYgYW5nbGVcbiAgICBNYXRoLmF0YW4yKEBpbWFnLCBAcmVhbClcbiAgZW5kXG5cbiAgYWxpYXMgYXJnIGFuZ2xlXG5cbiAgZGVmIGNvbmpcbiAgICBDb21wbGV4KEByZWFsLCAtQGltYWcpXG4gIGVuZFxuXG4gIGFsaWFzIGNvbmp1Z2F0ZSBjb25qXG5cbiAgZGVmIGRlbm9taW5hdG9yXG4gICAgQHJlYWwuZGVub21pbmF0b3IubGNtKEBpbWFnLmRlbm9taW5hdG9yKVxuICBlbmRcblxuICBhbGlhcyBkaXZpZGUgL1xuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIENvbXBsZXggPT09IG90aGVyICYmIEByZWFsLmNsYXNzID09IEBpbWFnLmNsYXNzICYmIHNlbGYgPT0gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIGZkaXYob3RoZXIpXG4gICAgdW5sZXNzIE51bWVyaWMgPT09IG90aGVyXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwiI3tvdGhlci5jbGFzc30gY2FuJ3QgYmUgY29lcmNlZCBpbnRvIENvbXBsZXhcIlxuICAgIGVuZFxuXG4gICAgc2VsZiAvIG90aGVyXG4gIGVuZFxuXG4gIGRlZiBmaW5pdGU/XG4gICAgQHJlYWwuZmluaXRlPyAmJiBAaW1hZy5maW5pdGU/XG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgXCJDb21wbGV4OiN7QHJlYWx9OiN7QGltYWd9XCJcbiAgZW5kXG5cbiAgYWxpYXMgaW1hZ2luYXJ5IGltYWdcblxuICBkZWYgaW5maW5pdGU/XG4gICAgQHJlYWwuaW5maW5pdGU/IHx8IEBpbWFnLmluZmluaXRlP1xuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiKCN7c2VsZn0pXCJcbiAgZW5kXG5cbiAgYWxpYXMgbWFnbml0dWRlIGFic1xuXG4gIHVuZGVmIG5lZ2F0aXZlP1xuXG4gIGRlZiBudW1lcmF0b3JcbiAgICBkID0gZGVub21pbmF0b3JcblxuICAgIENvbXBsZXgoQHJlYWwubnVtZXJhdG9yICogKGQgLyBAcmVhbC5kZW5vbWluYXRvciksXG4gICAgICBAaW1hZy5udW1lcmF0b3IgKiAoZCAvIEBpbWFnLmRlbm9taW5hdG9yKSxcbiAgICApXG4gIGVuZFxuXG4gIGFsaWFzIHBoYXNlIGFyZ1xuXG4gIGRlZiBwb2xhclxuICAgIFthYnMsIGFyZ11cbiAgZW5kXG5cbiAgdW5kZWYgcG9zaXRpdmU/XG5cbiAgYWxpYXMgcXVvIC9cblxuICBkZWYgcmF0aW9uYWxpemUoZXBzID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZm9yIDAuLjEpXCJ9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIEBpbWFnICE9IDBcbiAgICAgIHJhaXNlIFJhbmdlRXJyb3IsIFwiY2FuJ3QnIGNvbnZlcnQgI3tzZWxmfSBpbnRvIFJhdGlvbmFsXCJcbiAgICBlbmRcblxuICAgIHJlYWwucmF0aW9uYWxpemUoZXBzKVxuICBlbmRcblxuICBkZWYgcmVhbD9cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgcmVjdFxuICAgIFtAcmVhbCwgQGltYWddXG4gIGVuZFxuXG4gIGFsaWFzIHJlY3Rhbmd1bGFyIHJlY3RcblxuICBkZWYgdG9fZlxuICAgIHVubGVzcyBAaW1hZyA9PSAwXG4gICAgICByYWlzZSBSYW5nZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWxmfSBpbnRvIEZsb2F0XCJcbiAgICBlbmRcblxuICAgIEByZWFsLnRvX2ZcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICB1bmxlc3MgQGltYWcgPT0gMFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBJbnRlZ2VyXCJcbiAgICBlbmRcblxuICAgIEByZWFsLnRvX2lcbiAgZW5kXG5cbiAgZGVmIHRvX3JcbiAgICB1bmxlc3MgQGltYWcgPT0gMFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBSYXRpb25hbFwiXG4gICAgZW5kXG5cbiAgICBAcmVhbC50b19yXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgcmVzdWx0ID0gQHJlYWwuaW5zcGVjdFxuXG4gICAgcmVzdWx0ICs9XG4gICAgICBpZiAoTnVtYmVyID09PSBAaW1hZyAmJiBAaW1hZy5uYW4/KSB8fCBAaW1hZy5wb3NpdGl2ZT8gfHwgQGltYWcuemVybz9cbiAgICAgICAgJysnXG4gICAgICBlbHNlXG4gICAgICAgICctJ1xuICAgICAgZW5kXG5cbiAgICByZXN1bHQgKz0gQGltYWcuYWJzLmluc3BlY3RcblxuICAgIGlmIE51bWJlciA9PT0gQGltYWcgJiYgKEBpbWFnLm5hbj8gfHwgQGltYWcuaW5maW5pdGU/KVxuICAgICAgcmVzdWx0ICs9ICcqJ1xuICAgIGVuZFxuXG4gICAgcmVzdWx0ICsgJ2knXG4gIGVuZFxuXG4gIEkgPSBuZXcoMCwgMSlcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBDb21wbGV4KHJlYWwsIGltYWcgPSBuaWwpXG4gICAgaWYgaW1hZ1xuICAgICAgQ29tcGxleC5uZXcocmVhbCwgaW1hZylcbiAgICBlbHNlXG4gICAgICBDb21wbGV4Lm5ldyhyZWFsLCAwKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyBTdHJpbmdcbiAgZGVmIHRvX2NcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBzZWxmLFxuICAgICAgICAgIHJlID0gL1srLV0/W1xcZF9dKyhcXC5bXFxkX10rKT8oZVxcZCspPy8sXG4gICAgICAgICAgbWF0Y2ggPSBzdHIubWF0Y2gocmUpLFxuICAgICAgICAgIHJlYWwsIGltYWcsIGRlbm9taW5hdG9yO1xuXG4gICAgICBmdW5jdGlvbiBpc0Zsb2F0KCkge1xuICAgICAgICByZXR1cm4gcmUudGVzdChzdHIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjdXRGbG9hdCgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlKTtcbiAgICAgICAgdmFyIG51bWJlciA9IG1hdGNoWzBdO1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UobnVtYmVyLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBudW1iZXIucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZXMgYm90aCBmbG9hdHMgYW5kIHJhdGlvbmFsc1xuICAgICAgZnVuY3Rpb24gY3V0TnVtYmVyKCkge1xuICAgICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgICAgdmFyIG51bWVyYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG5cbiAgICAgICAgICBpZiAoc3RyWzBdID09PSAnLycpIHtcbiAgICAgICAgICAgIC8vIHJhdGlvbmFsIHJlYWwgcGFydFxuICAgICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuXG4gICAgICAgICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG4gICAgICAgICAgICAgIHJldHVybiAje1JhdGlvbmFsKGBudW1lcmF0b3JgLCBgZGVub21pbmF0b3JgKX07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyByZXZlcnRpbmcgJy8nXG4gICAgICAgICAgICAgIHN0ciA9ICcvJyArIHN0cjtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bWVyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZmxvYXQgcmVhbCBwYXJ0LCBubyBkZW5vbWluYXRvclxuICAgICAgICAgICAgcmV0dXJuIG51bWVyYXRvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVhbCA9IGN1dE51bWJlcigpO1xuXG4gICAgICBpZiAoIXJlYWwpIHtcbiAgICAgICAgaWYgKHN0clswXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gaSA9PiBDb21wbGV4KDAsIDEpXG4gICAgICAgICAgcmV0dXJuICN7Q29tcGxleCgwLCAxKX07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0clswXSA9PT0gJy0nICYmIHN0clsxXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gLWkgPT4gQ29tcGxleCgwLCAtMSlcbiAgICAgICAgICByZXR1cm4gI3tDb21wbGV4KDAsIC0xKX07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0clswXSA9PT0gJysnICYmIHN0clsxXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gK2kgPT4gQ29tcGxleCgwLCAxKVxuICAgICAgICAgIHJldHVybiAje0NvbXBsZXgoMCwgMSl9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFueXRoaW5nID0+IENvbXBsZXgoMCwgMClcbiAgICAgICAgcmV0dXJuICN7Q29tcGxleCgwLCAwKX07XG4gICAgICB9XG5cbiAgICAgIGltYWcgPSBjdXROdW1iZXIoKTtcbiAgICAgIGlmICghaW1hZykge1xuICAgICAgICBpZiAoc3RyWzBdID09PSAnaScpIHtcbiAgICAgICAgICAvLyAzaSA9PiBDb21wbGV4KDAsIDMpXG4gICAgICAgICAgcmV0dXJuICN7Q29tcGxleCgwLCBgcmVhbGApfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAzID0+IENvbXBsZXgoMywgMClcbiAgICAgICAgICByZXR1cm4gI3tDb21wbGV4KGByZWFsYCwgMCl9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAzKzJpID0+IENvbXBsZXgoMywgMilcbiAgICAgICAgcmV0dXJuICN7Q29tcGxleChgcmVhbGAsIGBpbWFnYCl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJyZWN0Iiwic2VsZiIsIjAiLCIkcmV0X29yXzEiLCIkcmV0X29yXzIiLCIkcmV0X29yXzMiLCI9PT0iLCJyZWFsIiwicmVhbD8iLCJpbWFnIiwicmFpc2UiLCJuZXciLCJwb2xhciIsIiRyZXRfb3JfNCIsIiRyZXRfb3JfNSIsIiRyZXRfb3JfNiIsInIiLCJ0aGV0YSIsIioiLCJjb3MiLCJzaW4iLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJAcmVhbCIsIkBpbWFnIiwiY29lcmNlIiwib3RoZXIiLCIkcmV0X29yXzciLCI9PSIsIiRyZXRfb3JfOCIsIiRyZXRfb3JfOSIsIiRyZXRfb3JfMTAiLCItQCIsIkNvbXBsZXgiLCIrIiwiJHJldF9vcl8xMSIsIl9fY29lcmNlZF9fIiwiLSIsIiRyZXRfb3JfMTIiLCIkcmV0X29yXzEzIiwiLyIsIiRyZXRfb3JfMTQiLCIkcmV0X29yXzE1IiwiJHJldF9vcl8xNiIsIiRyZXRfb3JfMTciLCJuYW4/IiwiJHJldF9vcl8xOCIsIiRyZXRfb3JfMTkiLCIkcmV0X29yXzIwIiwiY29uaiIsImFiczIiLCIkcmV0X29yXzIxIiwicXVvIiwiKioiLCIxIiwib3JlIiwib2ltIiwibnIiLCJleHAiLCJsb2ciLCJudGhldGEiLCI+IiwieCIsInoiLCJuIiwiIT0iLCJkaXZtb2QiLCIyIiwiZGl2IiwibW9kIiwiJHJldF9vcl8yMiIsImFicyIsImh5cG90IiwiYW5nbGUiLCJhdGFuMiIsImRlbm9taW5hdG9yIiwibGNtIiwiZXFsPyIsIiRyZXRfb3JfMjMiLCIkcmV0X29yXzI0IiwiZmRpdiIsImZpbml0ZT8iLCIkcmV0X29yXzI1IiwiaGFzaCIsImluZmluaXRlPyIsIiRyZXRfb3JfMjYiLCJpbnNwZWN0IiwibnVtZXJhdG9yIiwiZCIsImFyZyIsInJhdGlvbmFsaXplIiwiZXBzIiwidG9fZiIsInRvX2kiLCJ0b19yIiwidG9fcyIsInJlc3VsdCIsIiRyZXRfb3JfMjciLCIkcmV0X29yXzI4IiwiJHJldF9vcl8yOSIsInBvc2l0aXZlPyIsInplcm8/IiwiJHJldF9vcl8zMCIsIiRyZXRfb3JfMzEiLCJtb2R1bGUiLCJ0b19jIiwiUmF0aW9uYWwiLCItMSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxpQkFBUkEsQ0FBQTtBQUFBLEVBRUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxJQUFBQyxVQUFJQyxJQUFKRCxXQUFBQSxrQkFBQUEsZ0JBQWMsSUFBRCxFQUFPLElBQXBCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFKRjtBQUlzQixNQUFBO0FBQUEsTUFBQSxTQUFPRSxDQUFQO0FBQUEsTUFBQSxDQUp0QjtBQUFBLE1BS0ksSUFBQSxRQUFPLGFBQUEsSUFBQSxRQUxYQyxDQUFBQSxZQUtXLGFBQUEsSUFBQSxRQUxYQyxDQUFBQSxZQUtXLGFBQUEsSUFBQSxRQUxYQyxD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QUFBQSxDQUFRL0IsR0FBSSxJQUFaK0IsQ0FBbUI7QUFDdEM7QUFDQTtBQUNBLHFCQUFtQkEsU0FBQUEsQ0FBUyxNQUFPL0IsQ0FBaEIrQixDQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxtQkFBaUJBLFNBQUFBLENBQVMsTUFBUSxJQUFqQkEsQ0FBd0I7QUFDekM7QUFDQTtBQTVFRXdFLElBQUFBLENBQUFBLDZCQUFBQSxDQUFBQTtBQURGMUcsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0EvU0E7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMTA5NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmF0aW9uYWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xuXG5jbGFzcyBSYXRpb25hbCA8IE51bWVyaWNcbiAgZGVmIHNlbGYucmVkdWNlKG51bSwgZGVuKVxuICAgIG51bSA9IG51bS50b19pXG4gICAgZGVuID0gZGVuLnRvX2lcblxuICAgIGlmIGRlbiA9PSAwXG4gICAgICByYWlzZSBaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCdcbiAgICBlbHNpZiBkZW4gPCAwXG4gICAgICBudW0gPSAtbnVtXG4gICAgICBkZW4gPSAtZGVuXG4gICAgZWxzaWYgZGVuID09IDFcbiAgICAgIHJldHVybiBuZXcobnVtLCBkZW4pXG4gICAgZW5kXG5cbiAgICBnY2QgPSBudW0uZ2NkKGRlbilcblxuICAgIG5ldyhudW0gLyBnY2QsIGRlbiAvIGdjZClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29udmVydChudW0sIGRlbilcbiAgICBpZiBudW0ubmlsPyB8fCBkZW4ubmlsP1xuICAgICAgcmFpc2UgVHlwZUVycm9yLCAnY2Fubm90IGNvbnZlcnQgbmlsIGludG8gUmF0aW9uYWwnXG4gICAgZW5kXG5cbiAgICBpZiBJbnRlZ2VyID09PSBudW0gJiYgSW50ZWdlciA9PT0gZGVuXG4gICAgICByZXR1cm4gcmVkdWNlKG51bSwgZGVuKVxuICAgIGVuZFxuXG4gICAgaWYgRmxvYXQgPT09IG51bSB8fCBTdHJpbmcgPT09IG51bSB8fCBDb21wbGV4ID09PSBudW1cbiAgICAgIG51bSA9IG51bS50b19yXG4gICAgZW5kXG5cbiAgICBpZiBGbG9hdCA9PT0gZGVuIHx8IFN0cmluZyA9PT0gZGVuIHx8IENvbXBsZXggPT09IGRlblxuICAgICAgZGVuID0gZGVuLnRvX3JcbiAgICBlbmRcblxuICAgIGlmIGRlbi5lcXVhbD8oMSkgJiYgIShJbnRlZ2VyID09PSBudW0pXG4gICAgICBPcGFsLmNvZXJjZV90byEobnVtLCBSYXRpb25hbCwgOnRvX3IpXG4gICAgZWxzaWYgTnVtZXJpYyA9PT0gbnVtICYmIE51bWVyaWMgPT09IGRlblxuICAgICAgbnVtIC8gZGVuXG4gICAgZWxzZVxuICAgICAgcmVkdWNlKG51bSwgZGVuKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShudW0sIGRlbilcbiAgICBAbnVtID0gbnVtXG4gICAgQGRlbiA9IGRlblxuICBlbmRcblxuICBkZWYgbnVtZXJhdG9yXG4gICAgQG51bVxuICBlbmRcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICBAZGVuXG4gIGVuZFxuXG4gIGRlZiBjb2VyY2Uob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIFtvdGhlciwgc2VsZl1cblxuICAgIHdoZW4gSW50ZWdlclxuICAgICAgW290aGVyLnRvX3IsIHNlbGZdXG5cbiAgICB3aGVuIEZsb2F0XG4gICAgICBbb3RoZXIsIHRvX2ZdXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBSYXRpb25hbFxuICAgICAgQG51bSA9PSBvdGhlci5udW1lcmF0b3IgJiYgQGRlbiA9PSBvdGhlci5kZW5vbWluYXRvclxuXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBAbnVtID09IG90aGVyICYmIEBkZW4gPT0gMVxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgdG9fZiA9PSBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgb3RoZXIgPT0gc2VsZlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBAbnVtICogb3RoZXIuZGVub21pbmF0b3IgLSBAZGVuICogb3RoZXIubnVtZXJhdG9yIDw9PiAwXG5cbiAgICB3aGVuIEludGVnZXJcbiAgICAgIEBudW0gLSBAZGVuICogb3RoZXIgPD0+IDBcblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIHRvX2YgPD0+IG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6PD0+LCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKyhvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBSYXRpb25hbFxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLmRlbm9taW5hdG9yICsgQGRlbiAqIG90aGVyLm51bWVyYXRvclxuICAgICAgZGVuID0gQGRlbiAqIG90aGVyLmRlbm9taW5hdG9yXG5cbiAgICAgIFJhdGlvbmFsKG51bSwgZGVuKVxuXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBSYXRpb25hbChAbnVtICsgb3RoZXIgKiBAZGVuLCBAZGVuKVxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgdG9fZiArIG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Kywgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIG51bSA9IEBudW0gKiBvdGhlci5kZW5vbWluYXRvciAtIEBkZW4gKiBvdGhlci5udW1lcmF0b3JcbiAgICAgIGRlbiA9IEBkZW4gKiBvdGhlci5kZW5vbWluYXRvclxuXG4gICAgICBSYXRpb25hbChudW0sIGRlbilcblxuICAgIHdoZW4gSW50ZWdlclxuICAgICAgUmF0aW9uYWwoQG51bSAtIG90aGVyICogQGRlbiwgQGRlbilcblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIHRvX2YgLSBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOi0sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBudW0gPSBAbnVtICogb3RoZXIubnVtZXJhdG9yXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIuZGVub21pbmF0b3JcblxuICAgICAgUmF0aW9uYWwobnVtLCBkZW4pXG5cbiAgICB3aGVuIEludGVnZXJcbiAgICAgIFJhdGlvbmFsKEBudW0gKiBvdGhlciwgQGRlbilcblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIHRvX2YgKiBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOiosIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAvKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBudW0gPSBAbnVtICogb3RoZXIuZGVub21pbmF0b3JcbiAgICAgIGRlbiA9IEBkZW4gKiBvdGhlci5udW1lcmF0b3JcblxuICAgICAgUmF0aW9uYWwobnVtLCBkZW4pXG5cbiAgICB3aGVuIEludGVnZXJcbiAgICAgIGlmIG90aGVyID09IDBcbiAgICAgICAgdG9fZiAvIDAuMFxuICAgICAgZWxzZVxuICAgICAgICBSYXRpb25hbChAbnVtLCBAZGVuICogb3RoZXIpXG4gICAgICBlbmRcblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIHRvX2YgLyBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOi8sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKihvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBpZiBzZWxmID09IDAgJiYgb3RoZXIgPCAwXG4gICAgICAgIEZsb2F0OjpJTkZJTklUWVxuICAgICAgZWxzaWYgb3RoZXIgPiAwXG4gICAgICAgIFJhdGlvbmFsKEBudW0qKm90aGVyLCBAZGVuKipvdGhlcilcbiAgICAgIGVsc2lmIG90aGVyIDwgMFxuICAgICAgICBSYXRpb25hbChAZGVuKiotb3RoZXIsIEBudW0qKi1vdGhlcilcbiAgICAgIGVsc2VcbiAgICAgICAgUmF0aW9uYWwoMSwgMSlcbiAgICAgIGVuZFxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgdG9fZioqb3RoZXJcblxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIGlmIG90aGVyID09IDBcbiAgICAgICAgUmF0aW9uYWwoMSwgMSlcbiAgICAgIGVsc2lmIG90aGVyLmRlbm9taW5hdG9yID09IDFcbiAgICAgICAgaWYgb3RoZXIgPCAwXG4gICAgICAgICAgUmF0aW9uYWwoQGRlbioqb3RoZXIubnVtZXJhdG9yLmFicywgQG51bSoqb3RoZXIubnVtZXJhdG9yLmFicylcbiAgICAgICAgZWxzZVxuICAgICAgICAgIFJhdGlvbmFsKEBudW0qKm90aGVyLm51bWVyYXRvciwgQGRlbioqb3RoZXIubnVtZXJhdG9yKVxuICAgICAgICBlbmRcbiAgICAgIGVsc2lmIHNlbGYgPT0gMCAmJiBvdGhlciA8IDBcbiAgICAgICAgcmFpc2UgWmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnXG4gICAgICBlbHNlXG4gICAgICAgIHRvX2YqKm90aGVyXG4gICAgICBlbmRcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqKiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGFic1xuICAgIFJhdGlvbmFsKEBudW0uYWJzLCBAZGVuLmFicylcbiAgZW5kXG5cbiAgZGVmIGNlaWwocHJlY2lzaW9uID0gMClcbiAgICBpZiBwcmVjaXNpb24gPT0gMFxuICAgICAgKC0oLUBudW0gLyBAZGVuKSkuY2VpbFxuICAgIGVsc2VcbiAgICAgIHdpdGhfcHJlY2lzaW9uKDpjZWlsLCBwcmVjaXNpb24pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGFsaWFzIGRpdmlkZSAvXG5cbiAgZGVmIGZsb29yKHByZWNpc2lvbiA9IDApXG4gICAgaWYgcHJlY2lzaW9uID09IDBcbiAgICAgICgtKC1AbnVtIC8gQGRlbikpLmZsb29yXG4gICAgZWxzZVxuICAgICAgd2l0aF9wcmVjaXNpb24oOmZsb29yLCBwcmVjaXNpb24pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgXCJSYXRpb25hbDoje0BudW19OiN7QGRlbn1cIlxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiKCN7c2VsZn0pXCJcbiAgZW5kXG5cbiAgYWxpYXMgcXVvIC9cblxuICBkZWYgcmF0aW9uYWxpemUoZXBzID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZm9yIDAuLjEpXCJ9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZXBzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBlID0gI3tlcHMuYWJzfSxcbiAgICAgICAgICBhID0gI3tzZWxmIC0gYGVgfSxcbiAgICAgICAgICBiID0gI3tzZWxmICsgYGVgfTtcblxuICAgICAgdmFyIHAwID0gMCxcbiAgICAgICAgICBwMSA9IDEsXG4gICAgICAgICAgcTAgPSAxLFxuICAgICAgICAgIHExID0gMCxcbiAgICAgICAgICBwMiwgcTI7XG5cbiAgICAgIHZhciBjLCBrLCB0O1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjID0gI3tgYWAuY2VpbH07XG5cbiAgICAgICAgaWYgKCN7YGNgIDw9IGBiYH0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGsgID0gYyAtIDE7XG4gICAgICAgIHAyID0gayAqIHAxICsgcDA7XG4gICAgICAgIHEyID0gayAqIHExICsgcTA7XG4gICAgICAgIHQgID0gI3sxIC8gKGBiYCAtIGBrYCl9O1xuICAgICAgICBiICA9ICN7MSAvIChgYWAgLSBga2ApfTtcbiAgICAgICAgYSAgPSB0O1xuXG4gICAgICAgIHAwID0gcDE7XG4gICAgICAgIHEwID0gcTE7XG4gICAgICAgIHAxID0gcDI7XG4gICAgICAgIHExID0gcTI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje1JhdGlvbmFsKGBjICogcDEgKyBwMGAsIGBjICogcTEgKyBxMGApfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByb3VuZChwcmVjaXNpb24gPSAwKVxuICAgIHJldHVybiB3aXRoX3ByZWNpc2lvbig6cm91bmQsIHByZWNpc2lvbikgdW5sZXNzIHByZWNpc2lvbiA9PSAwXG4gICAgcmV0dXJuIDAgaWYgQG51bSA9PSAwXG4gICAgcmV0dXJuIEBudW0gaWYgQGRlbiA9PSAxXG5cbiAgICBudW0gPSBAbnVtLmFicyAqIDIgKyBAZGVuXG4gICAgZGVuID0gQGRlbiAqIDJcblxuICAgIGFwcHJveCA9IChudW0gLyBkZW4pLnRydW5jYXRlXG5cbiAgICBpZiBAbnVtIDwgMFxuICAgICAgLWFwcHJveFxuICAgIGVsc2VcbiAgICAgIGFwcHJveFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgIEBudW0gLyBAZGVuXG4gIGVuZFxuXG4gIGRlZiB0b19pXG4gICAgdHJ1bmNhdGVcbiAgZW5kXG5cbiAgZGVmIHRvX3JcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgXCIje0BudW19LyN7QGRlbn1cIlxuICBlbmRcblxuICBkZWYgdHJ1bmNhdGUocHJlY2lzaW9uID0gMClcbiAgICBpZiBwcmVjaXNpb24gPT0gMFxuICAgICAgQG51bSA8IDAgPyBjZWlsIDogZmxvb3JcbiAgICBlbHNlXG4gICAgICB3aXRoX3ByZWNpc2lvbig6dHJ1bmNhdGUsIHByZWNpc2lvbilcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHdpdGhfcHJlY2lzaW9uKG1ldGhvZCwgcHJlY2lzaW9uKVxuICAgIHJhaXNlIFR5cGVFcnJvciwgJ25vdCBhbiBJbnRlZ2VyJyB1bmxlc3MgSW50ZWdlciA9PT0gcHJlY2lzaW9uXG5cbiAgICBwID0gMTAqKnByZWNpc2lvblxuICAgIHMgPSBzZWxmICogcFxuXG4gICAgaWYgcHJlY2lzaW9uIDwgMVxuICAgICAgKHMuc2VuZChtZXRob2QpIC8gcCkudG9faVxuICAgIGVsc2VcbiAgICAgIFJhdGlvbmFsKHMuc2VuZChtZXRob2QpLCBwKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBSYXRpb25hbChudW1lcmF0b3IsIGRlbm9taW5hdG9yID0gMSlcbiAgICBSYXRpb25hbC5jb252ZXJ0KG51bWVyYXRvciwgZGVub21pbmF0b3IpXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFN0cmluZ1xuICBkZWYgdG9fclxuICAgICV4e1xuICAgICAgdmFyIHN0ciA9IHNlbGYudHJpbUxlZnQoKSxcbiAgICAgICAgICByZSA9IC9eWystXT9bXFxkX10rKFxcLltcXGRfXSspPy8sXG4gICAgICAgICAgbWF0Y2ggPSBzdHIubWF0Y2gocmUpLFxuICAgICAgICAgIG51bWVyYXRvciwgZGVub21pbmF0b3I7XG5cbiAgICAgIGZ1bmN0aW9uIGlzRmxvYXQoKSB7XG4gICAgICAgIHJldHVybiByZS50ZXN0KHN0cik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGN1dEZsb2F0KCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2gocmUpO1xuICAgICAgICB2YXIgbnVtYmVyID0gbWF0Y2hbMF07XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZShudW1iZXIubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG51bWJlci5yZXBsYWNlKC9fL2csICcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRmxvYXQoKSkge1xuICAgICAgICBudW1lcmF0b3IgPSBwYXJzZUZsb2F0KGN1dEZsb2F0KCkpO1xuXG4gICAgICAgIGlmIChzdHJbMF0gPT09ICcvJykge1xuICAgICAgICAgIC8vIHJhdGlvbmFsIHJlYWwgcGFydFxuICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcblxuICAgICAgICAgIGlmIChpc0Zsb2F0KCkpIHtcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gcGFyc2VGbG9hdChjdXRGbG9hdCgpKTtcbiAgICAgICAgICAgIHJldHVybiAje1JhdGlvbmFsKGBudW1lcmF0b3JgLCBgZGVub21pbmF0b3JgKX07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAje1JhdGlvbmFsKGBudW1lcmF0b3JgLCAxKX07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAje1JhdGlvbmFsKGBudW1lcmF0b3JgLCAxKX07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAje1JhdGlvbmFsKDAsIDEpfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwicmVkdWNlIiwic2VsZiIsIm51bSIsInRvX2kiLCJkZW4iLCI9PSIsIjAiLCJyYWlzZSIsIjwiLCItQCIsIjEiLCJuZXciLCJnY2QiLCIvIiwiY29udmVydCIsIiRyZXRfb3JfMSIsIm5pbD8iLCIkcmV0X29yXzIiLCI9PT0iLCIkcmV0X29yXzMiLCIkcmV0X29yXzQiLCJ0b19yIiwiJHJldF9vcl81IiwiJHJldF9vcl82IiwiJHJldF9vcl83IiwiZXF1YWw/IiwiISIsImNvZXJjZV90byEiLCIkcmV0X29yXzgiLCJpbml0aWFsaXplIiwiQG51bSIsIkBkZW4iLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsImNvZXJjZSIsIm90aGVyIiwidG9fZiIsIiRyZXRfb3JfOSIsIiRyZXRfb3JfMTAiLCI8PT4iLCItIiwiKiIsIl9fY29lcmNlZF9fIiwiKyIsIlJhdGlvbmFsIiwiKioiLCIkcmV0X29yXzExIiwiPiIsImFicyIsIiRyZXRfb3JfMTIiLCJjZWlsIiwicHJlY2lzaW9uIiwid2l0aF9wcmVjaXNpb24iLCJmbG9vciIsImhhc2giLCJpbnNwZWN0IiwicmF0aW9uYWxpemUiLCJlcHMiLCI8PSIsInJvdW5kIiwiMiIsImFwcHJveCIsInRydW5jYXRlIiwidG9fcyIsInAiLCIxMCIsInMiLCJzZW5kIiwibWV0aG9kIiwibW9kdWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQUFBO0FBQUEsRUFFQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUNFLElBQUFDLFVBQUlDLElBQUpELGFBQUFBLHFCQUFBQSxrQkFBZ0IsR0FBRCxFQUFNLEdBQXJCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBRSxNQUFNQSxHQUFBQyxNQUFBQSxDQUFBQSxDQUFOO0FBQUEsTUFDQUMsTUFBTUEsR0FBQUQsTUFBQUEsQ0FBQUEsQ0FETjtBQUFBLE1BR0EsSUFBR0MsR0FBQUMsT0FBQUEsQ0FBT0MsQ0FBUEQsQ0FBSDtBQUFBLFlBQ0VFLE9BQUFBLENBQU0sbUNBQW1CLGNBQXpCQTtBQURGLE1BQUEsT0FFQSxJQUFBLFFBQU1DLE9BQUFKLEdBQUFJLEVBQU1GLENBQU5FLENBQU4sQ0FBQTtBQUFBO0FBQ0UsUUFBQU4sTUFBT0EsR0FBRE8sT0FBQUEsQ0FBQUEsQ0FBTjtBQUFBLFFBQ0FMLE1BQU9BLEdBQURLLE9BQUFBLENBQUFBLENBRE47QUFERixNQUFBLE9BR0EsSUFBTUwsR0FBQUMsT0FBQUEsQ0FBT0ssQ0FBUEwsQ0FBTjtBQUFBLFFBQ0UsV0FBT00sS0FBQUEsQ0FBSVQsS0FBS0UsR0FBVE8sQ0FEVCxDQVJBO0FBQUEsTUFZQUMsTUFBTVYsR0FBQVUsS0FBQUEsQ0FBUVIsR0FBUlEsQ0FaTjtB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QTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFwV0Y7QUFvVzBCLE1BQUE7QUFBQSxNQUFBLGdCQUFjbEMsQ0FBZDtBQUFBLE1BQUEsQ0FwVzFCO0FBQUEsTUFxV0ksT0FBQSx3QkFBQUksU0FBQUEsQ0FBaUJrQixXQUFXQyxXQUE1Qm5CLENBcldKO0FBb1dFOEIsSUFBQUEsQ0FBQUEsa0NBQUFBO0FBREZ5QixFQUFBQSxHQUFBQSxXQUFBQSxXQWxXQTtBQUFBLEVBd1dBLE9BQUF0RTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0UsT0FBQXNCLENBQUFBLHdCQUFBQSxrQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFxQnVCLFVBQUFBLENBQVUsV0FBYSxXQUF2QkEsQ0FBcUM7QUFDMUQ7QUFDQSx1QkFBcUJBLFVBQUFBLENBQVUsV0FBWWxDLENBQXRCa0MsQ0FBeUI7QUFDOUM7QUFDQTtBQUNBLHFCQUFtQkEsVUFBQUEsQ0FBVSxXQUFZbEMsQ0FBdEJrQyxDQUF5QjtBQUM1QztBQUNBO0FBQ0EsbUJBQWlCQSxVQUFBQSxDQUFTdEMsR0FBR0ksQ0FBWmtDLENBQWU7QUFDaEM7QUFDQTtBQXJDRXZCLElBQUFBLENBQUFBLDZCQUFBQSxDQUFBQTtBQURGdEIsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0F4V0E7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMTYwMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvdGltZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHNsaWNlXG5cbnJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcblxuY2xhc3MgVGltZSA8IGBEYXRlYFxuICBpbmNsdWRlIENvbXBhcmFibGVcblxuICAleHtcbiAgICB2YXIgZGF5c19vZl93ZWVrID0gI3sld1tTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheSBTdW5kYXldfSxcbiAgICAgICAgc2hvcnRfZGF5cyAgID0gI3sld1tTdW4gTW9uIFR1ZSBXZWQgVGh1IEZyaSBTYXRdfSxcbiAgICAgICAgc2hvcnRfbW9udGhzID0gI3sld1tKYW4gRmViIE1hciBBcHIgTWF5IEp1biBKdWwgQXVnIFNlcCBPY3QgTm92IERlY119LFxuICAgICAgICBsb25nX21vbnRocyAgPSAjeyV3W0phbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJdfTtcbiAgfVxuXG4gIGRlZiBzZWxmLmF0KHNlY29uZHMsIGZyYWMgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAoI3tUaW1lID09PSBzZWNvbmRzfSkge1xuICAgICAgICBpZiAoZnJhYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCBUaW1lIGludG8gYW4gZXhhY3QgbnVtYmVyXCJ9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbmV3IERhdGUoc2Vjb25kcy5nZXRUaW1lKCkpO1xuICAgICAgICByZXN1bHQuaXNfdXRjID0gc2Vjb25kcy5pc191dGM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2Vjb25kcy4kJGlzX251bWJlcikge1xuICAgICAgICBzZWNvbmRzID0gI3tPcGFsLmNvZXJjZV90byEoc2Vjb25kcywgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZnJhYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShzZWNvbmRzICogMTAwMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZnJhYy4kJGlzX251bWJlcikge1xuICAgICAgICBmcmFjID0gI3tPcGFsLmNvZXJjZV90byEoZnJhYywgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERhdGUoc2Vjb25kcyAqIDEwMDAgKyAoZnJhYyAvIDEwMDApKTtcbiAgICB9XG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKSB7XG4gICAgICBpZiAoeWVhci4kJGlzX3N0cmluZykge1xuICAgICAgICB5ZWFyID0gcGFyc2VJbnQoeWVhciwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWVhciA9ICN7T3BhbC5jb2VyY2VfdG8hKGB5ZWFyYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAobW9udGggPT09IG5pbCkge1xuICAgICAgICBtb250aCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKCFtb250aC4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoI3tgbW9udGhgLnJlc3BvbmRfdG8/KDp0b19zdHIpfSkge1xuICAgICAgICAgIG1vbnRoID0gI3tgbW9udGhgLnRvX3N0cn07XG4gICAgICAgICAgc3dpdGNoIChtb250aC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSAnamFuJzogbW9udGggPSAgMTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZmViJzogbW9udGggPSAgMjsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWFyJzogbW9udGggPSAgMzsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYXByJzogbW9udGggPSAgNDsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWF5JzogbW9udGggPSAgNTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnanVuJzogbW9udGggPSAgNjsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnanVsJzogbW9udGggPSAgNzsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYXVnJzogbW9udGggPSAgODsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2VwJzogbW9udGggPSAgOTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnb2N0JzogbW9udGggPSAxMDsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbm92JzogbW9udGggPSAxMTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGVjJzogbW9udGggPSAxMjsgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDogbW9udGggPSAje2Btb250aGAudG9faX07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vbnRoID0gI3tPcGFsLmNvZXJjZV90byEoYG1vbnRoYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtb250aCA8IDEgfHwgbW9udGggPiAxMikge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibW9udGggb3V0IG9mIHJhbmdlOiAje2Btb250aGB9XCJ9XG4gICAgICB9XG4gICAgICBtb250aCA9IG1vbnRoIC0gMTtcblxuICAgICAgaWYgKGRheSA9PT0gbmlsKSB7XG4gICAgICAgIGRheSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGRheS4kJGlzX3N0cmluZykge1xuICAgICAgICBkYXkgPSBwYXJzZUludChkYXksIDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRheSA9ICN7T3BhbC5jb2VyY2VfdG8hKGBkYXlgLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXkgPCAxIHx8IGRheSA+IDMxKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJkYXkgb3V0IG9mIHJhbmdlOiAje2BkYXlgfVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoaG91ciA9PT0gbmlsKSB7XG4gICAgICAgIGhvdXIgPSAwO1xuICAgICAgfSBlbHNlIGlmIChob3VyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGhvdXIgPSBwYXJzZUludChob3VyLCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3VyID0gI3tPcGFsLmNvZXJjZV90byEoYGhvdXJgLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG5cbiAgICAgIGlmIChob3VyIDwgMCB8fCBob3VyID4gMjQpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImhvdXIgb3V0IG9mIHJhbmdlOiAje2Bob3VyYH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiA9PT0gbmlsKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKG1pbi4kJGlzX3N0cmluZykge1xuICAgICAgICBtaW4gPSBwYXJzZUludChtaW4sIDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pbiA9ICN7T3BhbC5jb2VyY2VfdG8hKGBtaW5gLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW4gPCAwIHx8IG1pbiA+IDU5KSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJtaW4gb3V0IG9mIHJhbmdlOiAje2BtaW5gfVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VjID09PSBuaWwpIHtcbiAgICAgICAgc2VjID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoIXNlYy4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoc2VjLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgc2VjID0gcGFyc2VJbnQoc2VjLCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VjID0gI3tPcGFsLmNvZXJjZV90byEoYHNlY2AsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VjIDwgMCB8fCBzZWMgPiA2MCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwic2VjIG91dCBvZiByYW5nZTogI3tgc2VjYH1cIn1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlY107XG4gICAgfVxuICB9XG5cbiAgZGVmIHNlbGYubmV3KHllYXIgPSB1bmRlZmluZWQsIG1vbnRoID0gbmlsLCBkYXkgPSBuaWwsIGhvdXIgPSBuaWwsIG1pbiA9IG5pbCwgc2VjID0gbmlsLCB1dGNfb2Zmc2V0ID0gbmlsKVxuICAgICV4e1xuICAgICAgdmFyIGFyZ3MsIHJlc3VsdDtcblxuICAgICAgaWYgKHllYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0Y19vZmZzZXQgIT09IG5pbCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdPcGFsIGRvZXMgbm90IHN1cHBvcnQgZXhwbGljaXRseSBzcGVjaWZ5aW5nIFVUQyBvZmZzZXQgZm9yIFRpbWUnfVxuICAgICAgfVxuXG4gICAgICBhcmdzICA9IHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKTtcbiAgICAgIHllYXIgID0gYXJnc1swXTtcbiAgICAgIG1vbnRoID0gYXJnc1sxXTtcbiAgICAgIGRheSAgID0gYXJnc1syXTtcbiAgICAgIGhvdXIgID0gYXJnc1szXTtcbiAgICAgIG1pbiAgID0gYXJnc1s0XTtcbiAgICAgIHNlYyAgID0gYXJnc1s1XTtcblxuICAgICAgcmVzdWx0ID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCAwLCBzZWMgKiAxMDAwKTtcbiAgICAgIGlmICh5ZWFyIDwgMTAwKSB7XG4gICAgICAgIHJlc3VsdC5zZXRGdWxsWWVhcih5ZWFyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5sb2NhbCh5ZWFyLCBtb250aCA9IG5pbCwgZGF5ID0gbmlsLCBob3VyID0gbmlsLCBtaW4gPSBuaWwsIHNlYyA9IG5pbCwgbWlsbGlzZWNvbmQgPSBuaWwsIF9kdW1teTEgPSBuaWwsIF9kdW1teTIgPSBuaWwsIF9kdW1teTMgPSBuaWwpXG4gICAgIyBUaGUgX2R1bW15IGFyZ3MgYXJlIHRoZXJlIG9ubHkgYmVjYXVzZSB0aGUgTVJJIHZlcnNpb24gYWNjZXB0cyB1cCB0byAxMCBhcmd1bWVudHNcbiAgICAleHtcbiAgICAgIHZhciBhcmdzLCByZXN1bHQ7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxMCkge1xuICAgICAgICBhcmdzICA9ICRzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHllYXIgID0gYXJnc1s1XTtcbiAgICAgICAgbW9udGggPSBhcmdzWzRdO1xuICAgICAgICBkYXkgICA9IGFyZ3NbM107XG4gICAgICAgIGhvdXIgID0gYXJnc1syXTtcbiAgICAgICAgbWluICAgPSBhcmdzWzFdO1xuICAgICAgICBzZWMgICA9IGFyZ3NbMF07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgID0gdGltZV9wYXJhbXMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpO1xuICAgICAgeWVhciAgPSBhcmdzWzBdO1xuICAgICAgbW9udGggPSBhcmdzWzFdO1xuICAgICAgZGF5ICAgPSBhcmdzWzJdO1xuICAgICAgaG91ciAgPSBhcmdzWzNdO1xuICAgICAgbWluICAgPSBhcmdzWzRdO1xuICAgICAgc2VjICAgPSBhcmdzWzVdO1xuXG4gICAgICByZXN1bHQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIDAsIHNlYyAqIDEwMDApO1xuICAgICAgaWYgKHllYXIgPCAxMDApIHtcbiAgICAgICAgcmVzdWx0LnNldEZ1bGxZZWFyKHllYXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmdtKHllYXIsIG1vbnRoID0gbmlsLCBkYXkgPSBuaWwsIGhvdXIgPSBuaWwsIG1pbiA9IG5pbCwgc2VjID0gbmlsLCBtaWxsaXNlY29uZCA9IG5pbCwgX2R1bW15MSA9IG5pbCwgX2R1bW15MiA9IG5pbCwgX2R1bW15MyA9IG5pbClcbiAgICAjIFRoZSBfZHVtbXkgYXJncyBhcmUgdGhlcmUgb25seSBiZWNhdXNlIHRoZSBNUkkgdmVyc2lvbiBhY2NlcHRzIHVwIHRvIDEwIGFyZ3VtZW50c1xuICAgICV4e1xuICAgICAgdmFyIGFyZ3MsIHJlc3VsdDtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEwKSB7XG4gICAgICAgIGFyZ3MgID0gJHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgeWVhciAgPSBhcmdzWzVdO1xuICAgICAgICBtb250aCA9IGFyZ3NbNF07XG4gICAgICAgIGRheSAgID0gYXJnc1szXTtcbiAgICAgICAgaG91ciAgPSBhcmdzWzJdO1xuICAgICAgICBtaW4gICA9IGFyZ3NbMV07XG4gICAgICAgIHNlYyAgID0gYXJnc1swXTtcbiAgICAgIH1cblxuICAgICAgYXJncyAgPSB0aW1lX3BhcmFtcyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYyk7XG4gICAgICB5ZWFyICA9IGFyZ3NbMF07XG4gICAgICBtb250aCA9IGFyZ3NbMV07XG4gICAgICBkYXkgICA9IGFyZ3NbMl07XG4gICAgICBob3VyICA9IGFyZ3NbM107XG4gICAgICBtaW4gICA9IGFyZ3NbNF07XG4gICAgICBzZWMgICA9IGFyZ3NbNV07XG5cbiAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgMCwgc2VjICogMTAwMCkpO1xuICAgICAgaWYgKHllYXIgPCAxMDApIHtcbiAgICAgICAgcmVzdWx0LnNldFVUQ0Z1bGxZZWFyKHllYXIpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmlzX3V0YyA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGFsaWFzIG1rdGltZSBsb2NhbFxuICAgIGFsaWFzIHV0YyBnbVxuICBlbmRcblxuICBkZWYgc2VsZi5ub3dcbiAgICBuZXdcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgaWYgVGltZSA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ3RpbWUgKyB0aW1lPydcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCFvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICBvdGhlciA9ICN7T3BhbC5jb2VyY2VfdG8hKG90aGVyLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkgKyAob3RoZXIgKiAxMDAwKSk7XG4gICAgICByZXN1bHQuaXNfdXRjID0gc2VsZi5pc191dGM7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgaWYgVGltZSA9PT0gb3RoZXJcbiAgICAgIHJldHVybiBgKHNlbGYuZ2V0VGltZSgpIC0gb3RoZXIuZ2V0VGltZSgpKSAvIDEwMDBgXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgb3RoZXIgPSAje09wYWwuY29lcmNlX3RvIShvdGhlciwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpIC0gKG90aGVyICogMTAwMCkpO1xuICAgICAgcmVzdWx0LmlzX3V0YyA9IHNlbGYuaXNfdXRjO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgaWYgVGltZSA9PT0gb3RoZXJcbiAgICAgIHRvX2YgPD0+IG90aGVyLnRvX2ZcbiAgICBlbHNlXG4gICAgICByID0gb3RoZXIgPD0+IHNlbGZcbiAgICAgIGlmIHIubmlsP1xuICAgICAgICBuaWxcbiAgICAgIGVsc2lmIHIgPiAwXG4gICAgICAgIC0xXG4gICAgICBlbHNpZiByIDwgMFxuICAgICAgICAxXG4gICAgICBlbHNlXG4gICAgICAgIDBcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgVGltZSA9PT0gb3RoZXIgJiYgYCN7dG9fZn0gPT09ICN7b3RoZXIudG9fZn1gXG4gIGVuZFxuXG4gIGRlZiBhc2N0aW1lXG4gICAgc3RyZnRpbWUgJyVhICViICVlICVIOiVNOiVTICVZJ1xuICBlbmRcblxuICBhbGlhcyBjdGltZSBhc2N0aW1lXG5cbiAgZGVmIGRheVxuICAgIGBzZWxmLmlzX3V0YyA/IHNlbGYuZ2V0VVRDRGF0ZSgpIDogc2VsZi5nZXREYXRlKClgXG4gIGVuZFxuXG4gIGRlZiB5ZGF5XG4gICAgIyBodHRwOi8vamF2YXNjcmlwdC5hYm91dC5jb20vbGlicmFyeS9ibGRheXllYXIuaHRtXG4gICAgIyBhbHNvIHNlZSBtb21lbnQuanMgaW1wbGVtZW50YXRpb246IGh0dHA6Ly9naXQuaW8vdkNLTkVcblxuICAgIHN0YXJ0X29mX3llYXIgPSBUaW1lLm5ldyh5ZWFyKS50b19pXG4gICAgc3RhcnRfb2ZfZGF5ICA9IFRpbWUubmV3KHllYXIsIG1vbnRoLCBkYXkpLnRvX2lcbiAgICBvbmVfZGF5ICAgICAgID0gODZfNDAwXG5cbiAgICAoKHN0YXJ0X29mX2RheSAtIHN0YXJ0X29mX3llYXIpIC8gb25lX2RheSkucm91bmQgKyAxXG4gIGVuZFxuXG4gIGRlZiBpc2RzdFxuICAgICV4e1xuICAgICAgdmFyIGphbiA9IG5ldyBEYXRlKHNlbGYuZ2V0RnVsbFllYXIoKSwgMCwgMSksXG4gICAgICAgICAganVsID0gbmV3IERhdGUoc2VsZi5nZXRGdWxsWWVhcigpLCA2LCAxKTtcbiAgICAgIHJldHVybiBzZWxmLmdldFRpbWV6b25lT2Zmc2V0KCkgPCBNYXRoLm1heChqYW4uZ2V0VGltZXpvbmVPZmZzZXQoKSwganVsLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZHN0PyBpc2RzdFxuXG4gIGRlZiBkdXBcbiAgICBjb3B5ID0gYG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpKWBcblxuICAgIGNvcHkuY29weV9pbnN0YW5jZV92YXJpYWJsZXMoc2VsZilcbiAgICBjb3B5LmluaXRpYWxpemVfZHVwKHNlbGYpXG5cbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIG90aGVyLmlzX2E/KFRpbWUpICYmIChzZWxmIDw9PiBvdGhlcikuemVybz9cbiAgZW5kXG5cbiAgZGVmIGZyaWRheT9cbiAgICBgI3t3ZGF5fSA9PSA1YFxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIGAnVGltZTonICsgc2VsZi5nZXRUaW1lKClgXG4gIGVuZFxuXG4gIGRlZiBob3VyXG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENIb3VycygpIDogc2VsZi5nZXRIb3VycygpYFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIGlmIHV0Yz9cbiAgICAgIHN0cmZ0aW1lICclWS0lbS0lZCAlSDolTTolUyBVVEMnXG4gICAgZWxzZVxuICAgICAgc3RyZnRpbWUgJyVZLSVtLSVkICVIOiVNOiVTICV6J1xuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyBtZGF5IGRheVxuXG4gIGRlZiBtaW5cbiAgICBgc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ01pbnV0ZXMoKSA6IHNlbGYuZ2V0TWludXRlcygpYFxuICBlbmRcblxuICBkZWYgbW9uXG4gICAgYChzZWxmLmlzX3V0YyA/IHNlbGYuZ2V0VVRDTW9udGgoKSA6IHNlbGYuZ2V0TW9udGgoKSkgKyAxYFxuICBlbmRcblxuICBkZWYgbW9uZGF5P1xuICAgIGAje3dkYXl9ID09IDFgXG4gIGVuZFxuXG4gIGFsaWFzIG1vbnRoIG1vblxuXG4gIGRlZiBzYXR1cmRheT9cbiAgICBgI3t3ZGF5fSA9PSA2YFxuICBlbmRcblxuICBkZWYgc2VjXG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENTZWNvbmRzKCkgOiBzZWxmLmdldFNlY29uZHMoKWBcbiAgZW5kXG5cbiAgZGVmIHN1Y2NcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSArIDEwMDApO1xuICAgICAgcmVzdWx0LmlzX3V0YyA9IHNlbGYuaXNfdXRjO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB1c2VjXG4gICAgYHNlbGYuZ2V0TWlsbGlzZWNvbmRzKCkgKiAxMDAwYFxuICBlbmRcblxuICBkZWYgem9uZVxuICAgICV4e1xuICAgICAgdmFyIHN0cmluZyA9IHNlbGYudG9TdHJpbmcoKSxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignKCcpID09IC0xKSB7XG4gICAgICAgIHJlc3VsdCA9IHN0cmluZy5tYXRjaCgvW0EtWl17Myw0fS8pWzBdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHN0cmluZy5tYXRjaCgvXFwoKC4rKVxcKSg/Olxcc3wkKS8pWzFdXG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQgPT0gXCJHTVRcIiAmJiAvKEdNVFxcVypcXGR7NH0pLy50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIFJlZ0V4cC4kMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdldGdtXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkpO1xuICAgICAgcmVzdWx0LmlzX3V0YyA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZ2V0dXRjIGdldGdtXG5cbiAgZGVmIGdtdGltZVxuICAgICV4e1xuICAgICAgc2VsZi5pc191dGMgPSB0cnVlO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyB1dGMgZ210aW1lXG5cbiAgZGVmIGdtdD9cbiAgICBgc2VsZi5pc191dGMgPT09IHRydWVgXG4gIGVuZFxuXG4gIGRlZiBnbXRfb2Zmc2V0XG4gICAgYHNlbGYuaXNfdXRjID8gMCA6IC1zZWxmLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MGBcbiAgZW5kXG5cbiAgZGVmIHN0cmZ0aW1lKGZvcm1hdClcbiAgICAleHtcbiAgICAgIHJldHVybiBmb3JtYXQucmVwbGFjZSgvJShbXFwtXyNeMF0qOnswLDJ9KShcXGQrKT8oW0VPXSopKC4pL2csIGZ1bmN0aW9uKGZ1bGwsIGZsYWdzLCB3aWR0aCwgXywgY29udikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIixcbiAgICAgICAgICAgIHplcm8gICA9IGZsYWdzLmluZGV4T2YoJzAnKSAhPT0gLTEsXG4gICAgICAgICAgICBwYWQgICAgPSBmbGFncy5pbmRleE9mKCctJykgPT09IC0xLFxuICAgICAgICAgICAgYmxhbmsgID0gZmxhZ3MuaW5kZXhPZignXycpICE9PSAtMSxcbiAgICAgICAgICAgIHVwY2FzZSA9IGZsYWdzLmluZGV4T2YoJ14nKSAhPT0gLTEsXG4gICAgICAgICAgICBpbnZlcnQgPSBmbGFncy5pbmRleE9mKCcjJykgIT09IC0xLFxuICAgICAgICAgICAgY29sb25zID0gKGZsYWdzLm1hdGNoKCc6JykgfHwgW10pLmxlbmd0aDtcblxuICAgICAgICB3aWR0aCA9IHBhcnNlSW50KHdpZHRoLCAxMCk7XG5cbiAgICAgICAgaWYgKHplcm8gJiYgYmxhbmspIHtcbiAgICAgICAgICBpZiAoZmxhZ3MuaW5kZXhPZignMCcpIDwgZmxhZ3MuaW5kZXhPZignXycpKSB7XG4gICAgICAgICAgICB6ZXJvID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxhbmsgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGNvbnYpIHtcbiAgICAgICAgICBjYXNlICdZJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3llYXJ9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gTWF0aC5yb3VuZCgje3llYXJ9IC8gMTAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICgje3llYXJ9ICUgMTAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7bW9ufTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQic6XG4gICAgICAgICAgICByZXN1bHQgKz0gbG9uZ19tb250aHNbI3ttb259IC0gMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgYmxhbmsgICA9ICF6ZXJvO1xuICAgICAgICAgICAgcmVzdWx0ICs9IHNob3J0X21vbnRoc1sje21vbn0gLSAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rXG4gICAgICAgICAgICByZXN1bHQgKz0gI3tkYXl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgIGJsYW5rICAgPSAhemVyb1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaic6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgd2lkdGggICA9IGlzTmFOKHdpZHRoKSA/IDMgOiB3aWR0aDtcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3lkYXl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tob3VyfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnayc6XG4gICAgICAgICAgICBibGFuayAgID0gIXplcm87XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tob3VyfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnSSc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICgje2hvdXJ9ICUgMTIgfHwgMTIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgIGJsYW5rICAgPSAhemVybztcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3tob3VyfSAlIDEyIHx8IDEyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gPj0gMTIgPyBcInBtXCIgOiBcImFtXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3tob3VyfSA+PSAxMiA/IFwiUE1cIiA6IFwiQU1cIik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAje21pbn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3NlY31cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgd2lkdGggICA9IGlzTmFOKHdpZHRoKSA/IDMgOiB3aWR0aDtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzZWxmLmdldE1pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAgIHdpZHRoICAgPSBpc05hTih3aWR0aCkgPyA5IDogd2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tgc2VsZi5nZXRNaWxsaXNlY29uZHMoKS50b1N0cmluZygpYC5yanVzdCgzLCAnMCcpfTtcbiAgICAgICAgICAgIHJlc3VsdCAgPSAje2ByZXN1bHRgLmxqdXN0KGB3aWR0aGAsICcwJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgIHZhciBvZmZzZXQgID0gc2VsZi5nZXRUaW1lem9uZU9mZnNldCgpLFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPSBNYXRoLmZsb29yKE1hdGguYWJzKG9mZnNldCkgLyA2MCksXG4gICAgICAgICAgICAgICAgbWludXRlcyA9IE1hdGguYWJzKG9mZnNldCkgJSA2MDtcblxuICAgICAgICAgICAgcmVzdWx0ICs9IG9mZnNldCA8IDAgPyBcIitcIiA6IFwiLVwiO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGhvdXJzIDwgMTAgPyBcIjBcIiA6IFwiXCI7XG4gICAgICAgICAgICByZXN1bHQgKz0gaG91cnM7XG5cbiAgICAgICAgICAgIGlmIChjb2xvbnMgPiAwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBcIjpcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ICs9IG1pbnV0ZXMgPCAxMCA/IFwiMFwiIDogXCJcIjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBtaW51dGVzO1xuXG4gICAgICAgICAgICBpZiAoY29sb25zID4gMSkge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gXCI6MDBcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3pvbmV9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBkYXlzX29mX3dlZWtbI3t3ZGF5fV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgcmVzdWx0ICs9IHNob3J0X2RheXNbI3t3ZGF5fV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICgje3dkYXl9ICsgMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7d2RheX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7Y3dlZWtfY3llYXJbMF0udG9fcy5yanVzdCgyLCAnMCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tjd2Vla19jeWVhclsxXX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7Y3dlZWtfY3llYXJbMV1bLTIuLi0xXX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7dG9faX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFx0XCI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJVwiO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclYSAlYiAlZSAlVCAlWScpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJW0vJWQvJXknKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0YnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVZLSVtLSVkJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclZS0lXmItJTRZJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclSTolTTolUyAlcCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJUg6JU0nKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVIOiVNOiVTJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBjYXNlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW52ZXJ0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1tBLVpdLywgZnVuY3Rpb24oYykgeyBjLnRvTG93ZXJDYXNlKCkgfSkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2UoL1thLXpdLywgZnVuY3Rpb24oYykgeyBjLnRvVXBwZXJDYXNlKCkgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFkICYmICh6ZXJvIHx8IGJsYW5rKSkge1xuICAgICAgICAgIHJlc3VsdCA9ICN7YHJlc3VsdGAucmp1c3QoYGlzTmFOKHdpZHRoKSA/IDIgOiB3aWR0aGAsIGBibGFuayA/IFwiIFwiIDogXCIwXCJgKX07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3VuZGF5P1xuICAgIGAje3dkYXl9ID09IDBgXG4gIGVuZFxuXG4gIGRlZiB0aHVyc2RheT9cbiAgICBgI3t3ZGF5fSA9PSA0YFxuICBlbmRcblxuICBkZWYgdG9fYVxuICAgIFtzZWMsIG1pbiwgaG91ciwgZGF5LCBtb250aCwgeWVhciwgd2RheSwgeWRheSwgaXNkc3QsIHpvbmVdXG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgYHNlbGYuZ2V0VGltZSgpIC8gMTAwMGBcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICBgcGFyc2VJbnQoc2VsZi5nZXRUaW1lKCkgLyAxMDAwLCAxMClgXG4gIGVuZFxuXG4gIGFsaWFzIHRvX3MgaW5zcGVjdFxuXG4gIGRlZiB0dWVzZGF5P1xuICAgIGAje3dkYXl9ID09IDJgXG4gIGVuZFxuXG4gIGFsaWFzIHR2X3NlYyB0b19pXG5cbiAgYWxpYXMgdHZfdXNlYyB1c2VjXG5cbiAgYWxpYXMgdXRjPyBnbXQ/XG5cbiAgYWxpYXMgZ210b2ZmIGdtdF9vZmZzZXRcbiAgYWxpYXMgdXRjX29mZnNldCBnbXRfb2Zmc2V0XG5cbiAgZGVmIHdkYXlcbiAgICBgc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ0RheSgpIDogc2VsZi5nZXREYXkoKWBcbiAgZW5kXG5cbiAgZGVmIHdlZG5lc2RheT9cbiAgICBgI3t3ZGF5fSA9PSAzYFxuICBlbmRcblxuICBkZWYgeWVhclxuICAgIGBzZWxmLmlzX3V0YyA/IHNlbGYuZ2V0VVRDRnVsbFllYXIoKSA6IHNlbGYuZ2V0RnVsbFllYXIoKWBcbiAgZW5kXG5cbiAgZGVmIGN3ZWVrX2N5ZWFyXG4gICAgamFuMDEgPSBUaW1lLm5ldyh5ZWFyLCAxLCAxKVxuICAgIGphbjAxX3dkYXkgPSBqYW4wMS53ZGF5XG4gICAgZmlyc3RfbW9uZGF5ID0gMFxuICAgIHllYXIgPSBzZWxmLnllYXJcbiAgICBpZiBqYW4wMV93ZGF5IDw9IDQgJiYgamFuMDFfd2RheSAhPSAwXG4gICAgICAjIEphbiAwMSBpcyBpbiB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhclxuICAgICAgb2Zmc2V0ID0gamFuMDFfd2RheSAtIDFcbiAgICBlbHNlXG4gICAgICAjIEphbiAwMSBpcyBpbiB0aGUgbGFzdCB3ZWVrIG9mIHRoZSBwcmV2aW91cyB5ZWFyXG4gICAgICBvZmZzZXQgPSBqYW4wMV93ZGF5IC0gNyAtIDFcbiAgICAgIG9mZnNldCA9IC0xIGlmIG9mZnNldCA9PSAtOCAjIEFkanVzdCBpZiBKYW4gMDEgaXMgYSBTdW5kYXlcbiAgICBlbmRcblxuICAgIHdlZWsgPSAoKHlkYXkgKyBvZmZzZXQpIC8gNy4wMCkuY2VpbFxuXG4gICAgaWYgd2VlayA8PSAwXG4gICAgICAjIEdldCB0aGUgbGFzdCB3ZWVrIG9mIHRoZSBwcmV2aW91cyB5ZWFyXG4gICAgICByZXR1cm4gVGltZS5uZXcoc2VsZi55ZWFyIC0gMSwgMTIsIDMxKS5jd2Vla19jeWVhclxuICAgIGVsc2lmIHdlZWsgPT0gNTNcbiAgICAgICMgRmluZCBvdXQgd2hldGhlciB0aGlzIGlzIGFjdHVhbGx5IHdlZWsgNTMgb3IgYWxyZWFkeSB3ZWVrIDAxIG9mIHRoZSBmb2xsb3dpbmcgeWVhclxuICAgICAgZGVjMzEgPSBUaW1lLm5ldyhzZWxmLnllYXIsIDEyLCAzMSlcbiAgICAgIGRlYzMxX3dkYXkgPSBkZWMzMS53ZGF5XG4gICAgICBpZiBkZWMzMV93ZGF5IDw9IDMgJiYgZGVjMzFfd2RheSAhPSAwXG4gICAgICAgIHdlZWsgPSAxXG4gICAgICAgIHllYXIgKz0gMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBbd2VlaywgeWVhcl1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJpbmNsdWRlIiwiYXQiLCJzZWxmIiwiPT09Iiwic2Vjb25kcyIsInJhaXNlIiwiY29lcmNlX3RvISIsImZyYWMiLCJyZXNwb25kX3RvPyIsInRvX3N0ciIsInRvX2kiLCJuZXciLCJsb2NhbCIsImdtIiwibm93IiwiKyIsIm90aGVyIiwiLSIsIjw9PiIsInRvX2YiLCJyIiwibmlsPyIsIj4iLCIwIiwiLTEiLCI8IiwiMSIsIj09IiwiJHJldF9vcl8xIiwiYXNjdGltZSIsInN0cmZ0aW1lIiwiZGF5IiwieWRheSIsInN0YXJ0X29mX3llYXIiLCJ5ZWFyIiwic3RhcnRfb2ZfZGF5IiwibW9udGgiLCJvbmVfZGF5IiwiODY0MDAiLCIvIiwicm91bmQiLCJpc2RzdCIsImR1cCIsImNvcHkiLCJjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyIsImluaXRpYWxpemVfZHVwIiwiZXFsPyIsIiRyZXRfb3JfMiIsImlzX2E/IiwiemVybz8iLCJmcmlkYXk/Iiwid2RheSIsImhhc2giLCJob3VyIiwiaW5zcGVjdCIsInV0Yz8iLCJtaW4iLCJtb24iLCJtb25kYXk/Iiwic2F0dXJkYXk/Iiwic2VjIiwic3VjYyIsInVzZWMiLCJ6b25lIiwiZ2V0Z20iLCJnbXRpbWUiLCJnbXQ/IiwiZ210X29mZnNldCIsInJqdXN0IiwiMyIsImxqdXN0IiwiY3dlZWtfY3llYXIiLCJbXSIsInRvX3MiLCIyIiwiLTIiLCJzdW5kYXk/IiwidGh1cnNkYXk/IiwidG9fYSIsInR1ZXNkYXk/Iiwid2VkbmVzZGF5PyIsImphbjAxIiwiamFuMDFfd2RheSIsImZpcnN0X21vbmRheSIsIiRyZXRfb3JfMyIsIjw9IiwiNCIsIiE9Iiwib2Zmc2V0IiwiNyIsIi04Iiwid2VlayIsImNlaWwiLCIxMiIsIjMxIiwiNTMiLCJkZWMzMSIsImRlYzMxX3dkYXkiLCIkcmV0X29yXzQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLE1BQUFBLFNBQUFBLENBQVEsb0JBQVJBLENBQUE7QUFBQSxFQUVBLE9BQUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxTQUFBQSxDQUFRLDBCQUFSQSxDQUFBO0FBQUE7QUFHRix1QkFBeUIsQ0FBRyxRQUFILEVBQVUsUUFBVixFQUFpQixTQUFqQixFQUF5QixXQUF6QixFQUFtQyxVQUFuQyxFQUE0QyxRQUE1QyxFQUFtRCxVQUFuRCxFQUE0RCxRQUE1RCxDQUFvRTtBQUM3Rix1QkFBeUIsQ0FBRyxLQUFILEVBQU8sS0FBUCxFQUFXLEtBQVgsRUFBZSxLQUFmLEVBQW1CLEtBQW5CLEVBQXVCLEtBQXZCLEVBQTJCLEtBQTNCLENBQWdDO0FBQ3pELHVCQUF5QixDQUFHLEtBQUgsRUFBTyxLQUFQLEVBQVcsS0FBWCxFQUFlLEtBQWYsRUFBbUIsS0FBbkIsRUFBdUIsS0FBdkIsRUFBMkIsS0FBM0IsRUFBK0IsS0FBL0IsRUFBbUMsS0FBbkMsRUFBdUMsS0FBdkMsRUFBMkMsS0FBM0MsRUFBK0MsS0FBL0MsQ0FBb0Q7QUFD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LEdBQUFBLFdBQUFBLEVBQWMsSUFBZEEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyNTU4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9zdHJ1Y3QucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG5jbGFzcyBTdHJ1Y3RcbiAgaW5jbHVkZSBFbnVtZXJhYmxlXG5cbiAgZGVmIHNlbGYubmV3KGNvbnN0X25hbWUsICphcmdzLCBrZXl3b3JkX2luaXQ6IGZhbHNlLCAmYmxvY2spXG4gICAgaWYgY29uc3RfbmFtZVxuICAgICAgYmVnaW5cbiAgICAgICAgY29uc3RfbmFtZSA9IE9wYWwuY29uc3RfbmFtZSEoY29uc3RfbmFtZSlcbiAgICAgIHJlc2N1ZSBUeXBlRXJyb3IsIE5hbWVFcnJvclxuICAgICAgICBhcmdzLnVuc2hpZnQoY29uc3RfbmFtZSlcbiAgICAgICAgY29uc3RfbmFtZSA9IG5pbFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBhcmdzLm1hcCBkbyB8YXJnfFxuICAgICAgT3BhbC5jb2VyY2VfdG8hKGFyZywgU3RyaW5nLCA6dG9fc3RyKVxuICAgIGVuZFxuXG4gICAga2xhc3MgPSBDbGFzcy5uZXcoc2VsZikgZG9cbiAgICAgIGFyZ3MuZWFjaCB7IHxhcmd8IGRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlKGFyZykgfVxuXG4gICAgICBjbGFzcyA8PCBzZWxmXG4gICAgICAgIGRlZiBuZXcoKmFyZ3MpXG4gICAgICAgICAgaW5zdGFuY2UgPSBhbGxvY2F0ZVxuICAgICAgICAgIGAje2luc3RhbmNlfS4kJGRhdGEgPSB7fWBcbiAgICAgICAgICBpbnN0YW5jZS5pbml0aWFsaXplKCphcmdzKVxuICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGFsaWFzX21ldGhvZCA6W10sIDpuZXdcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAga2xhc3MubW9kdWxlX2V2YWwoJmJsb2NrKSBpZiBibG9ja1xuICAgIGBrbGFzcy4kJGtleXdvcmRfaW5pdCA9IGtleXdvcmRfaW5pdGBcblxuICAgIGlmIGNvbnN0X25hbWVcbiAgICAgIFN0cnVjdC5jb25zdF9zZXQoY29uc3RfbmFtZSwga2xhc3MpXG4gICAgZW5kXG5cbiAgICBrbGFzc1xuICBlbmRcblxuICBkZWYgc2VsZi5kZWZpbmVfc3RydWN0X2F0dHJpYnV0ZShuYW1lKVxuICAgIGlmIHNlbGYgPT0gU3RydWN0XG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAneW91IGNhbm5vdCBkZWZpbmUgYXR0cmlidXRlcyB0byB0aGUgU3RydWN0IGNsYXNzJ1xuICAgIGVuZFxuXG4gICAgbWVtYmVycyA8PCBuYW1lXG5cbiAgICBkZWZpbmVfbWV0aG9kIG5hbWUgZG9cbiAgICAgIGBzZWxmLiQkZGF0YVtuYW1lXWBcbiAgICBlbmRcblxuICAgIGRlZmluZV9tZXRob2QgXCIje25hbWV9PVwiIGRvIHx2YWx1ZXxcbiAgICAgIGBzZWxmLiQkZGF0YVtuYW1lXSA9IHZhbHVlYFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5tZW1iZXJzXG4gICAgaWYgc2VsZiA9PSBTdHJ1Y3RcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0aGUgU3RydWN0IGNsYXNzIGhhcyBubyBtZW1iZXJzJ1xuICAgIGVuZFxuXG4gICAgQG1lbWJlcnMgfHw9IFtdXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmluaGVyaXRlZChrbGFzcylcbiAgICBtZW1iZXJzID0gQG1lbWJlcnNcblxuICAgIGtsYXNzLmluc3RhbmNlX2V2YWwgZG9cbiAgICAgIEBtZW1iZXJzID0gbWVtYmVyc1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgqYXJncylcbiAgICBpZiBgI3tzZWxmLmNsYXNzfS4kJGtleXdvcmRfaW5pdGBcbiAgICAgIGt3YXJncyA9IGFyZ3MubGFzdCB8fCB7fVxuXG4gICAgICBpZiBhcmdzLmxlbmd0aCA+IDEgfHwgYChhcmdzLmxlbmd0aCA9PT0gMSAmJiAha3dhcmdzLiQkaXNfaGFzaClgXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoZ2l2ZW4gI3thcmdzLmxlbmd0aH0sIGV4cGVjdGVkIDApXCJcbiAgICAgIGVuZFxuXG4gICAgICBleHRyYSA9IGt3YXJncy5rZXlzIC0gc2VsZi5jbGFzcy5tZW1iZXJzXG4gICAgICBpZiBleHRyYS5hbnk/XG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwidW5rbm93biBrZXl3b3JkczogI3tleHRyYS5qb2luKCcsICcpfVwiXG4gICAgICBlbmRcblxuICAgICAgc2VsZi5jbGFzcy5tZW1iZXJzLmVhY2ggZG8gfG5hbWV8XG4gICAgICAgIHNlbGZbbmFtZV0gPSBrd2FyZ3NbbmFtZV1cbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGlmIGFyZ3MubGVuZ3RoID4gc2VsZi5jbGFzcy5tZW1iZXJzLmxlbmd0aFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnc3RydWN0IHNpemUgZGlmZmVycydcbiAgICAgIGVuZFxuXG4gICAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaF93aXRoX2luZGV4IGRvIHxuYW1lLCBpbmRleHxcbiAgICAgICAgc2VsZltuYW1lXSA9IGFyZ3NbaW5kZXhdXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY29weShmcm9tKVxuICAgICV4e1xuICAgICAgc2VsZi4kJGRhdGEgPSB7fVxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tLiQkZGF0YSksIGksIG1heCwgbmFtZTtcbiAgICAgIGZvciAoaSA9IDAsIG1heCA9IGtleXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgbmFtZSA9IGtleXNbaV07XG4gICAgICAgIHNlbGYuJCRkYXRhW25hbWVdID0gZnJvbS4kJGRhdGFbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWVtYmVyc1xuICAgIHNlbGYuY2xhc3MubWVtYmVyc1xuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIEhhc2gubmV3KGBzZWxmLiQkZGF0YWApLmhhc2hcbiAgZW5kXG5cbiAgZGVmIFtdKG5hbWUpXG4gICAgaWYgSW50ZWdlciA9PT0gbmFtZVxuICAgICAgcmFpc2UgSW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gc21hbGwgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPCAtc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcbiAgICAgIHJhaXNlIEluZGV4RXJyb3IsIFwib2Zmc2V0ICN7bmFtZX0gdG9vIGxhcmdlIGZvciBzdHJ1Y3Qoc2l6ZToje3NlbGYuY2xhc3MubWVtYmVycy5zaXplfSlcIiBpZiBuYW1lID49IHNlbGYuY2xhc3MubWVtYmVycy5zaXplXG5cbiAgICAgIG5hbWUgPSBzZWxmLmNsYXNzLm1lbWJlcnNbbmFtZV1cbiAgICBlbHNpZiBTdHJpbmcgPT09IG5hbWVcbiAgICAgICV4e1xuICAgICAgICBpZighc2VsZi4kJGRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAje3JhaXNlIE5hbWVFcnJvci5uZXcoXCJubyBtZW1iZXIgJyN7bmFtZX0nIGluIHN0cnVjdFwiLCBuYW1lKX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mICN7bmFtZS5jbGFzc30gaW50byBJbnRlZ2VyXCJcbiAgICBlbmRcblxuICAgIG5hbWUgPSBPcGFsLmNvZXJjZV90byEobmFtZSwgU3RyaW5nLCA6dG9fc3RyKVxuICAgIGBzZWxmLiQkZGF0YVtuYW1lXWBcbiAgZW5kXG5cbiAgZGVmIFtdPShuYW1lLCB2YWx1ZSlcbiAgICBpZiBJbnRlZ2VyID09PSBuYW1lXG4gICAgICByYWlzZSBJbmRleEVycm9yLCBcIm9mZnNldCAje25hbWV9IHRvbyBzbWFsbCBmb3Igc3RydWN0KHNpemU6I3tzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZX0pXCIgaWYgbmFtZSA8IC1zZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZVxuICAgICAgcmFpc2UgSW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gbGFyZ2UgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPj0gc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcblxuICAgICAgbmFtZSA9IHNlbGYuY2xhc3MubWVtYmVyc1tuYW1lXVxuICAgIGVsc2lmIFN0cmluZyA9PT0gbmFtZVxuICAgICAgcmFpc2UgTmFtZUVycm9yLm5ldyhcIm5vIG1lbWJlciAnI3tuYW1lfScgaW4gc3RydWN0XCIsIG5hbWUpIHVubGVzcyBzZWxmLmNsYXNzLm1lbWJlcnMuaW5jbHVkZT8obmFtZS50b19zeW0pXG4gICAgZWxzZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgI3tuYW1lLmNsYXNzfSBpbnRvIEludGVnZXJcIlxuICAgIGVuZFxuXG4gICAgbmFtZSA9IE9wYWwuY29lcmNlX3RvIShuYW1lLCBTdHJpbmcsIDp0b19zdHIpXG4gICAgYHNlbGYuJCRkYXRhW25hbWVdID0gdmFsdWVgXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIG90aGVyLmluc3RhbmNlX29mPyhzZWxmLmNsYXNzKVxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVjdXJzZWQxID0ge30sIHJlY3Vyc2VkMiA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBfZXFlcShzdHJ1Y3QsIG90aGVyKSB7XG4gICAgICAgIHZhciBrZXksIGEsIGI7XG5cbiAgICAgICAgcmVjdXJzZWQxWyN7YHN0cnVjdGAuX19pZF9ffV0gPSB0cnVlO1xuICAgICAgICByZWN1cnNlZDJbI3tgb3RoZXJgLl9faWRfX31dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGtleSBpbiBzdHJ1Y3QuJCRkYXRhKSB7XG4gICAgICAgICAgYSA9IHN0cnVjdC4kJGRhdGFba2V5XTtcbiAgICAgICAgICBiID0gb3RoZXIuJCRkYXRhW2tleV07XG5cbiAgICAgICAgICBpZiAoI3tTdHJ1Y3QgPT09IGBhYH0pIHtcbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQxLmhhc093blByb3BlcnR5KCN7YGFgLl9faWRfX30pIHx8ICFyZWN1cnNlZDIuaGFzT3duUHJvcGVydHkoI3tgYmAuX19pZF9ffSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFfZXFlcShhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgID09IGBiYH0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxZXEoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBvdGhlci5pbnN0YW5jZV9vZj8oc2VsZi5jbGFzcylcblxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkMSA9IHt9LCByZWN1cnNlZDIgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxZXEoc3RydWN0LCBvdGhlcikge1xuICAgICAgICB2YXIga2V5LCBhLCBiO1xuXG4gICAgICAgIHJlY3Vyc2VkMVsje2BzdHJ1Y3RgLl9faWRfX31dID0gdHJ1ZTtcbiAgICAgICAgcmVjdXJzZWQyWyN7YG90aGVyYC5fX2lkX199XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gc3RydWN0LiQkZGF0YSkge1xuICAgICAgICAgIGEgPSBzdHJ1Y3QuJCRkYXRhW2tleV07XG4gICAgICAgICAgYiA9IG90aGVyLiQkZGF0YVtrZXldO1xuXG4gICAgICAgICAgaWYgKCN7U3RydWN0ID09PSBgYWB9KSB7XG4gICAgICAgICAgICBpZiAoIXJlY3Vyc2VkMS5oYXNPd25Qcm9wZXJ0eSgje2BhYC5fX2lkX199KSB8fCAhcmVjdXJzZWQyLmhhc093blByb3BlcnR5KCN7YGJgLl9faWRfX30pKSB7XG4gICAgICAgICAgICAgIGlmICghX2VxZXEoYSwgYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEje2BhYC5lcWw/KGBiYCl9KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9lcWVxKHNlbGYsIG90aGVyKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaCB7IHxuYW1lfCB5aWVsZCBzZWxmW25hbWVdIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX3BhaXJcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfcGFpcikgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzLmVhY2ggeyB8bmFtZXwgeWllbGQgW25hbWUsIHNlbGZbbmFtZV1dIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMubGVuZ3RoXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5cbiAgZGVmIHRvX2FcbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMubWFwIHsgfG5hbWV8IHNlbGZbbmFtZV0gfVxuICBlbmRcblxuICBhbGlhcyB2YWx1ZXMgdG9fYVxuXG4gIGRlZiBpbnNwZWN0XG4gICAgcmVzdWx0ID0gJyM8c3RydWN0ICdcblxuICAgIGlmIFN0cnVjdCA9PT0gc2VsZiAmJiBzZWxmLmNsYXNzLm5hbWVcbiAgICAgIHJlc3VsdCArPSBcIiN7c2VsZi5jbGFzc30gXCJcbiAgICBlbmRcblxuICAgIHJlc3VsdCArPSBlYWNoX3BhaXIubWFwIGRvIHxuYW1lLCB2YWx1ZXxcbiAgICAgIFwiI3tuYW1lfT0je3ZhbHVlLmluc3BlY3R9XCJcbiAgICBlbmQuam9pbiAnLCAnXG5cbiAgICByZXN1bHQgKz0gJz4nXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG5cbiAgZGVmIHRvX2goJmJsb2NrKVxuICAgIHJldHVybiBtYXAoJmJsb2NrKS50b19oKCphcmdzKSBpZiBibG9ja19naXZlbj9cblxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoX3dpdGhfb2JqZWN0KHt9KSB7IHxuYW1lLCBofCBoW25hbWVdID0gc2VsZltuYW1lXSB9XG4gIGVuZFxuXG4gIGRlZiB2YWx1ZXNfYXQoKmFyZ3MpXG4gICAgYXJncyA9IGFyZ3MubWFwIHsgfGFyZ3wgYGFyZy4kJGlzX3JhbmdlID8gI3thcmcudG9fYX0gOiBhcmdgIH0uZmxhdHRlblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFhcmdzW2ldLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje2BhcmdzW2ldYC5jbGFzc30gaW50byBJbnRlZ2VyXCJ9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goI3tzZWxmW2BhcmdzW2ldYF19KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGlnKGtleSwgKmtleXMpXG4gICAgaXRlbSA9IGlmIGBrZXkuJCRpc19zdHJpbmcgJiYgc2VsZi4kJGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KWBcbiAgICAgICAgICAgICBgc2VsZi4kJGRhdGFba2V5XSB8fCBuaWxgXG4gICAgICAgICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoaXRlbSA9PT0gbmlsIHx8IGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVubGVzcyBpdGVtLnJlc3BvbmRfdG8/KDpkaWcpXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwiI3tpdGVtLmNsYXNzfSBkb2VzIG5vdCBoYXZlICNkaWcgbWV0aG9kXCJcbiAgICBlbmRcblxuICAgIGl0ZW0uZGlnKCprZXlzKVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsImluY2x1ZGUiLCJuZXciLCJzZWxmIiwiY29uc3RfbmFtZSIsImNvbnN0X25hbWUhIiwiYXJncyIsInVuc2hpZnQiLCJtYXAiLCJjb2VyY2VfdG8hIiwiYXJnIiwia2xhc3MiLCJlYWNoIiwiZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUiLCJpbnN0YW5jZSIsImFsbG9jYXRlIiwiaW5pdGlhbGl6ZSIsImFsaWFzX21ldGhvZCIsImJsb2NrIiwibW9kdWxlX2V2YWwiLCJjb25zdF9zZXQiLCI9PSIsInJhaXNlIiwibWVtYmVycyIsIjw8IiwibmFtZSIsImRlZmluZV9tZXRob2QiLCJAbWVtYmVycyIsIiRyZXRfb3JfMSIsImluaGVyaXRlZCIsImluc3RhbmNlX2V2YWwiLCJrd2FyZ3MiLCIkcmV0X29yXzIiLCJsYXN0IiwiJHJldF9vcl8zIiwiPiIsImxlbmd0aCIsIjEiLCJleHRyYSIsIi0iLCJrZXlzIiwiYW55PyIsImpvaW4iLCIkd3JpdGVyIiwiW10iLCJbXT0iLCJlYWNoX3dpdGhfaW5kZXgiLCJpbmRleCIsImluaXRpYWxpemVfY29weSIsImhhc2giLCI9PT0iLCI8Iiwic2l6ZSIsIi1AIiwiPj0iLCJpbmNsdWRlPyIsInRvX3N5bSIsIm90aGVyIiwiaW5zdGFuY2Vfb2Y/IiwiX19pZF9fIiwiZXFsPyIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiZWFjaF9wYWlyIiwidG9fYSIsImluc3BlY3QiLCJyZXN1bHQiLCIkcmV0X29yXzQiLCIrIiwidmFsdWUiLCJ0b19oIiwiZWFjaF93aXRoX29iamVjdCIsImgiLCJ2YWx1ZXNfYXQiLCJmbGF0dGVuIiwiZGlnIiwiaXRlbSIsInJlc3BvbmRfdG8/Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLG9CQUFSQSxDQUFBO0FBQUEsRUFFQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUMsU0FBQUEsQ0FBUSwwQkFBUkEsQ0FBQTtBQUFBLElBRUFDLFVBQUlDLElBQUpELFVBQUFBLGdCQUFBQSxTQUFhLFVBQUQsRUFOZCxFQU1jLEVBTmQsRUFNRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBTkY7QUFNdUQsTUFBQSxvQ0FOdkQ7QUFBQTtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQUFBLE1BQUEseUNBQUE7QUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBLENBQUE7QUFBQTtBQU0yQixNQUFBLGtCQU4zQjtBQUFBO0FBTWtDLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxpQkFBYztBQUFkLE1BQUEsQ0FObEM7QUFBQSxNQU9JLElBQUEsUUFBR0UsVUFBSCxDQUFBO0FBQUE7QUFDRSxRQUNFO0FBQUEsVUFBQUEsYUFBYSxvQkFBQUMsZ0JBQUFBLENBQWlCRCxV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b0JBQXNCbkIsSUFBQXlDLE9BQUFBLENBQU0sT0FBTkEsQ0FBZ0I7QUFDdEM7QUFDQTtBQUNBLElBcFNBO0FBeVJFNkIsSUFBQUEsQ0FBQUEsbUNBQUFBLENBclJBO0FBQUEsSUFtU0EsT0FBQUUsQ0FBQUEsdUJBQUFBLGlCQUFBQSxlQUFRLEdBQUQsRUF2U1QsRUF1U0VBO0FBQUFBLE1BQUFBOztBQUFBQTtBQXZTRjtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQXVTZSxNQUFBLGtCQXZTZjtBQUFBLE1Bd1NJQyxPQUFPLGFBQUEsSUFBQSxRQUFJLGtEQUFKLENBQUE7QUFBQSxRQUNFLE9BQUMsdUJBQUQ7QUFERixNQUFBO0FBQUE7QUFBQSxNQUFBLENBQUEsa0JBeFNYO0FBQUE7QUE2U0E7QUFDQTtBQUNBO0FBQ0EsSUFoVEE7QUFBQSxNQWtUSSxJQUFBLFFBQU9BLElBQUFDLGdCQUFBQSxDQUFpQixLQUFqQkEsQ0FBUCxDQUFBO0FBQUEsTUFBQTtBQUFBLFlBQ0V2RCxPQUFBQSxDQUFNLDJCQUFXLEVBQUEsR0FBQSxDQUFHc0QsSUFBQTVFLE9BQUFBLENBQUFBLENBQUgsQ0FBQSxHQUFBLDRCQUFqQnNCO0FBREYsTUFBQSxDQWxUSjtBQUFBLE1Bc1RJLE9BQUFxRCxNQUFBQyxJQUFBRCxPQUFBQSxFQUFTLFVBQUNuQyxJQUFELENBQVRtQyxDQXRUSjtBQXVTRUEsSUFBQUEsQ0FBQUEsNkJBQUFBLENBQUFBLGVBblNBO0FBREYzRSxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQUZBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjMwOTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL21haW4ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiZGVmIHNlbGYudG9fc1xuICAnbWFpbidcbmVuZFxuXG5kZWYgc2VsZi5pbmNsdWRlKG1vZClcbiAgT2JqZWN0LmluY2x1ZGUgbW9kXG5lbmRcbiJdLCJuYW1lcyI6WyJ0b19zIiwic2VsZiIsImluY2x1ZGUiLCJtb2QiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLEVBQUFBLFVBQUlDLElBQUpELFdBQUFBLFVBQUFBLGdCQUFBQTtBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRSxPQUFBO0FBREZBLEVBQUFBLENBQUFBLHFCQUFBQSxDQUFBO0FBQUEsRUFJQSxPQUFBRSxDQUFBQSxVQUFJRCxJQUFKQyxjQUFBQSxhQUFBQSxtQkFBaUIsR0FBakJBO0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUEsc0JBQUFBLFNBQUFBLENBQWVDLEdBQWZEO0FBREZBLEVBQUFBLENBQUFBLHdCQUFBQSxDQUFBQSxtQkFKQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzMTEyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9kaXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgRGlyXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgY2hkaXIoZGlyKVxuICAgICAgcHJldl9jd2QgPSBgT3BhbC5jdXJyZW50X2RpcmBcbiAgICAgIGBPcGFsLmN1cnJlbnRfZGlyID0gI3tkaXJ9YFxuICAgICAgeWllbGRcbiAgICBlbnN1cmVcbiAgICAgIGBPcGFsLmN1cnJlbnRfZGlyID0gI3twcmV2X2N3ZH1gXG4gICAgZW5kXG5cbiAgICBkZWYgcHdkXG4gICAgICBgT3BhbC5jdXJyZW50X2RpciB8fCAnLidgXG4gICAgZW5kXG4gICAgYWxpYXMgZ2V0d2QgcHdkXG5cbiAgICBkZWYgaG9tZVxuICAgICAgRU5WWydIT01FJ10gfHwgJy4nXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJjaGRpciIsInByZXZfY3dkIiwiZGlyIiwicHdkIiwiaG9tZSIsIiRyZXRfb3JfMSIsIltdIiwic2VsZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0UsT0FBQTtBQUFBLE1BQUE7O0FBQUE7QUFDRTtBQUFBQyxNQUFBQSx5QkFBQUEsV0FBQUEsaUJBQVUsR0FBVkE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQUFBO0FBQUFBLGVBQ0UsY0FBQTtBQUFBO0FBQUEsUUFBQUMsV0FBWSxnQkFBWjtBQUFBLFFBQ0MsbUJBQXFCQyxHQUR0QjtBQUFBLFFBRUEsT0FBQSxxQkFBQSxFQUFBLENBRkE7QUFBQSxRQUFBO0FBQUEsVUFJQyxtQkFBcUJEO0FBSnRCLFFBQUEsQ0FBQTtBQURGRCxNQUFBQSxDQUFBQSxzQkFBQUEsQ0FBQTtBQUFBO0FBUUFHLE1BQUFBLHVCQUFBQSxTQUFBQSxlQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxPQUFDLHVCQUFEO0FBREZBLE1BQUFBLENBQUFBLG9CQUFBQSxDQVJBO0FBQUEsTUFXQSxpQkFBTSxPQUFOLEVBQVksS0FBWixDQVhBO0FBQUEsTUFhQSxPQUFBQyxDQUFBQSx3QkFBQUEsVUFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLElBQUEsUUFqQk5DLENBQUFBLFlBaUJNLG1CQUFBQyxPQUFBQSxDQUFJLE1BQUpBLENBakJORCxDQWlCTSxDQUFBO0FBQUEsVUFqQk4sT0FBQTtBQWlCTSxRQUFBO0FBQUEsVUFBZSxPQUFBO0FBQWYsUUFBQTtBQURGRCxNQUFBQSxDQUFBQSxxQkFBQUEsQ0FBQUEsZ0JBYkE7QUFERixJQUFBLDRCQUFTRyxJQUFUO0FBREZSLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjMxNjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2ZpbGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHlcblxuY2xhc3MgRmlsZSA8IElPXG4gIFNlcGFyYXRvciA9IFNFUEFSQVRPUiA9ICcvJ1xuICBBTFRfU0VQQVJBVE9SID0gbmlsXG4gIFBBVEhfU0VQQVJBVE9SID0gJzonXG4gICMgQXNzdW1pbmcgY2FzZSBpbnNlbnN0aXZlIGZpbGVzeXN0ZW1cbiAgRk5NX1NZU0NBU0UgPSAwXG4gIHdpbmRvd3Nfcm9vdF9yeCA9ICVye15bYS16QS1aXTooPzpcXFxcfFxcLyl9XG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhYnNvbHV0ZV9wYXRoKHBhdGgsIGJhc2VkaXIgPSBuaWwpXG4gICAgICBzZXAgPSBTRVBBUkFUT1JcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXG4gICAgICBuZXdfcGFydHMgPSBbXVxuXG4gICAgICBwYXRoID0gcGF0aC5yZXNwb25kX3RvPyg6dG9fcGF0aCkgPyBwYXRoLnRvX3BhdGggOiBwYXRoXG4gICAgICBiYXNlZGlyIHx8PSBEaXIucHdkXG4gICAgICBwYXRoX2FicyAgICA9IGBwYXRoLnN1YnN0cigwLCBzZXAubGVuZ3RoKSA9PT0gc2VwIHx8IHdpbmRvd3Nfcm9vdF9yeC50ZXN0KHBhdGgpYFxuICAgICAgYmFzZWRpcl9hYnMgPSBgYmFzZWRpci5zdWJzdHIoMCwgc2VwLmxlbmd0aCkgPT09IHNlcCB8fCB3aW5kb3dzX3Jvb3RfcngudGVzdChiYXNlZGlyKWBcblxuICAgICAgaWYgcGF0aF9hYnNcbiAgICAgICAgcGFydHMgICAgICAgPSBwYXRoLnNwbGl0KC9bI3tzZXBfY2hhcnN9XS8pXG4gICAgICAgIGxlYWRpbmdfc2VwID0gYHdpbmRvd3Nfcm9vdF9yeC50ZXN0KHBhdGgpID8gJycgOiAje3BhdGguc3ViKC9eKFsje3NlcF9jaGFyc31dKykuKiQvLCAnXFwxJyl9YFxuICAgICAgICBhYnMgICAgICAgICA9IHRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgcGFydHMgICAgICAgPSBiYXNlZGlyLnNwbGl0KC9bI3tzZXBfY2hhcnN9XS8pICsgcGF0aC5zcGxpdCgvWyN7c2VwX2NoYXJzfV0vKVxuICAgICAgICBsZWFkaW5nX3NlcCA9IGB3aW5kb3dzX3Jvb3RfcngudGVzdChiYXNlZGlyKSA/ICcnIDogI3tiYXNlZGlyLnN1YigvXihbI3tzZXBfY2hhcnN9XSspLiokLywgJ1xcMScpfWBcbiAgICAgICAgYWJzICAgICAgICAgPSBiYXNlZGlyX2Fic1xuICAgICAgZW5kXG5cbiAgICAgICV4e1xuICAgICAgICB2YXIgcGFydDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChwYXJ0ID09PSBuaWwpIHx8XG4gICAgICAgICAgICAocGFydCA9PT0gJycgICYmICgobmV3X3BhcnRzLmxlbmd0aCA9PT0gMCkgfHwgYWJzKSkgfHxcbiAgICAgICAgICAgIChwYXJ0ID09PSAnLicgJiYgKChuZXdfcGFydHMubGVuZ3RoID09PSAwKSB8fCBhYnMpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICAgICAgICBuZXdfcGFydHMucG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld19wYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWJzICYmIHBhcnRzWzBdICE9PSAnLicpIHtcbiAgICAgICAgICAje25ld19wYXJ0cy51bnNoaWZ0ICcuJ31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXdfcGF0aCA9IG5ld19wYXJ0cy5qb2luKHNlcClcbiAgICAgIG5ld19wYXRoID0gbGVhZGluZ19zZXAgKyBuZXdfcGF0aCBpZiBhYnNcbiAgICAgIG5ld19wYXRoXG4gICAgZW5kXG5cbiAgICBkZWYgZXhwYW5kX3BhdGgocGF0aCwgYmFzZWRpciA9IG5pbClcbiAgICAgIHNlcCA9IFNFUEFSQVRPUlxuICAgICAgc2VwX2NoYXJzID0gYCRzZXBfY2hhcnMoKWBcbiAgICAgIGlmIGBwYXRoWzBdID09PSAnficgfHwgKGJhc2VkaXIgJiYgYmFzZWRpclswXSA9PT0gJ34nKWBcbiAgICAgICAgaG9tZSA9IERpci5ob21lXG4gICAgICAgIHJhaXNlKEFyZ3VtZW50RXJyb3IsIFwiY291bGRuJ3QgZmluZCBIT01FIGVudmlyb25tZW50IC0tIGV4cGFuZGluZyBgfidcIikgdW5sZXNzIGhvbWVcbiAgICAgICAgbGVhZGluZ19zZXAgPSBgd2luZG93c19yb290X3J4LnRlc3QoaG9tZSkgPyAnJyA6ICN7aG9tZS5zdWIoL14oWyN7c2VwX2NoYXJzfV0rKS4qJC8sICdcXDEnKX1gXG4gICAgICAgIHJhaXNlKEFyZ3VtZW50RXJyb3IsICdub24tYWJzb2x1dGUgaG9tZScpIHVubGVzcyBob21lLnN0YXJ0X3dpdGg/KGxlYWRpbmdfc2VwKVxuXG4gICAgICAgIGhvbWUgICAgICAgICAgICArPSBzZXBcbiAgICAgICAgaG9tZV9wYXRoX3JlZ2V4cCA9IC9eXFx+KD86I3tzZXB9fCQpL1xuICAgICAgICBwYXRoICAgICAgICAgICAgID0gcGF0aC5zdWIoaG9tZV9wYXRoX3JlZ2V4cCwgaG9tZSlcbiAgICAgICAgYmFzZWRpciAgICAgICAgICA9IGJhc2VkaXIuc3ViKGhvbWVfcGF0aF9yZWdleHAsIGhvbWUpIGlmIGJhc2VkaXJcbiAgICAgIGVuZFxuICAgICAgYWJzb2x1dGVfcGF0aChwYXRoLCBiYXNlZGlyKVxuICAgIGVuZFxuICAgIGFsaWFzIHJlYWxwYXRoIGV4cGFuZF9wYXRoXG5cbiAgICAleHtcbiAgICAgIC8vIENvZXJjZSBhIGdpdmVuIHBhdGggdG8gYSBwYXRoIHN0cmluZyB1c2luZyAjdG9fcGF0aCBhbmQgI3RvX3N0clxuICAgICAgZnVuY3Rpb24gJGNvZXJjZV90b19wYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKCR0cnV0aHkoI3tgcGF0aGAucmVzcG9uZF90bz8oOnRvX3BhdGgpfSkpIHtcbiAgICAgICAgICBwYXRoID0gcGF0aC4kdG9fcGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aCA9ICN7T3BhbC5jb2VyY2VfdG8hKGBwYXRoYCwgU3RyaW5nLCA6dG9fc3RyKX07XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBhIFJlZ0V4cCBjb21wYXRpYmxlIGNoYXIgY2xhc3NcbiAgICAgIGZ1bmN0aW9uICRzZXBfY2hhcnMoKSB7XG4gICAgICAgIGlmICgje0FMVF9TRVBBUkFUT1J9ID09PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gT3BhbC5lc2NhcGVfcmVnZXhwKCN7U0VQQVJBVE9SfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIE9wYWwuZXNjYXBlX3JlZ2V4cCgje1NFUEFSQVRPUiArIEFMVF9TRVBBUkFUT1J9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGRlZiBkaXJuYW1lKHBhdGgpXG4gICAgICBzZXBfY2hhcnMgPSBgJHNlcF9jaGFycygpYFxuICAgICAgcGF0aCA9IGAkY29lcmNlX3RvX3BhdGgocGF0aClgXG4gICAgICAleHtcbiAgICAgICAgdmFyIGFic29sdXRlID0gcGF0aC5tYXRjaChuZXcgUmVnRXhwKCN7XCJeWyN7c2VwX2NoYXJzfV1cIn0pKTtcblxuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIlsje3NlcF9jaGFyc31dKyRcIn0pLCAnJyk7IC8vIHJlbW92ZSB0cmFpbGluZyBzZXBhcmF0b3JzXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiW14je3NlcF9jaGFyc31dKyRcIn0pLCAnJyk7IC8vIHJlbW92ZSB0cmFpbGluZyBiYXNlbmFtZVxuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIlsje3NlcF9jaGFyc31dKyRcIn0pLCAnJyk7IC8vIHJlbW92ZSBmaW5hbCB0cmFpbGluZyBzZXBhcmF0b3JzXG5cbiAgICAgICAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgICAgICAgcmV0dXJuIGFic29sdXRlID8gJy8nIDogJy4nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgYmFzZW5hbWUobmFtZSwgc3VmZml4ID0gbmlsKVxuICAgICAgc2VwX2NoYXJzID0gYCRzZXBfY2hhcnMoKWBcbiAgICAgIG5hbWUgPSBgJGNvZXJjZV90b19wYXRoKG5hbWUpYFxuICAgICAgJXh7XG4gICAgICAgIGlmIChuYW1lLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VmZml4ICE9PSBuaWwpIHtcbiAgICAgICAgICBzdWZmaXggPSAje09wYWwuY29lcmNlX3RvIShzdWZmaXgsIFN0cmluZywgOnRvX3N0cil9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VmZml4ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiKC4pWyN7c2VwX2NoYXJzfV0qJFwifSksICckMScpO1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIl4oPzouKlsje3NlcF9jaGFyc31dKT8oW14je3NlcF9jaGFyc31dKykkXCJ9KSwgJyQxJyk7XG5cbiAgICAgICAgaWYgKHN1ZmZpeCA9PT0gXCIuKlwiKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXFwuW15cXC5dKyQvLCAnJyk7XG4gICAgICAgIH0gZWxzZSBpZihzdWZmaXggIT09IG51bGwpIHtcbiAgICAgICAgICBzdWZmaXggPSBPcGFsLmVzY2FwZV9yZWdleHAoc3VmZml4KTtcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIiN7c3VmZml4fSRcIn0pLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiBleHRuYW1lKHBhdGgpXG4gICAgICBgcGF0aCA9ICRjb2VyY2VfdG9fcGF0aChwYXRoKWBcbiAgICAgIGZpbGVuYW1lID0gYmFzZW5hbWUocGF0aClcbiAgICAgIHJldHVybiAnJyBpZiBmaWxlbmFtZS5lbXB0eT9cbiAgICAgIGxhc3RfZG90X2lkeCA9IGZpbGVuYW1lWzEuLi0xXS5yaW5kZXgoJy4nKVxuICAgICAgIyBleHRlbnNpb24gbmFtZSBtdXN0IGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgLihzb21ldGhpbmcpXG4gICAgICBsYXN0X2RvdF9pZHgubmlsPyB8fCBsYXN0X2RvdF9pZHggKyAxID09IGZpbGVuYW1lLmxlbmd0aCAtIDEgPyAnJyA6IGZpbGVuYW1lWyhsYXN0X2RvdF9pZHggKyAxKS4uLTFdXG4gICAgZW5kXG5cbiAgICBkZWYgZXhpc3Q/KHBhdGgpXG4gICAgICBgT3BhbC5tb2R1bGVzWyN7cGF0aH1dICE9IG51bGxgXG4gICAgZW5kXG4gICAgYWxpYXMgZXhpc3RzPyBleGlzdD9cblxuICAgIGRlZiBkaXJlY3Rvcnk/KHBhdGgpXG4gICAgICBmaWxlcyA9IFtdXG4gICAgICAleHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIE9wYWwubW9kdWxlcykge1xuICAgICAgICAgICN7ZmlsZXN9LnB1c2goa2V5KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXRoID0gcGF0aC5nc3ViKC8oXi4je1NFUEFSQVRPUn0rfCN7U0VQQVJBVE9SfSskKS8pXG4gICAgICBmaWxlID0gZmlsZXMuZmluZCB7IHxmfCBmID1+IC9eI3twYXRofS8gfVxuICAgICAgZmlsZVxuICAgIGVuZFxuXG4gICAgZGVmIGpvaW4oKnBhdGhzKVxuICAgICAgaWYgcGF0aHMuZW1wdHk/XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgZW5kXG4gICAgICByZXN1bHQgPSAnJ1xuICAgICAgcGF0aHMgPSBwYXRocy5mbGF0dGVuLmVhY2hfd2l0aF9pbmRleC5tYXAgZG8gfGl0ZW0sIGluZGV4fFxuICAgICAgICBpZiBpbmRleCA9PSAwICYmIGl0ZW0uZW1wdHk/XG4gICAgICAgICAgU0VQQVJBVE9SXG4gICAgICAgIGVsc2lmIHBhdGhzLmxlbmd0aCA9PSBpbmRleCArIDEgJiYgaXRlbS5lbXB0eT9cbiAgICAgICAgICBTRVBBUkFUT1JcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGl0ZW1cbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHBhdGhzID0gcGF0aHMucmVqZWN0KCY6ZW1wdHk/KVxuICAgICAgcGF0aHMuZWFjaF93aXRoX2luZGV4IGRvIHxpdGVtLCBpbmRleHxcbiAgICAgICAgbmV4dF9pdGVtID0gcGF0aHNbaW5kZXggKyAxXVxuICAgICAgICBpZiBuZXh0X2l0ZW0ubmlsP1xuICAgICAgICAgIHJlc3VsdCA9IFwiI3tyZXN1bHR9I3tpdGVtfVwiXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpZiBpdGVtLmVuZF93aXRoPyhTRVBBUkFUT1IpICYmIG5leHRfaXRlbS5zdGFydF93aXRoPyhTRVBBUkFUT1IpXG4gICAgICAgICAgICBpdGVtID0gaXRlbS5zdWIoLyN7U0VQQVJBVE9SfSskLywgJycpXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgcmVzdWx0ID0gaWYgaXRlbS5lbmRfd2l0aD8oU0VQQVJBVE9SKSB8fCBuZXh0X2l0ZW0uc3RhcnRfd2l0aD8oU0VQQVJBVE9SKVxuICAgICAgICAgICAgICAgICAgICAgXCIje3Jlc3VsdH0je2l0ZW19XCJcbiAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICBcIiN7cmVzdWx0fSN7aXRlbX0je1NFUEFSQVRPUn1cIlxuICAgICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgcmVzdWx0XG4gICAgZW5kXG5cbiAgICBkZWYgc3BsaXQocGF0aClcbiAgICAgIHBhdGguc3BsaXQoU0VQQVJBVE9SKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiMCIsIndpbmRvd3Nfcm9vdF9yeCIsImFic29sdXRlX3BhdGgiLCJzZXAiLCJzZXBfY2hhcnMiLCJuZXdfcGFydHMiLCJwYXRoIiwicmVzcG9uZF90bz8iLCJ0b19wYXRoIiwiYmFzZWRpciIsIiRyZXRfb3JfMSIsInB3ZCIsInBhdGhfYWJzIiwiYmFzZWRpcl9hYnMiLCJwYXJ0cyIsInNwbGl0IiwibGVhZGluZ19zZXAiLCJzdWIiLCJhYnMiLCIrIiwidW5zaGlmdCIsIm5ld19wYXRoIiwiam9pbiIsImV4cGFuZF9wYXRoIiwiaG9tZSIsInJhaXNlIiwic3RhcnRfd2l0aD8iLCJob21lX3BhdGhfcmVnZXhwIiwiY29lcmNlX3RvISIsImRpcm5hbWUiLCJiYXNlbmFtZSIsIm5hbWUiLCJzdWZmaXgiLCJleHRuYW1lIiwiZmlsZW5hbWUiLCJlbXB0eT8iLCJsYXN0X2RvdF9pZHgiLCJbXSIsIjEiLCItMSIsInJpbmRleCIsIiRyZXRfb3JfMiIsIm5pbD8iLCI9PSIsIi0iLCJsZW5ndGgiLCJleGlzdD8iLCJkaXJlY3Rvcnk/IiwiZmlsZXMiLCJnc3ViIiwiZmlsZSIsImZpbmQiLCJmIiwiPX4iLCJwYXRocyIsInJlc3VsdCIsIm1hcCIsImZsYXR0ZW4iLCJlYWNoX3dpdGhfaW5kZXgiLCIkcmV0X29yXzMiLCJpbmRleCIsIml0ZW0iLCIkcmV0X29yXzQiLCJyZWplY3QiLCJuZXh0X2l0ZW0iLCIkcmV0X29yXzUiLCJlbmRfd2l0aD8iLCIkcmV0X29yXzYiLCJzZWxmIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztFQUVBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFBLHlDQUFZLHlDQUFZLEdBQVosQ0FBWixDQUFBO0FBQUEsSUFDQSw2Q0FBZ0IsR0FBaEIsQ0FEQTtBQUFBLElBRUEsOENBQWlCLEdBQWpCLENBRkE7QUFBQSxJQUlBLDJDQUFjQyxDQUFkLENBSkE7QUFBQSxJQUtBQyxrQkFBa0IscUJB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TU0sT0FBQUgsTUEzTU47QUE2S0lqQyxNQUFBQSxDQUFBQSxzQkFBQUEsQ0FqS0E7QUFBQSxNQWtNQSxPQUFBUCxDQUFBQSx5QkFBQUEsWUFBQUEsaUJBQVUsSUFBVkE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQ0UsT0FBQVQsSUFBQVMsT0FBQUEsQ0FBVyx5QkFBWEE7QUFERkEsTUFBQUEsQ0FBQUEsdUJBQUFBLENBQUFBLGlCQWxNQTtBQURGLElBQUEsNEJBQVNxRCxJQUFULFlBUEE7QUFERnJFLEVBQUFBLEdBQUFBLFdBQUFBLEVBQWEsa0JBQWJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjM0ODgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3Byb2Nlc3MucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgUHJvY2Vzc1xuICBAX19jbG9ja3NfXyA9IFtdXG4gIGRlZiBzZWxmLl9fcmVnaXN0ZXJfY2xvY2tfXyhuYW1lLCBmdW5jKVxuICAgIGNvbnN0X3NldCBuYW1lLCBAX19jbG9ja3NfXy5zaXplXG4gICAgQF9fY2xvY2tzX18gPDwgZnVuY1xuICBlbmRcblxuICBfX3JlZ2lzdGVyX2Nsb2NrX18gOkNMT0NLX1JFQUxUSU1FLCBgZnVuY3Rpb24oKSB7IHJldHVybiBEYXRlLm5vdygpIH1gXG5cbiAgbW9ub3RvbmljID0gZmFsc2VcblxuICAleHtcbiAgICBpZiAoT3BhbC5nbG9iYWwucGVyZm9ybWFuY2UpIHtcbiAgICAgIG1vbm90b25pYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKE9wYWwuZ2xvYmFsLnByb2Nlc3MgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICAgIC8vIGxldCBub3cgYmUgdGhlIGJhc2UgdG8gZ2V0IHNtYWxsZXIgbnVtYmVyc1xuICAgICAgdmFyIGhydGltZV9iYXNlID0gcHJvY2Vzcy5ocnRpbWUoKTtcblxuICAgICAgbW9ub3RvbmljID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBocnRpbWUgPSBwcm9jZXNzLmhydGltZShocnRpbWVfYmFzZSk7XG4gICAgICAgIHZhciB1cyA9IChocnRpbWVbMV0gLyAxMDAwKSB8IDA7IC8vIGN1dCBiZWxvdyBtaWNyb3NlY3M7XG4gICAgICAgIHJldHVybiAoKGhydGltZVswXSAqIDEwMDApICsgKHVzIC8gMTAwMCkpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBfX3JlZ2lzdGVyX2Nsb2NrX18oOkNMT0NLX01PTk9UT05JQywgbW9ub3RvbmljKSBpZiBtb25vdG9uaWNcblxuICBkZWYgc2VsZi5waWRcbiAgICAwXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRpbWVzXG4gICAgdCA9IFRpbWUubm93LnRvX2ZcbiAgICBCZW5jaG1hcms6OlRtcy5uZXcodCwgdCwgdCwgdCwgdClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY2xvY2tfZ2V0dGltZShjbG9ja19pZCwgdW5pdCA9IDpmbG9hdF9zZWNvbmQpXG4gICAgKGNsb2NrID0gQF9fY2xvY2tzX19bY2xvY2tfaWRdKSB8fCByYWlzZShFcnJubzo6RUlOVkFMLCBcImNsb2NrX2dldHRpbWUoI3tjbG9ja19pZH0pICN7QF9fY2xvY2tzX19bY2xvY2tfaWRdfVwiKVxuICAgICV4e1xuICAgICAgdmFyIG1zID0gY2xvY2soKTtcbiAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlICdmbG9hdF9zZWNvbmQnOiAgICAgIHJldHVybiAgKG1zIC8gMTAwMCk7ICAgICAgICAgLy8gbnVtYmVyIG9mIHNlY29uZHMgYXMgYSBmbG9hdCAoZGVmYXVsdClcbiAgICAgICAgY2FzZSAnZmxvYXRfbWlsbGlzZWNvbmQnOiByZXR1cm4gIChtcyAvIDEpOyAgICAgICAgICAgIC8vIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYXMgYSBmbG9hdFxuICAgICAgICBjYXNlICdmbG9hdF9taWNyb3NlY29uZCc6IHJldHVybiAgKG1zICogMTAwMCk7ICAgICAgICAgLy8gbnVtYmVyIG9mIG1pY3Jvc2Vjb25kcyBhcyBhIGZsb2F0XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6ICAgICAgICAgICAgcmV0dXJuICgobXMgLyAxMDAwKSAgICB8IDApOyAvLyBudW1iZXIgb2Ygc2Vjb25kcyBhcyBhbiBpbnRlZ2VyXG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogICAgICAgcmV0dXJuICgobXMgLyAxKSAgICAgICB8IDApOyAvLyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFzIGFuIGludGVnZXJcbiAgICAgICAgY2FzZSAnbWljcm9zZWNvbmQnOiAgICAgICByZXR1cm4gKChtcyAqIDEwMDApICAgIHwgMCk7IC8vIG51bWJlciBvZiBtaWNyb3NlY29uZHMgYXMgYW4gaW50ZWdlclxuICAgICAgICBjYXNlICduYW5vc2Vjb25kJzogICAgICAgIHJldHVybiAoKG1zICogMTAwMDAwMCkgfCAwKTsgLy8gbnVtYmVyIG9mIG5hbm9zZWNvbmRzIGFzIGFuIGludGVnZXJcbiAgICAgICAgZGVmYXVsdDogI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInVuZXhwZWN0ZWQgdW5pdDogI3t1bml0fVwifVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcblxuY2xhc3MgU2lnbmFsXG4gIGRlZiBzZWxmLnRyYXAoKilcbiAgZW5kXG5lbmRcblxuY2xhc3MgR0NcbiAgZGVmIHNlbGYuc3RhcnRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsIkBfX2Nsb2Nrc19fIiwiX19yZWdpc3Rlcl9jbG9ja19fIiwic2VsZiIsImNvbnN0X3NldCIsIm5hbWUiLCJzaXplIiwiPDwiLCJmdW5jIiwibW9ub3RvbmljIiwicGlkIiwiMCIsInRpbWVzIiwidCIsIm5vdyIsInRvX2YiLCJuZXciLCJjbG9ja19nZXR0aW1lIiwiJHJldF9vcl8xIiwiY2xvY2siLCJbXSIsImNsb2NrX2lkIiwicmFpc2UiLCJ1bml0IiwidHJhcCIsInN0YXJ0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxFQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQUMsa0JBQWMsRUFBZDtBQUFBLElBQ0FDLFVBQUlDLElBQUpELHlCQUFBQSxnQ0FBQUEsOEJBQTRCLElBQUQsRUFBTyxJQUFsQ0E7QUFBQUEsTUFBQUE7QUFBQUE7O0FBQUFBO0FBQ0UsVUFBQUUsV0FBQUEsQ0FBVUMsTUFBTUosZUFBQUssTUFBQUEsQ0FBQUEsQ0FBaEJGLENBQUE7QUFBQSxNQUNBLE9BQUFILGVBQUFNLE9BQUFBLENBQWVDLElBQWZELENBREE7QUFERkwsSUFBQUEsQ0FBQUEsMkNBQUFBLENBREE7QUFBQSxRQU1BQSxvQkFBQUEsQ0FBbUIsa0JBQWtCLGdDQUFyQ0EsQ0FOQTtBQUFBLElBUUFPLFlBQVksS0FSWjtBQUFBO0FBV0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQTFCRTtBQUFBLElBNEJBLElBQUEsUUFBbURBLFNBQW5ELENBQUE7QUFBQSxVQUFBUCxvQkFBQUEsQ0FBbUIsbUJBQWtCTyxTQUFyQ1AsQ0FBQSxDQTVCQTtBQUFBLElBOEJBUSxVQUFJUCxJQUFKTyxVQUFBQSxpQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQUM7QUFERkQsSUFBQUEsQ0FBQUEsNEJBQUFBLENBOUJBO0FBQUEsSUFrQ0FFLFVBQUlULElBQUpTLFlBQUFBLG1CQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQUMsSUFBSSxvQkFBQUMsS0FBQUEsQ0FBQUEsQ0FBQUMsTUFBQUEsQ0FBQUEsQ0FBSjtBQUFBLE1BQ0EsT0FBQSxJQUFBLHlCQUFBLFFBQUFDLEtBQUFBLENBQW1CSCxHQUFHQSxHQUFHQSxHQUFHQSxHQUFHQSxDQUEvQkcsQ0FEQTtBQURGSixJQUFBQSxDQUFBQSw4QkFBQUEsQ0FsQ0E7QUFBQSxJQXVDQSxPQUFBSyxDQUFBQSxVQUFJZCxJQUFKYyxvQkFBQUEsMkJBQUFBLHlCQUF1QixRQUFELEVBQVcsSUFBakNBO0FBQUFBLE1BQUFBO0FBQUFBOztBQUFBQTtBQXpDRjtBQXlDbUMsTUFBQTtBQUFBLE1BQUEsU0FBTyxjQUFQO0FBQUEsTUFBQSxDQXpDbkM7QUFBQSxNQTBDSSxJQUFBLFFBMUNKQyxDQUFBQSxZQTBDS0MsQ0FBQUEsUUFBUWxCLGVBQUFtQixPQUFBQSxDQUFZQyxRQUFaRCxDQUFSRCxDQTFDTEQsQ0EwQ0ksQ0FBQTtBQUFBLFFBMUNKO0FBMENJLE1BQUE7QUFBQSxZQUFtQ0ksT0FBQUEsQ0FBTSxJQUFBLHFCQUFBLGFBQWUsRUFBQSxHQUFBLGdCQUFBLEdBQUEsQ0FBaUJELFFBQWpCLENBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBOEJwQixlQUFBbUIsT0FBQUEsQ0FBWUMsUUFBWkQsQ0FBOUIsQ0FBckJFO0FBQW5DLE1BQUEsQ0ExQ0o7QUFBQTtBQTRDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBbUJBLE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLG1CQUFBLEdBQUEsQ0FBb0JDLElBQXBCLENBQXJCRDtBQUNuQjtBQUNBLElBdkRBO0FBeUNFTCxJQUFBQSxDQUFBQSx1Q0FBQUEsQ0FBQUEseUJBdkNBO0FBREZqQixFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQUFBO0FBQUEsRUEwREFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRSxPQUFBd0IsQ0FBQUEsVUFBSXJCLElBQUpxQixXQUFBQSxpQkFBQUEsZ0JBNURGLEVBNERFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUE1REY7QUFBQSxNQUFBLDREQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUEsT0FBQSxHQUFBO0FBNERFQSxJQUFBQSxDQUFBQSw2QkFBQUEsQ0FBQUE7QUFERnhCLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBMURBO0FBQUEsRUErREEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUF5QixDQUFBQSxVQUFJdEIsSUFBSnNCLFlBQUFBLGNBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFqRUYsT0FBQTtBQWlFRUEsSUFBQUEsQ0FBQUEseUJBQUFBLENBQUFBO0FBREZ6QixFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQS9EQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzNTk5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYW5kb20ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgUmFuZG9tXG4gIGF0dHJfcmVhZGVyIDpzZWVkLCA6c3RhdGVcblxuICBkZWYgaW5pdGlhbGl6ZShzZWVkID0gUmFuZG9tLm5ld19zZWVkKVxuICAgIHNlZWQgPSBPcGFsLmNvZXJjZV90byEoc2VlZCwgSW50ZWdlciwgOnRvX2ludClcbiAgICBAc3RhdGUgPSBzZWVkXG4gICAgcmVzZWVkKHNlZWQpXG4gIGVuZFxuXG4gIGRlZiByZXNlZWQoc2VlZClcbiAgICBAc2VlZCA9IHNlZWRcbiAgICBgc2VsZi4kcm5nID0gT3BhbC4kJHJhbmQucmVzZWVkKHNlZWQpYFxuICBlbmRcblxuICBkZWYgc2VsZi5uZXdfc2VlZFxuICAgIGBPcGFsLiQkcmFuZC5uZXdfc2VlZCgpYFxuICBlbmRcblxuICBkZWYgc2VsZi5yYW5kKGxpbWl0ID0gdW5kZWZpbmVkKVxuICAgIERFRkFVTFQucmFuZChsaW1pdClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuc3JhbmQobiA9IFJhbmRvbS5uZXdfc2VlZClcbiAgICBuID0gT3BhbC5jb2VyY2VfdG8hKG4sIEludGVnZXIsIDp0b19pbnQpXG5cbiAgICBwcmV2aW91c19zZWVkID0gREVGQVVMVC5zZWVkXG4gICAgREVGQVVMVC5yZXNlZWQobilcbiAgICBwcmV2aW91c19zZWVkXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnVyYW5kb20oc2l6ZSlcbiAgICBzaXplID0gT3BhbC5jb2VyY2VfdG8hKHNpemUsIEludGVnZXIsIDp0b19pbnQpXG5cbiAgICBpZiBzaXplIDwgMFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIHN0cmluZyBzaXplIChvciBzaXplIHRvbyBiaWcpJ1xuICAgIGVuZFxuXG4gICAgQXJyYXkubmV3KHNpemUpIHsgcmFuZCgyNTUpLmNociB9LmpvaW4uZW5jb2RlKCdBU0NJSS04QklUJylcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgUmFuZG9tID09PSBvdGhlclxuXG4gICAgc2VlZCA9PSBvdGhlci5zZWVkICYmIHN0YXRlID09IG90aGVyLnN0YXRlXG4gIGVuZFxuXG4gIGRlZiBieXRlcyhsZW5ndGgpXG4gICAgbGVuZ3RoID0gT3BhbC5jb2VyY2VfdG8hKGxlbmd0aCwgSW50ZWdlciwgOnRvX2ludClcblxuICAgIEFycmF5Lm5ldyhsZW5ndGgpIHsgcmFuZCgyNTUpLmNociB9LmpvaW4uZW5jb2RlKCdBU0NJSS04QklUJylcbiAgZW5kXG5cbiAgZGVmIHJhbmQobGltaXQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiByYW5kb21GbG9hdCgpIHtcbiAgICAgICAgc2VsZi5zdGF0ZSsrO1xuICAgICAgICByZXR1cm4gT3BhbC4kJHJhbmQucmFuZChzZWxmLiRybmcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByYW5kb21JbnQoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHJhbmRvbUZsb2F0KCkgKiBsaW1pdCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJhbmRvbVJhbmdlKCkge1xuICAgICAgICB2YXIgbWluID0gbGltaXQuYmVnaW4sXG4gICAgICAgICAgICBtYXggPSBsaW1pdC5lbmQ7XG5cbiAgICAgICAgaWYgKG1pbiA9PT0gbmlsIHx8IG1heCA9PT0gbmlsKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSBtYXggLSBtaW47XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4ICUgMSA9PT0gMCAmJiBtaW4gJSAxID09PSAwICYmICFsaW1pdC5leGNsKSB7XG4gICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZi4kcmFuZChsZW5ndGgpICsgbWluO1xuICAgICAgfVxuXG4gICAgICBpZiAobGltaXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmFuZG9tRmxvYXQoKTtcbiAgICAgIH0gZWxzZSBpZiAobGltaXQuJCRpc19yYW5nZSkge1xuICAgICAgICByZXR1cm4gcmFuZG9tUmFuZ2UoKTtcbiAgICAgIH0gZWxzZSBpZiAobGltaXQuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCBhcmd1bWVudCAtICN7bGltaXR9XCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGltaXQgJSAxID09PSAwKSB7XG4gICAgICAgICAgLy8gaW50ZWdlclxuICAgICAgICAgIHJldHVybiByYW5kb21JbnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmFuZG9tRmxvYXQoKSAqIGxpbWl0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW1pdCA9ICN7T3BhbC5jb2VyY2VfdG8hKGxpbWl0LCBJbnRlZ2VyLCA6dG9faW50KX07XG5cbiAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCBhcmd1bWVudCAtICN7bGltaXR9XCJ9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmFuZG9tSW50KCk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5nZW5lcmF0b3I9KGdlbmVyYXRvcilcbiAgICBgT3BhbC4kJHJhbmQgPSAje2dlbmVyYXRvcn1gXG5cbiAgICBpZiBjb25zdF9kZWZpbmVkPyA6REVGQVVMVFxuICAgICAgREVGQVVMVC5yZXNlZWRcbiAgICBlbHNlXG4gICAgICBjb25zdF9zZXQgOkRFRkFVTFQsIG5ldyhuZXdfc2VlZClcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIm5ld19zZWVkIiwic2VlZCIsImNvZXJjZV90byEiLCJAc3RhdGUiLCJyZXNlZWQiLCJAc2VlZCIsInNlbGYiLCJyYW5kIiwibGltaXQiLCJzcmFuZCIsIm4iLCJwcmV2aW91c19zZWVkIiwidXJhbmRvbSIsInNpemUiLCI8IiwiMCIsInJhaXNlIiwibmV3IiwiMjU1IiwiY2hyIiwiam9pbiIsImVuY29kZSIsIj09IiwiPT09Iiwib3RoZXIiLCIkcmV0X29yXzEiLCJzdGF0ZSIsImJ5dGVzIiwibGVuZ3RoIiwiZ2VuZXJhdG9yPSIsImdlbmVyYXRvciIsImNvbnN0X2RlZmluZWQ/IiwiY29uc3Rfc2V0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxhQUFBQSxDQUFZLFFBQU8sT0FBbkJBLENBQUE7QUFBQTtBQUVBQyxJQUFBQSw4QkFBQUEsdUJBQUFBLHNCQUFlLElBQWZBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUpGO0FBSWlCLE1BQUE7QUFBQSxNQUFBLFNBQU8sc0JBQUFDLFVBQUFBLENBQUFBLENBQVA7QUFBQSxNQUFBLENBSmpCO0FBQUEsTUFLSUMsT0FBTyxvQkFBQUMsZUFBQUEsQ0FB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LDBCQUFBQSxTQUFvQixTQUFwQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQyxjQUFnQkMsU0FBakI7QUFBQSxNQUVBLElBQUEsWUFBR0MsbUJBQUFBLENBQWUsU0FBZkEsQ0FBSCxDQUFBO0FBQUEsUUFDRSxPQUFBLHVCQUFBM0IsUUFBQUEsQ0FBQUE7QUFERixNQUFBO0FBQUEsUUFHRSxXQUFBNEIsV0FBQUEsQ0FBVSxlQUFVZixLQUFBQSxLQUFJakIsVUFBQUEsQ0FBQUEsQ0FBSmlCLENBQXBCZTtBQUhGLE1BQUEsQ0FGQTtBQURGSCxJQUFBQSxDQUFBQSxxQ0FBQUEsQ0FBQUEsc0JBbEhBO0FBREZoQyxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzNzc3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYW5kb20vbWVyc2VubmVfdHdpc3Rlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIFRoaXMgaXMgYmFzZWQgb24gYW4gYWRhcHRhdGlvbiBvZiBNYWtvdG8gTWF0c3Vtb3RvIGFuZCBUYWt1amkgTmlzaGltdXJhJ3MgY29kZVxuIyBkb25lIGJ5IFNlYW4gTWNDdWxsb3VnaCA8YmFua3NlYW5AZ21haWwuY29tPiBhbmQgRGF2ZSBIZWl0em1hblxuIyA8ZGF2ZWhlaXR6bWFuQHlhaG9vLmNvbT4sIHN1YnNlcXVlbnRseSByZWFkYXB0ZWQgZnJvbSBhbiB1cGRhdGVkIHZlcnNpb24gb2ZcbiMgcnVieSdzIHJhbmRvbS5jIChyZXYgYzM4YTE4MzAzMmE3ODI2ZGYxYWRhYmQ4YWEwNzI1YzcxM2Q1M2UxYykuXG4jXG4jIFRoZSBvcmlnaW5hbCBjb3B5cmlnaHQgbm90aWNlIGZyb20gcmFuZG9tLmMgZm9sbG93cy5cbiNcbiMgICBUaGlzIGlzIGJhc2VkIG9uIHRyaW1tZWQgdmVyc2lvbiBvZiBNVDE5OTM3LiAgVG8gZ2V0IHRoZSBvcmlnaW5hbCB2ZXJzaW9uLFxuIyAgIGNvbnRhY3QgPGh0dHA6Ly93d3cubWF0aC5zY2kuaGlyb3NoaW1hLXUuYWMuanAvfm0tbWF0L01UL2VtdC5odG1sPi5cbiNcbiMgICBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IG5vdGljZSBmb2xsb3dzLlxuI1xuIyAgICAgIEEgQy1wcm9ncmFtIGZvciBNVDE5OTM3LCB3aXRoIGluaXRpYWxpemF0aW9uIGltcHJvdmVkIDIwMDIvMi8xMC5cbiMgICAgICBDb2RlZCBieSBUYWt1amkgTmlzaGltdXJhIGFuZCBNYWtvdG8gTWF0c3Vtb3RvLlxuIyAgICAgIFRoaXMgaXMgYSBmYXN0ZXIgdmVyc2lvbiBieSB0YWtpbmcgU2hhd24gQ29rdXMncyBvcHRpbWl6YXRpb24sXG4jICAgICAgTWF0dGhlIEJlbGxldydzIHNpbXBsaWZpY2F0aW9uLCBJc2FrdSBXYWRhJ3MgcmVhbCB2ZXJzaW9uLlxuI1xuIyAgICAgIEJlZm9yZSB1c2luZywgaW5pdGlhbGl6ZSB0aGUgc3RhdGUgYnkgdXNpbmcgaW5pdF9nZW5yYW5kKG10LCBzZWVkKVxuIyAgICAgIG9yIGluaXRfYnlfYXJyYXkobXQsIGluaXRfa2V5LCBrZXlfbGVuZ3RoKS5cbiNcbiMgICAgICBDb3B5cmlnaHQgKEMpIDE5OTcgLSAyMDAyLCBNYWtvdG8gTWF0c3Vtb3RvIGFuZCBUYWt1amkgTmlzaGltdXJhLFxuIyAgICAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4jXG4jICAgICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4jICAgICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4jICAgICAgYXJlIG1ldDpcbiNcbiMgICAgICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4jICAgICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4jXG4jICAgICAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuIyAgICAgICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuIyAgICAgICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiNcbiMgICAgICAgIDMuIFRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGVcbiMgICAgICAgICAgIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlblxuIyAgICAgICAgICAgcGVybWlzc2lvbi5cbiNcbiMgICAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4jICAgICAgXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuIyAgICAgIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuIyAgICAgIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxuIyAgICAgIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxuIyAgICAgIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiMgICAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiMgICAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4jICAgICAgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiMgICAgICBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiMgICAgICBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiNcbiNcbiMgICAgICBBbnkgZmVlZGJhY2sgaXMgdmVyeSB3ZWxjb21lLlxuIyAgICAgIGh0dHA6Ly93d3cubWF0aC5rZWlvLmFjLmpwL21hdHVtb3RvL2VtdC5odG1sXG4jICAgICAgZW1haWw6IG1hdHVtb3RvQG1hdGgua2Vpby5hYy5qcFxubWVyc2VubmVfdHdpc3RlciA9ICV4eyhmdW5jdGlvbigpIHtcbiAgLyogUGVyaW9kIHBhcmFtZXRlcnMgKi9cbiAgdmFyIE4gPSA2MjQ7XG4gIHZhciBNID0gMzk3O1xuICB2YXIgTUFUUklYX0EgPSAweDk5MDhiMGRmOyAgICAgIC8qIGNvbnN0YW50IHZlY3RvciBhICovXG4gIHZhciBVTUFTSyA9IDB4ODAwMDAwMDA7ICAgICAgICAgLyogbW9zdCBzaWduaWZpY2FudCB3LXIgYml0cyAqL1xuICB2YXIgTE1BU0sgPSAweDdmZmZmZmZmOyAgICAgICAgIC8qIGxlYXN0IHNpZ25pZmljYW50IHIgYml0cyAqL1xuICB2YXIgTUlYQklUUyA9IGZ1bmN0aW9uKHUsdikgeyByZXR1cm4gKCAoKHUpICYgVU1BU0spIHwgKCh2KSAmIExNQVNLKSApOyB9O1xuICB2YXIgVFdJU1QgPSBmdW5jdGlvbih1LHYpIHsgcmV0dXJuIChNSVhCSVRTKCh1KSwodikpID4+PiAxKSBeICgodiAmIDB4MSkgPyBNQVRSSVhfQSA6IDB4MCk7IH07XG5cbiAgZnVuY3Rpb24gaW5pdChzKSB7XG4gICAgdmFyIG10ID0ge2xlZnQ6IDAsIG5leHQ6IE4sIHN0YXRlOiBuZXcgQXJyYXkoTil9O1xuICAgIGluaXRfZ2VucmFuZChtdCwgcyk7XG4gICAgcmV0dXJuIG10O1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZXMgbXRbTl0gd2l0aCBhIHNlZWQgKi9cbiAgZnVuY3Rpb24gaW5pdF9nZW5yYW5kKG10LCBzKSB7XG4gICAgdmFyIGosIGk7XG4gICAgbXQuc3RhdGVbMF0gPSBzID4+PiAwO1xuICAgIGZvciAoaj0xOyBqPE47IGorKykge1xuICAgICAgbXQuc3RhdGVbal0gPSAoMTgxMjQzMzI1MyAqICgobXQuc3RhdGVbai0xXSBeIChtdC5zdGF0ZVtqLTFdID4+IDMwKSA+Pj4gMCkpICsgaik7XG4gICAgICAvKiBTZWUgS251dGggVEFPQ1AgVm9sMi4gM3JkIEVkLiBQLjEwNiBmb3IgbXVsdGlwbGllci4gKi9cbiAgICAgIC8qIEluIHRoZSBwcmV2aW91cyB2ZXJzaW9ucywgTVNCcyBvZiB0aGUgc2VlZCBhZmZlY3QgICAqL1xuICAgICAgLyogb25seSBNU0JzIG9mIHRoZSBhcnJheSBzdGF0ZVtdLiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAvKiAyMDAyLzAxLzA5IG1vZGlmaWVkIGJ5IE1ha290byBNYXRzdW1vdG8gICAgICAgICAgICAgKi9cbiAgICAgIG10LnN0YXRlW2pdICY9IDB4ZmZmZmZmZmY7ICAvKiBmb3IgPjMyIGJpdCBtYWNoaW5lcyAqL1xuICAgIH1cbiAgICBtdC5sZWZ0ID0gMTtcbiAgICBtdC5uZXh0ID0gTjtcbiAgfVxuXG4gIC8qIGdlbmVyYXRlIE4gd29yZHMgYXQgb25lIHRpbWUgKi9cbiAgZnVuY3Rpb24gbmV4dF9zdGF0ZShtdCkge1xuICAgIHZhciBwID0gMCwgX3AgPSBtdC5zdGF0ZTtcbiAgICB2YXIgajtcblxuICAgIG10LmxlZnQgPSBOO1xuICAgIG10Lm5leHQgPSAwO1xuXG4gICAgZm9yIChqPU4tTSsxOyAtLWo7IHArKylcbiAgICAgIF9wW3BdID0gX3BbcCsoTSldIF4gVFdJU1QoX3BbcCsoMCldLCBfcFtwKygxKV0pO1xuXG4gICAgZm9yIChqPU07IC0tajsgcCsrKVxuICAgICAgX3BbcF0gPSBfcFtwKyhNLU4pXSBeIFRXSVNUKF9wW3ArKDApXSwgX3BbcCsoMSldKTtcblxuICAgIF9wW3BdID0gX3BbcCsoTS1OKV0gXiBUV0lTVChfcFtwKygwKV0sIF9wWzBdKTtcbiAgfVxuXG4gIC8qIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMHhmZmZmZmZmZl0taW50ZXJ2YWwgKi9cbiAgZnVuY3Rpb24gZ2VucmFuZF9pbnQzMihtdCkge1xuICAgIC8qIG10IG11c3QgYmUgaW5pdGlhbGl6ZWQgKi9cbiAgICB2YXIgeTtcblxuICAgIGlmICgtLW10LmxlZnQgPD0gMCkgbmV4dF9zdGF0ZShtdCk7XG4gICAgeSA9IG10LnN0YXRlW210Lm5leHQrK107XG5cbiAgICAvKiBUZW1wZXJpbmcgKi9cbiAgICB5IF49ICh5ID4+PiAxMSk7XG4gICAgeSBePSAoeSA8PCA3KSAmIDB4OWQyYzU2ODA7XG4gICAgeSBePSAoeSA8PCAxNSkgJiAweGVmYzYwMDAwO1xuICAgIHkgXj0gKHkgPj4+IDE4KTtcblxuICAgIHJldHVybiB5ID4+PiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaW50X3BhaXJfdG9fcmVhbF9leGNsdXNpdmUoYSwgYikge1xuICAgIGEgPj4+PSA1O1xuICAgIGIgPj4+PSA2O1xuICAgIHJldHVybihhKjY3MTA4ODY0LjArYikqKDEuMC85MDA3MTk5MjU0NzQwOTkyLjApO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwxKSB3aXRoIDUzLWJpdCByZXNvbHV0aW9uXG4gIGZ1bmN0aW9uIGdlbnJhbmRfcmVhbChtdCkge1xuICAgIC8qIG10IG11c3QgYmUgaW5pdGlhbGl6ZWQgKi9cbiAgICB2YXIgYSA9IGdlbnJhbmRfaW50MzIobXQpLCBiID0gZ2VucmFuZF9pbnQzMihtdCk7XG4gICAgcmV0dXJuIGludF9wYWlyX3RvX3JlYWxfZXhjbHVzaXZlKGEsIGIpO1xuICB9XG5cbiAgcmV0dXJuIHsgZ2VucmFuZF9yZWFsOiBnZW5yYW5kX3JlYWwsIGluaXQ6IGluaXQgfTtcbn0pKCl9XG5cbmNsYXNzIFJhbmRvbVxuICBgdmFyIE1BWF9JTlQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCBNYXRoLnBvdygyLCA1MykgLSAxYFxuXG4gIE1FUlNFTk5FX1RXSVNURVJfR0VORVJBVE9SID0gYHtcbiAgICBuZXdfc2VlZDogZnVuY3Rpb24oKSB7IHJldHVybiBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBNQVhfSU5UKTsgfSxcbiAgICByZXNlZWQ6IGZ1bmN0aW9uKHNlZWQpIHsgcmV0dXJuIG1lcnNlbm5lX3R3aXN0ZXIuaW5pdChzZWVkKTsgfSxcbiAgICByYW5kOiBmdW5jdGlvbihtdCkgeyByZXR1cm4gbWVyc2VubmVfdHdpc3Rlci5nZW5yYW5kX3JlYWwobXQpOyB9XG4gIH1gXG5cbiAgc2VsZi5nZW5lcmF0b3IgPSBNRVJTRU5ORV9UV0lTVEVSX0dFTkVSQVRPUlxuZW5kXG4iXSwibmFtZXMiOlsibWVyc2VubmVfdHdpc3RlciIsImNsYXNzIiwiJHdyaXRlciIsImdlbmVyYXRvcj0iLCJzZWxmIiwiLSIsIjEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQXNEQSxFQUFBQSxtQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFoRkE7QUFBQSxFQWtGQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQyw0REFBRDtBQUFBLElBRUEsMERBQThCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEdBSkUsQ0FGQTtBQUFBO0FBMUlGLElBQUFDLFVBQUEsQ0FrSm1CLDBDQWxKbkIsQ0FBQTtBQUFBLElBa0pFQyxNQUFBQyxJQUFBRCxjQUFBQSxFQWxKRixVQUFBRCxPQUFBLENBa0pFQyxDQWxKRjtBQUFBLElBQUEsT0FBQUQsT0FBQSxDQUFBRyxVQUFBSCxPQUFBLENBQUEsUUFBQSxDQUFBRyxFQUFBQyxDQUFBRCxDQUFBLENBQUEsQ0EwSUU7QUFERkosRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FsRkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMzg4NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvdW5zdXBwb3J0ZWQucmIiXSwic291cmNlc0NvbnRlbnQiOlsiJXh7XG4gIHZhciB3YXJuaW5ncyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKG1lc3NhZ2UpIHtcbiAgICBzd2l0Y2ggKE9wYWwuY29uZmlnLnVuc3VwcG9ydGVkX2ZlYXR1cmVzX3NldmVyaXR5KSB7XG4gICAgY2FzZSAnZXJyb3InOlxuICAgICAgI3tLZXJuZWwucmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYG1lc3NhZ2VgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnd2FybmluZyc6XG4gICAgICB3YXJuKG1lc3NhZ2UpXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OiAvLyBpZ25vcmVcbiAgICAgIC8vIG5vb3BcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKHN0cmluZykge1xuICAgIGlmICh3YXJuaW5nc1tzdHJpbmddKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmluZ3Nbc3RyaW5nXSA9IHRydWU7XG4gICAgI3t3YXJuKGBzdHJpbmdgKX07XG4gIH1cbn1cblxuY2xhc3MgU3RyaW5nXG4gIGB2YXIgRVJST1IgPSBcIlN0cmluZyMlcyBub3Qgc3VwcG9ydGVkLiBNdXRhYmxlIFN0cmluZyBtZXRob2RzIGFyZSBub3Qgc3VwcG9ydGVkIGluIE9wYWwuXCJgXG5cbiAgZGVmIDw8KCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICc8PCdcbiAgZW5kXG5cbiAgZGVmIGNhcGl0YWxpemUhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdjYXBpdGFsaXplISdcbiAgZW5kXG5cbiAgZGVmIGNob21wISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnY2hvbXAhJ1xuICBlbmRcblxuICBkZWYgY2hvcCEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2Nob3AhJ1xuICBlbmRcblxuICBkZWYgZG93bmNhc2UhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdkb3duY2FzZSEnXG4gIGVuZFxuXG4gIGRlZiBnc3ViISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnZ3N1YiEnXG4gIGVuZFxuXG4gIGRlZiBsc3RyaXAhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdsc3RyaXAhJ1xuICBlbmRcblxuICBkZWYgbmV4dCEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ25leHQhJ1xuICBlbmRcblxuICBkZWYgcmV2ZXJzZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ3JldmVyc2UhJ1xuICBlbmRcblxuICBkZWYgc2xpY2UhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdzbGljZSEnXG4gIGVuZFxuXG4gIGRlZiBzcXVlZXplISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnc3F1ZWV6ZSEnXG4gIGVuZFxuXG4gIGRlZiBzdHJpcCEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ3N0cmlwISdcbiAgZW5kXG5cbiAgZGVmIHN1YiEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ3N1YiEnXG4gIGVuZFxuXG4gIGRlZiBzdWNjISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnc3VjYyEnXG4gIGVuZFxuXG4gIGRlZiBzd2FwY2FzZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ3N3YXBjYXNlISdcbiAgZW5kXG5cbiAgZGVmIHRyISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAndHIhJ1xuICBlbmRcblxuICBkZWYgdHJfcyEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ3RyX3MhJ1xuICBlbmRcblxuICBkZWYgdXBjYXNlISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAndXBjYXNlISdcbiAgZW5kXG5cbiAgZGVmIHByZXBlbmQoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ3ByZXBlbmQnXG4gIGVuZFxuXG4gIGRlZiBbXT0oKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ1tdPSdcbiAgZW5kXG5cbiAgZGVmIGNsZWFyKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdjbGVhcidcbiAgZW5kXG5cbiAgZGVmIGVuY29kZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2VuY29kZSEnXG4gIGVuZFxuXG4gIGRlZiB1bmljb2RlX25vcm1hbGl6ZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ3VuaWNvZGVfbm9ybWFsaXplISdcbiAgZW5kXG5lbmRcblxubW9kdWxlIEtlcm5lbFxuICBgdmFyIEVSUk9SID0gXCJPYmplY3QgZnJlZXppbmcgaXMgbm90IHN1cHBvcnRlZCBieSBPcGFsXCJgXG5cbiAgZGVmIGZyZWV6ZVxuICAgIGBoYW5kbGVfdW5zdXBwb3J0ZWRfZmVhdHVyZShFUlJPUilgXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZnJvemVuP1xuICAgIGBoYW5kbGVfdW5zdXBwb3J0ZWRfZmVhdHVyZShFUlJPUilgXG4gICAgZmFsc2VcbiAgZW5kXG5lbmRcblxubW9kdWxlIEtlcm5lbFxuICBgdmFyIEVSUk9SID0gXCJPYmplY3QgdGFpbnRpbmcgaXMgbm90IHN1cHBvcnRlZCBieSBPcGFsXCJgXG5cbiAgZGVmIHRhaW50XG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB1bnRhaW50XG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0YWludGVkP1xuICAgIGBoYW5kbGVfdW5zdXBwb3J0ZWRfZmVhdHVyZShFUlJPUilgXG4gICAgZmFsc2VcbiAgZW5kXG5lbmRcblxuY2xhc3MgTW9kdWxlXG4gIGRlZiBwdWJsaWMoKm1ldGhvZHMpXG4gICAgJXh7XG4gICAgICBpZiAobWV0aG9kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VsZi4kJG1vZHVsZV9mdW5jdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgcHJpdmF0ZSBwdWJsaWNcblxuICBhbGlhcyBwcm90ZWN0ZWQgcHVibGljXG5cbiAgYWxpYXMgbmVzdGluZyBwdWJsaWNcblxuICBkZWYgcHJpdmF0ZV9jbGFzc19tZXRob2QoKilcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIHB1YmxpY19jbGFzc19tZXRob2QgcHJpdmF0ZV9jbGFzc19tZXRob2RcblxuICBkZWYgcHJpdmF0ZV9tZXRob2RfZGVmaW5lZD8ob2JqKVxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBwcml2YXRlX2NvbnN0YW50KCopXG4gIGVuZFxuXG4gIGFsaWFzIHByb3RlY3RlZF9tZXRob2RfZGVmaW5lZD8gcHJpdmF0ZV9tZXRob2RfZGVmaW5lZD9cblxuICBhbGlhcyBwdWJsaWNfaW5zdGFuY2VfbWV0aG9kcyBpbnN0YW5jZV9tZXRob2RzXG5cbiAgYWxpYXMgcHVibGljX2luc3RhbmNlX21ldGhvZCBpbnN0YW5jZV9tZXRob2RcblxuICBhbGlhcyBwdWJsaWNfbWV0aG9kX2RlZmluZWQ/IG1ldGhvZF9kZWZpbmVkP1xuZW5kXG5cbm1vZHVsZSBLZXJuZWxcbiAgZGVmIHByaXZhdGVfbWV0aG9kcygqKVxuICAgIFtdXG4gIGVuZFxuXG4gIGFsaWFzIHByaXZhdGVfaW5zdGFuY2VfbWV0aG9kcyBwcml2YXRlX21ldGhvZHNcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBldmFsKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgXCJUbyB1c2UgS2VybmVsI2V2YWwsIHlvdSBtdXN0IGZpcnN0IHJlcXVpcmUgJ29wYWwtcGFyc2VyJy4gXCJcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGFsL29wYWwvYmxvYi8je1JVQllfRU5HSU5FX1ZFUlNJT059L2RvY3Mvb3BhbF9wYXJzZXIubWQgZm9yIGRldGFpbHMuXCJcbiAgZW5kXG5lbmRcblxuZGVmIHNlbGYucHVibGljKCopXG4gICMgc3R1YlxuZW5kXG5cbmRlZiBzZWxmLnByaXZhdGUoKilcbiAgIyBzdHViXG5lbmRcbiJdLCJuYW1lcyI6WyJyYWlzZSIsIndhcm4iLCJjbGFzcyIsIjw8IiwiJSIsImNhcGl0YWxpemUhIiwiY2hvbXAhIiwiY2hvcCEiLCJkb3duY2FzZSEiLCJnc3ViISIsImxzdHJpcCEiLCJuZXh0ISIsInJldmVyc2UhIiwic2xpY2UhIiwic3F1ZWV6ZSEiLCJzdHJpcCEiLCJzdWIhIiwic3VjYyEiLCJzd2FwY2FzZSEiLCJ0ciEiLCJ0cl9zISIsInVwY2FzZSEiLCJwcmVwZW5kIiwiW109IiwiY2xlYXIiLCJlbmNvZGUhIiwidW5pY29kZV9ub3JtYWxpemUhIiwibW9kdWxlIiwiZnJlZXplIiwic2VsZiIsImZyb3plbj8iLCJ0YWludCIsInVudGFpbnQiLCJ0YWludGVkPyIsInB1YmxpYyIsInByaXZhdGVfY2xhc3NfbWV0aG9kIiwicHJpdmF0ZV9tZXRob2RfZGVmaW5lZD8iLCJwcml2YXRlX2NvbnN0YW50IiwicHJpdmF0ZV9tZXRob2RzIiwiZXZhbCIsInByaXZhdGUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBUSxzQkFBQUEsT0FBQUEsQ0FBYSxxQ0FBc0IsT0FBbkNBO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQU1DLE1BQUFBLENBQU0sTUFBTkEsQ0FBZTtBQUNyQjtBQXZCQTtBQUFBLEVBMEJBQztBQUFBQSxF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LG1DQUF6QyxDQUFBLEdBQUEsbUNBREEsQ0FBM0JBLENBN01KO0FBNE1FdUMsSUFBQUEsQ0FBQUEsOEJBQUFBO0FBREZaLEVBQUFBLEdBQUFBLFdBQUFBLFdBMU1BO0FBQUEsRUFpTkFPLFVBQUlMLElBQUpLLGFBQUFBLGFBQUFBLFNBbE5BLEVBa05BQTtBQUFBQSxJQUFBQTs7QUFBQUE7QUFsTkE7QUFBQSxJQUFBLDREQUFBO0FBQUEsSUFBQTtBQUFBLElBQUEsT0FBQSxHQUFBO0FBa05BQSxFQUFBQSxDQUFBQSx5QkFBQUEsQ0FqTkE7QUFBQSxFQXFOQSxPQUFBTSxDQUFBQSxVQUFJWCxJQUFKVyxjQUFBQSxjQUFBQSxTQXROQSxFQXNOQUE7QUFBQUEsSUFBQUE7O0FBQUFBO0FBdE5BO0FBQUEsSUFBQSw0REFBQTtBQUFBLElBQUE7QUFBQSxJQUFBLE9BQUEsR0FBQTtBQXNOQUEsRUFBQUEsQ0FBQUEsMEJBQUFBLENBQUFBLG1CQXJOQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0MzIyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9vcGFsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ29wYWwvYmFzZSdcbnJlcXVpcmUgJ29wYWwvbWluaSdcblxucmVxdWlyZSAnY29yZWxpYi9rZXJuZWwvZm9ybWF0J1xucmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvZW5jb2RpbmcnXG5yZXF1aXJlICdjb3JlbGliL21hdGgnXG5yZXF1aXJlICdjb3JlbGliL2NvbXBsZXgnXG5yZXF1aXJlICdjb3JlbGliL3JhdGlvbmFsJ1xucmVxdWlyZSAnY29yZWxpYi90aW1lJ1xucmVxdWlyZSAnY29yZWxpYi9zdHJ1Y3QnXG5yZXF1aXJlICdjb3JlbGliL2lvJ1xucmVxdWlyZSAnY29yZWxpYi9tYWluJ1xucmVxdWlyZSAnY29yZWxpYi9kaXInXG5yZXF1aXJlICdjb3JlbGliL2ZpbGUnXG5yZXF1aXJlICdjb3JlbGliL3Byb2Nlc3MnXG5yZXF1aXJlICdjb3JlbGliL3JhbmRvbSdcbnJlcXVpcmUgJ2NvcmVsaWIvcmFuZG9tL21lcnNlbm5lX3R3aXN0ZXInXG5cbnJlcXVpcmUgJ2NvcmVsaWIvdW5zdXBwb3J0ZWQnXG4iXSwibmFtZXMiOlsicmVxdWlyZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxXQUFSQSxDQUFBO0FBQUEsTUFDQUEsU0FBQUEsQ0FBUSxXQUFSQSxDQURBO0FBQUEsTUFHQUEsU0FBQUEsQ0FBUSx1QkFBUkEsQ0FIQTtBQUFBLE1BSUFBLFNBQUFBLENBQVEseUJBQVJBLENBSkE7QUFBQSxNQUtBQSxTQUFBQSxDQUFRLGNBQVJBLENBTEE7QUFBQSxNQU1BQSxTQUFBQSxDQUFRLGlCQUFSQSxDQU5BO0FBQUEsTUFPQUEsU0FBQUEsQ0FBUSxrQkFBUkEsQ0FQQTtBQUFBLE1BUUFBLFNBQUFBLENBQVEsY0FBUkEsQ0FSQTtBQUFBLE1BU0FBLFNBQUFBLENBQVEsZ0JBQVJBLENBVEE7QUFBQSxNQVVBQSxTQUFBQSxDQUFRLFlBQVJBLENBVkE7QUFBQSxNQVdBQSxTQUFBQSxDQUFRLGNBQVJBLENBWEE7QUFBQSxNQVlBQSxTQUFBQSxDQUFRLGFBQVJBLENBWkE7QUFBQSxNQWFBQSxTQUFBQSxDQUFRLGNBQVJBLENBYkE7QUFBQSxNQWNBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQWRBO0FBQUEsTUFlQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FmQTtBQUFBLE1BZ0JBQSxTQUFBQSxDQUFRLGlDQUFSQSxDQWhCQTtBQUFBLEVBa0JBLFdBQUFBLFNBQUFBLENBQVEscUJBQVJBLENBbEJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjQzNDcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL2pzb24ucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEpTT05cbiAgY2xhc3MgSlNPTkVycm9yIDwgU3RhbmRhcmRFcnJvclxuICBlbmRcblxuICBjbGFzcyBQYXJzZXJFcnJvciA8IEpTT05FcnJvclxuICBlbmRcblxuICAleHtcbiAgICB2YXIgJGhhc093biA9IE9wYWwuaGFzT3duUHJvcGVydHk7XG5cbiAgICBmdW5jdGlvbiAkcGFyc2Uoc291cmNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzb3VyY2UpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAje3JhaXNlIEpTT046OlBhcnNlckVycm9yLCBgZS5tZXNzYWdlYH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHRvX29wYWwodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBrbGFzcywgYXJyLCBoYXNoLCBpLCBpaSwgaztcblxuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgcmV0dXJuICEhdmFsdWU7XG5cbiAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgcmV0dXJuIG5pbDtcblxuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIGlmICghdmFsdWUpIHJldHVybiBuaWw7XG5cbiAgICAgICAgICBpZiAodmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgYXJyID0gI3tgb3B0aW9ucy5hcnJheV9jbGFzc2AubmV3fTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgaWkgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICN7YGFycmAucHVzaChgdG9fb3BhbCh2YWx1ZVtpXSwgb3B0aW9ucylgKX07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFzaCA9ICN7YG9wdGlvbnMub2JqZWN0X2NsYXNzYC5uZXd9O1xuXG4gICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKCRoYXNPd24uY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAje2BoYXNoYFtga2BdID0gYHRvX29wYWwodmFsdWVba10sIG9wdGlvbnMpYH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnBhcnNlICYmIChrbGFzcyA9ICN7YGhhc2hgW0pTT04uY3JlYXRlX2lkXX0pICE9IG5pbCkge1xuICAgICAgICAgICAgICByZXR1cm4gI3s6Ok9iamVjdC5jb25zdF9nZXQoYGtsYXNzYCkuanNvbl9jcmVhdGUoYGhhc2hgKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhdHRyX2FjY2Vzc29yIDpjcmVhdGVfaWRcbiAgZW5kXG5cbiAgc2VsZi5jcmVhdGVfaWQgPSA6anNvbl9jbGFzc1xuXG4gIGRlZiBzZWxmLltdKHZhbHVlLCBvcHRpb25zID0ge30pXG4gICAgaWYgU3RyaW5nID09PSB2YWx1ZVxuICAgICAgcGFyc2UodmFsdWUsIG9wdGlvbnMpXG4gICAgZWxzZVxuICAgICAgZ2VuZXJhdGUodmFsdWUsIG9wdGlvbnMpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnBhcnNlKHNvdXJjZSwgb3B0aW9ucyA9IHt9KVxuICAgIGZyb21fb2JqZWN0KGAkcGFyc2Uoc291cmNlKWAsIG9wdGlvbnMubWVyZ2UocGFyc2U6IHRydWUpKVxuICBlbmRcblxuICBkZWYgc2VsZi5wYXJzZSEoc291cmNlLCBvcHRpb25zID0ge30pXG4gICAgcGFyc2Uoc291cmNlLCBvcHRpb25zKVxuICBlbmRcblxuICBkZWYgc2VsZi5sb2FkKHNvdXJjZSwgb3B0aW9ucyA9IHt9KVxuICAgIGZyb21fb2JqZWN0KGAkcGFyc2Uoc291cmNlKWAsIG9wdGlvbnMpXG4gIGVuZFxuXG4gICMgUmF3IGpzIG9iamVjdCA9PiBvcGFsIG9iamVjdFxuICBkZWYgc2VsZi5mcm9tX29iamVjdChqc19vYmplY3QsIG9wdGlvbnMgPSB7fSlcbiAgICBvcHRpb25zWzpvYmplY3RfY2xhc3NdIHx8PSBIYXNoXG4gICAgb3B0aW9uc1s6YXJyYXlfY2xhc3NdICB8fD0gQXJyYXlcblxuICAgIGB0b19vcGFsKGpzX29iamVjdCwgb3B0aW9ucy4kJHNtYXApYFxuICBlbmRcblxuICBkZWYgc2VsZi5nZW5lcmF0ZShvYmosIG9wdGlvbnMgPSB7fSlcbiAgICBvYmoudG9fanNvbihvcHRpb25zKVxuICBlbmRcblxuICBkZWYgc2VsZi5kdW1wKG9iaiwgaW8gPSBuaWwsIGxpbWl0ID0gbmlsKVxuICAgIHN0cmluZyA9IGdlbmVyYXRlKG9iailcblxuICAgIGlmIGlvXG4gICAgICBpbyA9IGlvLnRvX2lvIGlmIGlvLnJlc3BvbmRzX3RvPyA6dG9faW9cbiAgICAgIGlvLndyaXRlIHN0cmluZ1xuXG4gICAgICBpb1xuICAgIGVsc2VcbiAgICAgIHN0cmluZ1xuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyBPYmplY3RcbiAgZGVmIHRvX2pzb25cbiAgICB0b19zLnRvX2pzb25cbiAgZW5kXG5lbmRcblxuIyBCVUc6IEVudW1lcmFibGUgbXVzdCBjb21lIGJlZm9yZSBBcnJheSwgb3RoZXJ3aXNlIGl0IG92ZXJyaWRlcyAjdG9fanNvblxuIyAgICAgIHRoaXMgaXMgZHVlIHRvIGhvdyBtb2R1bGVzIGFyZSBpbXBsZW1lbnRlZC5cbm1vZHVsZSBFbnVtZXJhYmxlXG4gIGRlZiB0b19qc29uXG4gICAgdG9fYS50b19qc29uXG4gIGVuZFxuZW5kXG5cbmNsYXNzIEFycmF5XG4gIGRlZiB0b19qc29uXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSAje3NlbGZ9Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCN7YHNlbGZbaV1gLnRvX2pzb259KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdbJyArIHJlc3VsdC5qb2luKCcsICcpICsgJ10nO1xuICAgIH1cbiAgZW5kXG5lbmRcblxuY2xhc3MgQm9vbGVhblxuICBkZWYgdG9fanNvblxuICAgIGAoc2VsZiA9PSB0cnVlKSA/ICd0cnVlJyA6ICdmYWxzZSdgXG4gIGVuZFxuZW5kXG5cbmNsYXNzIEhhc2hcbiAgZGVmIHRvX2pzb25cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKCN7YGtleWAudG9fcy50b19qc29ufSArICc6JyArICN7YHZhbHVlYC50b19qc29ufSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAneycgKyByZXN1bHQuam9pbignLCAnKSArICd9JztcbiAgICB9XG4gIGVuZFxuZW5kXG5cbmNsYXNzIE5pbENsYXNzXG4gIGRlZiB0b19qc29uXG4gICAgJ251bGwnXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE51bWVyaWNcbiAgZGVmIHRvX2pzb25cbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBTdHJpbmdcbiAgYWxpYXMgdG9fanNvbiBpbnNwZWN0XG5lbmRcblxuY2xhc3MgVGltZVxuICBkZWYgdG9fanNvblxuICAgIHN0cmZ0aW1lKCclRlQlVCV6JykudG9fanNvblxuICBlbmRcbmVuZFxuXG5jbGFzcyBEYXRlXG4gIGRlZiB0b19qc29uXG4gICAgdG9fcy50b19qc29uXG4gIGVuZFxuXG4gIGRlZiBhc19qc29uXG4gICAgdG9fc1xuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwicmFpc2UiLCJuZXciLCJwdXNoIiwiJHdyaXRlciIsIltdPSIsIi0iLCIxIiwiW10iLCJjcmVhdGVfaWQiLCJjb25zdF9nZXQiLCJqc29uX2NyZWF0ZSIsImF0dHJfYWNjZXNzb3IiLCJzZWxmIiwiY3JlYXRlX2lkPSIsIj09PSIsInZhbHVlIiwicGFyc2UiLCJvcHRpb25zIiwiZ2VuZXJhdGUiLCJmcm9tX29iamVjdCIsIm1lcmdlIiwicGFyc2UhIiwic291cmNlIiwibG9hZCIsIiRyZXRfb3JfMSIsIiRyZXRfb3JfMiIsIm9iaiIsInRvX2pzb24iLCJkdW1wIiwic3RyaW5nIiwiaW8iLCJyZXNwb25kc190bz8iLCJ0b19pbyIsIndyaXRlIiwidG9fcyIsInRvX2EiLCJzdHJmdGltZSIsImFzX2pzb24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLEVBQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFBQztBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQUFBLElBQUFBLEdBQUFBLFdBQUFBLEVBQWtCLDZCQUFsQkEsV0FBQTtBQUFBLElBR0FBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUE7QUFBQUEsSUFBQUEsR0FBQUEsV0FBQUEsRUFBb0IseUJBQXBCQSxXQUhBO0FBQUE7QUFPRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVVDLE9BQUFB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Q0FBUyxTQUFUQSxDQUFBVCxTQUFBQSxDQUFBQTtBQURGQSxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FBQUE7QUFERjVCLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBL0xBO0FBQUEsRUFxTUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFO0FBQUE0QixJQUFBQSwyQkFBQUEsbUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxXQUFBTyxNQUFBQSxDQUFBQSxDQUFBUCxTQUFBQSxDQUFBQTtBQURGQSxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FBQTtBQUFBLElBSUEsT0FBQVUsQ0FBQUEsMkJBQUFBLG1CQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsV0FBQUgsTUFBQUEsQ0FBQUE7QUFERkcsSUFBQUEsQ0FBQUEsOEJBQUFBLENBQUFBLG1CQUpBO0FBREZ0QyxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQXJNQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0Njg4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9kYXRlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIERhdGVcbiAgaW5jbHVkZSBDb21wYXJhYmxlXG5cbiAgY2xhc3MgSW5maW5pdHkgPCBOdW1lcmljXG4gICAgaW5jbHVkZSBDb21wYXJhYmxlXG5cbiAgICBkZWYgaW5pdGlhbGl6ZShkID0gMSlcbiAgICAgIEBkID0gZCA8PT4gMFxuICAgIGVuZFxuXG4gICAgYXR0cl9yZWFkZXIgOmRcblxuICAgIGRlZiB6ZXJvP1xuICAgICAgZmFsc2VcbiAgICBlbmRcblxuICAgIGRlZiBmaW5pdGU/XG4gICAgICBmYWxzZVxuICAgIGVuZFxuXG4gICAgZGVmIGluZmluaXRlP1xuICAgICAgZC5ub256ZXJvP1xuICAgIGVuZFxuXG4gICAgZGVmIG5hbj9cbiAgICAgIGQuemVybz9cbiAgICBlbmRcblxuICAgIGRlZiBhYnNcbiAgICAgIHNlbGYuY2xhc3MubmV3XG4gICAgZW5kXG5cbiAgICBkZWYgLUBcbiAgICAgIHNlbGYuY2xhc3MubmV3KC1kKVxuICAgIGVuZFxuXG4gICAgZGVmICtAXG4gICAgICBzZWxmLmNsYXNzLm5ldygrZClcbiAgICBlbmRcblxuICAgIGRlZiA8PT4ob3RoZXIpXG4gICAgICBjYXNlIG90aGVyXG4gICAgICB3aGVuIEluZmluaXR5XG4gICAgICAgIGQgPD0+IG90aGVyLmRcbiAgICAgIHdoZW4gTnVtZXJpY1xuICAgICAgICBkXG4gICAgICBlbHNlXG4gICAgICAgIGJlZ2luXG4gICAgICAgICAgbCwgciA9IG90aGVyLmNvZXJjZShzZWxmKVxuICAgICAgICAgIGwgPD0+IHJcbiAgICAgICAgcmVzY3VlIE5vTWV0aG9kRXJyb3JcbiAgICAgICAgICBuaWxcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBjb2VyY2Uob3RoZXIpXG4gICAgICBjYXNlIG90aGVyXG4gICAgICB3aGVuIE51bWVyaWNcbiAgICAgICAgWy1kLCBkXVxuICAgICAgZWxzZVxuICAgICAgICBzdXBlclxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgdG9fZlxuICAgICAgcmV0dXJuIDAgaWYgQGQgPT0gMFxuICAgICAgaWYgQGQgPiAwXG4gICAgICAgIEZsb2F0OjpJTkZJTklUWVxuICAgICAgZWxzZVxuICAgICAgICAtRmxvYXQ6OklORklOSVRZXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgSlVMSUFOICAgICAgICAgID0gSW5maW5pdHkubmV3XG4gIEdSRUdPUklBTiAgICAgICA9IC1JbmZpbml0eS5uZXdcbiAgSVRBTFkgICAgICAgICAgID0gMl8yOTlfMTYxICMgMTU4Mi0xMC0xNVxuICBFTkdMQU5EICAgICAgICAgPSAyXzM2MV8yMjIgIyAxNzUyLTA5LTE0XG4gIE1PTlRITkFNRVMgICAgICA9IFtuaWxdICsgJXdbSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlcl1cbiAgQUJCUl9NT05USE5BTUVTID0gJXdbamFuIGZlYiBtYXIgYXByIG1heSBqdW4ganVsIGF1ZyBzZXAgb2N0IG5vdiBkZWNdXG4gIERBWU5BTUVTICAgICAgICA9ICV3W1N1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XVxuICBBQkJSX0RBWU5BTUVTICAgPSAld1tTdW4gTW9uIFR1ZSBXZWQgVGh1IEZyaSBTYXRdXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGFsaWFzIGNpdmlsIG5ld1xuXG4gICAgZGVmIHdyYXAobmF0aXZlKVxuICAgICAgaW5zdGFuY2UgPSBhbGxvY2F0ZVxuICAgICAgYCN7aW5zdGFuY2V9LmRhdGUgPSAje25hdGl2ZX1gXG4gICAgICBpbnN0YW5jZVxuICAgIGVuZFxuXG4gICAgZGVmIHBhcnNlKHN0cmluZywgY29tcCA9IHRydWUpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGN1cnJlbnRfZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgdmFyIGN1cnJlbnRfZGF5ID0gY3VycmVudF9kYXRlLmdldERhdGUoKSxcbiAgICAgICAgICAgIGN1cnJlbnRfbW9udGggPSBjdXJyZW50X2RhdGUuZ2V0TW9udGgoKSxcbiAgICAgICAgICAgIGN1cnJlbnRfeWVhciA9IGN1cnJlbnRfZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgY3VycmVudF93ZGF5ID0gY3VycmVudF9kYXRlLmdldERheSgpLFxuICAgICAgICAgICAgZnVsbF9tb250aF9uYW1lX3JlZ2V4cCA9ICN7TU9OVEhOQU1FUy5jb21wYWN0LmpvaW4oJ3wnKX07XG5cbiAgICAgICAgZnVuY3Rpb24gbWF0Y2gxKG1hdGNoKSB7IHJldHVybiBtYXRjaFsxXTsgfVxuICAgICAgICBmdW5jdGlvbiBtYXRjaDIobWF0Y2gpIHsgcmV0dXJuIG1hdGNoWzJdOyB9XG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoMyhtYXRjaCkgeyByZXR1cm4gbWF0Y2hbM107IH1cbiAgICAgICAgZnVuY3Rpb24gbWF0Y2g0KG1hdGNoKSB7IHJldHVybiBtYXRjaFs0XTsgfVxuXG4gICAgICAgIC8vIENvbnZlcnRzIHBhc3NlZCBzaG9ydCB5ZWFyICgwLi45OSlcbiAgICAgICAgLy8gdG8gYSA0LWRpZ2l0cyB5ZWFyIGluIHRoZSByYW5nZSAoMTk2OS4uMjA2OClcbiAgICAgICAgZnVuY3Rpb24gZnJvbVNob3J0WWVhcihmbikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNob3J0X3llYXIgPSBmbihtYXRjaCk7XG5cbiAgICAgICAgICAgIGlmIChzaG9ydF95ZWFyID49IDY5KSB7XG4gICAgICAgICAgICAgIHNob3J0X3llYXIgKz0gMTkwMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNob3J0X3llYXIgKz0gMjAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaG9ydF95ZWFyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnRzIG1vbnRoIGFiYnIgKG5vdikgdG8gYSBtb250aCBudW1iZXJcbiAgICAgICAgZnVuY3Rpb24gZnJvbU1vbnRoQWJicihmbikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgdmFyIGFiYnIgPSBmbihtYXRjaCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiAje0FCQlJfTU9OVEhOQU1FU30uaW5kZXhPZihhYmJyKSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdG9JbnQoZm4pIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGZuKG1hdGNoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgJ2NvbXAnIHZhbHVlIGFwcGVuZHMgMjB4eCB0byBhIHBhc3NlZCB5ZWFyXG4gICAgICAgIGZ1bmN0aW9uIHRvMjAwMChmbikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZm4obWF0Y2gpO1xuICAgICAgICAgICAgaWYgKGNvbXApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICsgMjAwMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0cyBwYXNzZWQgd2VlayBkYXkgbmFtZSB0byBhIGRheSBudW1iZXJcbiAgICAgICAgZnVuY3Rpb24gZnJvbURheU5hbWUoZm4pIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBkYXluYW1lID0gZm4obWF0Y2gpLFxuICAgICAgICAgICAgICAgIHdkYXkgPSAje0RBWU5BTUVTLm1hcCgmOmRvd25jYXNlKX0uaW5kZXhPZigje2BkYXluYW1lYC5kb3duY2FzZX0pO1xuXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudF9kYXkgLSBjdXJyZW50X3dkYXkgKyB3ZGF5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnRzIHBhc3NlZCBtb250aCBuYW1lIHRvIGEgbW9udGggbnVtYmVyXG4gICAgICAgIGZ1bmN0aW9uIGZyb21GdWxsTW9udGhOYW1lKGZuKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgbW9udGhfbmFtZSA9IGZuKG1hdGNoKTtcbiAgICAgICAgICAgIHJldHVybiAje01PTlRITkFNRVMuY29tcGFjdC5tYXAoJjpkb3duY2FzZSl9LmluZGV4T2YoI3tgbW9udGhfbmFtZWAuZG93bmNhc2V9KSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJ1bGVzID0gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIEREIGFzIG1vbnRoIGRheSBudW1iZXJcbiAgICAgICAgICAgIHJlZ2V4cDogL14oXFxkezJ9KSQvLFxuICAgICAgICAgICAgeWVhcjogY3VycmVudF95ZWFyLFxuICAgICAgICAgICAgbW9udGg6IGN1cnJlbnRfbW9udGgsXG4gICAgICAgICAgICBkYXk6IHRvSW50KG1hdGNoMSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIERERCBhcyB5ZWFyIGRheSBudW1iZXJcbiAgICAgICAgICAgIHJlZ2V4cDogL14oXFxkezN9KSQvLFxuICAgICAgICAgICAgeWVhcjogY3VycmVudF95ZWFyLFxuICAgICAgICAgICAgbW9udGg6IDAsXG4gICAgICAgICAgICBkYXk6IHRvSW50KG1hdGNoMSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIE1NREQgYXMgbW9udGggYW5kIGRheVxuICAgICAgICAgICAgcmVnZXhwOiAvXihcXGR7Mn0pKFxcZHsyfSkkLyxcbiAgICAgICAgICAgIHllYXI6IGN1cnJlbnRfeWVhcixcbiAgICAgICAgICAgIG1vbnRoOiB0b0ludChtYXRjaDEpLFxuICAgICAgICAgICAgZGF5OiB0b0ludChtYXRjaDIpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBZWURERCBhcyB5ZWFyIGFuZCBkYXkgbnVtYmVyIGluIDE5NjktLTIwNjhcbiAgICAgICAgICAgIHJlZ2V4cDogL14oXFxkezJ9KShcXGR7M30pJC8sXG4gICAgICAgICAgICB5ZWFyOiBmcm9tU2hvcnRZZWFyKHRvSW50KG1hdGNoMSkpLFxuICAgICAgICAgICAgbW9udGg6IDAsXG4gICAgICAgICAgICBkYXk6IHRvSW50KG1hdGNoMilcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFlZTU1ERCBhcyB5ZWFyLCBtb250aCBhbmQgZGF5IGluIDE5NjktLTIwNjhcbiAgICAgICAgICAgIHJlZ2V4cDogL14oXFxkezJ9KShcXGR7Mn0pKFxcZHsyfSkkLyxcbiAgICAgICAgICAgIHllYXI6IGZyb21TaG9ydFllYXIodG9JbnQobWF0Y2gxKSksXG4gICAgICAgICAgICBtb250aDogdG9JbnQobWF0Y2gyKSxcbiAgICAgICAgICAgIGRheTogdG9JbnQobWF0Y2gzKVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gWVlZWURERCBhcyB5ZWFyIGFuZCBkYXkgbnVtYmVyXG4gICAgICAgICAgICByZWdleHA6IC9eKFxcZHs0fSkoXFxkezN9KSQvLFxuICAgICAgICAgICAgeWVhcjogdG9JbnQobWF0Y2gxKSxcbiAgICAgICAgICAgIG1vbnRoOiAwLFxuICAgICAgICAgICAgZGF5OiB0b0ludChtYXRjaDIpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBZWVlZTU1ERCBhcyB5ZWFyLCBtb250aCBhbmQgZGF5IG51bWJlclxuICAgICAgICAgICAgcmVnZXhwOiAvXihcXGR7NH0pKFxcZHsyfSkoXFxkezJ9KSQvLFxuICAgICAgICAgICAgeWVhcjogdG9JbnQobWF0Y2gxKSxcbiAgICAgICAgICAgIG1vbnRoOiB0b0ludChtYXRjaDIpLFxuICAgICAgICAgICAgZGF5OiB0b0ludChtYXRjaDMpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBtbW0gWVlZWVxuICAgICAgICAgICAgcmVnZXhwOiAvXihbYS16XXszfSlbXFxzXFwuXFwvXFwtXShcXGR7Myw0fSkkLyxcbiAgICAgICAgICAgIHllYXI6IHRvSW50KG1hdGNoMiksXG4gICAgICAgICAgICBtb250aDogZnJvbU1vbnRoQWJicihtYXRjaDEpLFxuICAgICAgICAgICAgZGF5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBERCBtbW0gWVlZWVxuICAgICAgICAgICAgcmVnZXhwOiAvXihcXGR7MSwyfSlbXFxzXFwuXFwvXFwtXShbYS16XXszfSlbXFxzXFwuXFwvXFwtXShcXGR7Myw0fSkkL2ksXG4gICAgICAgICAgICB5ZWFyOiB0b0ludChtYXRjaDMpLFxuICAgICAgICAgICAgbW9udGg6IGZyb21Nb250aEFiYnIobWF0Y2gyKSxcbiAgICAgICAgICAgIGRheTogdG9JbnQobWF0Y2gxKVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gbW1tIEREIFlZWVlcbiAgICAgICAgICAgIHJlZ2V4cDogL14oW2Etel17M30pW1xcc1xcLlxcL1xcLV0oXFxkezEsMn0pW1xcc1xcLlxcL1xcLV0oXFxkezMsNH0pJC9pLFxuICAgICAgICAgICAgeWVhcjogdG9JbnQobWF0Y2gzKSxcbiAgICAgICAgICAgIG1vbnRoOiBmcm9tTW9udGhBYmJyKG1hdGNoMSksXG4gICAgICAgICAgICBkYXk6IHRvSW50KG1hdGNoMilcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFlZWVkgbW1tIEREXG4gICAgICAgICAgICByZWdleHA6IC9eKFxcZHszLDR9KVtcXHNcXC5cXC9cXC1dKFthLXpdezN9KVtcXHNcXC5cXC9cXC1dKFxcZHsxLDJ9KSQvaSxcbiAgICAgICAgICAgIHllYXI6IHRvSW50KG1hdGNoMSksXG4gICAgICAgICAgICBtb250aDogZnJvbU1vbnRoQWJicihtYXRjaDIpLFxuICAgICAgICAgICAgZGF5OiB0b0ludChtYXRjaDMpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBZWVlZLU1NLUREIFlZWVkvTU0vREQgWVlZWS5NTS5ERFxuICAgICAgICAgICAgcmVnZXhwOiAvXihcXC0/XFxkezMsNH0pW1xcc1xcLlxcL1xcLV0oXFxkezEsMn0pW1xcc1xcLlxcL1xcLV0oXFxkezEsMn0pJC8sXG4gICAgICAgICAgICB5ZWFyOiB0b0ludChtYXRjaDEpLFxuICAgICAgICAgICAgbW9udGg6IHRvSW50KG1hdGNoMiksXG4gICAgICAgICAgICBkYXk6IHRvSW50KG1hdGNoMylcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFlZLU1NLUREXG4gICAgICAgICAgICByZWdleHA6IC9eKFxcZHsyfSlbXFxzXFwuXFwvXFwtXShcXGR7MSwyfSlbXFxzXFwuXFwvXFwtXShcXGR7MSwyfSkkLyxcbiAgICAgICAgICAgIHllYXI6IHRvMjAwMCh0b0ludChtYXRjaDEpKSxcbiAgICAgICAgICAgIG1vbnRoOiB0b0ludChtYXRjaDIpLFxuICAgICAgICAgICAgZGF5OiB0b0ludChtYXRjaDMpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBERC1NTS1ZWVlZXG4gICAgICAgICAgICByZWdleHA6IC9eKFxcZHsxLDJ9KVtcXHNcXC5cXC9cXC1dKFxcZHsxLDJ9KVtcXHNcXC5cXC9cXC1dKFxcLT9cXGR7Myw0fSkkLyxcbiAgICAgICAgICAgIHllYXI6IHRvSW50KG1hdGNoMyksXG4gICAgICAgICAgICBtb250aDogdG9JbnQobWF0Y2gyKSxcbiAgICAgICAgICAgIGRheTogdG9JbnQobWF0Y2gxKVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gZGRkXG4gICAgICAgICAgICByZWdleHA6IG5ldyBSZWdFeHAoXCJeKFwiICsgI3tEQVlOQU1FUy5qb2luKCd8Jyl9ICsgXCIpJFwiLCAnaScpLFxuICAgICAgICAgICAgeWVhcjogY3VycmVudF95ZWFyLFxuICAgICAgICAgICAgbW9udGg6IGN1cnJlbnRfbW9udGgsXG4gICAgICAgICAgICBkYXk6IGZyb21EYXlOYW1lKG1hdGNoMSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIG1vbnRobmFtZSBkYXludW1iZXIgWVlZWVxuICAgICAgICAgICAgcmVnZXhwOiBuZXcgUmVnRXhwKFwiXihcIiArIGZ1bGxfbW9udGhfbmFtZV9yZWdleHAgKyBcIilbXFxcXHNcXFxcLlxcXFwvXFxcXC1dKFxcXFxkezEsMn0pKHRofG5kfHJkKVtcXFxcc1xcXFwuXFxcXC9cXFxcLV0oXFxcXC0/XFxcXGR7Myw0fSkkXCIsIFwiaVwiKSxcbiAgICAgICAgICAgIHllYXI6IHRvSW50KG1hdGNoNCksXG4gICAgICAgICAgICBtb250aDogZnJvbUZ1bGxNb250aE5hbWUobWF0Y2gxKSxcbiAgICAgICAgICAgIGRheTogdG9JbnQobWF0Y2gyKVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gbW9udGhuYW1lIGRheW51bWJlclxuICAgICAgICAgICAgcmVnZXhwOiBuZXcgUmVnRXhwKFwiXihcIiArIGZ1bGxfbW9udGhfbmFtZV9yZWdleHAgKyBcIilbXFxcXHNcXFxcLlxcXFwvXFxcXC1dKFxcXFxkezEsMn0pKHRofG5kfHJkKVwiLCBcImlcIiksXG4gICAgICAgICAgICB5ZWFyOiBjdXJyZW50X3llYXIsXG4gICAgICAgICAgICBtb250aDogZnJvbUZ1bGxNb250aE5hbWUobWF0Y2gxKSxcbiAgICAgICAgICAgIGRheTogdG9JbnQobWF0Y2gyKVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gZGF5bnVtYmVyIG1vbnRobmFtZSBZWVlZXG4gICAgICAgICAgICByZWdleHA6IG5ldyBSZWdFeHAoXCJeKFxcXFxkezEsMn0pKHRofG5kfHJkKVtcXFxcc1xcXFwuXFxcXC9cXFxcLV0oXCIgKyBmdWxsX21vbnRoX25hbWVfcmVnZXhwICsgXCIpW1xcXFxzXFxcXC5cXFxcL1xcXFwtXShcXFxcLT9cXFxcZHszLDR9KSRcIiwgXCJpXCIpLFxuICAgICAgICAgICAgeWVhcjogdG9JbnQobWF0Y2g0KSxcbiAgICAgICAgICAgIG1vbnRoOiBmcm9tRnVsbE1vbnRoTmFtZShtYXRjaDMpLFxuICAgICAgICAgICAgZGF5OiB0b0ludChtYXRjaDEpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBZWVlZIG1vbnRobmFtZSBkYXludW1iZXJcbiAgICAgICAgICAgIHJlZ2V4cDogbmV3IFJlZ0V4cChcIl4oXFxcXC0/XFxcXGR7Myw0fSlbXFxcXHNcXFxcLlxcXFwvXFxcXC1dKFwiICsgZnVsbF9tb250aF9uYW1lX3JlZ2V4cCArIFwiKVtcXFxcc1xcXFwuXFxcXC9cXFxcLV0oXFxcXGR7MSwyfSkodGh8bmR8cmQpJFwiLCBcImlcIiksXG4gICAgICAgICAgICB5ZWFyOiB0b0ludChtYXRjaDEpLFxuICAgICAgICAgICAgbW9udGg6IGZyb21GdWxsTW9udGhOYW1lKG1hdGNoMiksXG4gICAgICAgICAgICBkYXk6IHRvSW50KG1hdGNoMylcbiAgICAgICAgICB9XG4gICAgICAgIF1cblxuICAgICAgICB2YXIgcnVsZSwgaSwgbWF0Y2g7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcnVsZSA9IHJ1bGVzW2ldO1xuICAgICAgICAgIG1hdGNoID0gcnVsZS5yZWdleHAuZXhlYyhzdHJpbmcpO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIHllYXIgPSBydWxlLnllYXI7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHllYXIpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHllYXIgPSB5ZWFyKG1hdGNoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1vbnRoID0gcnVsZS5tb250aDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YobW9udGgpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIG1vbnRoID0gbW9udGgobWF0Y2gpIC0gMVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF5ID0gcnVsZS5kYXk7XG4gICAgICAgICAgICBpZiAodHlwZW9mKGRheSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgZGF5ID0gZGF5KG1hdGNoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xuXG4gICAgICAgICAgICAvLyBhbiBlZGdlIGNhc2UsIEpTIGNhbid0IGhhbmRsZSAnbmV3IERhdGUoMSknLCBtaW5pbWFsIHllYXIgaXMgMTk3MFxuICAgICAgICAgICAgaWYgKHllYXIgPj0gMCAmJiB5ZWFyIDw9IDE5NzApIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnNldEZ1bGxZZWFyKHllYXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gI3t3cmFwIGByZXN1bHRgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdpbnZhbGlkIGRhdGUnXG4gICAgZW5kXG5cbiAgICBkZWYgdG9kYXlcbiAgICAgIHdyYXAgYG5ldyBEYXRlKClgXG4gICAgZW5kXG5cbiAgICBkZWYgZ3JlZ29yaWFuX2xlYXA/KHllYXIpXG4gICAgICBgKG5ldyBEYXRlKCN7eWVhcn0sIDEsIDI5KS5nZXRNb250aCgpLTEpID09PSAwYFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSh5ZWFyID0gLTQ3MTIsIG1vbnRoID0gMSwgZGF5ID0gMSwgc3RhcnQgPSBJVEFMWSlcbiAgICAleHtcbiAgICAgIC8vIEJlY2F1c2Ugb2YgR3JlZ29yaWFuIHJlZm9ybSBjYWxlbmRhciBnb2VzIGZyb20gMTU4Mi0xMC0wNCB0byAxNTgyLTEwLTE1LlxuICAgICAgLy8gQWxsIGRheXMgaW4gYmV0d2VlbiBlbmQgdXAgYXMgNCBvY3RvYmVyLlxuICAgICAgaWYgKHllYXIgPT09IDE1ODIgJiYgbW9udGggPT09IDEwICYmIGRheSA+IDQgJiYgZGF5IDwgMTUpIHtcbiAgICAgICAgZGF5ID0gNDtcbiAgICAgIH1cbiAgICB9XG4gICAgQGRhdGUgPSBgbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpYFxuICBlbmRcblxuICBkZWYgLShkYXRlKVxuICAgICV4e1xuICAgICAgaWYgKGRhdGUuJCRpc19udW1iZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICN7Y2xvbmV9O1xuICAgICAgICByZXN1bHQuZGF0ZS5zZXREYXRlKCN7QGRhdGV9LmdldERhdGUoKSAtIGRhdGUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZGF0ZS5kYXRlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKCgje0BkYXRlfSAtICN7ZGF0ZX0uZGF0ZSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiArKGRhdGUpXG4gICAgJXh7XG4gICAgICBpZiAoZGF0ZS4kJGlzX251bWJlcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gI3tjbG9uZX07XG4gICAgICAgIHJlc3VsdC5kYXRlLnNldERhdGUoI3tAZGF0ZX0uZ2V0RGF0ZSgpICsgZGF0ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3J9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDwob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgYSA9ICN7QGRhdGV9LCBiID0gI3tvdGhlcn0uZGF0ZTtcbiAgICAgIGEuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICBiLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGEgPCBiO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIGEgPSAje0BkYXRlfSwgYiA9ICN7b3RoZXJ9LmRhdGU7XG4gICAgICBhLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgYi5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBhIDw9IGI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBhID0gI3tAZGF0ZX0sIGIgPSAje290aGVyfS5kYXRlO1xuICAgICAgYS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIGIuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICByZXR1cm4gYSA+IGI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgYSA9ICN7QGRhdGV9LCBiID0gI3tvdGhlcn0uZGF0ZTtcbiAgICAgIGEuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICBiLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgcmV0dXJuIGEgPj0gYjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuICN7amQgPD0+IG90aGVyfVxuICAgICAgfVxuXG4gICAgICBpZiAoI3tEYXRlID09PSBvdGhlcn0pIHtcbiAgICAgICAgdmFyIGEgPSAje0BkYXRlfSwgYiA9ICN7b3RoZXJ9LmRhdGU7XG4gICAgICAgIGEuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgIGIuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG5cbiAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPj4obilcbiAgICAleHtcbiAgICAgIGlmICghbi4kJGlzX251bWJlcikge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvcn07XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSAje2Nsb25lfSwgZGF0ZSA9IHJlc3VsdC5kYXRlLCBjdXIgPSBkYXRlLmdldERhdGUoKTtcbiAgICAgIGRhdGUuc2V0RGF0ZSgxKTtcbiAgICAgIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgbik7XG4gICAgICBkYXRlLnNldERhdGUoTWF0aC5taW4oY3VyLCBkYXlzX2luX21vbnRoKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpKSkpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PChuKVxuICAgICV4e1xuICAgICAgaWYgKCFuLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7c2VsZiA+PiBgLW5gfTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGVxbD8gPT1cblxuICBkZWYgY2xvbmVcbiAgICBEYXRlLndyYXAoYG5ldyBEYXRlKCN7QGRhdGV9LmdldFRpbWUoKSlgKVxuICBlbmRcblxuICBkZWYgZGF5XG4gICAgYCN7QGRhdGV9LmdldERhdGUoKWBcbiAgZW5kXG5cbiAgZGVmIGZyaWRheT9cbiAgICB3ZGF5ID09IDVcbiAgZW5kXG5cbiAgZGVmIGpkXG4gICAgJXh7XG4gICAgLy9BZGFwdGVkIGZyb20gaHR0cDovL3d3dy5waHlzaWNzLnNmYXN1LmVkdS9hc3Ryby9qYXZhc2NyaXB0L2p1bGlhbmRheS5odG1sXG5cbiAgICB2YXIgbW0gPSAje0BkYXRlfS5nZXRNb250aCgpICsgMSxcbiAgICAgICAgZGQgPSAje0BkYXRlfS5nZXREYXRlKCksXG4gICAgICAgIHl5ID0gI3tAZGF0ZX0uZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgaHIgPSAxMiwgbW4gPSAwLCBzYyA9IDAsXG4gICAgICAgIGdnZywgcywgYSwgajEsIGpkO1xuXG4gICAgaHIgPSBociArIChtbiAvIDYwKSArIChzYy8zNjAwKTtcblxuICAgIGdnZyA9IDE7XG4gICAgaWYgKHl5IDw9IDE1ODUpIHtcbiAgICAgIGdnZyA9IDA7XG4gICAgfVxuXG4gICAgamQgPSAtMSAqIE1hdGguZmxvb3IoNyAqIChNYXRoLmZsb29yKChtbSArIDkpIC8gMTIpICsgeXkpIC8gNCk7XG5cbiAgICBzID0gMTtcbiAgICBpZiAoKG1tIC0gOSkgPCAwKSB7XG4gICAgICBzID0tIDE7XG4gICAgfVxuXG4gICAgYSA9IE1hdGguYWJzKG1tIC0gOSk7XG4gICAgajEgPSBNYXRoLmZsb29yKHl5ICsgcyAqIE1hdGguZmxvb3IoYSAvIDcpKTtcbiAgICBqMSA9IC0xICogTWF0aC5mbG9vcigoTWF0aC5mbG9vcihqMSAvIDEwMCkgKyAxKSAqIDMgLyA0KTtcblxuICAgIGpkID0gamQgKyBNYXRoLmZsb29yKDI3NSAqIG1tIC8gOSkgKyBkZCArIChnZ2cgKiBqMSk7XG4gICAgamQgPSBqZCArIDE3MjEwMjcgKyAyICogZ2dnICsgMzY3ICogeXkgLSAwLjU7XG4gICAgamQgPSBqZCArIChociAvIDI0KTtcblxuICAgIHJldHVybiBqZDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBqdWxpYW4/XG4gICAgYCN7QGRhdGV9IDwgbmV3IERhdGUoMTU4MiwgMTAgLSAxLCAxNSwgMTIpYFxuICBlbmRcblxuICBkZWYgbW9uZGF5P1xuICAgIHdkYXkgPT0gMVxuICBlbmRcblxuICBkZWYgbW9udGhcbiAgICBgI3tAZGF0ZX0uZ2V0TW9udGgoKSArIDFgXG4gIGVuZFxuXG4gIGRlZiBuZXh0XG4gICAgc2VsZiArIDFcbiAgZW5kXG5cbiAgZGVmIG5leHRfZGF5KG4gPSAxKVxuICAgIHNlbGYgKyBuXG4gIGVuZFxuXG4gIGRlZiBuZXh0X21vbnRoKG4gPSAxKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9ICN7Y2xvbmV9LCBkYXRlID0gcmVzdWx0LmRhdGUsIGN1ciA9IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgZGF0ZS5zZXREYXRlKDEpO1xuICAgICAgZGF0ZS5zZXRNb250aChkYXRlLmdldE1vbnRoKCkgKyBuKTtcbiAgICAgIGRhdGUuc2V0RGF0ZShNYXRoLm1pbihjdXIsIGRheXNfaW5fbW9udGgoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkpKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5leHRfeWVhcih5ZWFycyA9IDEpXG4gICAgc2VsZi5jbGFzcy5uZXcoeWVhciArIHllYXJzLCBtb250aCwgZGF5KVxuICBlbmRcblxuICBkZWYgcHJldl9kYXkobiA9IDEpXG4gICAgc2VsZiAtIG5cbiAgZW5kXG5cbiAgZGVmIHByZXZfbW9udGgobiA9IDEpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gI3tjbG9uZX0sIGRhdGUgPSByZXN1bHQuZGF0ZSwgY3VyID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgICBkYXRlLnNldERhdGUoMSk7XG4gICAgICBkYXRlLnNldE1vbnRoKGRhdGUuZ2V0TW9udGgoKSAtIG4pO1xuICAgICAgZGF0ZS5zZXREYXRlKE1hdGgubWluKGN1ciwgZGF5c19pbl9tb250aChkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSkpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHJldl95ZWFyKHllYXJzID0gMSlcbiAgICBzZWxmLmNsYXNzLm5ldyh5ZWFyIC0geWVhcnMsIG1vbnRoLCBkYXkpXG4gIGVuZFxuXG4gIGRlZiBzYXR1cmRheT9cbiAgICB3ZGF5ID09IDZcbiAgZW5kXG5cbiAgZGVmIHN0cmZ0aW1lKGZvcm1hdCA9ICcnKVxuICAgICV4e1xuICAgICAgaWYgKGZvcm1hdCA9PSAnJykge1xuICAgICAgICByZXR1cm4gI3t0b19zfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7QGRhdGV9LiRzdHJmdGltZSgje2Zvcm1hdH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc3VjYyBuZXh0XG5cbiAgZGVmIHN1bmRheT9cbiAgICB3ZGF5ID09IDBcbiAgZW5kXG5cbiAgZGVmIHRodXJzZGF5P1xuICAgIHdkYXkgPT0gNFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgICV4e1xuICAgICAgdmFyIGQgPSAje0BkYXRlfSwgeWVhciA9IGQuZ2V0RnVsbFllYXIoKSwgbW9udGggPSBkLmdldE1vbnRoKCkgKyAxLCBkYXkgPSBkLmdldERhdGUoKTtcbiAgICAgIGlmIChtb250aCA8IDEwKSB7IG1vbnRoID0gJzAnICsgbW9udGg7IH1cbiAgICAgIGlmIChkYXkgPCAxMCkgeyBkYXkgPSAnMCcgKyBkYXk7IH1cbiAgICAgIHJldHVybiB5ZWFyICsgJy0nICsgbW9udGggKyAnLScgKyBkYXk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fdGltZVxuICAgIFRpbWUubmV3KHllYXIsIG1vbnRoLCBkYXkpXG4gIGVuZFxuXG4gIGRlZiB0b19uXG4gICAgQGRhdGVcbiAgZW5kXG5cbiAgZGVmIHR1ZXNkYXk/XG4gICAgd2RheSA9PSAyXG4gIGVuZFxuXG4gIGRlZiBzdGVwKGxpbWl0LCBzdGVwID0gMSwgJmJsb2NrKVxuICAgIHN0ZXBzX2NvdW50ID0gKGxpbWl0IC0gc2VsZikudG9faVxuXG4gICAgc3RlcHMgPSBpZiBzdGVwc19jb3VudCAqIHN0ZXAgPCAwXG4gICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICBlbHNpZiBzdGVwc19jb3VudCA8IDBcbiAgICAgICAgICAgICAgKDAuLi1zdGVwc19jb3VudCkuc3RlcChzdGVwLmFicykubWFwKCY6LUApIC5yZXZlcnNlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICgwLi5zdGVwc19jb3VudCkuc3RlcChzdGVwLmFicylcbiAgICAgICAgICAgIGVuZFxuXG4gICAgcmVzdWx0ID0gc3RlcHMubWFwIHsgfGl8IHNlbGYgKyBpIH1cblxuXG4gICAgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXN1bHQuZWFjaCB7IHxpfCB5aWVsZChpKSB9XG4gICAgICBzZWxmXG4gICAgZWxzZVxuICAgICAgcmVzdWx0XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB1cHRvKG1heCwgJmJsb2NrKVxuICAgIHN0ZXAobWF4LCAxLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBkb3dudG8obWluLCAmYmxvY2spXG4gICAgc3RlcChtaW4sIC0xLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB3ZGF5XG4gICAgYCN7QGRhdGV9LmdldERheSgpYFxuICBlbmRcblxuICBkZWYgd2VkbmVzZGF5P1xuICAgIHdkYXkgPT0gM1xuICBlbmRcblxuICBkZWYgeWVhclxuICAgIGAje0BkYXRlfS5nZXRGdWxsWWVhcigpYFxuICBlbmRcblxuICBkZWYgY3dkYXlcbiAgICBgI3tAZGF0ZX0uZ2V0RGF5KCkgfHwgN2BcbiAgZW5kXG5cbiAgZGVmIGN3ZWVrXG4gICAgJXh7XG4gICAgICB2YXIgZCA9IG5ldyBEYXRlKCN7QGRhdGV9KTtcbiAgICAgIGQuc2V0SG91cnMoMCwwLDApO1xuICAgICAgZC5zZXREYXRlKGQuZ2V0RGF0ZSgpKzQtKGQuZ2V0RGF5KCl8fDcpKTtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwoKCgoZC1uZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksMCwxKSkvOC42NGU3KSsxKS83KTtcbiAgICB9XG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIGRheXNfaW5fbW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgIHZhciBsZWFwID0gKCh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwKTtcbiAgICAgIHJldHVybiBbMzEsIChsZWFwID8gMjkgOiAyOCksIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVttb250aF1cbiAgICB9XG4gIH1cbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiaW5jbHVkZSIsImluaXRpYWxpemUiLCIxIiwiQGQiLCJkIiwiPD0+IiwiMCIsImF0dHJfcmVhZGVyIiwiemVybz8iLCJmaW5pdGU/IiwiaW5maW5pdGU/Iiwibm9uemVybz8iLCJuYW4/IiwiYWJzIiwic2VsZiIsIm5ldyIsIi1AIiwiK0AiLCJvdGhlciIsImNvZXJjZSIsImwiLCJyIiwidG9fZiIsIj09IiwiPiIsIjIyOTkxNjEiLCIyMzYxMjIyIiwiKyIsIndyYXAiLCJpbnN0YW5jZSIsImFsbG9jYXRlIiwibmF0aXZlJCIsInBhcnNlIiwiY29tcGFjdCIsImpvaW4iLCJtYXAiLCJkb3duY2FzZSIsInJhaXNlIiwidG9kYXkiLCJncmVnb3JpYW5fbGVhcD8iLCJ5ZWFyIiwiLTQ3MTIiLCJAZGF0ZSIsIi0iLCJjbG9uZSIsImRhdGUiLCI8IiwiPD0iLCI+PSIsImpkIiwiPT09IiwiPj4iLCI8PCIsImRheSIsImZyaWRheT8iLCJ3ZGF5IiwiNSIsImp1bGlhbj8iLCJtb25kYXk/IiwibW9udGgiLCJuZXh0IiwibmV4dF9kYXkiLCJuIiwibmV4dF9tb250aCIsIm5leHRfeWVhciIsInllYXJzIiwicHJldl9kYXkiLCJwcmV2X21vbnRoIiwicHJldl95ZWFyIiwic2F0dXJkYXk/IiwiNiIsInN0cmZ0aW1lIiwidG9fcyIsImZvcm1hdCIsInN1bmRheT8iLCJ0aHVyc2RheT8iLCI0IiwidG9fdGltZSIsInRvX24iLCJ0dWVzZGF5PyIsIjIiLCJzdGVwIiwic3RlcHNfY291bnQiLCJsaW1pdCIsInRvX2kiLCJzdGVwcyIsIioiLCJyZXZlcnNlIiwicmVzdWx0IiwiaSIsImJsb2NrX2dpdmVuPyIsImVhY2giLCJ1cHRvIiwibWF4IiwiYmxvY2siLCJkb3dudG8iLCJtaW4iLCItMSIs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LE9BQUdiLFNBQU07QUFEWGEsSUFBQUEsQ0FBQUEsMkJBQUFBLENBMW9CQTtBQUFBO0FBOG9CQTJDLElBQUFBLDhCQUFBQSwwQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsV0FBQTNDLE1BQUFBLENBQUFBLENBQUFoQyxPQUFBQSxDQUFRNEUsQ0FBUjVFO0FBREYyRSxJQUFBQSxDQUFBQSxxQ0FBQUEsQ0E5b0JBO0FBQUE7QUFrcEJBMUQsSUFBQUEsd0JBQUFBLGdCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBR0UsU0FBTTtBQURYRixJQUFBQSxDQUFBQSwyQkFBQUEsQ0FscEJBO0FBQUE7QUFzcEJBNEQsSUFBQUEseUJBQUFBLGlCQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBRzFELFNBQU07QUFEWDBELElBQUFBLENBQUFBLDRCQUFBQSxDQXRwQkE7QUFBQTtBQTBwQkFDLElBQUFBLHlCQUFBQSxpQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGLHVCQUF5QjNELFNBQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFORTJELElBQUFBLENBQUFBLDRCQUFBQSxDQTFwQkE7QUFBQTtBQW9xQkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQXhxQkU7QUFERnRHLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjU2MDUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL3RvZG8ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyEvdXNyL2Jpbi9lbnYgcnVieVxuXG4jIHRvZG8ucmIgLSB0b2RvIGxpc3QgbWFuYWdlciBpbnNwaXJlZCBieSB0b2RvLnR4dCB1c2luZyB0aGUganNvbmwgZm9ybWF0LlxuI1xuIyBDb3B5cmlnaHQgKGMpIDIwMjAtMjAyMSBHYWJvciBCYXRhXG4jXG4jIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4jIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4jICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiMgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiMgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiMgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiMgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4jXG4jIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4jIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuI1xuIyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuIyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiMgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiMgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuIyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiMgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiMgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuIyBTT0ZUV0FSRS5cblxucmVxdWlyZSAnLi9qc29uLnJiJ1xucmVxdWlyZSAnLi9kYXRlLnJiJ1xuXG5jbGFzcyBUb2RvXG5cbiAgQ09MT1JfQ09ERVMgPSB7XG4gICAgYmxhY2s6ICAgMzAsXG4gICAgcmVkOiAgICAgMzEsXG4gICAgZ3JlZW46ICAgMzIsXG4gICAgeWVsbG93OiAgMzMsXG4gICAgYmx1ZTogICAgMzQsXG4gICAgbWFnZW50YTogMzUsXG4gICAgY3lhbjogICAgMzYsXG4gICAgd2hpdGU6ICAgMzdcbiAgfVxuXG4gIFNUQVRFUyA9IHtcbiAgICAnbmV3JyAgICAgPT4gJ1sgXScsXG4gICAgJ2RvbmUnICAgID0+ICdbeF0nLFxuICAgICdzdGFydGVkJyA9PiAnWz5dJyxcbiAgICAnYmxvY2tlZCcgPT4gJ1shXScsXG4gICAgJ2RlZmF1bHQnID0+ICdbP10nXG4gIH1cblxuICBPUkRFUiA9IHtcbiAgICAnbmV3JyAgICAgPT4gMyxcbiAgICAnZG9uZScgICAgPT4gNCxcbiAgICAnc3RhcnRlZCcgPT4gMixcbiAgICAnYmxvY2tlZCcgPT4gMSxcbiAgICAnZGVmYXVsdCcgPT4gMTAwXG4gIH1cblxuICBDT0xPUlMgPSB7XG4gICAgJ25ldycgICAgID0+IDp3aGl0ZSxcbiAgICAnZG9uZScgICAgPT4gOmJsdWUsXG4gICAgJ3N0YXJ0ZWQnID0+IDpncmVlbixcbiAgICAnYmxvY2tlZCcgPT4gOnllbGxvdyxcbiAgICAnZGVmYXVsdCcgPT4gOm1hZ2VudGFcbiAgfVxuXG4gIERBVEVfRk9STUFUID0gJyVZLSVtLSVkJ1xuICBEVUVfREFURV9EQVlTX1NJTVBMRSA9IFsndG9kYXknLCAndG9tb3Jyb3cnXVxuICBEVUVfREFURV9UQUdfUEFUVEVSTiA9IC8oXnwgKWR1ZTooW2EtekEtWjAtOS1dKykvXG4gIENPTlRFWFRfVEFHX1BBVFRFUk4gPSAvKF58IClbQCtdW1xcdy1dKy9cbiAgUFJJT1JJVFlfRkxBRyA9ICcqJ1xuICBUT0RPX0ZJTEUgPSBcInRvZG8uanNvbmxcIlxuICBcbiAgZGVmIGV4ZWN1dGUoYXJndW1lbnRzKVxuICAgIEB0ZXh0X2J1ZmZlciA9IFtdXG4gICAgYmVnaW5cbiAgICAgIHNldHVwXG4gICAgICBhY3Rpb24gPSBhcmd1bWVudHMuZmlyc3RcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHNbMS4uLTFdIHx8IFtdXG4gICAgICBjYXNlIGFjdGlvblxuICAgICAgd2hlbiAnYWRkJ1xuICAgICAgICByYWlzZSBhY3Rpb24gKyAnIGNvbW1hbmQgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIHBhcmFtZXRlcicgaWYgYXJncy5uaWw/IHx8IGFyZ3MuZW1wdHk/XG4gICAgICAgIGFkZChhcmdzLmpvaW4oJyAnKSlcbiAgICAgIHdoZW4gJ3N0YXJ0J1xuICAgICAgICBhcmdzLmxlbmd0aCA+IDAgPyBjaGFuZ2Vfc3RhdGUoYXJncy5maXJzdC50b19pLCAnc3RhcnRlZCcsIChhcmdzWzEuLi0xXSB8fCBbXSkuam9pbignICcpKSA6IGxpc3QobmlsLCBbJzpzdGFydGVkJ10pXG4gICAgICB3aGVuICdkb25lJ1xuICAgICAgICBhcmdzLmxlbmd0aCA+IDAgPyBjaGFuZ2Vfc3RhdGUoYXJncy5maXJzdC50b19pLCAnZG9uZScsIChhcmdzWzEuLi0xXSB8fCBbXSkuam9pbignICcpKSA6IGxpc3QobmlsLCBbJzpkb25lJ10pXG4gICAgICB3aGVuICdibG9jaydcbiAgICAgICAgYXJncy5sZW5ndGggPiAwID8gY2hhbmdlX3N0YXRlKGFyZ3MuZmlyc3QudG9faSwgJ2Jsb2NrZWQnLCAoYXJnc1sxLi4tMV0gfHwgW10pLmpvaW4oJyAnKSkgOiBsaXN0KG5pbCwgWyc6YmxvY2tlZCddKVxuICAgICAgd2hlbiAncmVzZXQnXG4gICAgICAgIGFyZ3MubGVuZ3RoID4gMCA/IGNoYW5nZV9zdGF0ZShhcmdzLmZpcnN0LnRvX2ksICduZXcnLCAoYXJnc1sxLi4tMV0gfHwgW10pLmpvaW4oJyAnKSkgOiBsaXN0KG5pbCwgWyc6bmV3J10pXG4gICAgICB3aGVuICdwcmlvJ1xuICAgICAgICByYWlzZSBhY3Rpb24gKyAnIGNvbW1hbmQgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIHBhcmFtZXRlcicgaWYgYXJncy5sZW5ndGggPCAxXG4gICAgICAgIHNldF9wcmlvcml0eShhcmdzLmZpcnN0LnRvX2ksIChhcmdzWzEuLi0xXSB8fCBbXSkuam9pbignICcpKVxuICAgICAgd2hlbiAnZHVlJ1xuICAgICAgICByYWlzZSBhY3Rpb24gKyAnIGNvbW1hbmQgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIHBhcmFtZXRlcicgaWYgYXJncy5sZW5ndGggPCAxXG4gICAgICAgIGR1ZV9kYXRlKGFyZ3MuZmlyc3QudG9faSwgKGFyZ3NbMS4uLTFdIHx8IFtdKS5qb2luKCcgJykpXG4gICAgICB3aGVuICdhcHBlbmQnXG4gICAgICAgIHJhaXNlIGFjdGlvbiArICcgY29tbWFuZCByZXF1aXJlcyBhdCBsZWFzdCB0d28gcGFyYW1ldGVycycgaWYgYXJncy5sZW5ndGggPCAyXG4gICAgICAgIGFwcGVuZChhcmdzLmZpcnN0LnRvX2ksIGFyZ3NbMS4uLTFdLmpvaW4oJyAnKSlcbiAgICAgIHdoZW4gJ3JlbmFtZSdcbiAgICAgICAgcmFpc2UgYWN0aW9uICsgJyBjb21tYW5kIHJlcXVpcmVzIGF0IGxlYXN0IHR3byBwYXJhbWV0ZXJzJyBpZiBhcmdzLmxlbmd0aCA8IDJcbiAgICAgICAgcmVuYW1lKGFyZ3MuZmlyc3QudG9faSwgYXJnc1sxLi4tMV0uam9pbignICcpKVxuICAgICAgd2hlbiAnZGVsJ1xuICAgICAgICByYWlzZSBhY3Rpb24gKyAnIGNvbW1hbmQgcmVxdWlyZXMgZXhhY3RseSBvbmUgcGFyYW1ldGVyJyBpZiBhcmdzLmxlbmd0aCAhPSAxXG4gICAgICAgIGRlbGV0ZShhcmdzLmZpcnN0LnRvX2kpXG4gICAgICB3aGVuICdub3RlJ1xuICAgICAgICByYWlzZSBhY3Rpb24gKyAnIGNvbW1hbmQgcmVxdWlyZXMgYXQgbGVhc3QgdHdvIHBhcmFtZXRlcnMnIGlmIGFyZ3MubGVuZ3RoIDwgMlxuICAgICAgICBhZGRfbm90ZShhcmdzLmZpcnN0LnRvX2ksIGFyZ3NbMS4uLTFdLmpvaW4oJyAnKSlcbiAgICAgIHdoZW4gJ2RlbG5vdGUnXG4gICAgICAgIHJhaXNlIGFjdGlvbiArICcgY29tbWFuZCByZXF1aXJlcyBleGFjdGx5IG9uZSBwYXJhbWV0ZXInIGlmIGFyZ3MubGVuZ3RoICE9IDFcbiAgICAgICAgZGVsZXRlX25vdGUoYXJncy5maXJzdC50b19pKVxuICAgICAgd2hlbiAnbGlzdCdcbiAgICAgICAgbGlzdChuaWwsIGFyZ3MpXG4gICAgICB3aGVuICdzaG93J1xuICAgICAgICByYWlzZSBhY3Rpb24gKyAnIGNvbW1hbmQgcmVxdWlyZXMgZXhhY3RseSBvbmUgcGFyYW1ldGVyJyBpZiBhcmdzLmxlbmd0aCAhPSAxXG4gICAgICAgIHNob3coYXJncy5maXJzdC50b19pKVxuICAgICAgd2hlbiAnaGVscCdcbiAgICAgICAgcmFpc2UgYWN0aW9uICsgJyBjb21tYW5kIGhhcyBubyBwYXJhbWV0ZXJzJyBpZiBhcmdzLmxlbmd0aCA+IDBcbiAgICAgICAgQHRleHRfYnVmZmVyLnB1c2ggdXNhZ2Uuc3RyaXBcbiAgICAgIGVsc2VcbiAgICAgICAgbGlzdChuaWwsIGFyZ3VtZW50cylcbiAgICAgIGVuZFxuICAgIHJlc2N1ZSA9PiBlcnJvclxuICAgICAgQHRleHRfYnVmZmVyLnB1c2ggXCIje2NvbG9yaXplKCdFUlJPUjonLCA6cmVkKX0gI3tlcnJvcn1cIlxuICAgIGVuZFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICAoQHRleHRfYnVmZmVyIHx8IFtdKS5qb2luKFwiXFxuXCIpICsgXCJcXG5cIlxuICBlbmRcblxuICBkZWYgdG9faHRtbFxuICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCJvdXRwdXRcIj4nICsgdG9fcy5cbiAgICAgIGdzdWIoJyYnLCAnJmFtcDsnKS5cbiAgICAgIGdzdWIoJzwnLCAnJmx0OycpLlxuICAgICAgZ3N1YignPicsICcmZ3Q7JykuXG4gICAgICBnc3ViKCcgJywgJyZuYnNwOycpLlxuICAgICAgZ3N1YihcIlxcblwiLCAnPGJyPicpLlxuICAgICAgZ3N1YigvXFxlXFxbMG0vLCAnPC9zcGFuPicpLlxuICAgICAgZ3N1YigvXFxlXFxbKFxcZCspbS8sICc8c3BhbiBjbGFzcz1cImNvbG9yIGNvbG9yLVxcMVwiPicpICsgJzwvc3Bhbj4nXG4gIGVuZFxuXG4gIHByaXZhdGVcblxuICBkZWYgdXNhZ2VcbiAgICA8PH5VU0FHRVxuICAgICAgVXNhZ2U6IHRvZG8gPGNvbW1hbmQ+IDxhcmd1bWVudHM+XG5cbiAgICAgIENvbW1hbmRzOlxuICAgICAgKiBhZGQgPHRleHQ+ICAgICAgICAgICAgICAgICAgICAgYWRkIG5ldyB0YXNrXG4gICAgICAqIHN0YXJ0IDx0YXNrbnVtYmVyPiBbdGV4dF0gICAgICBtYXJrIHRhc2sgYXMgc3RhcnRlZCwgd2l0aCBvcHRpb25hbCBub3RlXG4gICAgICAqIGRvbmUgPHRhc2tudW1iZXI+IFt0ZXh0XSAgICAgICBtYXJrIHRhc2sgYXMgY29tcGxldGVkLCB3aXRoIG9wdGlvbmFsIG5vdGVcbiAgICAgICogYmxvY2sgPHRhc2tudW1iZXI+IFt0ZXh0XSAgICAgIG1hcmsgdGFzayBhcyBibG9ja2VkLCB3aXRoIG9wdGlvbmFsIG5vdGVcbiAgICAgICogcmVzZXQgPHRhc2tudW1iZXI+IFt0ZXh0XSAgICAgIHJlc2V0IHRhc2sgdG8gbmV3IHN0YXRlLCB3aXRoIG9wdGlvbmFsIG5vdGVcbiAgICAgICogcHJpbyA8dGFza251bWJlcj4gW3RleHRdICAgICAgIHRvZ2dsZSBoaWdoIHByaW9yaXR5IGZsYWcsIHdpdGggb3B0aW9uYWwgbm90ZVxuICAgICAgKiBkdWUgPHRhc2tudW1iZXI+IFtkYXRlXSAgICAgICAgc2V0L3Vuc2V0IGR1ZSBkYXRlIChpbiBZWVlZLU1NLUREIGZvcm1hdClcblxuICAgICAgKiBhcHBlbmQgPHRhc2tudW1iZXI+IDx0ZXh0PiAgICAgYXBwZW5kIHRleHQgdG8gdGFzayB0aXRsZVxuICAgICAgKiByZW5hbWUgPHRhc2tudW1iZXI+IDx0ZXh0PiAgICAgcmVuYW1lIHRhc2tcbiAgICAgICogZGVsIDx0YXNrbnVtYmVyPiAgICAgICAgICAgICAgIGRlbGV0ZSB0YXNrXG4gICAgICAqIG5vdGUgPHRhc2tudW1iZXI+IDx0ZXh0PiAgICAgICBhZGQgbm90ZSB0byB0YXNrXG4gICAgICAqIGRlbG5vdGUgPHRhc2tudW1iZXI+ICAgICAgICAgICBkZWxldGUgYWxsIG5vdGVzIGZyb20gdGFza1xuXG4gICAgICAqIGxpc3QgPHJlZ2V4PiBbcmVnZXguLi5dICAgICAgICBsaXN0IHRhc2tzIChvbmx5IGFjdGl2ZSB0YXNrcyBieSBkZWZhdWx0KVxuICAgICAgKiBzaG93IDx0YXNrbnVtYmVyPiAgICAgICAgICAgICAgc2hvdyBhbGwgdGFzayBkZXRhaWxzXG4gICAgICAqIGhlbHAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGhlbHAgc2NyZWVuXG5cbiAgICAgIFdpdGggbGlzdCBjb21tYW5kIHRoZSBmb2xsb3dpbmcgcHJlLWRlZmluZWQgcmVnZXggcGF0dGVybnMgY2FuIGJlIGFsc28gdXNlZDpcbiAgICAgICN7QHF1ZXJpZXMua2V5cy5qb2luKCcsICcpfVxuXG4gICAgICBEdWUgZGF0ZXMgY2FuIGJlIGFsc28gYWRkZWQgdmlhIHRhZ3MgaW4gdGFzayB0aXRsZTogXCJkdWU6WVlZWS1NTS1ERFwiXG5cbiAgICAgIExlZ2VuZDpcbiAgICAgICN7U1RBVEVTLnNlbGVjdCB7IHxrLCB2fCBrICE9ICdkZWZhdWx0JyB9Lm1hcCB7IHxrLCB2fCBcIiN7a30gI3t2fVwiIH0uam9pbignLCAnKSB9LCBwcmlvcml0eSAje1BSSU9SSVRZX0ZMQUd9XG5cbiAgICAgIExvY2FsIHN0b3JhZ2U6ICN7VE9ET19GSUxFfVxuICAgIFVTQUdFXG4gIGVuZFxuXG4gIGRlZiBzZXR1cFxuICAgIEB0b2RheSA9IERhdGUucGFyc2UoRGF0ZS50b2RheS5zdHJmdGltZShEQVRFX0ZPUk1BVCkpXG4gICAgbmV4dF83X2RheXMgPSAoMC4uNikubWFwIGRvIHxkYXl8IEB0b2RheSArIGRheSBlbmRcbiAgICBAZHVlX2RhdGVfZGF5cyA9IG5leHRfN19kYXlzLm1hcCBkbyB8ZGF5fCBkYXkuc3RyZnRpbWUoJyVBJykuZG93bmNhc2UgZW5kXG4gICAgZHVlX2RhdGVzX2Zvcl9xdWVyaWVzID0gbmV4dF83X2RheXMubWFwIGRvIHxkYXl8IGRheS5zdHJmdGltZShEQVRFX0ZPUk1BVCkgZW5kXG5cbiAgICBAcXVlcmllcyA9IHtcbiAgICAgICc6YWN0aXZlJyAgICA9PiAnc3RhdGU9KG5ld3xzdGFydGVkfGJsb2NrZWQpJyxcbiAgICAgICc6ZG9uZScgICAgICA9PiAnc3RhdGU9ZG9uZScsXG4gICAgICAnOmJsb2NrZWQnICAgPT4gJ3N0YXRlPWJsb2NrZWQnLFxuICAgICAgJzpzdGFydGVkJyAgID0+ICdzdGF0ZT1zdGFydGVkJyxcbiAgICAgICc6bmV3JyAgICAgICA9PiAnc3RhdGU9bmV3JyxcbiAgICAgICc6YWxsJyAgICAgICA9PiAnc3RhdGU9XFx3KycsXG4gICAgICAnOnRvZGF5JyAgICAgPT4gXCJkdWU9I3tkdWVfZGF0ZXNfZm9yX3F1ZXJpZXNbMF19XCIsXG4gICAgICAnOnRvbW9ycm93JyAgPT4gXCJkdWU9I3tkdWVfZGF0ZXNfZm9yX3F1ZXJpZXNbMV19XCIsXG4gICAgICAnOm5leHQ3ZGF5cycgPT4gXCJkdWU9KCN7ZHVlX2RhdGVzX2Zvcl9xdWVyaWVzLmpvaW4oJ3wnKX0pXCJcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsb2FkX3Rhc2tzKGl0ZW1fdG9fY2hlY2sgPSBuaWwpXG4gICAgY291bnQgPSAwXG4gICAgdGFza3MgPSB7fVxuICAgIFxuICAgIHRvZG9fanNvbmwgPSBgd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKCN7VE9ET19GSUxFfSkgfHwgJydgXG4gICAgaWYgIXRvZG9fanNvbmwuZW1wdHk/XG4gICAgICB0b2RvX2pzb25sLnNwbGl0KFwiXFxuXCIpLmVhY2ggZG8gfGxpbmV8XG4gICAgICAgIG5leHQgaWYgbGluZS5zdHJpcCA9PSAnJ1xuICAgICAgICBjb3VudCArPSAxXG4gICAgICAgIHRhc2tzW2NvdW50XSA9IEpTT04ucGFyc2UobGluZS5jaG9tcCwgOnN5bWJvbGl6ZV9uYW1lcyA9PiB0cnVlKVxuICAgICAgZW5kXG4gICAgZW5kXG4gICAgaWYgaXRlbV90b19jaGVjayAmJiAhdGFza3MuaGFzX2tleT8oaXRlbV90b19jaGVjaylcbiAgICAgIHJhaXNlIFwiI3tpdGVtX3RvX2NoZWNrfTogTm8gc3VjaCB0b2RvXCJcbiAgICBlbmRcbiAgICB0YXNrc1xuICBlbmRcblxuICBkZWYgd3JpdGVfdGFza3ModGFza3MpXG4gICAgdG9kb19qc29ubCA9IHRhc2tzLmtleXMuc29ydC5tYXAgZG8gfGtleXwgSlNPTi5nZW5lcmF0ZSh0YXNrc1trZXldKSBlbmQuam9pbihcIlxcblwiKSArIFwiXFxuXCJcbiAgICBgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKCN7VE9ET19GSUxFfSwgdG9kb19qc29ubClgXG4gIGVuZFxuXG4gIGRlZiBwb3N0cHJvY2Vzc190YWdzKHRhc2spXG4gICAgbWF0Y2hfZGF0YSA9IHRhc2tbOnRpdGxlXS5tYXRjaChEVUVfREFURV9UQUdfUEFUVEVSTilcbiAgICBpZiBtYXRjaF9kYXRhXG4gICAgICB0YXNrWzp0aXRsZV0gPSB0YXNrWzp0aXRsZV0uZ3N1YihEVUVfREFURV9UQUdfUEFUVEVSTiwgJycpXG4gICAgICB0YXNrWzpkdWVdID0gY29udmVydF9kdWVfZGF0ZShtYXRjaF9kYXRhWzJdKVxuICAgIGVuZFxuICAgIHJhaXNlICd0aXRsZSBtdXN0IG5vdCBiZSBlbXB0eScgaWYgdGFza1s6dGl0bGVdLmVtcHR5P1xuICBlbmRcblxuICBkZWYgYWRkKHRleHQpXG4gICAgdGFzayA9IHtcbiAgICAgIHN0YXRlOiAnbmV3JyxcbiAgICAgIHRpdGxlOiB0ZXh0LFxuICAgICAgbW9kaWZpZWQ6IEB0b2RheS5zdHJmdGltZShEQVRFX0ZPUk1BVClcbiAgICB9XG4gICAgcG9zdHByb2Nlc3NfdGFncyh0YXNrKVxuXG4gICAgdG9kb19qc29ubCA9IGB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oI3tUT0RPX0ZJTEV9KSB8fCAnJ2BcbiAgICB0b2RvX2pzb25sICs9IEpTT04uZ2VuZXJhdGUodGFzaykgKyBcIlxcblwiXG4gICAgYHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSgje1RPRE9fRklMRX0sIHRvZG9fanNvbmwpYFxuICAgIGxpc3RcbiAgZW5kXG5cbiAgZGVmIGFwcGVuZChpdGVtLCB0ZXh0ID0gJycpXG4gICAgdGFza3MgPSBsb2FkX3Rhc2tzKGl0ZW0pXG4gICAgdGFza3NbaXRlbV1bOnRpdGxlXSA9IFt0YXNrc1tpdGVtXVs6dGl0bGVdLCB0ZXh0XS5qb2luKCcgJylcbiAgICB0YXNrc1tpdGVtXVs6bW9kaWZpZWRdID0gQHRvZGF5LnN0cmZ0aW1lKERBVEVfRk9STUFUKVxuICAgIHBvc3Rwcm9jZXNzX3RhZ3ModGFza3NbaXRlbV0pXG4gICAgd3JpdGVfdGFza3ModGFza3MpXG4gICAgbGlzdCh0YXNrcylcbiAgZW5kXG5cbiAgZGVmIHJlbmFtZShpdGVtLCB0ZXh0KVxuICAgIHRhc2tzID0gbG9hZF90YXNrcyhpdGVtKVxuICAgIHRhc2tzW2l0ZW1dWzp0aXRsZV0gPSB0ZXh0XG4gICAgdGFza3NbaXRlbV1bOm1vZGlmaWVkXSA9IEB0b2RheS5zdHJmdGltZShEQVRFX0ZPUk1BVClcbiAgICBwb3N0cHJvY2Vzc190YWdzKHRhc2tzW2l0ZW1dKVxuICAgIHdyaXRlX3Rhc2tzKHRhc2tzKVxuICAgIGxpc3QodGFza3MpXG4gIGVuZFxuXG4gIGRlZiBkZWxldGUoaXRlbSlcbiAgICB0YXNrcyA9IGxvYWRfdGFza3MoaXRlbSlcbiAgICB0YXNrcy5kZWxldGUoaXRlbSlcbiAgICB3cml0ZV90YXNrcyh0YXNrcylcbiAgICBsaXN0XG4gIGVuZFxuXG4gIGRlZiBjaGFuZ2Vfc3RhdGUoaXRlbSwgc3RhdGUsIG5vdGUgPSBuaWwpXG4gICAgdGFza3MgPSBsb2FkX3Rhc2tzKGl0ZW0pXG4gICAgdGFza3NbaXRlbV1bOnN0YXRlXSA9IHN0YXRlXG4gICAgdGFza3NbaXRlbV1bOm1vZGlmaWVkXSA9IEB0b2RheS5zdHJmdGltZShEQVRFX0ZPUk1BVClcbiAgICBpZiAhbm90ZS5uaWw/ICYmICFub3RlLmVtcHR5P1xuICAgICAgdGFza3NbaXRlbV1bOm5vdGVdIHx8PSBbXVxuICAgICAgdGFza3NbaXRlbV1bOm5vdGVdLnB1c2gobm90ZSlcbiAgICBlbmRcbiAgICB3cml0ZV90YXNrcyh0YXNrcylcbiAgICBsaXN0KHRhc2tzKVxuICBlbmRcblxuICBkZWYgc2V0X3ByaW9yaXR5KGl0ZW0sIG5vdGUgPSBuaWwpXG4gICAgdGFza3MgPSBsb2FkX3Rhc2tzKGl0ZW0pXG4gICAgdGFza3NbaXRlbV1bOnByaW9yaXR5XSA9ICF0YXNrc1tpdGVtXVs6cHJpb3JpdHldXG4gICAgdGFza3NbaXRlbV0uZGVsZXRlKDpwcmlvcml0eSkgaWYgIXRhc2tzW2l0ZW1dWzpwcmlvcml0eV1cbiAgICB0YXNrc1tpdGVtXVs6bW9kaWZpZWRdID0gQHRvZGF5LnN0cmZ0aW1lKERBVEVfRk9STUFUKVxuICAgIGlmICFub3RlLm5pbD8gJiYgIW5vdGUuZW1wdHk/XG4gICAgICB0YXNrc1tpdGVtXVs6bm90ZV0gfHw9IFtdXG4gICAgICB0YXNrc1tpdGVtXVs6bm90ZV0ucHVzaChub3RlKVxuICAgIGVuZFxuICAgIHdyaXRlX3Rhc2tzKHRhc2tzKVxuICAgIGxpc3QodGFza3MpXG4gIGVuZFxuXG4gIGRlZiBkdWVfZGF0ZShpdGVtLCBkYXRlID0gJycpXG4gICAgdGFza3MgPSBsb2FkX3Rhc2tzKGl0ZW0pXG4gICAgdGFza3NbaXRlbV1bOmR1ZV0gPSBjb252ZXJ0X2R1ZV9kYXRlKGRhdGUpXG4gICAgdGFza3NbaXRlbV0uZGVsZXRlKDpkdWUpIGlmIHRhc2tzW2l0ZW1dWzpkdWVdLm5pbD9cbiAgICB0YXNrc1tpdGVtXVs6bW9kaWZpZWRdID0gQHRvZGF5LnN0cmZ0aW1lKERBVEVfRk9STUFUKVxuICAgIHdyaXRlX3Rhc2tzKHRhc2tzKVxuICAgIGxpc3QodGFza3MpXG4gIGVuZFxuXG4gIGRlZiBsaXN0KHRhc2tzID0gbmlsLCBwYXR0ZXJucyA9IG5pbClcbiAgICBpdGVtcyA9IHt9XG4gICAgdGFza3MgPSB0YXNrcyB8fCBsb2FkX3Rhc2tzXG4gICAgdGFza19pbmRlbnQgPSBbdGFza3Mua2V5cy5tYXgudG9fcy5zaXplLCA0XS5tYXhcbiAgICBwYXR0ZXJucyA9IHBhdHRlcm5zLm5pbD8gfHwgcGF0dGVybnMuZW1wdHk/ID8gW0BxdWVyaWVzWyc6YWN0aXZlJ11dIDogcGF0dGVybnNcbiAgICB0YXNrcy5lYWNoIGRvIHxudW0sIHRhc2t8XG4gICAgICBub3JtYWxpemVkX3Rhc2sgPSBcInN0YXRlPSN7dGFza1s6c3RhdGVdfSBkdWU9I3t0YXNrWzpkdWVdfSAje3Rhc2tbOnRpdGxlXX1cIlxuICAgICAgbWF0Y2ggPSB0cnVlXG4gICAgICBwYXR0ZXJucy5lYWNoIGRvIHxwYXR0ZXJufFxuICAgICAgICBtYXRjaCA9IGZhbHNlIHVubGVzcyAvI3tAcXVlcmllc1twYXR0ZXJuXSB8fCBwYXR0ZXJufS9peC5tYXRjaChub3JtYWxpemVkX3Rhc2spXG4gICAgICBlbmRcbiAgICAgIGl0ZW1zW251bV0gPSB0YXNrIGlmIG1hdGNoXG4gICAgZW5kXG4gICAgaXRlbXMgPSBpdGVtcy5zb3J0X2J5IGRvIHxudW0sIHRhc2t8XG4gICAgICBbdGFza1s6cHJpb3JpdHldICYmIHRhc2tbOnN0YXRlXSAhPSAnZG9uZScgPyAwIDogMSwgT1JERVJbdGFza1s6c3RhdGVdIHx8ICdkZWZhdWx0J10sIHRhc2tbOmR1ZV0gfHwgJ24vYScsIG51bV1cbiAgICBlbmRcbiAgICBpdGVtcy5lYWNoIGRvIHxudW0sIHRhc2t8XG4gICAgICBzdGF0ZSA9IHRhc2tbOnN0YXRlXSB8fCAnZGVmYXVsdCdcbiAgICAgIGNvbG9yID0gQ09MT1JTW3N0YXRlXVxuICAgICAgZGlzcGxheV9zdGF0ZSA9IGNvbG9yaXplKFNUQVRFU1tzdGF0ZV0sIGNvbG9yKVxuICAgICAgdGl0bGUgPSB0YXNrWzp0aXRsZV0uZ3N1YihDT05URVhUX1RBR19QQVRURVJOKSBkbyB8dGFnfFxuICAgICAgICAodGFnLnN0YXJ0X3dpdGg/KCcgJykgPyAnICcgOiAnJykgKyBjb2xvcml6ZSh0YWcuc3RyaXAsIDpjeWFuKVxuICAgICAgZW5kXG4gICAgICBwcmlvcml0eV9mbGFnID0gdGFza1s6cHJpb3JpdHldID8gY29sb3JpemUoUFJJT1JJVFlfRkxBRywgOnJlZCkgOiAnICdcbiAgICAgIGR1ZV9kYXRlID0gJydcbiAgICAgIGlmIHRhc2tbOmR1ZV0gJiYgc3RhdGUgIT0gJ2RvbmUnXG4gICAgICAgIGRhdGVfZGlmZiA9IChEYXRlLnBhcnNlKHRhc2tbOmR1ZV0pIC0gQHRvZGF5KS50b19pXG4gICAgICAgIGlmIGRhdGVfZGlmZiA8IDBcbiAgICAgICAgICBkdWVfZGF0ZSA9IGNvbG9yaXplKFwiKCN7ZGF0ZV9kaWZmLmFic31kIG92ZXJkdWUpXCIsIDpyZWQpXG4gICAgICAgIGVsc2lmIGRhdGVfZGlmZiA9PSAwIHx8IGRhdGVfZGlmZiA9PSAxXG4gICAgICAgICAgZHVlX2RhdGUgPSBjb2xvcml6ZShcIigje0RVRV9EQVRFX0RBWVNfU0lNUExFW2RhdGVfZGlmZl19KVwiLCA6eWVsbG93KVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZHVlX2RhdGUgPSBjb2xvcml6ZShcIigje0BkdWVfZGF0ZV9kYXlzW2RhdGVfZGlmZl0gfHwgdGFza1s6ZHVlXX0pXCIsIDptYWdlbnRhKSBpZiBkYXRlX2RpZmYgPiAxXG4gICAgICAgIGVuZFxuICAgICAgICBkdWVfZGF0ZSA9ICcgJyArIGR1ZV9kYXRlXG4gICAgICBlbmRcbiAgICAgIEB0ZXh0X2J1ZmZlci5wdXNoIFwiI3tudW0udG9fcy5yanVzdCh0YXNrX2luZGVudCwgJyAnKX06I3twcmlvcml0eV9mbGFnfSN7ZGlzcGxheV9zdGF0ZX0gI3t0aXRsZX0je2R1ZV9kYXRlfVwiXG4gICAgZW5kXG4gICAgQHRleHRfYnVmZmVyLnB1c2ggJ05vIHRvZG9zIGZvdW5kJyBpZiBpdGVtcy5lbXB0eT9cbiAgZW5kXG5cbiAgZGVmIGFkZF9ub3RlKGl0ZW0sIHRleHQpXG4gICAgdGFza3MgPSBsb2FkX3Rhc2tzKGl0ZW0pXG4gICAgdGFza3NbaXRlbV1bOm5vdGVdIHx8PSBbXVxuICAgIHRhc2tzW2l0ZW1dWzpub3RlXS5wdXNoKHRleHQpXG4gICAgdGFza3NbaXRlbV1bOm1vZGlmaWVkXSA9IEB0b2RheS5zdHJmdGltZShEQVRFX0ZPUk1BVClcbiAgICB3cml0ZV90YXNrcyh0YXNrcylcbiAgICBzaG93KGl0ZW0pXG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfbm90ZShpdGVtKVxuICAgIHRhc2tzID0gbG9hZF90YXNrcyhpdGVtKVxuICAgIHRhc2tzW2l0ZW1dLmRlbGV0ZSg6bm90ZSlcbiAgICB0YXNrc1tpdGVtXVs6bW9kaWZpZWRdID0gQHRvZGF5LnN0cmZ0aW1lKERBVEVfRk9STUFUKVxuICAgIHdyaXRlX3Rhc2tzKHRhc2tzKVxuICAgIHNob3coaXRlbSlcbiAgZW5kXG5cbiAgZGVmIHNob3coaXRlbSlcbiAgICB0YXNrcyA9IGxvYWRfdGFza3MoaXRlbSlcbiAgICB0YXNrc1tpdGVtXS5lYWNoIGRvIHxrZXksIHZhbHVlfFxuICAgICAgdmFsID0gdmFsdWUua2luZF9vZj8oQXJyYXkpID8gXCJcXG5cIiArIHZhbHVlLmpvaW4oXCJcXG5cIikgOiB2YWx1ZVxuICAgICAgQHRleHRfYnVmZmVyLnB1c2ggXCIje2NvbG9yaXplKGtleS50b19zLnJqdXN0KDEwLCAnICcpICsgJzonLCA6Y3lhbil9ICN7dmFsfVwiXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBjb2xvcml6ZSh0ZXh0LCBjb2xvcilcbiAgICBcIlxcZVsje0NPTE9SX0NPREVTW2NvbG9yXX1tI3t0ZXh0fVxcZVswbVwiXG4gIGVuZFxuXG4gIGRlZiBjb252ZXJ0X2R1ZV9kYXRlKGRhdGUgPSAnJylcbiAgICBkdWUgPSBuaWxcbiAgICBkYXlfaW5kZXggPSBAZHVlX2RhdGVfZGF5cy5pbmRleChkYXRlLnRvX3MuZG93bmNhc2UpIHx8XG4gICAgICBEVUVfREFURV9EQVlTX1NJTVBMRS5pbmRleChkYXRlLnRvX3MuZG93bmNhc2UpIHx8XG4gICAgICBAZHVlX2RhdGVfZGF5cy5tYXAgZG8gfGRheXwgZGF5WzAuLjJdIGVuZC5pbmRleChkYXRlLnRvX3MuZG93bmNhc2UpXG4gICAgaWYgZGF5X2luZGV4XG4gICAgICBkdWUgPSAoQHRvZGF5ICsgZGF5X2luZGV4KS5zdHJmdGltZShEQVRFX0ZPUk1BVClcbiAgICBlbHNlXG4gICAgICBkdWUgPSBkYXRlLm5pbD8gfHwgZGF0ZS5lbXB0eT8gPyBuaWwgOiBEYXRlLnBhcnNlKGRhdGUpLnN0cmZ0aW1lKERBVEVfRk9STUFUKVxuICAgIGVuZFxuICAgIHJldHVybiBkdWVcbiAgZW5kXG5cbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsIjMwIiwiMzEiLCIzMiIsIjMzIiwiMzQiLCIzNSIsIjM2IiwiMzciLCIzIiwiNCIsIjIiLCIxIiwiMTAwIiwiZXhlY3V0ZSIsIkB0ZXh0X2J1ZmZlciIsInNldHVwIiwiYWN0aW9uIiwiYXJndW1lbnRzJCIsImZpcnN0IiwiYXJncyIsIiRyZXRfb3JfMSIsIltdIiwiLTEiLCIkcmV0X29yXzIiLCJuaWw/IiwiZW1wdHk/IiwicmFpc2UiLCIrIiwiYWRkIiwiam9pbiIsIj4iLCJsZW5ndGgiLCIwIiwiY2hhbmdlX3N0YXRlIiwidG9faSIsIiRyZXRfb3JfMyIsImxpc3QiLCIkcmV0X29yXzQiLCIkcmV0X29yXzUiLCIkcmV0X29yXzYiLCI8Iiwic2V0X3ByaW9yaXR5IiwiJHJldF9vcl83IiwiZHVlX2RhdGUiLCIkcmV0X29yXzgiLCJhcHBlbmQiLCJyZW5hbWUiLCIhPSIsImRlbGV0ZSIsImFkZF9ub3RlIiwiZGVsZXRlX25vdGUiLCJzaG93IiwicHVzaCIsInVzYWdlIiwic3RyaXAiLCJlcnJvciIsImNvbG9yaXplIiwic2VsZiIsInRvX3MiLCIkcmV0X29yXzkiLCJ0b19odG1sIiwiZ3N1YiIsInByaXZhdGUiLCJAcXVlcmllcyIsImtleXMiLCJtYXAiLCJzZWxlY3QiLCJrIiwidiIsIkB0b2RheSIsInBhcnNlIiwidG9kYXkiLCJzdHJmdGltZSIsIm5leHRfN19kYXlzIiwiNiIsImRheSIsIkBkdWVfZGF0ZV9kYXlzIiwiZG93bmNhc2UiLCJkdWVfZGF0ZXNfZm9yX3F1ZXJpZXMiLCJsb2FkX3Rhc2tzIiwiY291bnQiLCJ0YXNrcyIsInRvZG9fanNvbmwiLCIhIiwiZWFjaCIsInNwbGl0IiwibGluZSIsIj09IiwiJHdyaXRlciIsImNob21wIiwiW109IiwiLSIsIiRyZXRfb3JfMTAiLCJpdGVtX3RvX2NoZWNrIiwiaGFzX2tleT8iLCJ3cml0ZV90YXNrcyIsInNvcnQiLCJnZW5lcmF0ZSIsImtleSIsInBvc3Rwcm9jZXNzX3RhZ3MiLCJtYXRjaF9kYXRhIiwidGFzayIsIm1hdGNoIiwiY29udmVydF9kdWVfZGF0ZSIsInRleHQiLCJpdGVtIiwic3RhdGUiLCIkcmV0X29yXzExIiwibm90ZSIsIiRsb2dpY2FsX29wX3JlY3ZyX3RtcF8xIiwiJHJldF9vcl8xMiIsIiRyZXRfb3JfMTMiLCIkbG9naWNhbF9vcF9yZWN2cl90bXBfMiIsIiRyZXRfb3JfMTQiLCJkYXRlIiwiaXRlbXMiLCIkcmV0X29yXzE1IiwidGFza19pbmRlbnQiLCJtYXgiLCJzaXplIiwicGF0dGVybnMiLCIkcmV0X29yXzE2Iiwibm9ybWFsaXplZF90YXNrIiwiJHJldF9vcl8xNyIsInBhdHRlcm4iLCJudW0iLCJzb3J0X2J5IiwiJHJldF9vcl8xOCIsIiRyZXRfb3JfMTkiLCIkcmV0X29yXzIwIiwiJHJldF9vcl8yMSIsImNvbG9yIiwiZGlzcGxheV9zdGF0ZSIsInRpdGxlIiwidGFnIiwic3RhcnRfd2l0aD8iLCJwcmlvcml0eV9mbGFnIiwiJHJldF9vcl8yMiIsImRhdGVfZGlmZiIsImFicyIsIiRyZXRfb3JfMjMiLCIkcmV0X29yXzI0Iiwicmp1c3QiLCIkbG9naWNhbF9vcF9yZWN2cl90bXBfMyIsIiRyZXRfb3JfMjUiLCJ2YWwiLCJ2YWx1ZSIsImtpbmRfb2Y/IiwiMTAiLCJkdWUiLCJkYXlfaW5kZXgiLCIkcmV0X29yXzI2IiwiJHJldF9vcl8yNyIsImluZGV4IiwiJHJldF9vcl8yOCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBLE1BQUFBLFNBQUFBLENBQVEsV0FBUkEsQ0FBQTtBQUFBLE1BQ0FBLFNBQUFBLENBQVEsV0FBUkEsQ0FEQTtBQUFBLEVBR0EsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUVFLElBQUEsMkNBQWMsaUZBQUEsU0FDSEMsRUFERyxFQUFBLE9BRUhDLEVBRkcsRUFBQSxTQUdIQyxFQUhHLEVBQUEsVUFJSEMsRUFKRyxFQUFBLFFBS0hDLEVBTEcsRUFBQSxXQU1IQyxFQU5HLEVBQUEsUUFPSEMsRUFQRyxFQUFBLFNBUUhDLEVBUkcsRUFBZCxDQUFBO0FBQUEsSUFXQSxzQ0FBUywwREFBQSxPQUNNLEtBRE4sRUFBQSxRQUVNLEtBRk4sRUFBQSxXQUdNLEtBSE4sRUFBQSxXQUlNLEtBSk4sRUFBQSxXQUtNLEtBTE4sRUFBVCxDQVhBO0FBQUEsSUFtQkEscUNBQVEsMERBQUEsT0FDT0MsQ0FEUCxFQUFBLFFBRU9DLENBRlAsRUFBQSxXQUdPQyxDQUhQLEVBQUEsV0FJT0MsQ0FKUCxFQUFBLFdBS09DLEdBTFAsRUFBUixDQW5CQTtBQUFBLElBMkJBLHNDQUFTLDBEQUFBLE9BQ00sT0FETixFQUFBLFFBRU0sTUFGTixFQUFBLFdBR00sT0FITixFQUFBLFdBSU0sUUFKTixFQUFBLFdBS00sU0FMTixFQUFULENBM0JBO0FBQUEsSUFtQ0EsMkNBQWMsVUFBZCxDQW5DQTtBQUFBLElBb0NBLG9EQUF1QixDQUFDLE9BQUQsRUFBVSxVQUFWLENBQXZCLENBcENBO0FBQUEsSUFxQ0Esb0RBQXVCLDBCQUF2QixDQXJDQTtBQUFBLElBc0NBLG1EQUFzQixpQkFBdEIsQ0F0Q0E7QUFBQSxJQXVDQSw2Q0FBZ0IsR0FBaEIsQ0F2Q0E7QUFBQSxJQXdDQSx5Q0FBWSxZQUFaLENBeENBO0FBQUE7QUEwQ0FDLElBQUFBLDJCQUFBQSxrQkFBQUEsbUJBQVksVUFBWkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQUMsbUJBQWUsRUFBZjtBQUFBO0FBQ0EsTUFDRTtBQUFBO0FBQUEsWUFBQUMsT0FBQUEsQ0FBQUEsQ0FBQTtBQUFBLFFBQ0FDLFNBQVNDLFVBQUFDLE9BQUFBLENBQUFBLENBRFQ7QUFBQSxRQUVBQyxPQUFPLGFBQUEsSUFBQSxRQS9FYkMsQ0FBQUEsWUErRWFILFVBQUFJLE9BQUFBLENBQVUsT0FBQVYsQ0FBQSxFQUFHVyxFQUFILFFBQVZELENBL0ViRCxDQStFYSxDQUFBO0FBQUEsVUEvRWIsT0FBQTtBQStFYSxRQUFBO0FBQUEsVUFBb0IsT0FBQTtBQUFwQixRQUFBLENBQUEsa0JBRlA7QUFBQSxRQUdBLFFBQUtKLE1BQUw7QUFBQSxRQUNBLElBQUssb0JBQUw7QUFDRSxRQUFBLElBQUEsUUFBNkQsYUFBQSxJQUFBLFFBbEZyRU8sQ0FBQUEsWUFrRnFFSixJQUFBSyxTQUFBQSxDQUFBQSxDQWxGckVELENBa0ZxRSxDQUFBO0FBQUEsVUFsRnJFLE9BQUE7QUFrRnFFLFFBQUE7QUFBQSxVQUFhLE9BQUFKLElBQUFNLFdBQUFBLENBQUFBO0FBQWIsUUFBQSxDQUFBLGtCQUE3RCxDQUFBO0FBQUEsY0FBQUMsT0FBQUEsQ0FBTUMsU0FBQVgsTUFBQVcsRUFBUywwQ0FBVEEsQ0FBTkQsQ0FBQSxDQUFBO0FBQUEsWUFDQUUsS0FBQUEsQ0FBSVQsSUFBQVUsTUFBQUEsQ0FBVSxHQUFWQSxDQUFKRCxDQURBLENBREY7QUFEQSxRQUFBLEtBSUEsSUFBSyxzQkFBTCxHQUNFLElBQUEsUUFBQUUsT0FBQVgsSUFBQVksUUFBQUEsQ0FBQUEsQ0FBQUQsRUFBY0UsQ0FBZEYsQ0FBQSxDQUFBO0FBQUEsY0FBa0JHLGNBQUFBLENBQWFkLElBQUFELE9BQUFBLENBQUFBLENBQUFnQixNQUFBQSxDQUFBQSxHQUFpQixXQUFZLGFBQUEsSUFBQSxRQXJGcEVDLENBQUFBLFlBcUZvRWhCLElBQUFFLE9BQUFBLENBQUssT0FBQVYsQ0FBQSxFQUFHVyxFQUFILFFBQUxELENBckZwRWMsQ0FxRm9FLENBQUE7QUFBQSxZQXJGcEUsT0FBQTtBQXFGb0UsVUFBQTtBQUFBLFlBQWUsT0FBQTtBQUFmLFVBQUEsQ0FBQSxrQkFBRE4sTUFBQUEsQ0FBeUIsR0FBekJBLENBQXpDSTtBQUFsQixRQUFBO0FBQUEsY0FBNEZHLE1BQUFBLENBQUssS0FBSyxDQUFDLFVBQUQsQ0FBVkE7QUFBNUYsUUFBQSxDQURGO0FBSkEsUUFBQSxLQU1BLElBQUsscUJBQUwsR0FDRSxJQUFBLFFBQUFOLE9BQUFYLElBQUFZLFFBQUFBLENBQUFBLENBQUFELEVBQWNFLENBQWRGLENBQUEsQ0FBQTtBQUFBLGNBQWtCRyxjQUFBQSxDQUFhZCxJQUFBRCxPQUFBQSxDQUFBQSxDQUFBZ0IsTUFBQUEsQ0FBQUEsR0FBaUIsUUFBUyxhQUFBLElBQUEsUUF2RmpFRyxDQUFBQSxZQXVGaUVsQixJQUFBRSxPQUFBQSxDQUFLLE9BQUFWLENBQUEsRUFBR1csRUFBSCxRQUFMRCxDQXZGakVnQixDQXVGaUUsQ0FBQTtBQUFBLFlBdkZqRSxPQUFBO0FBdUZpRSxVQUFBO0FBQUEsWUFBZSxPQUFBO0FBQWYsVUFBQSxDQUFBLGtCQUFEUixNQUFBQSxDQUF5QixHQUF6QkEsQ0FBdENJO0FBQWxCLFFBQUE7QUFBQSxjQUF5RkcsTUFBQUEsQ0FBSyxLQUFLLENBQUMsT0FBRCxDQUFWQTtBQUF6RixRQUFBLENBREY7QUFOQSxRQUFBLEtBUUEsSUFBSyxzQkFBTCxHQUNFLElBQUEsUUFBQU4sT0FBQVgsSUFBQVksUUFBQUEsQ0FBQUEsQ0FBQUQsRUFBY0UsQ0FBZEYsQ0FBQSxDQUFBO0FBQUEsY0FBa0JHLGNBQUFBLENBQWFkLElBQUFELE9BQUFBLENBQUFBLENBQUFnQixNQUFBQSxDQUFBQSxHQUFpQixXQUFZLGFBQUEsSUFBQSxRQXpGcEVJLENBQUFBLFlBeUZvRW5CLElBQUFFLE9BQUFBLENBQUssT0FBQVYsQ0FBQSxFQUFHVyxFQUFILFFBQUxELENBekZwRWlCLENBeUZvRSxDQUFBO0FBQUEsWUF6RnBFLE9BQUE7QUF5Rm9FLFVBQUE7QUFBQSxZQUFlLE9BQUE7QUFBZixVQUFBLENBQUEsa0JBQURULE1BQUFBLENBQXlCLEdBQXpCQSxDQUF6Q0k7QUFBbEIsUUFBQTtBQUFBLGNBQTRGRyxNQUFBQSxDQUFLLEtBQUssQ0FBQyxVQUFELENBQVZBO0FBQTVGLFFBQUEsQ0FERjtBQVJBLFFBQUEsS0FVQSxJQUFLLHNCQUFMLEdBQ0UsSUFBQSxRQUFBTixPQUFBWCxJQUFBWSxRQUFBQSxDQUFBQSxDQUFBRCxFQUFjRSxDQUFkRixDQUFBLENBQUE7QUFBQSxjQUFrQkcsY0FBQUEsQ0FBYWQsSUFBQUQsT0FBQUEsQ0FBQUEsQ0FBQWdCLE1BQUFBLENBQUFBLEdBQWlCLE9BQVEsYUFBQSxJQUFBLFFBM0ZoRUssQ0FBQUEsWUEyRmdFcEIsSUFBQUUsT0FBQUEsQ0FBSyxPQUFBVixDQUFBLEVBQUdXLEVBQUgsUUFBTEQsQ0EzRmhFa0IsQ0EyRmdFLENBQUE7QUFBQSxZQTNGaEUsT0FBQTtBQTJGZ0UsVUFBQTtBQUFBLFlBQWUsT0FBQTtBQUFmLFVBQUEsQ0FBQSxrQkFBRFYsTUFBQUEsQ0FBeUIsR0FBekJBLENBQXJDSTtBQUFsQixRQUFBO0FBQUEsY0FBd0ZHLE1BQUFBLENBQUssS0FBSyxDQUFDLE1BQUQsQ0FBVkE7QUFBeEYsUUFBQSxDQURGO0FBVkEsUUFBQSxLQVlBLElBQUsscUJBQUw7QUFDRSxRQUFBLElBQUEsUUFBNkRJLE9BQUFyQixJQUFBWSxRQUFBQSxDQUFBQSxDQUFBUyxFQUFjN0IsQ0FBZDZCLENBQTdELENBQUE7QUFBQSxjQUFBZCxPQUFBQSxDQUFNQyxTQUFBWCxNQUFBVyxFQUFTLDBDQUFUQSxDQUFORCxDQUFBLENBQUE7QUFBQSxZQUNBZSxjQUFBQSxDQUFhdEIsSUFBQUQsT0FBQUEsQ0FBQUEsQ0FBQWdCLE1BQUFBLENBQUFBLEdBQWtCLGFBQUEsSUFBQSxRQTlGdkNRLENBQUFBLFlBOEZ1Q3ZCLElBQUFFLE9BQUFBLENBQUssT0FBQVYsQ0FBQSxFQUFHVyxFQUFILFFBQUxELENBOUZ2Q3FCLENBOEZ1QyxDQUFBO0FBQUEsVUE5RnZDLE9BQUE7QUE4RnVDLFFBQUE7QUFBQSxVQUFlLE9BQUE7QUFBZixRQUFBLENBQUEsa0JBQURiLE1BQUFBLENBQXlCLEdBQXpCQSxDQUE5QlksQ0FEQSxDQURGO0FBWkEsUUFBQSxLQWVBLElBQUssb0JBQUw7QUFDRSxRQUFBLElBQUEsUUFBNkRELE9BQUFyQixJQUFBWSxRQUFBQSxDQUFBQSxDQUFBUyxFQUFjN0IsQ0FBZDZCLENBQTdELENBQUE7QUFBQSxjQUFBZCxPQUFBQSxDQUFNQyxTQUFBWCxNQUFBVyxFQUFTLDBDQUFUQSxDQUFORCxDQUFBLENBQUE7QUFBQSxZQUNBaUIsVUFBQUEsQ0FBU3hCLElBQUFELE9BQUFBLENBQUFBLENBQUFnQixNQUFBQSxDQUFBQSxHQUFrQixhQUFBLElBQUEsUUFqR25DVSxDQUFBQSxZQWlHbUN6QixJQUFBRSxPQUFBQSxDQUFLLE9BQUFWLENBQUEsRUFBR1csRUFBSCxRQUFMRCxDQWpHbkN1QixDQWlHbUMsQ0FBQTtBQUFBLFVBakduQyxPQUFBO0FBaUdtQyxRQUFBO0FBQUEsVUFBZSxPQUFBO0FBQWYsUUFBQSxDQUFBLGtCQUFEZixNQUFBQSxDQUF5QixHQUF6QkEsQ0FBMUJjLENBREEsQ0FERjtBQWZBLFFBQUEsS0FrQkEsSUFBSyx1QkFBTDtBQUNFLFFBQUEsSUFBQSxRQUE4REgsT0FBQXJCLElBQUFZLFFBQUFBLENBQUFBLENBQUFTLEVBQWM5QixDQUFkOEIsQ0FBOUQsQ0FBQTtBQUFBLGNBQUFkLE9BQUFBLENBQU1DLFNBQUFYLE1BQUFXLEVBQVMsMkNBQVRBLENBQU5ELENBQUEsQ0FBQTtBQUFBLFlBQ0FtQixRQUFBQSxDQUFPMUIsSUFBQUQsT0FBQUEsQ0FBQUEsQ0FBQWdCLE1BQUFBLENBQUFBLEdBQWlCZixJQUFBRSxPQUFBQSxDQUFLLE9BQUFWLENBQUEsRUFBR1csRUFBSCxRQUFMRCxDQUFBUSxNQUFBQSxDQUFpQixHQUFqQkEsQ0FBeEJnQixDQURBLENBREY7QUFsQkEsUUFBQSxLQXFCQSxJQUFLLHVCQUFMO0FBQ0UsUUFBQSxJQUFBLFFBQThETCxPQUFBckIsSUFBQVksUUFBQUEsQ0FBQUEsQ0FBQVMsRUFBYzlCLENBQWQ4QixDQUE5RCxDQUFBO0FBQUEsY0FBQWQsT0FBQUEsQ0FBTUMsU0FBQVgsTUFBQVcsRUFBUywyQ0FBVEEsQ0FBTkQsQ0FBQSxDQUFBO0FBQUEsWUFDQW9CLFFBQUFBLENBQU8zQixJQUFBRCxPQUFBQSxDQUFBQSxDQUFBZ0IsTUFBQUEsQ0FBQUEsR0FBaUJmLElBQUFFLE9BQUFBLENBQUssT0FBQVYsQ0FBQSxFQUFHVyxFQUFILFFBQUxELENBQUFRLE1BQUFBLENBQWlCLEdBQWpCQSxDQUF4QmlCLENBREEsQ0FERjtBQXJCQSxRQUFBLEtBd0JBLElBQUssb0JBQUw7QUFDRSxRQUFBLElBQUEsUUFBNEQzQixJQUFBWSxRQUFBQSxDQUFBQSxDQUFBZ0IsT0FBQUEsQ0FBZXBDLENBQWZvQyxDQUE1RCxDQUFBO0FBQUEsY0FBQXJCLE9BQUFBLENBQU1DLFNBQUFYLE1BQUFXLEVBQVMseUNBQVRBLENBQU5ELENBQUEsQ0FBQTtBQUFBLFlBQ0FzQixRQUFBQSxDQUFPN0IsSUFBQUQsT0FBQUEsQ0FBQUEsQ0FBQWdCLE1BQUFBLENBQUFBLENBQVBjLENBREEsQ0FERjtBQXhCQSxRQUFBLEtBMkJBLElBQUsscUJBQUw7QUFDRSxRQUFBLElBQUEsUUFBOERSLE9BQUFyQixJQUFBWSxRQUFBQSxDQUFBQSxDQUFBUyxFQUFjOUIsQ0FBZDhCLENBQTlELENBQUE7QUFBQSxjQUFBZCxPQUFBQSxDQUFNQyxTQUFBWCxNQUFBVyxFQUFTLDJDQUFUQSxDQUFORCxDQUFBLENBQUE7QUFBQSxZQUNBdUIsVUFBQUEsQ0FBUzlCLElBQUFELE9BQUFBLENBQUFBLENBQUFnQixNQUFBQSxDQUFBQSxHQUFpQmYsSUFBQUUsT0FBQUEsQ0FBSyxPQUFBVixDQUFBLEVBQUdXLEVBQUgsUUFBTEQsQ0FBQVEsTUFBQUEsQ0FBaUIsR0FBakJBLENBQTFCb0IsQ0FEQSxDQURGO0FBM0JBLFFBQUEsS0E4QkEsSUFBSyx3QkFBTDtBQUNFLFFBQUEsSUFBQSxRQUE0RDlCLElBQUFZLFFBQUFBLENBQUFBLENBQUFnQixPQUFBQSxDQUFlcEMsQ0FBZm9DLENBQTVELENBQUE7QUFBQSxjQUFBckIsT0FBQUEsQ0FBTUMsU0FBQVgsTUFBQVcsRUFBUyx5Q0FBVEEsQ0FBTkQsQ0FBQSxDQUFBO0FBQUEsWUFDQXdCLGFBQUFBLENBQVkvQixJQUFBRCxPQUFBQSxDQUFBQSxDQUFBZ0IsTUFBQUEsQ0FBQUEsQ0FBWmdCLENBREEsQ0FERjtBQTlCQSxRQUFBLEtBaUNBLElBQUsscUJBQUwsT0FDRWQsTUFBQUEsQ0FBSyxLQUFLakIsSUFBVmlCLENBREY7QUFqQ0EsUUFBQSxLQW1DQSxJQUFLLHFCQUFMO0FBQ0UsUUFBQSxJQUFBLFFBQTREakIsSUFBQVksUUFBQUEsQ0FBQUEsQ0FBQWdCLE9BQUFBLENBQWVwQyxDQUFmb0MsQ0FBNUQsQ0FBQTtBQUFBLGNBQUFyQixPQUFBQSxDQUFNQyxTQUFBWCxNQUFBVyxFQUFTLHlDQUFUQSxDQUFORCxDQUFBLENBQUE7QUFBQSxZQUNBeUIsTUFBQUEsQ0FBS2hDLElBQUFELE9BQUFBLENBQUFBLENBQUFnQixNQUFBQSxDQUFBQSxDQUFMaUIsQ0FEQSxDQURGO0FBbkNBLFFBQUEsS0FzQ0EsSUFBSyxxQkFBTDtBQUNFLFFBQUEsSUFBQSxRQUErQ3JCLE9BQUFYLElBQUFZLFFBQUFBLENBQUFBLENBQUFELEVBQWNFLENBQWRGLENBQS9DLENBQUE7QUFBQSxjQUFBSixPQUFBQSxDQUFNQyxTQUFBWCxNQUFBVyxFQUFTLDRCQUFUQSxDQUFORCxDQUFBLENBQUE7QUFBQSxRQUNBWixnQkFBQXNDLE1BQUFBLEtBQWtCQyxPQUFBQSxDQUFBQSxDQUFBQyxPQUFBQSxDQUFBQSxDQUFsQkYsQ0FEQSxDQURGO0FBdENBLFFBQUEsVUEwQ0VoQixNQUFBQSxDQUFLLEtBQUtuQixVQUFWbUIsQ0ExQ0YsQ0FIQTtBQUFBLE1BQUE7QUFBQSxRQStDRixxREFBQSxJQUFVbUIsQ0FBQUEsWUFBQUE7QUFBVixVQUFBO0FBQUEsWUFDRXpDLGdCQUFBc0MsTUFBQUEsQ0FBa0IsRUFBQSxHQUFBLEtBQUdJLFVBQUFBLENBQVMsVUFBVSxLQUFuQkEsQ0FBSCxDQUFBLEdBQUEsR0FBQSxHQUFBLENBQStCRCxLQUEvQixDQUFsQkg7QUFERixVQUFBO0FBQUEsUUFBQSxDQS9DRTtBQUFBLE1BQUEsQ0FERixDQURBO0FBQUEsTUFvREEsT0FBQUssSUFwREE7QUFERjVDLElBQUFBLENBQUFBLDZCQUFBQSxDQTFDQTtBQUFBO0FBa0dBNkMsSUFBQUEsd0JBQUFBLGVBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBL0IsU0FBQyxhQUFBLElBQUEsUUFuSUxnQyxDQUFBQSxZQW1JSzdDLGdCQW5JTDZDLENBbUlLLENBQUE7QUFBQSxRQW5JTCxPQUFBO0FBbUlLLE1BQUE7QUFBQSxRQUFnQixPQUFBO0FBQWhCLE1BQUEsQ0FBQSxrQkFBRDlCLE1BQUFBLENBQTBCLElBQTFCQSxDQUFBRixFQUFrQyxJQUFsQ0E7QUFERitCLElBQUFBLENBQUFBLDBCQUFBQSxDQWxHQTtBQUFBO0FBc0dBRSxJQUFBQSwyQkFBQUEsa0JBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFPakMsU0FBQUEsU0FBQSx5QkFBQUEsTUFBMEIrQixNQUFBQSxDQUFBQSxDQUFBRyxNQUFBQSxDQUMxQixLQUFLLE9BRHFCQSxDQUFBQSxNQUFBQSxDQUUxQixLQUFLLE1BRnFCQSxDQUFBQSxNQUFBQSxDQUcxQixLQUFLLE1BSHFCQSxDQUFBQSxNQUFBQSxDQUkxQixLQUFLLFFBSnFCQSxDQUFBQSxNQUFBQSxDQUsxQixNQUFNLE1BTG9CQSxDQUFBQSxNQUFBQSxDQU0xQixVQUFVLFNBTmdCQSxDQUFBQSxNQUFBQSxDQU8xQixjQUFjLGtDQVBZQSxDQUExQmxDLENBQUFBLEVBT2lELFNBUGpEQTtBQURUaUMsSUFBQUEsQ0FBQUEsNkJBQUFBLENBdEdBO0FBQUEsUUFpSEFFLFNBQUFBLENBQUFBLENBakhBO0FBQUE7QUFtSEFULElBQUFBLHlCQUFBQSxnQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsRUFBQSxHQUFBLHFDQUFBLEdBQUEsSUFBQSxHQUFBLGFBQUEsR0FBQSxpREFBQSxHQUFBLDZFQUFBLEdBQUEsK0VBQUEsR0FBQSw2RUFBQSxHQUFBLGdGQUFBLEdBQUEsa0ZBQUEsR0FBQSw4RUFBQSxHQUFBLElBQUEsR0FBQSw4REFBQSxHQUFBLGdEQUFBLEdBQUEsZ0RBQUEsR0FBQSxxREFBQSxHQUFBLCtEQUFBLEdBQUEsSUFBQSxHQUFBLDhFQUFBLEdBQUEsMERBQUEsR0FBQSxxREFBQSxHQUFBLElBQUEsR0FBQSxnRkFBQSxHQUFBLENBdUJJVSxZQUFBQyxNQUFBQSxDQUFBQSxDQUFBbkMsTUFBQUEsQ0FBbUIsSUFBbkJBLENBdkJKLENBQUEsR0FBQSxJQUFBLEdBQUEsSUFBQSxHQUFBLDBFQUFBLEdBQUEsSUFBQSxHQUFBLFdBQUEsR0FBQSxDQTRCSW9DLE1BQUFDLE1BQUEsc0JBQUFBLFVBQUFBLEVBQUFBLEVBQUFBLEVBaExSLGdCQWdMeUIsQ0FBRCxFQUFJLENBaEw1QixFQUFBOztBQUFBO0FBQUE7QUFnTHlCLFFBQUE7QUFBQSxRQUFBO0FBQUEsUUFBQSxDQWhMekI7QUFBQTtBQWdMNEIsUUFBQTtBQUFBLFFBQUE7QUFBQSxRQUFBLENBaEw1QjtBQUFBLFFBZ0wrQixPQUFBQyxDQUFBcEIsT0FBQUEsQ0FBSyxTQUFMQSxDQWhML0IsQ0FBQSxrQkFBQSxpQkFBQSxLQWdMUW1CLENBQUFELE9BQUFBLEVBQUFBLEVBQUFBLEVBaExSLGdCQWdMdUQsQ0FBRCxFQUFJLENBaEwxRCxFQUFBOztBQUFBO0FBQUE7QUFnTHVELFFBQUE7QUFBQSxRQUFBO0FBQUEsUUFBQSxDQWhMdkQ7QUFBQTtBQWdMMEQsUUFBQTtBQUFBLFFBQUE7QUFBQSxRQUFBLENBaEwxRDtBQUFBLFFBZ0w2RCxPQUFBLEVBQUEsR0FBQSxDQUFHRSxDQUFILENBQUEsR0FBQSxHQUFBLEdBQUEsQ0FBUUMsQ0FBUixDQWhMN0QsQ0FBQSxrQkFBQSxpQkFBQSxLQWdMUUgsQ0FBQXBDLE1BQUFBLENBQXdFLElBQXhFQSxDQTVCSixDQUFBLEdBQUEsYUFBQSxHQUFBLENBNEJnRyw2QkE1QmhHLENBQUEsR0FBQSxJQUFBLEdBQUEsSUFBQSxHQUFBLGlCQUFBLEdBQUEsQ0E4Qm1CLHlCQTlCbkIsQ0FBQSxHQUFBO0FBREZ3QixJQUFBQSxDQUFBQSwyQkFBQUEsQ0FuSEE7QUFBQTtBQXNKQXRDLElBQUFBLHlCQUFBQSxnQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFzRCxhQUFTLG9CQUFBQyxPQUFBQSxDQUFXLG9CQUFBQyxPQUFBQSxDQUFBQSxDQUFBQyxVQUFBQSxDQUFvQiwyQkFBcEJBLENBQVhGLENBQVQ7QUFBQSxNQUNBRyxjQUFjUixNQUFDLE9BQUFqQyxDQUFBLEVBQUcwQyxDQUFILFFBQURULE9BQUFBLEVBQUFBLEVBQUFBLEVBeExsQixnQkF3TGlDLEdBeExqQyxFQUFBO0FBQUE7O0FBQUE7QUFBQTtBQXdMaUMsUUFBQTtBQUFBLFFBQUE7QUFBQSxRQUFBLENBeExqQztBQUFBLFFBd0xzQyxPQUFBdEMsU0FBQTBDLFVBQUExQyxFQUFTZ0QsR0FBVGhELENBeEx0QyxDQUFBLGtCQUFBLGlCQUFBLEtBd0xrQnNDLENBRGQ7QUFBQSxNQUVBVyxxQkFBaUJYLE1BQUFRLFdBQUFSLE9BQUFBLEVBQUFBLEVBQUFBLEVBekxyQixnQkF5THlDLEdBekx6QyxFQUFBOztBQUFBO0FBQUE7QUF5THlDLFFBQUE7QUFBQSxRQUFBO0FBQUEsUUFBQSxDQXpMekM7QUFBQSxRQXlMOEMsT0FBQVUsR0FBQUgsVUFBQUEsQ0FBYSxJQUFiQSxDQUFBSyxVQUFBQSxDQUFBQSxDQXpMOUMsQ0FBQSxrQkFBQSxpQkFBQSxLQXlMcUJaLENBRmpCO0FBQUEsTUFHQWEsd0JBQXdCYixNQUFBUSxXQUFBUixPQUFBQSxFQUFBQSxFQUFBQSxFQTFMNUIsaUJBMExnRCxHQTFMaEQsRUFBQTs7QUFBQTtBQUFBO0FBMExnRCxRQUFBO0FBQUEsUUFBQTtBQUFBLFFBQUEsQ0ExTGhEO0FBQUEsUUEwTHFELE9BQUFVLEdBQUFILFVBQUFBLENBQWEsMkJBQWJBLENBMUxyRCxDQUFBLG1CQUFBLGtCQUFBLE1BMEw0QlAsQ0FIeEI7QUFBQSxNQUtBLE9BQUFGLENBQUFBLGVBQVcsMkdBQUEsV0FDTyw2QkFEUCxFQUFBLFNBRU8sWUFGUCxFQUFBLFlBR08sZUFIUCxFQUFBLFlBSU8sZUFKUCxFQUFBLFFBS08sV0FMUCxFQUFBLFFBTU8sWUFOUCxFQUFBLFVBT08sRUFBQSxHQUFBLE1BQUEsR0FBQSxDQUFPZSxxQkFBQXpELE9BQUFBLENBQXNCVyxDQUF0QlgsQ0FBUCxDQVBQLEVBQUEsYUFRTyxFQUFBLEdBQUEsTUFBQSxHQUFBLENBQU95RCxxQkFBQXpELE9BQUFBLENBQXNCVixDQUF0QlUsQ0FBUCxDQVJQLEVBQUEsY0FTTyxFQUFBLEdBQUEsT0FBQSxHQUFBLENBQVF5RCxxQkFBQWpELE1BQUFBLENBQTJCLEdBQTNCQSxDQUFSLENBQUEsR0FBQSxHQVRQLEVBQVhrQyxDQUxBO0FBREZoRCxJQUFBQSxDQUFBQSwyQkFBQUEsQ0F0SkE7QUFBQTtBQXlLQWdFLElBQUFBLDhCQUFBQSxzQkFBQUEsc0JBQWUsYUFBZkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBek1GO0FBeU1pQixNQUFBO0FBQUEsTUFBQSxrQkFBZ0IsR0FBaEI7QUFBQSxNQUFBLENBek1qQjtBQUFBLE1BME1JQyxRQUFRaEQsQ0ExTVo7QUFBQSxNQTJNSWlELFFBQVEsWUFBQSxFQTNNWjtBQUFBLE1BNk1JQyxhQUFjLDRCQUE4Qix5QkFBVSxPQTdNMUQ7QUFBQSxNQThNSSxJQUFBLFFBQUlBLFVBQUF6RCxXQUFBQSxDQUFBQSxDQUFEMEQsTUFBQUEsQ0FBQUEsQ0FBSCxDQUFBO0FBQUEsUUFDRUMsTUFBQUYsVUFBQUcsT0FBQUEsQ0FBaUIsSUFBakJBLENBQUFELFFBQUFBLEVBQUFBLEVBQUFBLEVBL01OLGlCQStNc0MsSUEvTXRDLEVBQUE7O0FBQUE7QUFBQTtBQStNc0MsVUFBQTtBQUFBLFVBQUE7QUFBQSxVQUFBLENBL010QztBQUFBLFVBZ05RLElBQVFFLElBQUFoQyxPQUFBQSxDQUFBQSxDQUFBaUMsT0FBQUEsQ0FBYyxFQUFkQSxDQUFSO0FBQUEsWUFBQSxVQUFBLENBQUEsQ0FoTlI7QUFBQSxVQWlOUVAsUUFqTlJyRCxTQWlOUXFELEtBak5SckQsRUFpTmlCaEIsQ0FqTmpCZ0IsQ0FBQTtBQUFBO0FBQUEsVUFBQTZELFVBQUEsQ0FrTmNSLEtBbE5kLEVBa051QixvQkFBQVYsT0FBQUEsQ0FBV2dCLElBQUFHLE9BQUFBLENBQUFBLEdBQVksNkJBQUEsbUJBQW9CLElBQXBCLEVBQXZCbkIsQ0FsTnZCLENBQUE7QUFBQSxVQWtOUW9CLE1BQUFULEtBQUFTLE9BQUFBLEVBbE5SLFVBQUFGLE9BQUEsQ0FrTlFFLENBbE5SO0FBQUEsVUFBQSxPQUFBRixPQUFBLENBQUFHLFVBQUFILE9BQUEsQ0FBQSxRQUFBLENBQUFHLEVBQUFoRixDQUFBZ0YsQ0FBQSxDQUFBLENBQUEsQ0FBQSxtQkFBQSxrQkFBQSxNQStNTVAsQ0FERixDQTlNSjtBQUFBLE1BcU5JLElBQUEsUUFBRyxhQUFBLElBQUEsUUFyTlBRLENBQUFBLGFBcU5PQyxhQXJOUEQsQ0FxTk8sQ0FBQTtBQUFBLFFBQWlCLE9BQUNYLEtBQUFhLGFBQUFBLENBQWVELGFBQWZDLENBQURYLE1BQUFBLENBQUFBO0FBQWpCLE1BQUE7QUFBQSxRQXJOUCxPQUFBO0FBcU5PLE1BQUEsQ0FBQSxrQkFBSCxDQUFBO0FBQUEsWUFDRXpELE9BQUFBLENBQU0sRUFBQSxHQUFBLENBQUdtRSxhQUFILENBQUEsR0FBQSxnQkFBTm5FLENBREYsQ0FyTko7QUFBQSxNQXdOSSxPQUFBdUQsS0F4Tko7QUF5TUVGLElBQUFBLENBQUFBLGtDQUFBQSxDQXpLQTtBQUFBO0FBMkxBZ0IsSUFBQUEsK0JBQUFBLHVCQUFBQSx1QkFBZ0IsS0FBaEJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFiLGFBQWF2RCxTQUFBc0MsTUFBQWdCLEtBQUFqQixNQUFBQSxDQUFBQSxDQUFBZ0MsTUFBQUEsQ0FBQUEsQ0FBQS9CLE9BQUFBLEVBQUFBLEVBQUFBLEVBNU5qQixpQkE0TnlDLEdBNU56QyxFQUFBOztBQUFBO0FBQUE7QUE0TnlDLFFBQUE7QUFBQSxRQUFBO0FBQUEsUUFBQSxDQTVOekM7QUFBQSxRQTROOEMsT0FBQSxvQkFBQWdDLFVBQUFBLENBQWNoQixLQUFBNUQsT0FBQUEsQ0FBTTZFLEdBQU43RSxDQUFkNEUsQ0E1TjlDLENBQUEsbUJBQUEsa0JBQUEsTUE0TmlCaEMsQ0FBQXBDLE1BQUFBLENBQWdFLElBQWhFQSxDQUFBRixFQUF3RSxJQUF4RUEsQ0FBYjtBQUFBLE1BQ0EsT0FBQyw0QkFBOEIseUJBQVUsYUFEekM7QUFERm9FLElBQUFBLENBQUFBLGtDQUFBQSxDQTNMQTtBQUFBO0FBZ01BSSxJQUFBQSxvQ0FBQUEsNEJBQUFBLDRCQUFxQixJQUFyQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQUMsYUFBYUMsSUFBQWhGLE9BQUFBLENBQUssT0FBTEEsQ0FBQWlGLE9BQUFBLENBQW1CLG9DQUFuQkEsQ0FBYjtBQUFBLE1BQ0EsSUFBQSxRQUFHRixVQUFILENBQUE7QUFBQTtBQUNFO0FBbk9OLFFBQUFaLFVBQUEsQ0FtT1csT0FuT1gsRUFtT3FCYSxJQUFBaEYsT0FBQUEsQ0FBSyxPQUFMQSxDQUFBd0MsTUFBQUEsQ0FBa0Isc0NBQXNCLEVBQXhDQSxDQW5PckIsQ0FBQTtBQUFBLFFBbU9NNkIsTUFBQVcsSUFBQVgsT0FBQUEsRUFuT04sVUFBQUYsT0FBQSxDQW1PTUUsQ0FuT047QUFBQSxRQUFBRixPQUFBLENBQUFHLFVBQUFILE9BQUEsQ0FBQSxRQUFBLENBQUFHLEVBQUFoRixDQUFBZ0YsQ0FBQSxDQUFBLENBbU9NO0FBQUE7QUFuT04sUUFBQUgsVUFBQSxDQW9PVyxLQXBPWCxNQW9PbUJlLGtCQUFBQSxDQUFpQkgsVUFBQS9FLE9BQUFBLENBQVdYLENBQVhXLENBQWpCa0YsQ0FwT25CLENBQUE7QUFBQSxRQW9PTWIsTUFBQVcsSUFBQVgsT0FBQUEsRUFwT04sVUFBQUYsT0FBQSxDQW9PTUUsQ0FwT047QUFBQSxRQUFBRixPQUFBLENBQUFHLFVBQUFILE9BQUEsQ0FBQSxRQUFBLENBQUFHLEVBQUFoRixDQUFBZ0YsQ0FBQSxDQUFBLENBbU9NLENBREYsQ0FEQTtBQUFBLE1BS0EsSUFBQSxRQUFtQ1UsSUFBQWhGLE9BQUFBLENBQUssT0FBTEEsQ0FBQUksV0FBQUEsQ0FBQUEsQ0FBbkMsQ0FBQTtBQUFBLFFBQUEsV0FBQUMsT0FBQUEsQ0FBTSx5QkFBTkE7QUFBQSxNQUFBO0FBQUE7QUFBQSxNQUFBLENBTEE7QUFERnlFLElBQUFBLENBQUFBLHVDQUFBQSxDQWhNQTtBQUFBO0FBeU1BdkUsSUFBQUEsdUJBQUFBLGVBQUFBLGVBQVEsSUFBUkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQXlFLE9BQU8sd0NBQUEsU0FDRSxLQURGLEVBQUEsU0FFRUcsSUFGRixFQUFBLFlBR0tuQyxVQUFBRyxVQUFBQSxDQUFnQiwyQkFBaEJBLENBSEwsRUFBUDtBQUFBLFVBS0EyQixrQkFBQUEsQ0FBaUJFLElBQWpCRixDQUxBO0FBQUEsTUFPQWpCLGFBQWMsNEJBQThCLHlCQUFVLE9BUHREO0FBQUEsTUFRQUEsYUFsUEp2RCxTQWtQSXVELFVBbFBKdkQsRUFrUGtCQSxTQUFBLG9CQUFBc0UsVUFBQUEsQ0FBY0ksSUFBZEosQ0FBQXRFLEVBQXNCLElBQXRCQSxDQWxQbEJBLENBME9JO0FBQUEsTUFTQyw0QkFBOEIseUJBQVUsYUFUekM7QUFBQSxNQVVBLFdBQUFTLE1BQUFBLENBQUFBLENBVkE7QUFERlIsSUFBQUEsQ0FBQUEsMEJBQUFBLENBek1BO0FBQUE7QUF1TkFpQixJQUFBQSwwQkFBQUEsa0JBQUFBLGtCQUFXLElBQUQsRUFBTyxJQUFqQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBdlBGO0FBdVBtQixNQUFBO0FBQUEsTUFBQSxTQUFPLEVBQVA7QUFBQSxNQUFBLENBdlBuQjtBQUFBLE1Bd1BJb0MsWUFBUUYsWUFBQUEsQ0FBVzBCLElBQVgxQixDQXhQWjtBQUFBO0FBQUEsTUFBQVMsVUFBQSxDQXlQZ0IsT0F6UGhCLEVBeVAwQixDQUFDUCxLQUFBNUQsT0FBQUEsQ0FBTW9GLElBQU5wRixDQUFBQSxPQUFBQSxDQUFZLE9BQVpBLENBQUQsRUFBc0JtRixJQUF0QixDQUFBM0UsTUFBQUEsQ0FBaUMsR0FBakNBLENBelAxQixDQUFBO0FBQUEsTUF5UEk2RCxNQUFBVCxLQUFBNUQsT0FBQUEsQ0FBTW9GLElBQU5wRixDQUFBcUUsT0FBQUEsRUF6UEosVUFBQUYsT0FBQSxDQXlQSUUsQ0F6UEo7QUFBQSxNQUFBRixPQUFBLENBQUFHLFVBQUFILE9BQUEsQ0FBQSxRQUFBLENBQUFHLEVBQUFoRixDQUFBZ0YsQ0FBQSxDQUFBLENBQUE7QUFBQTtBQUFBLE1BQUFILFVBQUEsQ0EwUGdCLFVBMVBoQixFQTBQNkJuQixVQUFBRyxVQUFBQSxDQUFnQiwyQkFBaEJBLENBMVA3QixDQUFBO0FBQUEsTUEwUElrQixNQUFBVCxLQUFBNUQsT0FBQUEsQ0FBTW9GLElBQU5wRixDQUFBcUUsT0FBQUEsRUExUEosVUFBQUYsT0FBQSxDQTBQSUUsQ0ExUEo7QUFBQSxNQUFBRixPQUFBLENBQUFHLFVBQUFILE9BQUEsQ0FBQSxRQUFBLENBQUFHLEVBQUFoRixDQUFBZ0YsQ0FBQSxDQUFBLENBQUE7QUFBQSxVQTJQSVEsa0JBQUFBLENBQWlCbEIsS0FBQTVELE9BQUFBLENBQU1vRixJQUFOcEYsQ0FBakI4RSxDQTNQSjtBQUFBLFVBNFBJSixhQUFBQSxDQUFZZCxLQUFaYyxDQTVQSjtBQUFBLE1BNlBJLFdBQUEzRCxNQUFBQSxDQUFLNkMsS0FBTDdDLENBN1BKO0FBdVBFUyxJQUFBQSxDQUFBQSw4QkFBQUEsQ0F2TkE7QUFBQTtBQWdPQUMsSUFBQUEsMEJBQUFBLGtCQUFBQSxrQkFBVyxJQUFELEVBQU8sSUFBakJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFtQyxZQUFRRixZQUFBQSxDQUFXMEIsSUFBWDFCLENBQVI7QUFBQTtBQWpRSixNQUFBUyxVQUFBLENBa1FnQixPQWxRaEIsRUFrUTBCZ0IsSUFsUTFCLENBQUE7QUFBQSxNQWtRSWQsTUFBQVQsS0FBQTVELE9BQUFBLENBQU1vRixJQUFOcEYsQ0FBQXFFLE9BQUFBLEVBbFFKLFVBQUFGLE9BQUEsQ0FrUUlFLENBbFFKO0FBQUEsTUFBQUYsT0FBQSxDQUFBRyxVQUFBSCxPQUFBLENBQUEsUUFBQSxDQUFBRyxFQUFBaEYsQ0FBQWdGLENBQUEsQ0FBQSxDQWlRSTtBQUFBO0FBalFKLE1BQUFILFVBQUEsQ0FtUWdCLFVBblFoQixFQW1RNkJuQixVQUFBRyxVQUFBQSxDQUFnQiwyQkFBaEJBLENBblE3QixDQUFBO0FBQUEsTUFtUUlrQixNQUFBVCxLQUFBNUQsT0FBQUEsQ0FBTW9GLElBQU5wRixDQUFBcUUsT0FBQUEsRUFuUUosVUFBQUYsT0FBQSxDQW1RSUUsQ0FuUUo7QUFBQSxNQUFBRixPQUFBLENBQUFHLFVBQUFILE9BQUEsQ0FBQSxRQUFBLENBQUFHLEVBQUFoRixDQUFBZ0YsQ0FBQSxDQUFBLENBaVFJO0FBQUEsVUFHQVEsa0JBQUFBLENBQWlCbEIsS0FBQTVELE9BQUFBLENBQU1vRixJQUFOcEYsQ0FBakI4RSxDQUhBO0FBQUEsVUFJQUosYUFBQUEsQ0FBWWQsS0FBWmMsQ0FKQTtBQUFBLE1BS0EsV0FBQTNELE1BQUFBLENBQUs2QyxLQUFMN0MsQ0FMQTtBQURGVSxJQUFBQSxDQUFBQSw2QkFBQUEsQ0FoT0E7QUFBQTtBQXlPQUUsSUFBQUEsMEJBQUFBLGtCQUFBQSxTQUFXLElBQVhBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFpQyxZQUFRRixZQUFBQSxDQUFXMEIsSUFBWDFCLENBQVI7QUFBQSxNQUNBRSxLQUFBakMsUUFBQUEsQ0FBYXlELElBQWJ6RCxDQURBO0FBQUEsVUFFQStDLGFBQUFBLENBQVlkLEtBQVpjLENBRkE7QUFBQSxNQUdBLFdBQUEzRCxNQUFBQSxDQUFBQSxDQUhBO0FBREZZLElBQUFBLENBQUFBLDZCQUFBQSxDQXpPQTtBQUFBO0FBZ1BBZixJQUFBQSxnQ0FBQUEsd0JBQUFBLHdCQUFpQixJQUFELEVBQU8sS0FBUCxFQUFjLElBQTlCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFoUkY7QUFnUmdDLE1BQUE7QUFBQSxNQUFBLFNBQU8sR0FBUDtBQUFBLE1BQUEsQ0FoUmhDO0FBQUEsTUFpUklnRCxZQUFRRixZQUFBQSxDQUFXMEIsSUFBWDFCLENBalJaO0FBQUE7QUFBQSxNQUFBUyxVQUFBLENBa1JnQixPQWxSaEIsRUFrUjBCa0IsS0FsUjFCLENBQUE7QUFBQSxNQWtSSWhCLE1BQUFULEtBQUE1RCxPQUFBQSxDQUFNb0YsSUFBTnBGLENBQUFxRSxPQUFBQSxFQWxSSixVQUFBRixPQUFBLENBa1JJRSxDQWxSSjtBQUFBLE1BQUFGLE9BQUEsQ0FBQUcsVUFBQUgsT0FBQSxDQUFBLFFBQUEsQ0FBQUcsRUFBQWhGLENBQUFnRixDQUFBLENBQUEsQ0FBQTtBQUFBO0FBQUEsTUFBQUgsVUFBQSxDQW1SZ0IsVUFuUmhCLEVBbVI2Qm5CLFVBQUFHLFVBQUFBLENBQWdCLDJCQUFoQkEsQ0FuUjdCLENBQUE7QUFBQSxNQW1SSWtCLE1BQUFULEtBQUE1RCxPQUFBQSxDQUFNb0YsSUFBTnBGLENBQUFxRSxPQUFBQSxFQW5SSixVQUFBRixPQUFBLENBbVJJRSxDQW5SSjtBQUFBLE1BQUFGLE9BQUEsQ0FBQUcsVUFBQUgsT0FBQSxDQUFBLFFBQUEsQ0FBQUcsRUFBQWhGLENBQUFnRixDQUFBLENBQUEsQ0FBQTtBQUFBLE1Bb1JJLElBQUEsUUFBRyxhQUFBLElBQUEsUUFwUlBnQixDQUFBQSxhQW9SUUMsSUFBQXBGLFNBQUFBLENBQUFBLENBQUQyRCxNQUFBQSxDQUFBQSxDQXBSUHdCLENBb1JPLENBQUE7QUFBQSxRQUFjLE9BQUNDLElBQUFuRixXQUFBQSxDQUFBQSxDQUFEMEQsTUFBQUEsQ0FBQUE7QUFBZCxNQUFBO0FBQUEsUUFwUlAsT0FBQTtBQW9STyxNQUFBLENBQUEsa0JBQUgsQ0FBQTtBQUFBO0FBQ0U7QUFyUk4sUUFBQTBCLDBCQXFSTTVCLEtBQUE1RCxPQUFBQSxDQUFNb0YsSUFBTnBGLENBclJOO0FBQUEsUUFBQSxJQUFBLFFBQUF5RixDQUFBQSxhQUFBLHVCQXFSTXpGLE9BQUFBLENBQVksTUFBWkEsQ0FyUk55RixDQUFBLENBQUE7QUFBQSxVQUFBO0FBQUEsUUFBQTtBQUFBO0FBQUEsVUFBQXRCLFVBQUEsQ0FxUmtCLE1BclJsQixFQXFSNkIsRUFyUjdCLENBQUE7QUFBQSxVQXFSTUUsTUFyUk4sdUJBcVJNQSxPQUFBQSxFQXJSTixVQUFBRixPQUFBLENBcVJNRSxDQXJSTjtBQUFBLFVBQUFGLE9BQUEsQ0FBQUcsVUFBQUgsT0FBQSxDQUFBLFFBQUEsQ0FBQUcsRUFBQWhGLENBQUFnRixDQUFBLENBQUE7QUFBQSxRQUFBLENBQUEsQ0FxUk07QUFBQSxRQUNBVixLQUFBNUQsT0FBQUEsQ0FBTW9GLElBQU5wRixDQUFBQSxPQUFBQSxDQUFZLE1BQVpBLENBQUErQixNQUFBQSxDQUF3QndELElBQXhCeEQsQ0FEQSxDQURGLENBcFJKO0FBQUEsVUF3UkkyQyxhQUFBQSxDQUFZZCxLQUFaYyxDQXhSSjtBQUFBLE1BeVJJLFdBQUEzRCxNQUFBQSxDQUFLNkMsS0FBTDdDLENBelJKO0FBZ1JFSCxJQUFBQSxDQUFBQSxvQ0FBQUEsQ0FoUEE7QUFBQTtBQTRQQVEsSUFBQUEsZ0NBQUFBLHdCQUFBQSx3QkFBaUIsSUFBRCxFQUFPLElBQXZCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUE1UkY7QUE0UnlCLE1BQUE7QUFBQSxNQUFBLFNBQU8sR0FBUDtBQUFBLE1BQUEsQ0E1UnpCO0FBQUEsTUE2Ukl3QyxZQUFRRixZQUFBQSxDQUFXMEIsSUFBWDFCLENBN1JaO0FBQUE7QUFBQSxNQUFBUyxVQUFBLENBOFJnQixVQTlSaEIsRUE4UjhCUCxLQUFBNUQsT0FBQUEsQ0FBTW9GLElBQU5wRixDQUFBQSxPQUFBQSxDQUFZLFVBQVpBLENBQUQ4RCxNQUFBQSxDQUFBQSxDQTlSN0IsQ0FBQTtBQUFBLE1BOFJJTyxNQUFBVCxLQUFBNUQsT0FBQUEsQ0FBTW9GLElBQU5wRixDQUFBcUUsT0FBQUEsRUE5UkosVUFBQUYsT0FBQSxDQThSSUUsQ0E5Uko7QUFBQSxNQUFBRixPQUFBLENBQUFHLFVBQUFILE9BQUEsQ0FBQSxRQUFBLENBQUFHLEVBQUFoRixDQUFBZ0YsQ0FBQSxDQUFBLENBQUE7QUFBQSxNQStSSSxJQUFBLFFBQWtDVixLQUFBNUQsT0FBQUEsQ0FBTW9GLElBQU5wRixDQUFBQSxPQUFBQSxDQUFZLFVBQVpBLENBQUQ4RCxNQUFBQSxDQUFBQSxDQUFqQyxDQUFBO0FBQUEsUUFBQUYsS0FBQTVELE9BQUFBLENBQU1vRixJQUFOcEYsQ0FBQTJCLFFBQUFBLENBQW1CLFVBQW5CQSxDQUFBLENBL1JKO0FBQUE7QUFBQSxNQUFBd0MsVUFBQSxDQWdTZ0IsVUFoU2hCLEVBZ1M2Qm5CLFVBQUFHLFVBQUFBLENBQWdCLDJCQUFoQkEsQ0FoUzdCLENBQUE7QUFBQSxNQWdTSWtCLE1BQUFULEtBQUE1RCxPQUFBQSxDQUFNb0YsSUFBTnBGLENBQUFxRSxPQUFBQSxFQWhTSixVQUFBRixPQUFBLENBZ1NJRSxDQWhTSjtBQUFBLE1BQUFGLE9BQUEsQ0FBQUcsVUFBQUgsT0FBQSxDQUFBLFFBQUEsQ0FBQUcsRUFBQWhGLENBQUFnRixDQUFBLENBQUEsQ0FBQTtBQUFBLE1BaVNJLElBQUEsUUFBRyxhQUFBLElBQUEsUUFqU1BvQixDQUFBQSxhQWlTUUgsSUFBQXBGLFNBQUFBLENBQUFBLENBQUQyRCxNQUFBQSxDQUFBQSxDQWpTUDRCLENBaVNPLENBQUE7QUFBQSxRQUFjLE9BQUNILElBQUFuRixXQUFBQSxDQUFBQSxDQUFEMEQsTUFBQUEsQ0FBQUE7QUFBZCxNQUFBO0FBQUEsUUFqU1AsT0FBQTtBQWlTTyxNQUFBLENBQUEsa0JBQUgsQ0FBQTtBQUFBO0FBQ0U7QUFsU04sUUFBQTZCLDBCQWtTTS9CLEtBQUE1RCxPQUFBQSxDQUFNb0YsSUFBTnBGLENBbFNOO0FBQUEsUUFBQSxJQUFBLFFBQUE0RixDQUFBQSxhQUFBLHVCQWtTTTVGLE9BQUFBLENBQVksTUFBWkEsQ0FsU040RixDQUFBLENBQUE7QUFBQSxVQUFBO0FBQUEsUUFBQTtBQUFBO0FBQUEsVUFBQXpCLFVBQUEsQ0FrU2tCLE1BbFNsQixFQWtTNkIsRUFsUzdCLENBQUE7QUFBQSxVQWtTTUUsTUFsU04sdUJBa1NNQSxPQUFBQSxFQWxTTixVQUFBRixPQUFBLENBa1NNRSxDQWxTTjtBQUFBLFVBQUFGLE9BQUEsQ0FBQUcsVUFBQUgsT0FBQSxDQUFBLFFBQUEsQ0FBQUcsRUFBQWhGLENBQUFnRixDQUFBLENBQUE7QUFBQSxRQUFBLENBQUEsQ0FrU007QUFBQSxRQUNBVixLQUFBNUQsT0FBQUEsQ0FBTW9GLElBQU5wRixDQUFBQSxPQUFBQSxDQUFZLE1BQVpBLENBQUErQixNQUFBQSxDQUF3QndELElBQXhCeEQsQ0FEQSxDQURGLENBalNKO0FBQUEsVUFxU0kyQyxhQUFBQSxDQUFZZCxLQUFaYyxDQXJTSjtBQUFBLE1Bc1NJLFdBQUEzRCxNQUFBQSxDQUFLNkMsS0FBTDdDLENBdFNKO0FBNFJFSyxJQUFBQSxDQUFBQSxvQ0FBQUEsQ0E1UEE7QUFBQTtBQXlRQUUsSUFBQUEsNEJBQUFBLG9CQUFBQSxvQkFBYSxJQUFELEVBQU8sSUFBbkJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQXpTRjtBQXlTcUIsTUFBQTtBQUFBLE1BQUEsU0FBTyxFQUFQO0FBQUEsTUFBQSxDQXpTckI7QUFBQSxNQTBTSXNDLFlBQVFGLFlBQUFBLENBQVcwQixJQUFYMUIsQ0ExU1o7QUFBQTtBQUFBLE1BQUFTLFVBQUEsQ0EyU2dCLEtBM1NoQixNQTJTd0JlLGtCQUFBQSxDQUFpQlcsSUFBakJYLENBM1N4QixDQUFBO0FBQUEsTUEyU0liLE1BQUFULEtBQUE1RCxPQUFBQSxDQUFNb0YsSUFBTnBGLENBQUFxRSxPQUFBQSxFQTNTSixVQUFBRixPQUFBLENBMlNJRSxDQTNTSjtBQUFBLE1BQUFGLE9BQUEsQ0FBQUcsVUFBQUgsT0FBQSxDQUFBLFFBQUEsQ0FBQUcsRUFBQWhGLENBQUFnRixDQUFBLENBQUEsQ0FBQTtBQUFBLE1BNFNJLElBQUEsUUFBNEJWLEtBQUE1RCxPQUFBQSxDQUFNb0YsSUFBTnBGLENBQUFBLE9BQUFBLENBQVksS0FBWkEsQ0FBQUcsU0FBQUEsQ0FBQUEsQ0FBNUIsQ0FBQTtBQUFBLFFBQUF5RCxLQUFBNUQsT0FBQUEsQ0FBTW9GLElBQU5wRixDQUFBMkIsUUFBQUEsQ0FBbUIsS0FBbkJBLENBQUEsQ0E1U0o7QUFBQTtBQUFBLE1BQUF3QyxVQUFBLENBNlNnQixVQTdTaEIsRUE2UzZCbkIsVUFBQUcsVUFBQUEsQ0FBZ0IsMkJBQWhCQSxDQTdTN0IsQ0FBQTtBQUFBLE1BNlNJa0IsTUFBQVQsS0FBQTVELE9BQUFBLENBQU1vRixJQUFOcEYsQ0FBQXFFLE9BQUFBLEVBN1NKLFVBQUFGLE9BQUEsQ0E2U0lFLENBN1NKO0FBQUEsTUFBQUYsT0FBQSxDQUFBRyxVQUFBSCxPQUFBLENBQUEsUUFBQSxDQUFBRyxFQUFBaEYsQ0FBQWdGLENBQUEsQ0FBQSxDQUFBO0FBQUEsVUE4U0lJLGFBQUFBLENBQVlkLEtBQVpjLENBOVNKO0FBQUEsTUErU0ksV0FBQTNELE1BQUFBLENBQUs2QyxLQUFMN0MsQ0EvU0o7QUF5U0VPLElBQUFBLENBQUFBLGdDQUFBQSxDQXpRQTtBQUFBO0FBa1JBUCxJQUFBQSx3QkFBQUEsZ0JBQUFBLGdCQUFTLEtBQUQsRUFBYyxRQUF0QkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBbFRGO0FBa1RXLE1BQUE7QUFBQSxNQUFBLFVBQVEsR0FBUjtBQUFBLE1BQUEsQ0FsVFg7QUFBQTtBQWtUd0IsTUFBQTtBQUFBLE1BQUEsYUFBVyxHQUFYO0FBQUEsTUFBQSxDQWxUeEI7QUFBQSxNQW1USStFLFFBQVEsWUFBQSxFQW5UWjtBQUFBLE1Bb1RJbEMsUUFBUSxhQUFBLElBQUEsUUFwVFptQyxDQUFBQSxhQW9UWW5DLEtBcFRabUMsQ0FvVFksQ0FBQTtBQUFBLFFBcFRaLE9BQUE7QUFvVFksTUFBQTtBQUFBLFFBQVMsV0FBQXJDLFlBQUFBLENBQUFBO0FBQVQsTUFBQSxDQUFBLGtCQXBUWjtBQUFBLE1BcVRJc0MsY0FBYyxDQUFDcEMsS0FBQWpCLE1BQUFBLENBQUFBLENBQUFzRCxLQUFBQSxDQUFBQSxDQUFBNUQsTUFBQUEsQ0FBQUEsQ0FBQTZELE1BQUFBLENBQUFBLENBQUQsRUFBMkI5RyxDQUEzQixDQUFBNkcsS0FBQUEsQ0FBQUEsQ0FyVGxCO0FBQUEsTUFzVElFLFdBQVcsYUFBQSxJQUFBLFFBQUEsYUFBQSxJQUFBLFFBdFRmQyxDQUFBQSxhQXNUZUQsUUFBQWhHLFNBQUFBLENBQUFBLENBdFRmaUcsQ0FzVGUsQ0FBQTtBQUFBLFFBdFRmLE9BQUE7QUFzVGUsTUFBQTtBQUFBLFFBQWlCLE9BQUFELFFBQUEvRixXQUFBQSxDQUFBQTtBQUFqQixNQUFBLENBQUEsa0JBQUEsQ0FBQTtBQUFBLFFBQW1DLE9BQUEsQ0FBQ3NDLFlBQUExQyxPQUFBQSxDQUFTLFNBQVRBLENBQUQ7QUFBbkMsTUFBQTtBQUFBLFFBQTJELE9BQUFtRztBQUEzRCxNQUFBLENBQUEsa0JBdFRmO0FBQUEsTUF1VElwQyxNQUFBSCxLQUFBRyxRQUFBQSxFQUFBQSxFQUFBQSxFQXZUSixpQkF1VG1CLEdBQUQsRUFBTSxJQXZUeEIsRUFBQTs7QUFBQTtBQUFBO0FBdVRtQixRQUFBO0FBQUEsUUFBQTtBQUFBLFFBQUEsQ0F2VG5CO0FBQUE7QUF1VHdCLFFBQUE7QUFBQSxRQUFBO0FBQUEsUUFBQSxDQXZUeEI7QUFBQSxRQXdUTXNDLGtCQUFrQixFQUFBLEdBQUEsUUFBQSxHQUFBLENBQVNyQixJQUFBaEYsT0FBQUEsQ0FBSyxPQUFMQSxDQUFULENBQUEsR0FBQSxPQUFBLEdBQUEsQ0FBNkJnRixJQUFBaEYsT0FBQUEsQ0FBSyxLQUFMQSxDQUE3QixDQUFBLEdBQUEsR0FBQSxHQUFBLENBQTJDZ0YsSUFBQWhGLE9BQUFBLENBQUssT0FBTEEsQ0FBM0MsQ0F4VHhCO0FBQUEsUUF5VE1pRixRQUFRLElBelRkO0FBQUEsUUEwVE1sQixNQUFBb0MsUUFBQXBDLFFBQUFBLEVBQUFBLEVBQUFBLEVBMVROLGlCQTBUd0IsT0ExVHhCLEVBQUE7QUFBQTs7QUFBQTtBQUFBO0FBMFR3QixVQUFBO0FBQUEsVUFBQTtBQUFBLFVBQUEsQ0ExVHhCO0FBQUEsVUEyVFEsSUFBQSxRQUFxQixhQUFHLGFBQUEsSUFBQSxRQTNUaEN1QyxDQUFBQSxhQTJUZ0M1RCxZQUFBMUMsT0FBQUEsQ0FBU3VHLE9BQVR2RyxDQTNUaENzRyxDQTJUZ0MsQ0FBQTtBQUFBLFlBM1RoQyxPQUFBO0FBMlRnQyxVQUFBO0FBQUEsWUFBcUIsT0FBQUM7QUFBckIsVUFBQSxDQUFBLGtCQUFILENBQUEsS0FBQSxDQUFBdEIsT0FBQUEsQ0FBMENvQixlQUExQ3BCLENBQXJCLENBQUE7QUFBQTtBQUFBLFVBQUE7QUFBQSxZQUFBLE9BQUFBLENBQUFBLFFBQVEsS0FBUkE7QUFBQSxVQUFBLENBM1RSLENBQUEsbUJBQUEsa0JBQUEsTUEwVE1sQixDQTFUTjtBQUFBLFFBNlRNLElBQUEsUUFBcUJrQixLQUFyQixDQUFBO0FBQUE7QUE3VE4sVUFBQWQsVUFBQSxDQTZUWXFDLEdBN1RaLEVBNlRtQnhCLElBN1RuQixDQUFBO0FBQUEsVUE2VE1YLE1BQUF5QixLQUFBekIsT0FBQUEsRUE3VE4sVUFBQUYsT0FBQSxDQTZUTUUsQ0E3VE47QUFBQSxVQUFBLE9BQUFGLE9BQUEsQ0FBQUcsVUFBQUgsT0FBQSxDQUFBLFFBQUEsQ0FBQUcsRUFBQWhGLENBQUFnRixDQUFBLENBQUE7QUE2VE0sUUFBQTtBQUFBO0FBQUEsUUFBQSxDQTdUTixDQUFBLG1CQUFBLGtCQUFBLE1BdVRJUCxDQXZUSjtBQUFBLE1BK1RJK0IsUUFBUVcsTUFBQVgsS0FBQVcsV0FBQUEsRUFBQUEsRUFBQUEsRUEvVFosaUJBK1Q4QixHQUFELEVBQU0sSUEvVG5DLEVBQUE7O0FBQUE7QUFBQTtBQStUOEIsUUFBQTtBQUFBLFFBQUE7QUFBQSxRQUFBLENBL1Q5QjtBQUFBO0FBK1RtQyxRQUFBO0FBQUEsUUFBQTtBQUFBLFFBQUEsQ0EvVG5DO0FBQUEsUUFnVU0sT0FBQSxDQUFDLGFBQUEsSUFBQSxRQUFBLGFBQUEsSUFBQSxRQWhVUEMsQ0FBQUEsYUFnVU8xQixJQUFBaEYsT0FBQUEsQ0FBSyxVQUFMQSxDQWhVUDBHLENBZ1VPLENBQUE7QUFBQSxVQUFtQixPQUFBMUIsSUFBQWhGLE9BQUFBLENBQUssT0FBTEEsQ0FBQTBCLE9BQUFBLENBQWdCLE1BQWhCQTtBQUFuQixRQUFBO0FBQUEsVUFoVVAsT0FBQTtBQWdVTyxRQUFBLENBQUEsa0JBQUEsQ0FBQTtBQUFBLFVBQTRDLE9BQUFmO0FBQTVDLFFBQUE7QUFBQSxVQUFnRCxPQUFBckI7QUFBaEQsUUFBQSxDQUFBLGtCQUFELEVBQW9ELHFCQUFBVSxPQUFBQSxDQUFNLGFBQUEsSUFBQSxRQWhVaEUyRyxDQUFBQSxhQWdVZ0UzQixJQUFBaEYsT0FBQUEsQ0FBSyxPQUFMQSxDQWhVaEUyRyxDQWdVZ0UsQ0FBQTtBQUFBLFVBaFVoRSxPQUFBO0FBZ1VnRSxRQUFBO0FBQUEsVUFBZ0IsT0FBQTtBQUFoQixRQUFBLENBQUEsa0JBQU4zRyxDQUFwRCxFQUFzRixhQUFBLElBQUEsUUFoVTVGNEcsQ0FBQUEsYUFnVTRGNUIsSUFBQWhGLE9BQUFBLENBQUssS0FBTEEsQ0FoVTVGNEcsQ0FnVTRGLENBQUE7QUFBQSxVQWhVNUYsT0FBQTtBQWdVNEYsUUFBQTtBQUFBLFVBQWMsT0FBQTtBQUFkLFFBQUEsQ0FBQSxrQkFBdEYsRUFBMkdKLEdBQTNHLENBaFVOLENBQUEsbUJBQUEsa0JBQUEsTUErVFlDLENBL1RaO0FBQUEsTUFrVUkxQyxNQUFBK0IsS0FBQS9CLFFBQUFBLEVBQUFBLEVBQUFBLEVBbFVKLGlCQWtVbUIsR0FBRCxFQUFNLElBbFV4QixFQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFrVW1CLFFBQUE7QUFBQSxRQUFBO0FBQUEsUUFBQSxDQWxVbkI7QUFBQTtBQWtVd0IsUUFBQTtBQUFBLFFBQUE7QUFBQSxRQUFBLENBbFV4QjtBQUFBLFFBbVVNc0IsUUFBUSxhQUFBLElBQUEsUUFuVWR3QixDQUFBQSxhQW1VYzdCLElBQUFoRixPQUFBQSxDQUFLLE9BQUxBLENBblVkNkcsQ0FtVWMsQ0FBQTtBQUFBLFVBblVkLE9BQUE7QUFtVWMsUUFBQTtBQUFBLFVBQWdCLE9BQUE7QUFBaEIsUUFBQSxDQUFBLGtCQW5VZDtBQUFBLFFBb1VNQyxRQUFRLHNCQUFBOUcsT0FBQUEsQ0FBT3FGLEtBQVByRixDQXBVZDtBQUFBLFFBcVVNK0csb0JBQWdCNUUsVUFBQUEsQ0FBUyxzQkFBQW5DLE9BQUFBLENBQU9xRixLQUFQckYsR0FBZThHLEtBQXhCM0UsQ0FyVXRCO0FBQUEsUUFzVU02RSxRQUFReEUsTUFBQXdDLElBQUFoRixPQUFBQSxDQUFLLE9BQUxBLENBQUF3QyxRQUFBQSxFQUFBQSxDQUFrQixtQ0FBbEJBLENBQUFBLEVBdFVkLGlCQXNVeUQsR0F0VXpELEVBQUE7O0FBQUE7QUFBQTtBQXNVeUQsVUFBQTtBQUFBLFVBQUE7QUFBQSxVQUFBLENBdFV6RDtBQUFBLFVBdVVRLE9BQUFsQyxTQUFDLGFBQUEsSUFBQSxRQUFBMkcsR0FBQUMsZ0JBQUFBLENBQWdCLEdBQWhCQSxDQUFBLENBQUE7QUFBQSxZQUF1QixPQUFBO0FBQXZCLFVBQUE7QUFBQSxZQUE2QixPQUFBO0FBQTdCLFVBQUEsQ0FBQSxrQkFBRDVHLE1BQW9DNkIsVUFBQUEsQ0FBUzhFLEdBQUFoRixPQUFBQSxDQUFBQSxHQUFXLE1BQXBCRSxDQUFwQzdCLENBdlVSLENBQUEsbUJBQUEsa0JBQUEsTUFzVWNrQyxDQXRVZDtBQUFBLFFBeVVNMkUsZ0JBQWdCLGFBQUEsSUFBQSxRQUFBbkMsSUFBQWhGLE9BQUFBLENBQUssVUFBTEEsQ0FBQSxDQUFBO0FBQUEsVUFBa0IsV0FBQW1DLFVBQUFBLENBQVMsK0JBQWUsS0FBeEJBO0FBQWxCLFFBQUE7QUFBQSxVQUFrRCxPQUFBO0FBQWxELFFBQUEsQ0FBQSxrQkF6VXRCO0FBQUEsUUEwVU1iLFdBQVcsRUExVWpCO0FBQUEsUUEyVU0sSUFBQSxRQUFHLGFBQUEsSUFBQSxRQTNVVDhGLENBQUFBLGFBMlVTcEMsSUFBQWhGLE9BQUFBLENBQUssS0FBTEEsQ0EzVVRvSCxDQTJVUyxDQUFBO0FBQUEsVUFBYyxPQUFBL0IsS0FBQTNELE9BQUFBLENBQVMsTUFBVEE7QUFBZCxRQUFBO0FBQUEsVUEzVVQsT0FBQTtBQTJVUyxRQUFBLENBQUEsa0JBQUgsQ0FBQTtBQUFBO0FBQ0UsVUFBQTJGLFlBQWEvQyxVQUFBLG9CQUFBckIsT0FBQUEsQ0FBVytCLElBQUFoRixPQUFBQSxDQUFLLEtBQUxBLENBQVhpRCxDQUFBcUIsRUFBeUJ0QixVQUF6QnNCLENBQUR6RCxNQUFBQSxDQUFBQSxDQUFaO0FBQUEsVUFDQSxJQUFBLFFBQUdNLE9BQUFrRyxTQUFBbEcsRUFBWVIsQ0FBWlEsQ0FBSCxDQUFBO0FBQUEsWUFDRUcsZUFBV2EsVUFBQUEsQ0FBUyxFQUFBLEdBQUEsR0FBQSxHQUFBLENBQUlrRixTQUFBQyxLQUFBQSxDQUFBQSxDQUFKLENBQUEsR0FBQSxjQUErQixLQUF4Q25GO0FBRGIsVUFBQSxPQUVBLElBQUEsUUFBTSxhQUFBLElBQUEsUUEvVWRvRixDQUFBQSxhQStVY0YsU0FBQW5ELE9BQUFBLENBQWF2RCxDQUFidUQsQ0EvVWRxRCxDQStVYyxDQUFBO0FBQUEsWUEvVWQsT0FBQTtBQStVYyxVQUFBO0FBQUEsWUFBa0IsT0FBQUYsU0FBQW5ELE9BQUFBLENBQWE1RSxDQUFiNEU7QUFBbEIsVUFBQSxDQUFBLGtCQUFOLENBQUE7QUFBQSxZQUNFNUMsZUFBV2EsVUFBQUEsQ0FBUyxFQUFBLEdBQUEsR0FBQSxHQUFBLENBQUksb0NBQUFuQyxPQUFBQSxDQUFxQnFILFNBQXJCckgsQ0FBSixDQUFBLEdBQUEsS0FBd0MsUUFBakRtQztBQURiLFVBQUEsT0FHRSxJQUFBLFFBQWlGMUIsT0FBQTRHLFNBQUE1RyxFQUFZbkIsQ0FBWm1CLENBQWpGLENBQUE7QUFBQSxZQUFBYSxlQUFXYSxVQUFBQSxDQUFTLEVBQUEsR0FBQSxHQUFBLEdBQUEsQ0FBSSxhQUFBLElBQUEsUUFsVmxDcUYsQ0FBQUEsYUFrVmtDakUsa0JBQUF2RCxPQUFBQSxDQUFlcUgsU0FBZnJILENBbFZsQ3dILENBa1ZrQyxDQUFBO0FBQUEsY0FsVmxDLE9BQUE7QUFrVmtDLFlBQUE7QUFBQSxjQUE2QixPQUFBeEMsSUFBQWhGLE9BQUFBLENBQUssS0FBTEE7QUFBN0IsWUFBQSxDQUFBLGtCQUFKLENBQUEsR0FBQSxLQUFnRCxTQUF6RG1DLENBQVgsQ0FORjtBQUFBLFVBUUFiLFdBQVdoQixTQUFBLEdBQUFBLEVBQU1nQixRQUFOaEIsQ0FSWCxDQURGLENBM1VOO0FBQUEsUUFzVk0sT0FBQWIsZ0JBQUFzQyxNQUFBQSxDQUFrQixFQUFBLEdBQUEsQ0FBR3lFLEdBQUFuRSxNQUFBQSxDQUFBQSxDQUFBb0YsT0FBQUEsQ0FBZXpCLGFBQWEsR0FBNUJ5QixDQUFILENBQUEsR0FBQSxHQUFBLEdBQUEsQ0FBdUNOLGFBQXZDLENBQUEsR0FBQSxDQUF1REosYUFBdkQsQ0FBQSxHQUFBLEdBQUEsR0FBQSxDQUF3RUMsS0FBeEUsQ0FBQSxHQUFBLENBQWdGMUYsUUFBaEYsQ0FBbEJTLENBdFZOLENBQUEsbUJBQUEsa0JBQUEsTUFrVUlnQyxDQWxVSjtBQUFBLE1Bd1ZJLElBQUEsUUFBc0MrQixLQUFBMUYsV0FBQUEsQ0FBQUEsQ0FBdEMsQ0FBQTtBQUFBLFFBQUEsT0FBQVgsZ0JBQUFzQyxNQUFBQSxDQUFrQixnQkFBbEJBO0FBQUEsTUFBQTtBQUFBO0FBQUEsTUFBQSxDQXhWSjtBQWtURWhCLElBQUFBLENBQUFBLDRCQUFBQSxDQWxSQTtBQUFBO0FBMlRBYSxJQUFBQSw0QkFBQUEsb0JBQUFBLG9CQUFhLElBQUQsRUFBTyxJQUFuQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQWdDLFlBQVFGLFlBQUFBLENBQVcwQixJQUFYMUIsQ0FBUjtBQUFBO0FBNVZKLE1BQUFnRSwwQkE2Vkk5RCxLQUFBNUQsT0FBQUEsQ0FBTW9GLElBQU5wRixDQTdWSjtBQUFBLE1BQUEsSUFBQSxRQUFBMkgsQ0FBQUEsYUFBQSx1QkE2VkkzSCxPQUFBQSxDQUFZLE1BQVpBLENBN1ZKMkgsQ0FBQSxDQUFBO0FBQUEsUUFBQTtBQUFBLE1BQUE7QUFBQTtBQUFBLFFBQUF4RCxVQUFBLENBNlZnQixNQTdWaEIsRUE2VjJCLEVBN1YzQixDQUFBO0FBQUEsUUE2VklFLE1BN1ZKLHVCQTZWSUEsT0FBQUEsRUE3VkosVUFBQUYsT0FBQSxDQTZWSUUsQ0E3Vko7QUFBQSxRQUFBRixPQUFBLENBQUFHLFVBQUFILE9BQUEsQ0FBQSxRQUFBLENBQUFHLEVBQUFoRixDQUFBZ0YsQ0FBQSxDQUFBO0FBQUEsTUFBQSxDQUFBLENBNFZJO0FBQUEsTUFFQVYsS0FBQTVELE9BQUFBLENBQU1vRixJQUFOcEYsQ0FBQUEsT0FBQUEsQ0FBWSxNQUFaQSxDQUFBK0IsTUFBQUEsQ0FBd0JvRCxJQUF4QnBELENBRkE7QUFBQTtBQTVWSixNQUFBb0MsVUFBQSxDQStWZ0IsVUEvVmhCLEVBK1Y2Qm5CLFVBQUFHLFVBQUFBLENBQWdCLDJCQUFoQkEsQ0EvVjdCLENBQUE7QUFBQSxNQStWSWtCLE1BQUFULEtBQUE1RCxPQUFBQSxDQUFNb0YsSUFBTnBGLENBQUFxRSxPQUFBQSxFQS9WSixVQUFBRixPQUFBLENBK1ZJRSxDQS9WSjtBQUFBLE1BQUFGLE9BQUEsQ0FBQUcsVUFBQUgsT0FBQSxDQUFBLFFBQUEsQ0FBQUcsRUFBQWhGLENBQUFnRixDQUFBLENBQUEsQ0E0Vkk7QUFBQSxVQUlBSSxhQUFBQSxDQUFZZCxLQUFaYyxDQUpBO0FBQUEsTUFLQSxXQUFBNUMsTUFBQUEsQ0FBS3NELElBQUx0RCxDQUxBO0FBREZGLElBQUFBLENBQUFBLCtCQUFBQSxDQTNUQTtBQUFBO0FBb1VBQyxJQUFBQSwrQkFBQUEsdUJBQUFBLHVCQUFnQixJQUFoQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQStCLFlBQVFGLFlBQUFBLENBQVcwQixJQUFYMUIsQ0FBUjtBQUFBLE1BQ0FFLEtBQUE1RCxPQUFBQSxDQUFNb0YsSUFBTnBGLENBQUEyQixRQUFBQSxDQUFtQixNQUFuQkEsQ0FEQTtBQUFBO0FBcldKLE1BQUF3QyxVQUFBLENBdVdnQixVQXZXaEIsRUF1VzZCbkIsVUFBQUcsVUFBQUEsQ0FBZ0IsMkJBQWhCQSxDQXZXN0IsQ0FBQTtBQUFBLE1BdVdJa0IsTUFBQVQsS0FBQTVELE9BQUFBLENBQU1vRixJQUFOcEYsQ0FBQXFFLE9BQUFBLEVBdldKLFVBQUFGLE9BQUEsQ0F1V0lFLENBdldKO0FBQUEsTUFBQUYsT0FBQSxDQUFBRyxVQUFBSCxPQUFBLENBQUEsUUFBQSxDQUFBRyxFQUFBaEYsQ0FBQWdGLENBQUEsQ0FBQSxDQXFXSTtBQUFBLFVBR0FJLGFBQUFBLENBQVlkLEtBQVpjLENBSEE7QUFBQSxNQUlBLFdBQUE1QyxNQUFBQSxDQUFLc0QsSUFBTHRELENBSkE7QUFERkQsSUFBQUEsQ0FBQUEsa0NBQUFBLENBcFVBO0FBQUE7QUE0VUFDLElBQUFBLHdCQUFBQSxnQkFBQUEsZ0JBQVMsSUFBVEE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQThCLFlBQVFGLFlBQUFBLENBQVcwQixJQUFYMUIsQ0FBUjtBQUFBLE1BQ0EsT0FBQUssTUFBQUgsS0FBQTVELE9BQUFBLENBQU1vRixJQUFOcEYsQ0FBQStELFFBQUFBLEVBQUFBLEVBQUFBLEVBOVdKLGlCQThXeUIsR0FBRCxFQUFNLEtBOVc5QixFQUFBO0FBQUE7O0FBQUE7QUFBQTtBQThXeUIsUUFBQTtBQUFBLFFBQUE7QUFBQSxRQUFBLENBOVd6QjtBQUFBO0FBOFc4QixRQUFBO0FBQUEsUUFBQTtBQUFBLFFBQUEsQ0E5VzlCO0FBQUEsUUErV002RCxNQUFNLGFBQUEsSUFBQSxRQUFBQyxLQUFBQyxhQUFBQSxDQUFlLHFCQUFmQSxDQUFBLENBQUE7QUFBQSxVQUF3QixPQUFBeEgsU0FBQSxJQUFBQSxFQUFPdUgsS0FBQXJILE1BQUFBLENBQVcsSUFBWEEsQ0FBUEY7QUFBeEIsUUFBQTtBQUFBLFVBQWtELE9BQUF1SDtBQUFsRCxRQUFBLENBQUEsa0JBL1daO0FBQUEsUUFnWE0sT0FBQXBJLGdCQUFBc0MsTUFBQUEsQ0FBa0IsRUFBQSxHQUFBLEtBQUdJLFVBQUFBLENBQVM3QixTQUFBdUUsR0FBQXhDLE1BQUFBLENBQUFBLENBQUFvRixPQUFBQSxDQUFlTSxJQUFJLEdBQW5CTixDQUFBbkgsRUFBMEIsR0FBMUJBLEdBQStCLE1BQXhDNkIsQ0FBSCxDQUFBLEdBQUEsR0FBQSxHQUFBLENBQXFEeUYsR0FBckQsQ0FBbEI3RixDQWhYTixDQUFBLG1CQUFBLGtCQUFBLE1BOFdJZ0MsQ0FEQTtBQURGakMsSUFBQUEsQ0FBQUEsMkJBQUFBLENBNVVBO0FBQUE7QUFvVkFLLElBQUFBLDRCQUFBQSxvQkFBQUEsb0JBQWEsSUFBRCxFQUFPLEtBQW5CQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLEVBQUEsR0FBQSxLQUFBLEdBQUEsQ0FBTSwyQkFBQW5DLE9BQUFBLENBQVk4RyxLQUFaOUcsQ0FBTixDQUFBLEdBQUEsR0FBQSxHQUFBLENBQTRCbUYsSUFBNUIsQ0FBQSxHQUFBO0FBREZoRCxJQUFBQSxDQUFBQSwrQkFBQUEsQ0FwVkE7QUFBQSxJQXdWQSxPQUFBK0MsQ0FBQUEsb0NBQUFBLDRCQUFBQSw0QkFBcUIsSUFBckJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQXhYRjtBQXdYdUIsTUFBQTtBQUFBLE1BQUEsU0FBTyxFQUFQO0FBQUEsTUFBQSxDQXhYdkI7QUFBQSxNQXlYSThDLE1BQU0sR0F6WFY7QUFBQSxNQTBYSUMsWUFBWSxhQUFBLElBQUEsUUExWGhCQyxDQUFBQSxhQTBYZ0IsYUFBQSxJQUFBLFFBMVhoQkMsQ0FBQUEsYUEwWGdCNUUsa0JBQUE2RSxPQUFBQSxDQUFxQnZDLElBQUF4RCxNQUFBQSxDQUFBQSxDQUFBbUIsVUFBQUEsQ0FBQUEsQ0FBckI0RSxDQTFYaEJELENBMFhnQixDQUFBO0FBQUEsUUExWGhCLE9BQUE7QUEwWGdCLE1BQUE7QUFBQSxRQUNWLE9BQUEsb0NBQUFDLE9BQUFBLENBQTJCdkMsSUFBQXhELE1BQUFBLENBQUFBLENBQUFtQixVQUFBQSxDQUFBQSxDQUEzQjRFO0FBRFUsTUFBQSxDQUFBLGtCQTFYaEJGLENBMFhnQixDQUFBO0FBQUEsUUExWGhCLE9BQUE7QUEwWGdCLE1BQUE7QUFBQSxRQUVWLE9BQUF0RixNQUFBVyxrQkFBQVgsT0FBQUEsRUFBQUEsRUFBQUEsRUE1WE4saUJBNFg2QixHQTVYN0IsRUFBQTs7QUFBQTtBQUFBO0FBNFg2QixVQUFBO0FBQUEsVUFBQTtBQUFBLFVBQUEsQ0E1WDdCO0FBQUEsVUE0WGtDLE9BQUFVLEdBQUF0RCxPQUFBQSxDQUFJLE9BQUFXLENBQUEsRUFBR3RCLENBQUgsUUFBSlcsQ0E1WGxDLENBQUEsbUJBQUEsa0JBQUEsTUE0WE00QyxDQUFBd0YsT0FBQUEsQ0FBZ0R2QyxJQUFBeEQsTUFBQUEsQ0FBQUEsQ0FBQW1CLFVBQUFBLENBQUFBLENBQWhENEU7QUFGVSxNQUFBLENBQUEsa0JBMVhoQjtBQUFBLE1BNlhJLElBQUEsUUFBR0gsU0FBSCxDQUFBO0FBQUEsUUFDRUQsTUFBTzFILFNBQUEwQyxVQUFBMUMsRUFBUzJILFNBQVQzSCxDQUFENkMsVUFBQUEsQ0FBOEIsMkJBQTlCQTtBQURSLE1BQUE7QUFBQSxRQUdFNkUsTUFBTSxhQUFBLElBQUEsUUFBQSxhQUFBLElBQUEsUUFoWVpLLENBQUFBLGFBZ1lZeEMsSUFBQTFGLFNBQUFBLENBQUFBLENBaFlaa0ksQ0FnWVksQ0FBQTtBQUFBLFVBaFlaLE9BQUE7QUFnWVksUUFBQTtBQUFBLFVBQWEsT0FBQXhDLElBQUF6RixXQUFBQSxDQUFBQTtBQUFiLFFBQUEsQ0FBQSxrQkFBQSxDQUFBO0FBQUEsVUFBMkIsT0FBQTtBQUEzQixRQUFBO0FBQUEsVUFBaUMsT0FBQSxvQkFBQTZDLE9BQUFBLENBQVc0QyxJQUFYNUMsQ0FBQUUsVUFBQUEsQ0FBMEIsMkJBQTFCQTtBQUFqQyxRQUFBLENBQUE7QUFIUixNQUFBLENBN1hKO0FBQUEsTUFrWUksT0FBTzZFLEdBbFlYO0FBd1hFOUMsSUFBQUEsQ0FBQUEsd0NBQUFBLENBQUFBLDRCQXhWQTtBQUZGeEcsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FIQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2MzQ2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYXBwLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJy4vdG9kby5yYidcblxudG9kbyA9IFRvZG8ubmV3XG5cbmRlZmF1bHRfY2FsbGJhY2sgPSBsYW1iZGEgZG8gfHRlcm1pbmFsLCBjb21tYW5kLCBwYXJhbXN8XG4gIGBcbiAgdHJ5IHtcbiAgICB2YXIgb3V0cHV0ID0gI3t0b2RvLmV4ZWN1dGUoW2NvbW1hbmRdICsgcGFyYW1zKS50b19odG1sfTtcbiAgICB0ZXJtaW5hbC5vdXRwdXQob3V0cHV0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0ZXJtaW5hbC5vdXRwdXQoJzxzcGFuIGNsYXNzPVwib3V0cHV0XCI+PHNwYW4gY2xhc3M9XCJjb2xvciBjb2xvci0zMVwiPkVSUk9SOjwvc3Bhbj4gJyArIGVzY2FwZUh0bWwoZXJyb3IpICsgJzwvc3Bhbj4nKTtcbiAgfVxuICBgXG5lbmRcblxuYFxudmFyIGVzY2FwZUh0bWwgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIChvYmogfHwgJycpLnRvU3RyaW5nKCkucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpO1xufTtcblxudmFyIHRlcm0gPSBuZXcgVmFuaWxsYVRlcm1pbmFsKHtcbiAgJ3dlbGNvbWUnOiAnPHU+dG9kbyBsaXN0IG1hbmFnZXI8L3U+IFJFUEwgdjAuMS4yMTxicj5UeXBlIFwiaGVscFwiIGZvciBtb3JlIGluZm9ybWF0aW9uLjxicj48YnI+JyxcbiAgJ2RlZmF1bHRDYWxsYmFjayc6IGRlZmF1bHRfY2FsbGJhY2ssXG4gICdwcm9tcHQnOiAndG9kbycsXG4gICdjb21tYW5kcyc6IHtcbiAgICAnY2xzJzogZnVuY3Rpb24odGVybWluYWwpIHtcbiAgICAgIHRlcm1pbmFsLmNsZWFyKCk7XG4gICAgfSxcbiAgICAnd2lwZSc6IGZ1bmN0aW9uKHRlcm1pbmFsKSB7XG4gICAgICB0ZXJtaW5hbC5wcm9tcHQoJ0FyZSB5b3Ugc3VyZSByZW1vdmUgYWxsIHlvdXIgdG9kbyBkYXRhPyB5L24nLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUudHJpbSgpLnRvVXBwZXJDYXNlKCkgPT09ICdZJykge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCN7VG9kbzo6VE9ET19GSUxFfSk7XG4gICAgICAgICAgdGVybWluYWwuaGlzdG9yeSA9IFtdO1xuICAgICAgICAgIHRlcm1pbmFsLmhpc3RvcnlDdXJzb3IgPSAwO1xuICAgICAgICAgIHRlcm1pbmFsLm91dHB1dCgndG9kbyBkYXRhIHdpcGVkLicpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pO1xuXG50cnkge1xuICB0ZXJtLm91dHB1dCgje3RvZG8uZXhlY3V0ZShbJ2xpc3QnXSkudG9faHRtbH0pO1xufSBjYXRjaCAoZXJyb3IpIHtcbiAgdGVybS5vdXRwdXQoJzxzcGFuIGNsYXNzPVwib3V0cHV0XCI+PHNwYW4gY2xhc3M9XCJjb2xvciBjb2xvci0zMVwiPkVSUk9SOjwvc3Bhbj4gJyArIGVzY2FwZUh0bWwoZXJyb3IpICsgJzwvc3Bhbj4nKTtcbn1cbmBcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwidG9kbyIsIm5ldyIsImRlZmF1bHRfY2FsbGJhY2siLCJsYW1iZGEiLCJleGVjdXRlIiwiKyIsImNvbW1hbmQiLCJwYXJhbXMiLCJ0b19odG1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLFdBQVJBLENBQUE7QUFBQSxFQUVBQyxPQUFPLG9CQUFBQyxLQUFBQSxDQUFBQSxDQUZQO0FBQUEsRUFJQUMsbUJBQW1CQyxVQUFBQSxVQUFBQSxFQUFBQSxFQUFBQSxFQUxuQixnQkFLOEIsUUFBRCxFQUFXLE9BQVgsRUFBb0IsTUFMakQsRUFBQTs7QUFBQTtBQUFBO0FBSzhCLElBQUE7QUFBQSxJQUFBO0FBQUEsSUFBQSxDQUw5QjtBQUFBO0FBS3dDLElBQUE7QUFBQSxJQUFBO0FBQUEsSUFBQSxDQUx4QztBQUFBO0FBS2lELElBQUE7QUFBQSxJQUFBO0FBQUEsSUFBQSxDQUxqRDtBQUFBO0FBT0E7QUFDQSxpQkFBbUJILElBQUFJLFNBQUFBLENBQWFDLFNBQUEsQ0FBQ0MsT0FBRCxDQUFBRCxFQUFZRSxNQUFaRixDQUFiRCxDQUFBSSxTQUFBQSxDQUFBQSxDQUF5QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBYkEsQ0FBQSxrQkFBQSxpQkFBQSxLQUttQkwsQ0FKbkI7QUFBQTtBQWdCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFvQyxJQUFBLG9CQUFBLGNBQWdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFnQkgsSUFBQUksU0FBQUEsQ0FBYSxDQUFDLE1BQUQsQ0FBYkEsQ0FBQUksU0FBQUEsQ0FBQUEsQ0FBK0I7QUFDL0M7QUFDQTtBQUNBO0FBN0NBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjY0MTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIoZXhpdCkiXSwic291cmNlc0NvbnRlbnQiOlsiS2VybmVsLmV4aXRcbiJdLCJuYW1lcyI6WyJleGl0Il0sIm1hcHBpbmdzIjoiOzs7OztFQUFBLE9BQUEsc0JBQUFBLE1BQUFBLENBQUFBOzsifX1dfQ==
